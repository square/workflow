{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview \u00b6 Workflow is an application framework that provides architectural primitives. Workflow is: Written in and used for Kotlin and Swift A unidirectional data flow library that uses immutable data within each Workflow. Data flows in a single direction from source to UI, and events in a single direction from the UI to the business logic. A library that supports writing business logic and complex UI navigation logic as state machines, thereby enabling confident reasoning about state and validation of correctness. Optimized for composability and scalability of features and screens. Corresponding UI frameworks that bind Rendering data classes for \u201cviews\u201d (including event callbacks) to Mobile UI frameworks for Android and iOS. A corresponding testing framework that facilitates simple-to-write unit tests for all application business logic and helps ensure correctness. Using Workflows in your project \u00b6 Swift \u00b6 See the square/workflow-swift repository. Kotlin \u00b6 See the square/workflow-kotlin repository. Resources \u00b6 Wondering why to use Workflow? See \u201cWhy Workflow\u201d There is a Glossary of Terms We have a User Guide describing core concepts. For Kotlin (and Android), there is a codelab style tutorial in the repo. For Swift (and iOS), there is also a Getting Started tutorial in the repo. There are also a number of Kotlin samples and Swift samples . Support & Contact \u00b6 Workflow discussion happens in the Workflow Community slack. Use this open invitation . Workflow maintainers also hang out in the #squarelibraries channel on the Kotlin Slack . Releasing and Deploying \u00b6 See RELEASING.md . License \u00b6 Copyright 2019 Square Inc. Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"Overview"},{"location":"#overview","text":"Workflow is an application framework that provides architectural primitives. Workflow is: Written in and used for Kotlin and Swift A unidirectional data flow library that uses immutable data within each Workflow. Data flows in a single direction from source to UI, and events in a single direction from the UI to the business logic. A library that supports writing business logic and complex UI navigation logic as state machines, thereby enabling confident reasoning about state and validation of correctness. Optimized for composability and scalability of features and screens. Corresponding UI frameworks that bind Rendering data classes for \u201cviews\u201d (including event callbacks) to Mobile UI frameworks for Android and iOS. A corresponding testing framework that facilitates simple-to-write unit tests for all application business logic and helps ensure correctness.","title":"Overview"},{"location":"#using-workflows-in-your-project","text":"","title":"Using Workflows in your project"},{"location":"#swift","text":"See the square/workflow-swift repository.","title":"Swift"},{"location":"#kotlin","text":"See the square/workflow-kotlin repository.","title":"Kotlin"},{"location":"#resources","text":"Wondering why to use Workflow? See \u201cWhy Workflow\u201d There is a Glossary of Terms We have a User Guide describing core concepts. For Kotlin (and Android), there is a codelab style tutorial in the repo. For Swift (and iOS), there is also a Getting Started tutorial in the repo. There are also a number of Kotlin samples and Swift samples .","title":"Resources"},{"location":"#support-contact","text":"Workflow discussion happens in the Workflow Community slack. Use this open invitation . Workflow maintainers also hang out in the #squarelibraries channel on the Kotlin Slack .","title":"Support &amp; Contact"},{"location":"#releasing-and-deploying","text":"See RELEASING.md .","title":"Releasing and Deploying"},{"location":"#license","text":"Copyright 2019 Square Inc. Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"License"},{"location":"CHANGELOG/","text":"Changelog \u00b6 You can find the changelogs for the library in the respective language repositories: Kotlin Swift","title":"Changelog"},{"location":"CHANGELOG/#changelog","text":"You can find the changelogs for the library in the respective language repositories: Kotlin Swift","title":"Changelog"},{"location":"CODE_OF_CONDUCT/","text":"Open Source Code of Conduct \u00b6 At Square, we are committed to contributing to the open source community and simplifying the process of releasing and managing open source software. We\u2019ve seen incredible support and enthusiasm from thousands of people who have already contributed to our projects\u200a\u2014\u200aand we want to ensure ourcommunity continues to be truly open for everyone. This code of conduct outlines our expectations for participants, as well as steps to reporting unacceptable behavior. We are committed to providing a welcoming and inspiring community for all and expect our code of conduct to be honored. Square\u2019s open source community strives to: Be open : We invite anyone to participate in any aspect of our projects. Our community is open, and any responsibility can be carried by a contributor who demonstrates the required capacity and competence. Be considerate : People use our work, and we depend on the work of others. Consider users and colleagues before taking action. For example, changes to code, infrastructure, policy, and documentation may negatively impact others. Be respectful : We expect people to work together to resolve conflict, assume good intentions, and act with empathy. Do not turn disagreements into personal attacks. Be collaborative : Collaboration reduces redundancy and improves the quality of our work. We strive for transparency within our open source community, and we work closely with upstream developers and others in the free software community to coordinate our efforts. Be pragmatic : Questions are encouraged and should be asked early in the process to avoid problems later. Be thoughtful and considerate when seeking out the appropriate forum for your questions. Those who are asked should be responsive and helpful. Step down considerately : Members of every project come and go. When somebody leaves or disengages from the project, they should make it known and take the proper steps to ensure that others can pick up where they left off. This code is not exhaustive or complete. It serves to distill our common understanding of a collaborative, shared environment, and goals. We expect it to be followed in spirit as much as in the letter. Diversity Statement \u00b6 We encourage everyone to participate and are committed to building a community for all. Although we may not be able to satisfy everyone, we all agree that everyone is equal. Whenever a participant has made a mistake, we expect them to take responsibility for it. If someone has been harmed or offended, it is our responsibility to listen carefully and respectfully, and do our best to right the wrong. Although this list cannot be exhaustive, we explicitly honor diversity in age, culture, ethnicity, gender identity or expression, language, national origin, political beliefs, profession, race, religion, sexual orientation, socioeconomic status, and technical ability. We will not tolerate discrimination based on any of the protected characteristics above, including participants with disabilities. Reporting Issues \u00b6 If you experience or witness unacceptable behavior\u200a\u2014\u200aor have any other concerns\u200a\u2014\u200aplease report it by emailing codeofconduct@squareup.com . For more details, please see our Reporting Guidelines below. Thanks \u00b6 Some of the ideas and wording for the statements and guidelines above were based on work by the Twitter , Ubuntu , GDC , and Django communities. We are thankful for their work. Reporting Guide \u00b6 If you experience or witness unacceptable behavior\u200a\u2014\u200aor have any other concerns\u200a\u2014\u200aplease report it by emailing codeofconduct@squareup.com . All reports will be handled with discretion. In your report please include: Your contact information. Names (real, nicknames, or pseudonyms) of any individuals involved. If there are additional witnesses, please include them as well. Your account of what occurred, and if you believe the incident is ongoing. If there is a publicly available record (e.g. a mailing list archive or a public IRC logger), please include a link. Any additional information that may be helpful. After filing a report, a representative from the Square Code of Conduct committee will contact you personally. The committee will then review the incident, follow up with any additional questions, and make a decision as to how to respond. Anyone asked to stop unacceptable behavior is expected to comply immediately. If an individual engages in unacceptable behavior, the Square Code of Conduct committee may take any action they deem appropriate, up to and including a permanent ban from all of Square spaces without warning.","title":"Code of Conduct"},{"location":"CODE_OF_CONDUCT/#open-source-code-of-conduct","text":"At Square, we are committed to contributing to the open source community and simplifying the process of releasing and managing open source software. We\u2019ve seen incredible support and enthusiasm from thousands of people who have already contributed to our projects\u200a\u2014\u200aand we want to ensure ourcommunity continues to be truly open for everyone. This code of conduct outlines our expectations for participants, as well as steps to reporting unacceptable behavior. We are committed to providing a welcoming and inspiring community for all and expect our code of conduct to be honored. Square\u2019s open source community strives to: Be open : We invite anyone to participate in any aspect of our projects. Our community is open, and any responsibility can be carried by a contributor who demonstrates the required capacity and competence. Be considerate : People use our work, and we depend on the work of others. Consider users and colleagues before taking action. For example, changes to code, infrastructure, policy, and documentation may negatively impact others. Be respectful : We expect people to work together to resolve conflict, assume good intentions, and act with empathy. Do not turn disagreements into personal attacks. Be collaborative : Collaboration reduces redundancy and improves the quality of our work. We strive for transparency within our open source community, and we work closely with upstream developers and others in the free software community to coordinate our efforts. Be pragmatic : Questions are encouraged and should be asked early in the process to avoid problems later. Be thoughtful and considerate when seeking out the appropriate forum for your questions. Those who are asked should be responsive and helpful. Step down considerately : Members of every project come and go. When somebody leaves or disengages from the project, they should make it known and take the proper steps to ensure that others can pick up where they left off. This code is not exhaustive or complete. It serves to distill our common understanding of a collaborative, shared environment, and goals. We expect it to be followed in spirit as much as in the letter.","title":"Open Source Code of Conduct"},{"location":"CODE_OF_CONDUCT/#diversity-statement","text":"We encourage everyone to participate and are committed to building a community for all. Although we may not be able to satisfy everyone, we all agree that everyone is equal. Whenever a participant has made a mistake, we expect them to take responsibility for it. If someone has been harmed or offended, it is our responsibility to listen carefully and respectfully, and do our best to right the wrong. Although this list cannot be exhaustive, we explicitly honor diversity in age, culture, ethnicity, gender identity or expression, language, national origin, political beliefs, profession, race, religion, sexual orientation, socioeconomic status, and technical ability. We will not tolerate discrimination based on any of the protected characteristics above, including participants with disabilities.","title":"Diversity Statement"},{"location":"CODE_OF_CONDUCT/#reporting-issues","text":"If you experience or witness unacceptable behavior\u200a\u2014\u200aor have any other concerns\u200a\u2014\u200aplease report it by emailing codeofconduct@squareup.com . For more details, please see our Reporting Guidelines below.","title":"Reporting Issues"},{"location":"CODE_OF_CONDUCT/#thanks","text":"Some of the ideas and wording for the statements and guidelines above were based on work by the Twitter , Ubuntu , GDC , and Django communities. We are thankful for their work.","title":"Thanks"},{"location":"CODE_OF_CONDUCT/#reporting-guide","text":"If you experience or witness unacceptable behavior\u200a\u2014\u200aor have any other concerns\u200a\u2014\u200aplease report it by emailing codeofconduct@squareup.com . All reports will be handled with discretion. In your report please include: Your contact information. Names (real, nicknames, or pseudonyms) of any individuals involved. If there are additional witnesses, please include them as well. Your account of what occurred, and if you believe the incident is ongoing. If there is a publicly available record (e.g. a mailing list archive or a public IRC logger), please include a link. Any additional information that may be helpful. After filing a report, a representative from the Square Code of Conduct committee will contact you personally. The committee will then review the incident, follow up with any additional questions, and make a decision as to how to respond. Anyone asked to stop unacceptable behavior is expected to comply immediately. If an individual engages in unacceptable behavior, the Square Code of Conduct committee may take any action they deem appropriate, up to and including a permanent ban from all of Square spaces without warning.","title":"Reporting Guide"},{"location":"CONTRIBUTING/","text":"Contributing \u00b6 If you would like to contribute code to Workflow you can do so through GitHub by forking the repository and sending a pull request. When submitting code, please make every effort to follow existing conventions and style in order to keep the code as readable as possible. Please also make sure your code compiles. Before your code can be accepted into the project you must also sign the Individual Contributor License Agreement (CLA) .","title":"Contributing"},{"location":"CONTRIBUTING/#contributing","text":"If you would like to contribute code to Workflow you can do so through GitHub by forking the repository and sending a pull request. When submitting code, please make every effort to follow existing conventions and style in order to keep the code as readable as possible. Please also make sure your code compiles. Before your code can be accepted into the project you must also sign the Individual Contributor License Agreement (CLA) .","title":"Contributing"},{"location":"RELEASING/","text":"Releasing workflow \u00b6 Deploying the documentation website \u00b6 Official Workflow documentation lives at https://square.github.io/workflow . The website content consists of three parts: Markdown documentation: Lives in the docs/ folder, and consists of a set of hand-written Markdown files that document high-level concepts. The static site generator mkdocs (with Material theming) is used to convert the Markdown to static, styled HTML. Kotlin API reference: Kdoc embedded in Kotlin source files is converted to GitHub-flavored Markdown by Dokka and then included in the statically-generated website. Swift API reference: Markup comments from Swift files are converted Markdown by Sourcedocs and then included in the statically-generated website. Note: The documentation site is automatically built and deployed whenever a version tag is pushed. You only need these steps if you want to work on the site locally. Setting up the site generators \u00b6 If you\u2019ve already done this, you can skip to Deploying the website to production below. Kotlin: Dokka \u00b6 Dokka runs as a Gradle plugin, so you need to be able to build the Kotlin source with Gradle, but that\u2019s it. To generate the docs manually, run: cd kotlin ./gradlew dokka Swift: Sourcedocs \u00b6 Sourcedocs generates a Markdown site from Swift files. You need Ruby, rubygems, bundler (2.x), Xcode 10.2+, CocoaPods, and of course Sourcedocs itself, to run it. Assuming you\u2019ve already got Xcode, Ruby, and rubygems set up, install the rest of the dependencies: gem install bundler cocoapods brew install sourcedocs You will also need a checkout of the Swift repo: git clone https://github.com/square/workflow-swift.git cd workflow-swift Then generate an Xcode project before running Sourcedocs: cd Samples/SampleApp/ bundle exec pod install # If this is your first time running CocoaPods, that will fail and you'll need to run this instead: #bundle exec pod install --repo-update You can manually generate the docs to verify everything is working correctly by running: #cd Samples/SampleApp/ sourcedocs generate -- -scheme Workflow -workspace SampleApp.xcworkspace sourcedocs generate -- -scheme WorkflowUI -workspace SampleApp.xcworkspace sourcedocs generate -- -scheme WorkflowTesting -workspace SampleApp.xcworkspace Note that currently sourcedocs only supports Xcode 10, if you run it with Xcode 11 you might see an error about Catalyst and only empty READMEs will get generated. mkdocs \u00b6 Mkdocs is written in Python, so you\u2019ll need Python 3 and pip in order to run it. Assuming those are set up, run: pip install -r requirements.txt Generate the site manually with: mkdocs build While you\u2019re working on the documentation files, you can run the site locally with: mkdocs serve Deploying the website to production \u00b6 Note: The documentation site is automatically built and deployed by a Github Workflow whenever a version tag is pushed. You only need these steps if you want to publish the site manually. Before deploying the website for real, you need to export our Google Analytics key in an environment variable so that it will get added to the HTML. Get the key from one of the project maintainers, then add the following to your .bashrc and re-source it: export WORKFLOW_GOOGLE_ANALYTICS_KEY = UA-__________-1 Now you\u2019re ready to publish the site! Just choose a tag or SHA to deploy from, and run: ./deploy_website.sh TAG_OR_SHA # For example: #./deploy_website.sh v0.18.0 This will clone the repo to a temporary directory, checkout the right SHA, build Kotlin and Swift API docs, generate HTML, and push the newly-generated content to the gh-pages branch on GitHub. Validating Markdown \u00b6 Since all of our high-level documentation is written in Markdown, we run a linter in CI to ensure we use consistent formatting. Lint errors will fail your PR builds, so to run locally, install markdownlint : gem install mdl Run the linter using the lint_docs.sh : ./lint_docs.sh Rules can be configured by editing .markdownlint.rb . Kotlin Notes \u00b6 Development \u00b6 To build and install the current version to your local Maven repository ( ~/.m2 ), run: ./gradlew clean installArchives Deploying \u00b6 Configuration \u00b6 In order to deploy artifacts to a Maven repository, you\u2019ll need to set 4 properties in your private Gradle properties file ( ~/.gradle/gradle.properties ): RELEASE_REPOSITORY_URL=<url of release repository> SNAPSHOT_REPOSITORY_URL=<url of snapshot repository SONATYPE_NEXUS_USERNAME=<username> SONATYPE_NEXUS_PASSWORD=<password> Snapshot Releases \u00b6 Double-check that gradle.properties correctly contains the -SNAPSHOT suffix, then upload snapshot artifacts to Sonatype just like you would for a production release: ./gradlew clean build && ./gradlew uploadArchives --no-parallel --no-daemon You can verify the artifacts are available by visiting https://oss.sonatype.org/content/repositories/snapshots/com/squareup/workflow/ .","title":"Releasing workflow"},{"location":"RELEASING/#releasing-workflow","text":"","title":"Releasing workflow"},{"location":"RELEASING/#deploying-the-documentation-website","text":"Official Workflow documentation lives at https://square.github.io/workflow . The website content consists of three parts: Markdown documentation: Lives in the docs/ folder, and consists of a set of hand-written Markdown files that document high-level concepts. The static site generator mkdocs (with Material theming) is used to convert the Markdown to static, styled HTML. Kotlin API reference: Kdoc embedded in Kotlin source files is converted to GitHub-flavored Markdown by Dokka and then included in the statically-generated website. Swift API reference: Markup comments from Swift files are converted Markdown by Sourcedocs and then included in the statically-generated website. Note: The documentation site is automatically built and deployed whenever a version tag is pushed. You only need these steps if you want to work on the site locally.","title":"Deploying the documentation website"},{"location":"RELEASING/#setting-up-the-site-generators","text":"If you\u2019ve already done this, you can skip to Deploying the website to production below.","title":"Setting up the site generators"},{"location":"RELEASING/#kotlin-dokka","text":"Dokka runs as a Gradle plugin, so you need to be able to build the Kotlin source with Gradle, but that\u2019s it. To generate the docs manually, run: cd kotlin ./gradlew dokka","title":"Kotlin: Dokka"},{"location":"RELEASING/#swift-sourcedocs","text":"Sourcedocs generates a Markdown site from Swift files. You need Ruby, rubygems, bundler (2.x), Xcode 10.2+, CocoaPods, and of course Sourcedocs itself, to run it. Assuming you\u2019ve already got Xcode, Ruby, and rubygems set up, install the rest of the dependencies: gem install bundler cocoapods brew install sourcedocs You will also need a checkout of the Swift repo: git clone https://github.com/square/workflow-swift.git cd workflow-swift Then generate an Xcode project before running Sourcedocs: cd Samples/SampleApp/ bundle exec pod install # If this is your first time running CocoaPods, that will fail and you'll need to run this instead: #bundle exec pod install --repo-update You can manually generate the docs to verify everything is working correctly by running: #cd Samples/SampleApp/ sourcedocs generate -- -scheme Workflow -workspace SampleApp.xcworkspace sourcedocs generate -- -scheme WorkflowUI -workspace SampleApp.xcworkspace sourcedocs generate -- -scheme WorkflowTesting -workspace SampleApp.xcworkspace Note that currently sourcedocs only supports Xcode 10, if you run it with Xcode 11 you might see an error about Catalyst and only empty READMEs will get generated.","title":"Swift: Sourcedocs"},{"location":"RELEASING/#mkdocs","text":"Mkdocs is written in Python, so you\u2019ll need Python 3 and pip in order to run it. Assuming those are set up, run: pip install -r requirements.txt Generate the site manually with: mkdocs build While you\u2019re working on the documentation files, you can run the site locally with: mkdocs serve","title":"mkdocs"},{"location":"RELEASING/#deploying-the-website-to-production","text":"Note: The documentation site is automatically built and deployed by a Github Workflow whenever a version tag is pushed. You only need these steps if you want to publish the site manually. Before deploying the website for real, you need to export our Google Analytics key in an environment variable so that it will get added to the HTML. Get the key from one of the project maintainers, then add the following to your .bashrc and re-source it: export WORKFLOW_GOOGLE_ANALYTICS_KEY = UA-__________-1 Now you\u2019re ready to publish the site! Just choose a tag or SHA to deploy from, and run: ./deploy_website.sh TAG_OR_SHA # For example: #./deploy_website.sh v0.18.0 This will clone the repo to a temporary directory, checkout the right SHA, build Kotlin and Swift API docs, generate HTML, and push the newly-generated content to the gh-pages branch on GitHub.","title":"Deploying the website to production"},{"location":"RELEASING/#validating-markdown","text":"Since all of our high-level documentation is written in Markdown, we run a linter in CI to ensure we use consistent formatting. Lint errors will fail your PR builds, so to run locally, install markdownlint : gem install mdl Run the linter using the lint_docs.sh : ./lint_docs.sh Rules can be configured by editing .markdownlint.rb .","title":"Validating Markdown"},{"location":"RELEASING/#kotlin-notes","text":"","title":"Kotlin Notes"},{"location":"RELEASING/#development","text":"To build and install the current version to your local Maven repository ( ~/.m2 ), run: ./gradlew clean installArchives","title":"Development"},{"location":"RELEASING/#deploying","text":"","title":"Deploying"},{"location":"RELEASING/#configuration","text":"In order to deploy artifacts to a Maven repository, you\u2019ll need to set 4 properties in your private Gradle properties file ( ~/.gradle/gradle.properties ): RELEASE_REPOSITORY_URL=<url of release repository> SNAPSHOT_REPOSITORY_URL=<url of snapshot repository SONATYPE_NEXUS_USERNAME=<username> SONATYPE_NEXUS_PASSWORD=<password>","title":"Configuration"},{"location":"RELEASING/#snapshot-releases","text":"Double-check that gradle.properties correctly contains the -SNAPSHOT suffix, then upload snapshot artifacts to Sonatype just like you would for a production release: ./gradlew clean build && ./gradlew uploadArchives --no-parallel --no-daemon You can verify the artifacts are available by visiting https://oss.sonatype.org/content/repositories/snapshots/com/squareup/workflow/ .","title":"Snapshot Releases"},{"location":"code-recipes/","text":"Code Receipes \u00b6 Coming soon!","title":"Code Receipes"},{"location":"code-recipes/#code-receipes","text":"Coming soon!","title":"Code Receipes"},{"location":"development-process/","text":"Development Process \u00b6 Coming soon!","title":"Development Process"},{"location":"development-process/#development-process","text":"Coming soon!","title":"Development Process"},{"location":"faq/","text":"Frequently Asked Questions \u00b6 Why do we need another architecture? \u00b6 We ask this question too! So we wrote a longer answer for it: \u201cWhy Workflow?\u201d . How do I get involved and/or contribute? \u00b6 Workflow is open source! See our CONTRIBUTING doc to get started. Stay tuned! We\u2019re considering hosting a public Slack channel for open source contributors. Isn\u2019t this basically React/Elm? \u00b6 React and the Elm architecture were both strong influences for this library. However both those libraries are written for JavaScript. Workflows are written in and for both Kotlin and Swift, making use of features of those languages, and with usability from those languages as a major design goal. There are some architectural differences which we can see briefly in the following table: React Elm Workflow Modularity Component Module s for code organization, but not \u2018composable\u2019 in the same way. A Workflow is analogous to React\u2019s Component State Each Component has a state property that is read directly and updated via a setState method. State is called Model in Elm. Workflow s have an associated state type. The state can only be updated when the props change, or with a WorkflowAction . Views Component s have a render method that returns a tree of elements. Elm applications have a view function that returns a tree of elements. Since workflows are not tied to any particular UI view layer, they can have an arbitrary rendering type. The render() method returns this type. Injected Dependencies React allows parent components to pass \u201cprops\u201d down to their children. N/A In Swift, Workflow s are often structs that need to be initialized with their dependencies and configuration data from their parent. In Kotlin, they have a separate type parameter ( PropsT ) that is always passed down from the parent. Workflow instances can also inject dependencies, and play nicely with dependency injection frameworks. Composability Component s are composed of other Component s. N/A Workflow s can have children; they control their lifecycle and can choose to incorporate child renderings into their own. Event Handling DOM event listeners are hooked up to functions on the Component . The update function takes a Msg to modify state based on events. action can be sent to the Sink to update State . How is this different than MvRx? \u00b6 Besides being very Android and Rx specific, MvRx solves view modeling problems only per screen. Workflow was mainly inspired by the need to manage and compose navigation in apps with dozens or hundreds of screens. This seems clever. Can I stick with a traditional development approach? \u00b6 Of course! Workflow was designed to make complex application architecture predictable and safe for large development teams. We\u2019re confident that it brings benefits even to smaller projects, but there is never only one right way to build software. We recommend to follow good practices and use an architecture that makes sense for your project .","title":"FAQ"},{"location":"faq/#frequently-asked-questions","text":"","title":"Frequently Asked Questions"},{"location":"faq/#why-do-we-need-another-architecture","text":"We ask this question too! So we wrote a longer answer for it: \u201cWhy Workflow?\u201d .","title":"Why do we need another architecture?"},{"location":"faq/#how-do-i-get-involved-andor-contribute","text":"Workflow is open source! See our CONTRIBUTING doc to get started. Stay tuned! We\u2019re considering hosting a public Slack channel for open source contributors.","title":"How do I get involved and/or contribute?"},{"location":"faq/#isnt-this-basically-reactelm","text":"React and the Elm architecture were both strong influences for this library. However both those libraries are written for JavaScript. Workflows are written in and for both Kotlin and Swift, making use of features of those languages, and with usability from those languages as a major design goal. There are some architectural differences which we can see briefly in the following table: React Elm Workflow Modularity Component Module s for code organization, but not \u2018composable\u2019 in the same way. A Workflow is analogous to React\u2019s Component State Each Component has a state property that is read directly and updated via a setState method. State is called Model in Elm. Workflow s have an associated state type. The state can only be updated when the props change, or with a WorkflowAction . Views Component s have a render method that returns a tree of elements. Elm applications have a view function that returns a tree of elements. Since workflows are not tied to any particular UI view layer, they can have an arbitrary rendering type. The render() method returns this type. Injected Dependencies React allows parent components to pass \u201cprops\u201d down to their children. N/A In Swift, Workflow s are often structs that need to be initialized with their dependencies and configuration data from their parent. In Kotlin, they have a separate type parameter ( PropsT ) that is always passed down from the parent. Workflow instances can also inject dependencies, and play nicely with dependency injection frameworks. Composability Component s are composed of other Component s. N/A Workflow s can have children; they control their lifecycle and can choose to incorporate child renderings into their own. Event Handling DOM event listeners are hooked up to functions on the Component . The update function takes a Msg to modify state based on events. action can be sent to the Sink to update State .","title":"Isn't this basically React/Elm?"},{"location":"faq/#how-is-this-different-than-mvrx","text":"Besides being very Android and Rx specific, MvRx solves view modeling problems only per screen. Workflow was mainly inspired by the need to manage and compose navigation in apps with dozens or hundreds of screens.","title":"How is this different than MvRx?"},{"location":"faq/#this-seems-clever-can-i-stick-with-a-traditional-development-approach","text":"Of course! Workflow was designed to make complex application architecture predictable and safe for large development teams. We\u2019re confident that it brings benefits even to smaller projects, but there is never only one right way to build software. We recommend to follow good practices and use an architecture that makes sense for your project .","title":"This seems clever. Can I stick with a traditional development approach?"},{"location":"glossary/","text":"Glossary of Terms \u00b6 Reactive Programming \u00b6 A style of programming where data or events are pushed to the logic processing them rather than having the logic pull the data and events from a source. A representation of program logic as a series of operations on a stream of data that is performed while a subscription to that stream is active. Unidirectional Data Flow \u00b6 Data travels a single path from business logic to UI, and travels the entirety of that path in a single direction. Events travel a single path from UI to business logic and they travel the entirety of that path in a single direction. There are thus two sets of directed edges in the graph that are handled separately and neither set has any cycles or back edges on its own. Declarative Programming \u00b6 A declarative program declares the state it wants the system to be in rather than how that is accomplished. Imperative Programming \u00b6 An imperative program\u2019s code is a series of statements that directly change a program\u2019s state as a result of certain events. State Machine \u00b6 An abstraction that models a program\u2019s logic as a graph of a set of states and the transitions between them (edges). See: en.wikipedia.org/wiki/Finite-state_machine Idempotent \u00b6 A function whose side effects won\u2019t be repeated with multiple invocations, the result is purely a function of the input. In other words, if called multiple times with the same input, the result is the same. For Workflows, the render() function must be idempotent, as the runtime offers no guarantees for how many times it may be called. Workflow Runtime \u00b6 An event loop that executes a Workflow Tree. On each pass: A Rendering is assembled by calling render() on each Node of the Workflow Tree with each parent Workflow given the option to incorporate the Renderings of its children into its own. The event loop waits for an Action to be sent to the Sink. This Action provides a (possibly updated) State for the Workflow that created it and possibly an Output. Any Output emitted is processed in turn by an Action defined by the updated Workflow\u2019s parent again possibly updating its State and emitting an Output cascading up the hierarchy. A new render() pass is made against the entire Workflow Tree with the updated States. We use the term Workflow Runtime to refer to the core code in the framework that executes this event loop, responding to Actions and invoking render() . Workflow (Instance) \u00b6 An object that defines the transitions and side effects of a state machine as, effectively, two functions: Providing the first state: (Props) -> State Providing a rendering: (Props and State) -> (Rendering and Side Effect Invocations and Child Workflow Invocations) The Child Workflow Invocations declared by the render function result in calls to the children\u2019s render() functions in turn, allowing the parent render function to choose to incorporate child Rendering values into its own. A Workflow is not itself a state machine, and ideally has no state of its own. It is rather a schema that identifies a particular type of state machine that can be started in initialState() by the Workflow Runtime, and advanced by repeated invocations of render() . Note: there is significant fuzziness in using the term \u2018Workflow\u2019, as it can mean at times the class/struct that declares the Workflow behavior as well as the object representing the running Workflow Node. To understand the Runtime behavior, grasping this distinction is necessary and valuable. When using a Workflow, the formal distinction is less valuable than the mental model of how a Workflow will be run. Workflow (Node) \u00b6 An active state machine whose behavior is defined by a Workflow Instance. This is the object that is held by the Workflow Runtime and whose state is updated (or \u201cdriven\u201d) according to the behavior declared in the Workflow Instance. In Kotlin and Swift a Workflow Node is implemented with the private WorkflowNode class/struct. Workflow Lifecycle \u00b6 Every Workflow or Side Effect Node has a lifecycle that is determined by its parent. In the case of the root Workflow, this lifecycle is determined by how long the host of the root chooses to use the stream of Renderings from the root Workflow. In the case of a non-root Workflow or Side Effect \u2014 that is, in the case of a Child \u2014 its lifecycle is determined as follows: Start: the first time its parent invokes the Child in the parent\u2019s own render() pass. End: the first subsequent render() pass that does not invoke the Child. Note that in between Start and End, the Workflow, or Side Effect is not \u201cre-invoked\u201d in the sense of starting again with each render() pass, but rather the originally invoked instance continues to run until a render() call is made without invoking it. Workflow Tree \u00b6 The tree of Workflow Nodes sharing a root. Workflow Nodes can have children and form a hierarchy. Workflow Root \u00b6 The root of a Workflow Tree. This is owned by a host which starts the Workflow Runtime with a particular Workflow instance. RenderContext \u00b6 The object which provides access to the Workflow Runtime from a Workflow render method. Provides three services: a Sink for accepting WorkflowActions recursively rendering Workflow children executing Side Effects Render Pass \u00b6 The portion of the Workflow Runtime event loop which traverses the Workflow tree, calling render() on each Workflow Node. When the RenderContext Sink receives an Action an Action Cascade occurs and at the completion of the Action Cascade the Render Pass occurs. Output Event \u00b6 When a Child Workflow emits an Output value, this is an Output Event. Handlers are registered when a Child Workflow is invoked to transform the child\u2019s Output values to Actions, which can advance the state of the parent. UI Event \u00b6 Any occurrence in the UI of a program \u2014 e.g. click, drag, keypress \u2014 the listener for which has been connected to a callback in the Rendering of a Workflow. UI Event callbacks typically add Actions to the Sink, to advance the state of the Workflow. Action \u00b6 A type associated with a particular Workflow (Instance) that is responsible for transforming a given State into a new State and optionally emitting an Output. Actions are sent to the Sink to be processed by the Workflow Runtime. Action Cascade \u00b6 When an event occurs and the handler provides an Action, this Action may possibly produce an Output for the parent Workflow which in turn has its own handler provide an Action that may produce an Output and onwards up the Workflow Tree. This is an Action Cascade. Sink \u00b6 The handle provided by the RenderContext to send Actions to the Workflow Runtime. These Actions are applied by the Workflow Runtime to advance a Workflow\u2019s State, and optionally produce an Output to be processed by the handler its parent registered. Props \u00b6 The set of input properties for a particular Workflow. This is the public state which is provided to a child Workflow by its parent, or to the root Workflow by its host. For Swift: The set of properties on the struct implementing the Workflow. For Kotlin: Parameter type PropsT in the Workflow signature. In Kotlin there is a formal distinction between Props and other dependencies, typically provided as constructor parameters. State \u00b6 The type of the internal state of a Workflow implementation. \u201cImmutable\u201d State \u00b6 The State object itself is immutable, in other words, its property values cannot be changed. What this means for Workflows is that the Workflow Runtime holds a canonical instance of the internal State of each Workflow. A Workflow\u2019s state is \u201cadvanced\u201d when that canonical instance is atomically replaced by one returned when an Action is invoked. State can only be mutated through WorkflowAction which will trigger a re-render. There are a number of benefits to keeping State immutable in this way: Reasoning about and debugging the Workflow is easier because, for any given State, there is a deterministic Rendering and the State cannot change except as a new parameter value to the render() method. This assists in making render() idempotent as the State will not be modified in the course of the execution of that function. Note that this immutability can be enforced only by convention. It is possible to cheat, but that is strongly discouraged. Rendering \u00b6 The externally available public representation of the state of a Workflow. It may include event handling functions. It is given a concrete type in the Workflow signature. Note that this \u201cRendering\u201d does not have to represent the UI of a program. The \u201cRendering\u201d is simply the published state of the Workflow, and could simply be data. Often that data is used to render UI, but it can be used in other ways \u2014 for example, as the implementation of a service API. Output \u00b6 The type of the object that can optionally be delivered to the Workflow\u2019s parent or the host of the root Workflow by an Action. Child Workflow \u00b6 A Workflow which has a parent. A parent may compose a child Workflow\u2019s Rendering into its own. Side Effect \u00b6 From render() , runningSideEffect() can be called with a given key and a function that will be called once by the Workflow Runtime. For Swift, a Lifetime object is also passed to runningSideEffect() which has an onEnded() closure that can be used for cleanup. For Kotlin, a coroutine scope is used to execute the function so it can be cancelled() at cleanup time. Given that any property (including the Sink) could be captured by the closure of the Side Effect this is the basic building block that can be used to interact with asynchronous (and often imperative) Workflow Children. Worker \u00b6 A Child Workflow that provides only output, with no rendering \u2014 a pattern for doing asynchronous work in Workflows. For Kotlin, this is an actual Interface which provides a convenient way to specify asynchronous work that produces an Output and a handler for that Output which can provide an Action. There are Kotlin extensions to map Rx Observables and Kotlin Flows to create Worker implementations. For Swift, there are at least 3 different Worker types which are convenience wrappers around reactive APIs that facilitate performing work. View \u00b6 A class or function managing a 2d box in a graphical user interface system, able to paint a defined region of the display and respond to user input events within its bounds. Views are arranged in a hierarchical tree, with parents able to lay out children and manage their painting and event handling. Instances supported by Workflow are: For Kotlin: Classic Android: class android.view.View Android JetPack Compose: @Composable fun Box() For Swift: class NSViewController Screen \u00b6 An interface / protocol identifying Renderings that model a View. Workflow UI libraries can map a given Screen type to a View instance that can display a series of such Screens. In Kotlin, Screen is a marker interface. Each type S : Screen is mapped by the Android UI library to a ScreenViewFactory&lt;S> that is able to: create instances of android.view.View or provide a @Composable fun Content(S) function to be called from a Box {} context. Note that the Android UI support is able to interleave Screens bound to View or @Composable seamlessly. In Swift, the Screen protocol defines a single function creating ViewControllerDescription instances, objects which create and update ViewController instances to display Screens of the corresponding type. Overlay (Kotlin only) \u00b6 An interface identifying Renderings that model a plane covering a base Screen, possibly hosting another Screen \u2014 \u201ccovering\u201d in that they have a higher z-index, for visibility and event-handling. In Kotlin, Overlay is a marker interface. Each type O : Overlay is mapped by the Android UI library to an OverlayDialogFactory&lt;O> able to create and update instances of android.app.Dialog Container Screen \u00b6 A design pattern, describing a Screen type whose instances wrap one or more other Screens, commonly to either annotate those Screens or define the relationships between them. Wrapping one Screen in another does not necessarily imply that the derived View hierarchy will change. It is common for the Kotlin ScreenViewFactory or Swift ViewControllerDescription bound to a Container Screen to delegate its construction and updating work to those of the wrapped Screens. Container View \u00b6 A View able to host children that are driven by Screen renderings. A Container View is generally driven by Container Screens of a specific type \u2014 e.g., a BackStackContainer View that can display BackStackScreen values. The exception is a root Container View, which is able to display a series of Screen instances of any type. For Kotlin, the root Container Views are WorkflowLayout : FrameLayout , and @Composable Workflow.renderAsState() . Custom Container Views written to display custom Container Screens can use WorkflowViewStub : FrameLayout or @Composable fun WorkflowRendering() to display wrapped Screens. For Swift, the root Container View is ContainerViewController . Custom Container Views written to render custom Container Screens can be built as subclasses of ScreenViewController , and use DescribedViewController to display wrapped Screens. ViewEnvironment \u00b6 A read-only key/value map passed from a Container View down to its children at update time, similar in spirit to Swift UI EnvironmentValues and Jetpack CompositionLocal . Like them, the ViewEnvironment is primarily intended to allow parents to offer children hints about the context in which they are being displayed \u2014 for example, to allow a child to know if it is a member of a back stack, and so decide whether or not to display a Go Back button. The ViewEnvironment also can be used judiciously as a service provider for UI-specific concerns, like image loaders \u2014 tread carefully.","title":"Glossary"},{"location":"glossary/#glossary-of-terms","text":"","title":"Glossary of Terms"},{"location":"glossary/#reactive-programming","text":"A style of programming where data or events are pushed to the logic processing them rather than having the logic pull the data and events from a source. A representation of program logic as a series of operations on a stream of data that is performed while a subscription to that stream is active.","title":"Reactive Programming"},{"location":"glossary/#unidirectional-data-flow","text":"Data travels a single path from business logic to UI, and travels the entirety of that path in a single direction. Events travel a single path from UI to business logic and they travel the entirety of that path in a single direction. There are thus two sets of directed edges in the graph that are handled separately and neither set has any cycles or back edges on its own.","title":"Unidirectional Data Flow"},{"location":"glossary/#declarative-programming","text":"A declarative program declares the state it wants the system to be in rather than how that is accomplished.","title":"Declarative Programming"},{"location":"glossary/#imperative-programming","text":"An imperative program\u2019s code is a series of statements that directly change a program\u2019s state as a result of certain events.","title":"Imperative Programming"},{"location":"glossary/#state-machine","text":"An abstraction that models a program\u2019s logic as a graph of a set of states and the transitions between them (edges). See: en.wikipedia.org/wiki/Finite-state_machine","title":"State Machine"},{"location":"glossary/#idempotent","text":"A function whose side effects won\u2019t be repeated with multiple invocations, the result is purely a function of the input. In other words, if called multiple times with the same input, the result is the same. For Workflows, the render() function must be idempotent, as the runtime offers no guarantees for how many times it may be called.","title":"Idempotent"},{"location":"glossary/#workflow-runtime","text":"An event loop that executes a Workflow Tree. On each pass: A Rendering is assembled by calling render() on each Node of the Workflow Tree with each parent Workflow given the option to incorporate the Renderings of its children into its own. The event loop waits for an Action to be sent to the Sink. This Action provides a (possibly updated) State for the Workflow that created it and possibly an Output. Any Output emitted is processed in turn by an Action defined by the updated Workflow\u2019s parent again possibly updating its State and emitting an Output cascading up the hierarchy. A new render() pass is made against the entire Workflow Tree with the updated States. We use the term Workflow Runtime to refer to the core code in the framework that executes this event loop, responding to Actions and invoking render() .","title":"Workflow Runtime"},{"location":"glossary/#workflow-instance","text":"An object that defines the transitions and side effects of a state machine as, effectively, two functions: Providing the first state: (Props) -> State Providing a rendering: (Props and State) -> (Rendering and Side Effect Invocations and Child Workflow Invocations) The Child Workflow Invocations declared by the render function result in calls to the children\u2019s render() functions in turn, allowing the parent render function to choose to incorporate child Rendering values into its own. A Workflow is not itself a state machine, and ideally has no state of its own. It is rather a schema that identifies a particular type of state machine that can be started in initialState() by the Workflow Runtime, and advanced by repeated invocations of render() . Note: there is significant fuzziness in using the term \u2018Workflow\u2019, as it can mean at times the class/struct that declares the Workflow behavior as well as the object representing the running Workflow Node. To understand the Runtime behavior, grasping this distinction is necessary and valuable. When using a Workflow, the formal distinction is less valuable than the mental model of how a Workflow will be run.","title":"Workflow (Instance)"},{"location":"glossary/#workflow-node","text":"An active state machine whose behavior is defined by a Workflow Instance. This is the object that is held by the Workflow Runtime and whose state is updated (or \u201cdriven\u201d) according to the behavior declared in the Workflow Instance. In Kotlin and Swift a Workflow Node is implemented with the private WorkflowNode class/struct.","title":"Workflow (Node)"},{"location":"glossary/#workflow-lifecycle","text":"Every Workflow or Side Effect Node has a lifecycle that is determined by its parent. In the case of the root Workflow, this lifecycle is determined by how long the host of the root chooses to use the stream of Renderings from the root Workflow. In the case of a non-root Workflow or Side Effect \u2014 that is, in the case of a Child \u2014 its lifecycle is determined as follows: Start: the first time its parent invokes the Child in the parent\u2019s own render() pass. End: the first subsequent render() pass that does not invoke the Child. Note that in between Start and End, the Workflow, or Side Effect is not \u201cre-invoked\u201d in the sense of starting again with each render() pass, but rather the originally invoked instance continues to run until a render() call is made without invoking it.","title":"Workflow Lifecycle"},{"location":"glossary/#workflow-tree","text":"The tree of Workflow Nodes sharing a root. Workflow Nodes can have children and form a hierarchy.","title":"Workflow Tree"},{"location":"glossary/#workflow-root","text":"The root of a Workflow Tree. This is owned by a host which starts the Workflow Runtime with a particular Workflow instance.","title":"Workflow Root"},{"location":"glossary/#rendercontext","text":"The object which provides access to the Workflow Runtime from a Workflow render method. Provides three services: a Sink for accepting WorkflowActions recursively rendering Workflow children executing Side Effects","title":"RenderContext"},{"location":"glossary/#render-pass","text":"The portion of the Workflow Runtime event loop which traverses the Workflow tree, calling render() on each Workflow Node. When the RenderContext Sink receives an Action an Action Cascade occurs and at the completion of the Action Cascade the Render Pass occurs.","title":"Render Pass"},{"location":"glossary/#output-event","text":"When a Child Workflow emits an Output value, this is an Output Event. Handlers are registered when a Child Workflow is invoked to transform the child\u2019s Output values to Actions, which can advance the state of the parent.","title":"Output Event"},{"location":"glossary/#ui-event","text":"Any occurrence in the UI of a program \u2014 e.g. click, drag, keypress \u2014 the listener for which has been connected to a callback in the Rendering of a Workflow. UI Event callbacks typically add Actions to the Sink, to advance the state of the Workflow.","title":"UI Event"},{"location":"glossary/#action","text":"A type associated with a particular Workflow (Instance) that is responsible for transforming a given State into a new State and optionally emitting an Output. Actions are sent to the Sink to be processed by the Workflow Runtime.","title":"Action"},{"location":"glossary/#action-cascade","text":"When an event occurs and the handler provides an Action, this Action may possibly produce an Output for the parent Workflow which in turn has its own handler provide an Action that may produce an Output and onwards up the Workflow Tree. This is an Action Cascade.","title":"Action Cascade"},{"location":"glossary/#sink","text":"The handle provided by the RenderContext to send Actions to the Workflow Runtime. These Actions are applied by the Workflow Runtime to advance a Workflow\u2019s State, and optionally produce an Output to be processed by the handler its parent registered.","title":"Sink"},{"location":"glossary/#props","text":"The set of input properties for a particular Workflow. This is the public state which is provided to a child Workflow by its parent, or to the root Workflow by its host. For Swift: The set of properties on the struct implementing the Workflow. For Kotlin: Parameter type PropsT in the Workflow signature. In Kotlin there is a formal distinction between Props and other dependencies, typically provided as constructor parameters.","title":"Props"},{"location":"glossary/#state","text":"The type of the internal state of a Workflow implementation.","title":"State"},{"location":"glossary/#immutable-state","text":"The State object itself is immutable, in other words, its property values cannot be changed. What this means for Workflows is that the Workflow Runtime holds a canonical instance of the internal State of each Workflow. A Workflow\u2019s state is \u201cadvanced\u201d when that canonical instance is atomically replaced by one returned when an Action is invoked. State can only be mutated through WorkflowAction which will trigger a re-render. There are a number of benefits to keeping State immutable in this way: Reasoning about and debugging the Workflow is easier because, for any given State, there is a deterministic Rendering and the State cannot change except as a new parameter value to the render() method. This assists in making render() idempotent as the State will not be modified in the course of the execution of that function. Note that this immutability can be enforced only by convention. It is possible to cheat, but that is strongly discouraged.","title":"\"Immutable\" State"},{"location":"glossary/#rendering","text":"The externally available public representation of the state of a Workflow. It may include event handling functions. It is given a concrete type in the Workflow signature. Note that this \u201cRendering\u201d does not have to represent the UI of a program. The \u201cRendering\u201d is simply the published state of the Workflow, and could simply be data. Often that data is used to render UI, but it can be used in other ways \u2014 for example, as the implementation of a service API.","title":"Rendering"},{"location":"glossary/#output","text":"The type of the object that can optionally be delivered to the Workflow\u2019s parent or the host of the root Workflow by an Action.","title":"Output"},{"location":"glossary/#child-workflow","text":"A Workflow which has a parent. A parent may compose a child Workflow\u2019s Rendering into its own.","title":"Child Workflow"},{"location":"glossary/#side-effect","text":"From render() , runningSideEffect() can be called with a given key and a function that will be called once by the Workflow Runtime. For Swift, a Lifetime object is also passed to runningSideEffect() which has an onEnded() closure that can be used for cleanup. For Kotlin, a coroutine scope is used to execute the function so it can be cancelled() at cleanup time. Given that any property (including the Sink) could be captured by the closure of the Side Effect this is the basic building block that can be used to interact with asynchronous (and often imperative) Workflow Children.","title":"Side Effect"},{"location":"glossary/#worker","text":"A Child Workflow that provides only output, with no rendering \u2014 a pattern for doing asynchronous work in Workflows. For Kotlin, this is an actual Interface which provides a convenient way to specify asynchronous work that produces an Output and a handler for that Output which can provide an Action. There are Kotlin extensions to map Rx Observables and Kotlin Flows to create Worker implementations. For Swift, there are at least 3 different Worker types which are convenience wrappers around reactive APIs that facilitate performing work.","title":"Worker"},{"location":"glossary/#view","text":"A class or function managing a 2d box in a graphical user interface system, able to paint a defined region of the display and respond to user input events within its bounds. Views are arranged in a hierarchical tree, with parents able to lay out children and manage their painting and event handling. Instances supported by Workflow are: For Kotlin: Classic Android: class android.view.View Android JetPack Compose: @Composable fun Box() For Swift: class NSViewController","title":"View"},{"location":"glossary/#screen","text":"An interface / protocol identifying Renderings that model a View. Workflow UI libraries can map a given Screen type to a View instance that can display a series of such Screens. In Kotlin, Screen is a marker interface. Each type S : Screen is mapped by the Android UI library to a ScreenViewFactory&lt;S> that is able to: create instances of android.view.View or provide a @Composable fun Content(S) function to be called from a Box {} context. Note that the Android UI support is able to interleave Screens bound to View or @Composable seamlessly. In Swift, the Screen protocol defines a single function creating ViewControllerDescription instances, objects which create and update ViewController instances to display Screens of the corresponding type.","title":"Screen"},{"location":"glossary/#overlay-kotlin-only","text":"An interface identifying Renderings that model a plane covering a base Screen, possibly hosting another Screen \u2014 \u201ccovering\u201d in that they have a higher z-index, for visibility and event-handling. In Kotlin, Overlay is a marker interface. Each type O : Overlay is mapped by the Android UI library to an OverlayDialogFactory&lt;O> able to create and update instances of android.app.Dialog","title":"Overlay (Kotlin only)"},{"location":"glossary/#container-screen","text":"A design pattern, describing a Screen type whose instances wrap one or more other Screens, commonly to either annotate those Screens or define the relationships between them. Wrapping one Screen in another does not necessarily imply that the derived View hierarchy will change. It is common for the Kotlin ScreenViewFactory or Swift ViewControllerDescription bound to a Container Screen to delegate its construction and updating work to those of the wrapped Screens.","title":"Container Screen"},{"location":"glossary/#container-view","text":"A View able to host children that are driven by Screen renderings. A Container View is generally driven by Container Screens of a specific type \u2014 e.g., a BackStackContainer View that can display BackStackScreen values. The exception is a root Container View, which is able to display a series of Screen instances of any type. For Kotlin, the root Container Views are WorkflowLayout : FrameLayout , and @Composable Workflow.renderAsState() . Custom Container Views written to display custom Container Screens can use WorkflowViewStub : FrameLayout or @Composable fun WorkflowRendering() to display wrapped Screens. For Swift, the root Container View is ContainerViewController . Custom Container Views written to render custom Container Screens can be built as subclasses of ScreenViewController , and use DescribedViewController to display wrapped Screens.","title":"Container View"},{"location":"glossary/#viewenvironment","text":"A read-only key/value map passed from a Container View down to its children at update time, similar in spirit to Swift UI EnvironmentValues and Jetpack CompositionLocal . Like them, the ViewEnvironment is primarily intended to allow parents to offer children hints about the context in which they are being displayed \u2014 for example, to allow a child to know if it is a member of a back stack, and so decide whether or not to display a Go Back button. The ViewEnvironment also can be used judiciously as a service provider for UI-specific concerns, like image loaders \u2014 tread carefully.","title":"ViewEnvironment"},{"location":"historical/","text":"Pre-1.0 Presentations and Resources \u00b6 Square Workflow \u2013 Droidcon NYC 2019 ( slides ) SF Android GDG @ Square 2019 - Hello Workflow (live coding) Android Dialogs 5-part Coding Series 1 , 2 , 3 , 4 , 5 Reactive Workflows a Year Later \u2013 Droidcon NYC 2018 The Reactive Workflow Pattern \u2013 Fragmented Podcast The Reactive Workflow Pattern Update \u2013 Droidcon SF 2017 The Rx Workflow Pattern \u2013 Droidcon NYC 2017 ( slides )","title":"Pre-1.0 Resources"},{"location":"historical/#pre-10-presentations-and-resources","text":"Square Workflow \u2013 Droidcon NYC 2019 ( slides ) SF Android GDG @ Square 2019 - Hello Workflow (live coding) Android Dialogs 5-part Coding Series 1 , 2 , 3 , 4 , 5 Reactive Workflows a Year Later \u2013 Droidcon NYC 2018 The Reactive Workflow Pattern \u2013 Fragmented Podcast The Reactive Workflow Pattern Update \u2013 Droidcon SF 2017 The Rx Workflow Pattern \u2013 Droidcon NYC 2017 ( slides )","title":"Pre-1.0 Presentations and Resources"},{"location":"sequence_diagrams/","text":"Sequence Diagrams \u00b6 These are the source files used to generate the sequence diagrams via WebSequenceDiagrams .","title":"Sequence Diagrams"},{"location":"sequence_diagrams/#sequence-diagrams","text":"These are the source files used to generate the sequence diagrams via WebSequenceDiagrams .","title":"Sequence Diagrams"},{"location":"swift/api/Workflow/","text":"Reference Documentation \u00b6 Protocols \u00b6 AnyWorkflowConvertible ObserversInterceptor Workflow WorkflowAction WorkflowDebugger WorkflowObserver Structs \u00b6 AnyWorkflow AnyWorkflowAction Sink StateMutationSink WorkflowHierarchyDebugSnapshot WorkflowHierarchyDebugSnapshot.Child WorkflowLogging.Config WorkflowSession WorkflowSession.Identifier WorkflowUpdateDebugInfo Classes \u00b6 Lifetime RenderContext WorkflowHost Enums \u00b6 Config.RenderLoggingMode WorkflowLogging WorkflowObservation WorkflowUpdateDebugInfo.Kind WorkflowUpdateDebugInfo.Source Extensions \u00b6 AnyWorkflow AnyWorkflowAction AnyWorkflowConvertible DispatchQueue RenderContext Workflow WorkflowLogging WorkflowLogging.Config WorkflowObserver WorkflowUpdateDebugInfo.Kind WorkflowUpdateDebugInfo.Source Typealiases \u00b6 AnyWorkflow.Output AnyWorkflow.Rendering AnyWorkflow.State This file was generated by SourceDocs on 2023-06-06 23:39:34 +0000","title":"Workflow "},{"location":"swift/api/Workflow/#reference-documentation","text":"","title":"Reference Documentation"},{"location":"swift/api/Workflow/#protocols","text":"AnyWorkflowConvertible ObserversInterceptor Workflow WorkflowAction WorkflowDebugger WorkflowObserver","title":"Protocols"},{"location":"swift/api/Workflow/#structs","text":"AnyWorkflow AnyWorkflowAction Sink StateMutationSink WorkflowHierarchyDebugSnapshot WorkflowHierarchyDebugSnapshot.Child WorkflowLogging.Config WorkflowSession WorkflowSession.Identifier WorkflowUpdateDebugInfo","title":"Structs"},{"location":"swift/api/Workflow/#classes","text":"Lifetime RenderContext WorkflowHost","title":"Classes"},{"location":"swift/api/Workflow/#enums","text":"Config.RenderLoggingMode WorkflowLogging WorkflowObservation WorkflowUpdateDebugInfo.Kind WorkflowUpdateDebugInfo.Source","title":"Enums"},{"location":"swift/api/Workflow/#extensions","text":"AnyWorkflow AnyWorkflowAction AnyWorkflowConvertible DispatchQueue RenderContext Workflow WorkflowLogging WorkflowLogging.Config WorkflowObserver WorkflowUpdateDebugInfo.Kind WorkflowUpdateDebugInfo.Source","title":"Extensions"},{"location":"swift/api/Workflow/#typealiases","text":"AnyWorkflow.Output AnyWorkflow.Rendering AnyWorkflow.State This file was generated by SourceDocs on 2023-06-06 23:39:34 +0000","title":"Typealiases"},{"location":"swift/api/Workflow/classes/Lifetime/","text":"CLASS Lifetime \u00b6 Represents the lifetime of an object. Once ended, the onEnded closure is called. Properties \u00b6 hasEnded \u00b6 Methods \u00b6 onEnded(_:) \u00b6 Hook to clean-up after end of lifetime . deinit \u00b6","title":"Lifetime"},{"location":"swift/api/Workflow/classes/Lifetime/#lifetime","text":"Represents the lifetime of an object. Once ended, the onEnded closure is called.","title":"Lifetime"},{"location":"swift/api/Workflow/classes/Lifetime/#properties","text":"","title":"Properties"},{"location":"swift/api/Workflow/classes/Lifetime/#hasended","text":"","title":"hasEnded"},{"location":"swift/api/Workflow/classes/Lifetime/#methods","text":"","title":"Methods"},{"location":"swift/api/Workflow/classes/Lifetime/#onended_","text":"Hook to clean-up after end of lifetime .","title":"onEnded(_:)"},{"location":"swift/api/Workflow/classes/Lifetime/#deinit","text":"","title":"deinit"},{"location":"swift/api/Workflow/classes/RenderContext/","text":"CLASS RenderContext \u00b6 RenderContext is the composition point for the workflow tree. During a render pass, a workflow may want to defer to a child workflow to render some portion of its content. For example, a workflow that renders to a split-screen view model might delegate to child A for the left side, and child B for the right side view models. Nesting allows for a fractal tree that is constructed out of many small parts. If a parent wants to delegate to a child workflow, it must first create an instance of that workflow. This can be thought of as the model of the child workflow. It does not contain any active state, it simply contains the data necessary to create or update a workflow node. The parent then calls render(workflow:outputMap:) with two values: - The child workflow. - A closure that transforms the child\u2019s output events into the parent\u2019s Event type so that the parent can respond to events generated by the child. If the parent had previously rendered a child of the same type, the existing child workflow node is updated. If the parent had not rendered a child of the same type in the previous render pass, a new child workflow node is generated. The infrastructure then performs a render pass on the child to obtain its Rendering value, which is then returned to the caller. Methods \u00b6 makeSink(of:) \u00b6 runSideEffect(key:action:) \u00b6 Execute a side-effect action. Note that it is a programmer error to run two side-effects with the same key during the same render pass. action will be executed the first time a side-effect is run with a given key . runSideEffect calls with a given key on subsequent renders are ignored. If after a render pass, a side-effect with a key that was previously used is not used, it\u2019s lifetime ends and the Lifetime object\u2019s onEnded closure will be called. Parameters: key: represents the block of work that needs to be executed. action: a block of work that will be executed.","title":"RenderContext"},{"location":"swift/api/Workflow/classes/RenderContext/#rendercontext","text":"RenderContext is the composition point for the workflow tree. During a render pass, a workflow may want to defer to a child workflow to render some portion of its content. For example, a workflow that renders to a split-screen view model might delegate to child A for the left side, and child B for the right side view models. Nesting allows for a fractal tree that is constructed out of many small parts. If a parent wants to delegate to a child workflow, it must first create an instance of that workflow. This can be thought of as the model of the child workflow. It does not contain any active state, it simply contains the data necessary to create or update a workflow node. The parent then calls render(workflow:outputMap:) with two values: - The child workflow. - A closure that transforms the child\u2019s output events into the parent\u2019s Event type so that the parent can respond to events generated by the child. If the parent had previously rendered a child of the same type, the existing child workflow node is updated. If the parent had not rendered a child of the same type in the previous render pass, a new child workflow node is generated. The infrastructure then performs a render pass on the child to obtain its Rendering value, which is then returned to the caller.","title":"RenderContext"},{"location":"swift/api/Workflow/classes/RenderContext/#methods","text":"","title":"Methods"},{"location":"swift/api/Workflow/classes/RenderContext/#makesinkof","text":"","title":"makeSink(of:)"},{"location":"swift/api/Workflow/classes/RenderContext/#runsideeffectkeyaction","text":"Execute a side-effect action. Note that it is a programmer error to run two side-effects with the same key during the same render pass. action will be executed the first time a side-effect is run with a given key . runSideEffect calls with a given key on subsequent renders are ignored. If after a render pass, a side-effect with a key that was previously used is not used, it\u2019s lifetime ends and the Lifetime object\u2019s onEnded closure will be called. Parameters: key: represents the block of work that needs to be executed. action: a block of work that will be executed.","title":"runSideEffect(key:action:)"},{"location":"swift/api/Workflow/classes/WorkflowHost/","text":"CLASS WorkflowHost \u00b6 Manages an active workflow hierarchy. Properties \u00b6 rendering \u00b6 Represents the Rendering produced by the root workflow in the hierarchy. New Rendering values are produced as state transitions occur within the hierarchy. output \u00b6 A signal containing output events emitted by the root workflow in the hierarchy. Methods \u00b6 init(workflow:observers:debugger:) \u00b6 Initializes a new host with the given workflow at the root. Parameter workflow: The root workflow in the hierarchy Parameter observers: An optional array of WorkflowObservers that will allow runtime introspection for this WorkflowHost Parameter debugger: An optional debugger. If provided, the host will notify the debugger of updates to the workflow hierarchy as state transitions occur. update(workflow:) \u00b6 Update the input for the workflow. Will cause a render pass.","title":"WorkflowHost"},{"location":"swift/api/Workflow/classes/WorkflowHost/#workflowhost","text":"Manages an active workflow hierarchy.","title":"WorkflowHost"},{"location":"swift/api/Workflow/classes/WorkflowHost/#properties","text":"","title":"Properties"},{"location":"swift/api/Workflow/classes/WorkflowHost/#rendering","text":"Represents the Rendering produced by the root workflow in the hierarchy. New Rendering values are produced as state transitions occur within the hierarchy.","title":"rendering"},{"location":"swift/api/Workflow/classes/WorkflowHost/#output","text":"A signal containing output events emitted by the root workflow in the hierarchy.","title":"output"},{"location":"swift/api/Workflow/classes/WorkflowHost/#methods","text":"","title":"Methods"},{"location":"swift/api/Workflow/classes/WorkflowHost/#initworkflowobserversdebugger","text":"Initializes a new host with the given workflow at the root. Parameter workflow: The root workflow in the hierarchy Parameter observers: An optional array of WorkflowObservers that will allow runtime introspection for this WorkflowHost Parameter debugger: An optional debugger. If provided, the host will notify the debugger of updates to the workflow hierarchy as state transitions occur.","title":"init(workflow:observers:debugger:)"},{"location":"swift/api/Workflow/classes/WorkflowHost/#updateworkflow","text":"Update the input for the workflow. Will cause a render pass.","title":"update(workflow:)"},{"location":"swift/api/Workflow/enums/Config.RenderLoggingMode/","text":"ENUM Config.RenderLoggingMode \u00b6 Configuration options to control logging during a render pass. Cases \u00b6 none \u00b6 No data will be recorded for WorkflowNode render timings. rootsOnly \u00b6 Render timings will only be recorded for root nodes in a Workflow tree. allNodes \u00b6 Render timings will be recorded for all nodes in a Workflow tree. N.B. performance may be noticeably impacted when using this option.","title":"Config.RenderLoggingMode"},{"location":"swift/api/Workflow/enums/Config.RenderLoggingMode/#configrenderloggingmode","text":"Configuration options to control logging during a render pass.","title":"Config.RenderLoggingMode"},{"location":"swift/api/Workflow/enums/Config.RenderLoggingMode/#cases","text":"","title":"Cases"},{"location":"swift/api/Workflow/enums/Config.RenderLoggingMode/#none","text":"No data will be recorded for WorkflowNode render timings.","title":"none"},{"location":"swift/api/Workflow/enums/Config.RenderLoggingMode/#rootsonly","text":"Render timings will only be recorded for root nodes in a Workflow tree.","title":"rootsOnly"},{"location":"swift/api/Workflow/enums/Config.RenderLoggingMode/#allnodes","text":"Render timings will be recorded for all nodes in a Workflow tree. N.B. performance may be noticeably impacted when using this option.","title":"allNodes"},{"location":"swift/api/Workflow/enums/WorkflowLogging/","text":"ENUM WorkflowLogging \u00b6 Namespace for specifying logging configuration data.","title":"WorkflowLogging"},{"location":"swift/api/Workflow/enums/WorkflowLogging/#workflowlogging","text":"Namespace for specifying logging configuration data.","title":"WorkflowLogging"},{"location":"swift/api/Workflow/enums/WorkflowObservation/","text":"ENUM WorkflowObservation \u00b6 Properties \u00b6 sharedObserversInterceptor \u00b6 The DefaultObserversProvider used by all runtimes.","title":"WorkflowObservation"},{"location":"swift/api/Workflow/enums/WorkflowObservation/#workflowobservation","text":"","title":"WorkflowObservation"},{"location":"swift/api/Workflow/enums/WorkflowObservation/#properties","text":"","title":"Properties"},{"location":"swift/api/Workflow/enums/WorkflowObservation/#sharedobserversinterceptor","text":"The DefaultObserversProvider used by all runtimes.","title":"sharedObserversInterceptor"},{"location":"swift/api/Workflow/enums/WorkflowUpdateDebugInfo.Kind/","text":"ENUM WorkflowUpdateDebugInfo.Kind \u00b6 Cases \u00b6 didUpdate(source:) \u00b6 childDidUpdate(_:) \u00b6","title":"WorkflowUpdateDebugInfo.Kind"},{"location":"swift/api/Workflow/enums/WorkflowUpdateDebugInfo.Kind/#workflowupdatedebuginfokind","text":"","title":"WorkflowUpdateDebugInfo.Kind"},{"location":"swift/api/Workflow/enums/WorkflowUpdateDebugInfo.Kind/#cases","text":"","title":"Cases"},{"location":"swift/api/Workflow/enums/WorkflowUpdateDebugInfo.Kind/#didupdatesource","text":"","title":"didUpdate(source:)"},{"location":"swift/api/Workflow/enums/WorkflowUpdateDebugInfo.Kind/#childdidupdate_","text":"","title":"childDidUpdate(_:)"},{"location":"swift/api/Workflow/enums/WorkflowUpdateDebugInfo.Source/","text":"ENUM WorkflowUpdateDebugInfo.Source \u00b6 Cases \u00b6 external \u00b6 worker \u00b6 sideEffect \u00b6 subtree(_:) \u00b6","title":"WorkflowUpdateDebugInfo.Source"},{"location":"swift/api/Workflow/enums/WorkflowUpdateDebugInfo.Source/#workflowupdatedebuginfosource","text":"","title":"WorkflowUpdateDebugInfo.Source"},{"location":"swift/api/Workflow/enums/WorkflowUpdateDebugInfo.Source/#cases","text":"","title":"Cases"},{"location":"swift/api/Workflow/enums/WorkflowUpdateDebugInfo.Source/#external","text":"","title":"external"},{"location":"swift/api/Workflow/enums/WorkflowUpdateDebugInfo.Source/#worker","text":"","title":"worker"},{"location":"swift/api/Workflow/enums/WorkflowUpdateDebugInfo.Source/#sideeffect","text":"","title":"sideEffect"},{"location":"swift/api/Workflow/enums/WorkflowUpdateDebugInfo.Source/#subtree_","text":"","title":"subtree(_:)"},{"location":"swift/api/Workflow/extensions/AnyWorkflow/","text":"EXTENSION AnyWorkflow \u00b6 Methods \u00b6 render(state:context:) \u00b6 asAnyWorkflow() \u00b6 mapOutput(_:) \u00b6 Returns a new AnyWorkflow whose Output type has been transformed into the given type. Parameter transform: An escaping closure that maps the original output type into the new output type. Returns: A type erased workflow with the new output type (the rendering type remains unchanged). mapRendering(_:) \u00b6 Returns a new AnyWorkflow whose Rendering type has been transformed into the given type. Parameter transform: An escaping closure that maps the original rendering type into the new rendering type. Returns: A type erased workflow with the new rendering type (the output type remains unchanged).","title":"AnyWorkflow"},{"location":"swift/api/Workflow/extensions/AnyWorkflow/#anyworkflow","text":"","title":"AnyWorkflow"},{"location":"swift/api/Workflow/extensions/AnyWorkflow/#methods","text":"","title":"Methods"},{"location":"swift/api/Workflow/extensions/AnyWorkflow/#renderstatecontext","text":"","title":"render(state:context:)"},{"location":"swift/api/Workflow/extensions/AnyWorkflow/#asanyworkflow","text":"","title":"asAnyWorkflow()"},{"location":"swift/api/Workflow/extensions/AnyWorkflow/#mapoutput_","text":"Returns a new AnyWorkflow whose Output type has been transformed into the given type. Parameter transform: An escaping closure that maps the original output type into the new output type. Returns: A type erased workflow with the new output type (the rendering type remains unchanged).","title":"mapOutput(_:)"},{"location":"swift/api/Workflow/extensions/AnyWorkflow/#maprendering_","text":"Returns a new AnyWorkflow whose Rendering type has been transformed into the given type. Parameter transform: An escaping closure that maps the original rendering type into the new rendering type. Returns: A type erased workflow with the new rendering type (the output type remains unchanged).","title":"mapRendering(_:)"},{"location":"swift/api/Workflow/extensions/AnyWorkflowAction/","text":"EXTENSION AnyWorkflowAction \u00b6 Properties \u00b6 noAction \u00b6 Creates a type-erased workflow action that does nothing (it leaves state unchanged and does not emit an output event). Methods \u00b6 init(sendingOutput:) \u00b6 Creates a type-erased workflow action that simply sends the given output event. Parameter output: The output event to send when this action is applied.","title":"AnyWorkflowAction"},{"location":"swift/api/Workflow/extensions/AnyWorkflowAction/#anyworkflowaction","text":"","title":"AnyWorkflowAction"},{"location":"swift/api/Workflow/extensions/AnyWorkflowAction/#properties","text":"","title":"Properties"},{"location":"swift/api/Workflow/extensions/AnyWorkflowAction/#noaction","text":"Creates a type-erased workflow action that does nothing (it leaves state unchanged and does not emit an output event).","title":"noAction"},{"location":"swift/api/Workflow/extensions/AnyWorkflowAction/#methods","text":"","title":"Methods"},{"location":"swift/api/Workflow/extensions/AnyWorkflowAction/#initsendingoutput","text":"Creates a type-erased workflow action that simply sends the given output event. Parameter output: The output event to send when this action is applied.","title":"init(sendingOutput:)"},{"location":"swift/api/Workflow/extensions/AnyWorkflowConvertible/","text":"EXTENSION AnyWorkflowConvertible \u00b6 Methods \u00b6 mapOutput(_:) \u00b6 mapRendering(_:) \u00b6 rendered(in:key:) \u00b6 Creates or updates a child workflow of the given type, performs a render pass, and returns the result. Note that it is a programmer error to render two instances of a given workflow type with the same key during the same render pass. Parameter context: The context with which the workflow will be rendered. Parameter key: A string that uniquely identifies this workflow. Returns: The Rendering generated by the workflow. rendered(in:key:outputMap:) \u00b6 rendered(in:key:) \u00b6 rendered(in:key:) \u00b6 Creates or updates a child workflow of the given type, performs a render pass, and returns the result. Note that it is a programmer error to render two instances of a given workflow type with the same key during the same render pass. Parameter context: The context with which the workflow will be rendered. Parameter key: A string that uniquely identifies this workflow. Returns: The Rendering generated by the workflow. running(in:key:outputMap:) \u00b6 running(in:key:) \u00b6 onOutput(_:) \u00b6 Process an Output Parameter apply: On Output , mutate State as necessary and return new Output (or nil ). ignoringOutput() \u00b6 Wraps this workflow in a workflow that ignores all outputs. Returns: An AnyWorkflow with the same rendering and no output.","title":"AnyWorkflowConvertible"},{"location":"swift/api/Workflow/extensions/AnyWorkflowConvertible/#anyworkflowconvertible","text":"","title":"AnyWorkflowConvertible"},{"location":"swift/api/Workflow/extensions/AnyWorkflowConvertible/#methods","text":"","title":"Methods"},{"location":"swift/api/Workflow/extensions/AnyWorkflowConvertible/#mapoutput_","text":"","title":"mapOutput(_:)"},{"location":"swift/api/Workflow/extensions/AnyWorkflowConvertible/#maprendering_","text":"","title":"mapRendering(_:)"},{"location":"swift/api/Workflow/extensions/AnyWorkflowConvertible/#renderedinkey","text":"Creates or updates a child workflow of the given type, performs a render pass, and returns the result. Note that it is a programmer error to render two instances of a given workflow type with the same key during the same render pass. Parameter context: The context with which the workflow will be rendered. Parameter key: A string that uniquely identifies this workflow. Returns: The Rendering generated by the workflow.","title":"rendered(in:key:)"},{"location":"swift/api/Workflow/extensions/AnyWorkflowConvertible/#renderedinkeyoutputmap","text":"","title":"rendered(in:key:outputMap:)"},{"location":"swift/api/Workflow/extensions/AnyWorkflowConvertible/#renderedinkey_1","text":"","title":"rendered(in:key:)"},{"location":"swift/api/Workflow/extensions/AnyWorkflowConvertible/#renderedinkey_2","text":"Creates or updates a child workflow of the given type, performs a render pass, and returns the result. Note that it is a programmer error to render two instances of a given workflow type with the same key during the same render pass. Parameter context: The context with which the workflow will be rendered. Parameter key: A string that uniquely identifies this workflow. Returns: The Rendering generated by the workflow.","title":"rendered(in:key:)"},{"location":"swift/api/Workflow/extensions/AnyWorkflowConvertible/#runninginkeyoutputmap","text":"","title":"running(in:key:outputMap:)"},{"location":"swift/api/Workflow/extensions/AnyWorkflowConvertible/#runninginkey","text":"","title":"running(in:key:)"},{"location":"swift/api/Workflow/extensions/AnyWorkflowConvertible/#onoutput_","text":"Process an Output Parameter apply: On Output , mutate State as necessary and return new Output (or nil ).","title":"onOutput(_:)"},{"location":"swift/api/Workflow/extensions/AnyWorkflowConvertible/#ignoringoutput","text":"Wraps this workflow in a workflow that ignores all outputs. Returns: An AnyWorkflow with the same rendering and no output.","title":"ignoringOutput()"},{"location":"swift/api/Workflow/extensions/DispatchQueue/","text":"EXTENSION DispatchQueue \u00b6 Properties \u00b6 workflowExecution \u00b6","title":"DispatchQueue"},{"location":"swift/api/Workflow/extensions/DispatchQueue/#dispatchqueue","text":"","title":"DispatchQueue"},{"location":"swift/api/Workflow/extensions/DispatchQueue/#properties","text":"","title":"Properties"},{"location":"swift/api/Workflow/extensions/DispatchQueue/#workflowexecution","text":"","title":"workflowExecution"},{"location":"swift/api/Workflow/extensions/RenderContext/","text":"EXTENSION RenderContext \u00b6 Methods \u00b6 makeSink(of:onEvent:) \u00b6 makeOutputSink() \u00b6 Generates a sink that allows sending the Workflow\u2019s output wrapped in an AnyWorkflowAction, allowing bypassing an intermediate action. makeStateMutationSink() \u00b6 Creates StateMutationSink . To create a sink: let stateMutationSink = context.makeStateMutationSink() To mutate State on an event: stateMutationSink.send(\\State.value, value: 10)","title":"RenderContext"},{"location":"swift/api/Workflow/extensions/RenderContext/#rendercontext","text":"","title":"RenderContext"},{"location":"swift/api/Workflow/extensions/RenderContext/#methods","text":"","title":"Methods"},{"location":"swift/api/Workflow/extensions/RenderContext/#makesinkofonevent","text":"","title":"makeSink(of:onEvent:)"},{"location":"swift/api/Workflow/extensions/RenderContext/#makeoutputsink","text":"Generates a sink that allows sending the Workflow\u2019s output wrapped in an AnyWorkflowAction, allowing bypassing an intermediate action.","title":"makeOutputSink()"},{"location":"swift/api/Workflow/extensions/RenderContext/#makestatemutationsink","text":"Creates StateMutationSink . To create a sink: let stateMutationSink = context.makeStateMutationSink() To mutate State on an event: stateMutationSink.send(\\State.value, value: 10)","title":"makeStateMutationSink()"},{"location":"swift/api/Workflow/extensions/Workflow/","text":"EXTENSION Workflow \u00b6 Methods \u00b6 workflowDidChange(from:state:) \u00b6 makeInitialState() \u00b6 workflowDidChange(from:state:) \u00b6 asAnyWorkflow() \u00b6","title":"Workflow"},{"location":"swift/api/Workflow/extensions/Workflow/#workflow","text":"","title":"Workflow"},{"location":"swift/api/Workflow/extensions/Workflow/#methods","text":"","title":"Methods"},{"location":"swift/api/Workflow/extensions/Workflow/#workflowdidchangefromstate","text":"","title":"workflowDidChange(from:state:)"},{"location":"swift/api/Workflow/extensions/Workflow/#makeinitialstate","text":"","title":"makeInitialState()"},{"location":"swift/api/Workflow/extensions/Workflow/#workflowdidchangefromstate_1","text":"","title":"workflowDidChange(from:state:)"},{"location":"swift/api/Workflow/extensions/Workflow/#asanyworkflow","text":"","title":"asAnyWorkflow()"},{"location":"swift/api/Workflow/extensions/WorkflowLogging.Config/","text":"EXTENSION WorkflowLogging.Config \u00b6 Properties \u00b6 debug \u00b6 Logging config that will output the most information. Will also have the most noticeable effect on performance. rootRendersAndActions \u00b6 Logging config that will record render timings for root nodes as well as action events. This provides a reasonable performance tradeoff if you\u2019re interested in the runtime\u2019s behavior but don\u2019t wan to pay the price of logging everything.","title":"WorkflowLogging.Config"},{"location":"swift/api/Workflow/extensions/WorkflowLogging.Config/#workflowloggingconfig","text":"","title":"WorkflowLogging.Config"},{"location":"swift/api/Workflow/extensions/WorkflowLogging.Config/#properties","text":"","title":"Properties"},{"location":"swift/api/Workflow/extensions/WorkflowLogging.Config/#debug","text":"Logging config that will output the most information. Will also have the most noticeable effect on performance.","title":"debug"},{"location":"swift/api/Workflow/extensions/WorkflowLogging.Config/#rootrendersandactions","text":"Logging config that will record render timings for root nodes as well as action events. This provides a reasonable performance tradeoff if you\u2019re interested in the runtime\u2019s behavior but don\u2019t wan to pay the price of logging everything.","title":"rootRendersAndActions"},{"location":"swift/api/Workflow/extensions/WorkflowLogging/","text":"EXTENSION WorkflowLogging \u00b6 Properties \u00b6 enabled \u00b6 Global setting to enable or disable logging. Note, this is independent of the specified config value, and simply governs whether the runtime should emit any logs. To enable logging, at a minimum you must set: WorkflowLogging.enabled = true If you wish for more control over what the runtime will log, you may additionally specify a custom value for WorkflowLogging.config . config \u00b6 Configuration options used to determine which activities are logged.","title":"WorkflowLogging"},{"location":"swift/api/Workflow/extensions/WorkflowLogging/#workflowlogging","text":"","title":"WorkflowLogging"},{"location":"swift/api/Workflow/extensions/WorkflowLogging/#properties","text":"","title":"Properties"},{"location":"swift/api/Workflow/extensions/WorkflowLogging/#enabled","text":"Global setting to enable or disable logging. Note, this is independent of the specified config value, and simply governs whether the runtime should emit any logs. To enable logging, at a minimum you must set: WorkflowLogging.enabled = true If you wish for more control over what the runtime will log, you may additionally specify a custom value for WorkflowLogging.config .","title":"enabled"},{"location":"swift/api/Workflow/extensions/WorkflowLogging/#config","text":"Configuration options used to determine which activities are logged.","title":"config"},{"location":"swift/api/Workflow/extensions/WorkflowObserver/","text":"EXTENSION WorkflowObserver \u00b6 Methods \u00b6 sessionDidBegin(_:) \u00b6 sessionDidEnd(_:) \u00b6 workflowDidMakeInitialState(_:initialState:session:) \u00b6 workflowWillRender(_:state:session:) \u00b6 workflowDidChange(from:to:state:session:) \u00b6 workflowDidReceiveAction(_:workflow:session:) \u00b6 workflowWillApplyAction(_:workflow:state:session:) \u00b6","title":"WorkflowObserver"},{"location":"swift/api/Workflow/extensions/WorkflowObserver/#workflowobserver","text":"","title":"WorkflowObserver"},{"location":"swift/api/Workflow/extensions/WorkflowObserver/#methods","text":"","title":"Methods"},{"location":"swift/api/Workflow/extensions/WorkflowObserver/#sessiondidbegin_","text":"","title":"sessionDidBegin(_:)"},{"location":"swift/api/Workflow/extensions/WorkflowObserver/#sessiondidend_","text":"","title":"sessionDidEnd(_:)"},{"location":"swift/api/Workflow/extensions/WorkflowObserver/#workflowdidmakeinitialstate_initialstatesession","text":"","title":"workflowDidMakeInitialState(_:initialState:session:)"},{"location":"swift/api/Workflow/extensions/WorkflowObserver/#workflowwillrender_statesession","text":"","title":"workflowWillRender(_:state:session:)"},{"location":"swift/api/Workflow/extensions/WorkflowObserver/#workflowdidchangefromtostatesession","text":"","title":"workflowDidChange(from:to:state:session:)"},{"location":"swift/api/Workflow/extensions/WorkflowObserver/#workflowdidreceiveaction_workflowsession","text":"","title":"workflowDidReceiveAction(_:workflow:session:)"},{"location":"swift/api/Workflow/extensions/WorkflowObserver/#workflowwillapplyaction_workflowstatesession","text":"","title":"workflowWillApplyAction(_:workflow:state:session:)"},{"location":"swift/api/Workflow/extensions/WorkflowUpdateDebugInfo.Kind/","text":"EXTENSION WorkflowUpdateDebugInfo.Kind \u00b6 Methods \u00b6 encode(to:) \u00b6 init(from:) \u00b6","title":"WorkflowUpdateDebugInfo.Kind"},{"location":"swift/api/Workflow/extensions/WorkflowUpdateDebugInfo.Kind/#workflowupdatedebuginfokind","text":"","title":"WorkflowUpdateDebugInfo.Kind"},{"location":"swift/api/Workflow/extensions/WorkflowUpdateDebugInfo.Kind/#methods","text":"","title":"Methods"},{"location":"swift/api/Workflow/extensions/WorkflowUpdateDebugInfo.Kind/#encodeto","text":"","title":"encode(to:)"},{"location":"swift/api/Workflow/extensions/WorkflowUpdateDebugInfo.Kind/#initfrom","text":"","title":"init(from:)"},{"location":"swift/api/Workflow/extensions/WorkflowUpdateDebugInfo.Source/","text":"EXTENSION WorkflowUpdateDebugInfo.Source \u00b6 Methods \u00b6 encode(to:) \u00b6 init(from:) \u00b6","title":"WorkflowUpdateDebugInfo.Source"},{"location":"swift/api/Workflow/extensions/WorkflowUpdateDebugInfo.Source/#workflowupdatedebuginfosource","text":"","title":"WorkflowUpdateDebugInfo.Source"},{"location":"swift/api/Workflow/extensions/WorkflowUpdateDebugInfo.Source/#methods","text":"","title":"Methods"},{"location":"swift/api/Workflow/extensions/WorkflowUpdateDebugInfo.Source/#encodeto","text":"","title":"encode(to:)"},{"location":"swift/api/Workflow/extensions/WorkflowUpdateDebugInfo.Source/#initfrom","text":"","title":"init(from:)"},{"location":"swift/api/Workflow/protocols/AnyWorkflowConvertible/","text":"PROTOCOL AnyWorkflowConvertible \u00b6 Conforming types can be converted into AnyWorkflow values, allowing them to participate in a workflow hierarchy. Methods \u00b6 asAnyWorkflow() \u00b6 Returns an AnyWorkflow representing this value.","title":"AnyWorkflowConvertible"},{"location":"swift/api/Workflow/protocols/AnyWorkflowConvertible/#anyworkflowconvertible","text":"Conforming types can be converted into AnyWorkflow values, allowing them to participate in a workflow hierarchy.","title":"AnyWorkflowConvertible"},{"location":"swift/api/Workflow/protocols/AnyWorkflowConvertible/#methods","text":"","title":"Methods"},{"location":"swift/api/Workflow/protocols/AnyWorkflowConvertible/#asanyworkflow","text":"Returns an AnyWorkflow representing this value.","title":"asAnyWorkflow()"},{"location":"swift/api/Workflow/protocols/ObserversInterceptor/","text":"PROTOCOL ObserversInterceptor \u00b6 Methods \u00b6 workflowObservers(for:) \u00b6 Provides a single access point to provide the final list of WorkflowObserver used by the runtime. This may be used to ensure a known set of observers is used in a particular order for all WorkflowHost s created over the life of a program. - Parameter initialObservers: Array of observers passed to a WorkflowHost constructor - Returns: The array of WorkflowObserver s to be used by the WorkflowHost","title":"ObserversInterceptor"},{"location":"swift/api/Workflow/protocols/ObserversInterceptor/#observersinterceptor","text":"","title":"ObserversInterceptor"},{"location":"swift/api/Workflow/protocols/ObserversInterceptor/#methods","text":"","title":"Methods"},{"location":"swift/api/Workflow/protocols/ObserversInterceptor/#workflowobserversfor","text":"Provides a single access point to provide the final list of WorkflowObserver used by the runtime. This may be used to ensure a known set of observers is used in a particular order for all WorkflowHost s created over the life of a program. - Parameter initialObservers: Array of observers passed to a WorkflowHost constructor - Returns: The array of WorkflowObserver s to be used by the WorkflowHost","title":"workflowObservers(for:)"},{"location":"swift/api/Workflow/protocols/Workflow/","text":"PROTOCOL Workflow \u00b6 Defines a node in the workflow tree. Initialization and Updating A workflow node comes into existence after its parent produces an instance of that workflow and uses it during a render pass (see the render method for more details). If this is the first time the parent has rendered a child of this type, a new workflow node is created. The workflow passed in from the parent will be used to invoke initialState() to obtain an initial state. If the parent had previously rendered a child of this type, the existing workflow node will be updated. workflowDidChange(from:state:) will be invoked to allow the workflow to respond to the change. Render After a workflow node has been created, or any time its state changes, a render pass occurs. The render pass takes the workflow that was passed down from the parent along with the current state and generates a value of type Rendering . In a common case, a workflow might render to a screen model for display. func render(state: State, context: RenderContext<Self>) -> MyScreenModel { return MyScreenModel() } Methods \u00b6 makeInitialState() \u00b6 This method is invoked once when a workflow node comes into existence. Returns: The initial state for the workflow. workflowDidChange(from:state:) \u00b6 Called when a new workflow is passed down from the parent to an existing workflow node. Parameter previousWorkflow: The workflow before the update. Parameter state: The current state. render(state:context:) \u00b6 Called by the internal Workflow infrastructure to \u201crender\u201d the current state into Rendering . A workflow\u2019s Rendering type is commonly a view or screen model. Parameter state: The current state. Parameter context: The workflow context is the composition point for the workflow tree. To use a nested workflow, instantiate it based on the current state, then call rendered(in:key:outputMap:) . This will return the child\u2019s Rendering type after creating or updating the nested workflow.","title":"Workflow"},{"location":"swift/api/Workflow/protocols/Workflow/#workflow","text":"Defines a node in the workflow tree. Initialization and Updating A workflow node comes into existence after its parent produces an instance of that workflow and uses it during a render pass (see the render method for more details). If this is the first time the parent has rendered a child of this type, a new workflow node is created. The workflow passed in from the parent will be used to invoke initialState() to obtain an initial state. If the parent had previously rendered a child of this type, the existing workflow node will be updated. workflowDidChange(from:state:) will be invoked to allow the workflow to respond to the change. Render After a workflow node has been created, or any time its state changes, a render pass occurs. The render pass takes the workflow that was passed down from the parent along with the current state and generates a value of type Rendering . In a common case, a workflow might render to a screen model for display. func render(state: State, context: RenderContext<Self>) -> MyScreenModel { return MyScreenModel() }","title":"Workflow"},{"location":"swift/api/Workflow/protocols/Workflow/#methods","text":"","title":"Methods"},{"location":"swift/api/Workflow/protocols/Workflow/#makeinitialstate","text":"This method is invoked once when a workflow node comes into existence. Returns: The initial state for the workflow.","title":"makeInitialState()"},{"location":"swift/api/Workflow/protocols/Workflow/#workflowdidchangefromstate","text":"Called when a new workflow is passed down from the parent to an existing workflow node. Parameter previousWorkflow: The workflow before the update. Parameter state: The current state.","title":"workflowDidChange(from:state:)"},{"location":"swift/api/Workflow/protocols/Workflow/#renderstatecontext","text":"Called by the internal Workflow infrastructure to \u201crender\u201d the current state into Rendering . A workflow\u2019s Rendering type is commonly a view or screen model. Parameter state: The current state. Parameter context: The workflow context is the composition point for the workflow tree. To use a nested workflow, instantiate it based on the current state, then call rendered(in:key:outputMap:) . This will return the child\u2019s Rendering type after creating or updating the nested workflow.","title":"render(state:context:)"},{"location":"swift/api/Workflow/protocols/WorkflowAction/","text":"PROTOCOL WorkflowAction \u00b6 Conforming types represent an action that advances a workflow. When applied, an action emits the next state and / or output for the workflow. Methods \u00b6 apply(toState:) \u00b6 Applies this action to a given state of the workflow, optionally returning an output event. Parameter state: The current state of the workflow. The state is passed as an inout param, allowing actions to modify state during application. Returns: An optional output event for the workflow. If an output event is returned, it will be passed up the workflow hierarchy to this workflow\u2019s parent.","title":"WorkflowAction"},{"location":"swift/api/Workflow/protocols/WorkflowAction/#workflowaction","text":"Conforming types represent an action that advances a workflow. When applied, an action emits the next state and / or output for the workflow.","title":"WorkflowAction"},{"location":"swift/api/Workflow/protocols/WorkflowAction/#methods","text":"","title":"Methods"},{"location":"swift/api/Workflow/protocols/WorkflowAction/#applytostate","text":"Applies this action to a given state of the workflow, optionally returning an output event. Parameter state: The current state of the workflow. The state is passed as an inout param, allowing actions to modify state during application. Returns: An optional output event for the workflow. If an output event is returned, it will be passed up the workflow hierarchy to this workflow\u2019s parent.","title":"apply(toState:)"},{"location":"swift/api/Workflow/protocols/WorkflowDebugger/","text":"PROTOCOL WorkflowDebugger \u00b6 Defines a type that receives debug information about a running workflow hierarchy. Methods \u00b6 didEnterInitialState(snapshot:) \u00b6 Called once when the workflow hierarchy initializes. Parameter snapshot: Debug information about the workflow hierarchy. didUpdate(snapshot:updateInfo:) \u00b6 Called when an update occurs anywhere within the workflow hierarchy. Parameter snapshot: Debug information about the workflow hierarchy after the update. Parameter updateInfo: Information about the update.","title":"WorkflowDebugger"},{"location":"swift/api/Workflow/protocols/WorkflowDebugger/#workflowdebugger","text":"Defines a type that receives debug information about a running workflow hierarchy.","title":"WorkflowDebugger"},{"location":"swift/api/Workflow/protocols/WorkflowDebugger/#methods","text":"","title":"Methods"},{"location":"swift/api/Workflow/protocols/WorkflowDebugger/#didenterinitialstatesnapshot","text":"Called once when the workflow hierarchy initializes. Parameter snapshot: Debug information about the workflow hierarchy.","title":"didEnterInitialState(snapshot:)"},{"location":"swift/api/Workflow/protocols/WorkflowDebugger/#didupdatesnapshotupdateinfo","text":"Called when an update occurs anywhere within the workflow hierarchy. Parameter snapshot: Debug information about the workflow hierarchy after the update. Parameter updateInfo: Information about the update.","title":"didUpdate(snapshot:updateInfo:)"},{"location":"swift/api/Workflow/protocols/WorkflowObserver/","text":"PROTOCOL WorkflowObserver \u00b6 The WorkflowObserver protocol provides an interface to receive updates during the runtime\u2019s execution loop. All requirements are optional, and no-ops are provided by default. Methods \u00b6 sessionDidBegin(_:) \u00b6 Indicates the start of a WorkflowSession , which tracks the life of the underlying WorkflowNode used to provide renderings for a given Workflow type and rendering key. - Parameter session: The WorkflowSession that began. sessionDidEnd(_:) \u00b6 Marks the end of a WorkflowSession , indicating that the corresponding WorkflowNode has been removed from the tree of Workflows. - Parameter session: The WorkflowSession that ended. workflowDidMakeInitialState(_:initialState:session:) \u00b6 Indicates a Workflow produced its initial state value. - Parameters: - workflow: The Workflow that just produced its initial state. - initialState: The State that was created. - session: The WorkflowSession corresponding to the backing WorkflowNode workflowWillRender(_:state:session:) \u00b6 Called before a Workflow is queried for its latest Rendering . - Parameters: - workflow: The Workflow that is about to be render. - state: The corresponding State that will be used during the render call. - session: The WorkflowSession corresponding to the backing WorkflowNode . - Returns: An optional closure to be called immediately after the new Rendering is produced, which takes the rendering as the only parameter. workflowDidChange(from:to:state:session:) \u00b6 Called after an existing Workflow is updated. - Parameters: - oldWorkflow: The previous Workflow - newWorkflow: The new Workflow - state: The state after the update has occurred. - session: The WorkflowSession corresponding to the backing WorkflowNode . workflowDidReceiveAction(_:workflow:session:) \u00b6 Called after a WorkflowAction is received, but before it has been handled and propagated up the tree. - Parameters: - action: The action that was received. - session: The WorkflowSession corresponding to the backing WorkflowNode . workflowWillApplyAction(_:workflow:state:session:) \u00b6 Called when a WorkflowAction will be applied to its corresponding Workflow\u2019s State - Parameters: - action: The action that will be applied. - workflow: The action\u2019s corresponding Workflow . - state: The state to which the action will be applied. - session: The WorkflowSession corresponding to the backing WorkflowNode . - Returns: An optional closure to be called immediately after the action is applied to the State , and an optional Output has been produced. The closure takes the updated state and optional output as its arguments.","title":"WorkflowObserver"},{"location":"swift/api/Workflow/protocols/WorkflowObserver/#workflowobserver","text":"The WorkflowObserver protocol provides an interface to receive updates during the runtime\u2019s execution loop. All requirements are optional, and no-ops are provided by default.","title":"WorkflowObserver"},{"location":"swift/api/Workflow/protocols/WorkflowObserver/#methods","text":"","title":"Methods"},{"location":"swift/api/Workflow/protocols/WorkflowObserver/#sessiondidbegin_","text":"Indicates the start of a WorkflowSession , which tracks the life of the underlying WorkflowNode used to provide renderings for a given Workflow type and rendering key. - Parameter session: The WorkflowSession that began.","title":"sessionDidBegin(_:)"},{"location":"swift/api/Workflow/protocols/WorkflowObserver/#sessiondidend_","text":"Marks the end of a WorkflowSession , indicating that the corresponding WorkflowNode has been removed from the tree of Workflows. - Parameter session: The WorkflowSession that ended.","title":"sessionDidEnd(_:)"},{"location":"swift/api/Workflow/protocols/WorkflowObserver/#workflowdidmakeinitialstate_initialstatesession","text":"Indicates a Workflow produced its initial state value. - Parameters: - workflow: The Workflow that just produced its initial state. - initialState: The State that was created. - session: The WorkflowSession corresponding to the backing WorkflowNode","title":"workflowDidMakeInitialState(_:initialState:session:)"},{"location":"swift/api/Workflow/protocols/WorkflowObserver/#workflowwillrender_statesession","text":"Called before a Workflow is queried for its latest Rendering . - Parameters: - workflow: The Workflow that is about to be render. - state: The corresponding State that will be used during the render call. - session: The WorkflowSession corresponding to the backing WorkflowNode . - Returns: An optional closure to be called immediately after the new Rendering is produced, which takes the rendering as the only parameter.","title":"workflowWillRender(_:state:session:)"},{"location":"swift/api/Workflow/protocols/WorkflowObserver/#workflowdidchangefromtostatesession","text":"Called after an existing Workflow is updated. - Parameters: - oldWorkflow: The previous Workflow - newWorkflow: The new Workflow - state: The state after the update has occurred. - session: The WorkflowSession corresponding to the backing WorkflowNode .","title":"workflowDidChange(from:to:state:session:)"},{"location":"swift/api/Workflow/protocols/WorkflowObserver/#workflowdidreceiveaction_workflowsession","text":"Called after a WorkflowAction is received, but before it has been handled and propagated up the tree. - Parameters: - action: The action that was received. - session: The WorkflowSession corresponding to the backing WorkflowNode .","title":"workflowDidReceiveAction(_:workflow:session:)"},{"location":"swift/api/Workflow/protocols/WorkflowObserver/#workflowwillapplyaction_workflowstatesession","text":"Called when a WorkflowAction will be applied to its corresponding Workflow\u2019s State - Parameters: - action: The action that will be applied. - workflow: The action\u2019s corresponding Workflow . - state: The state to which the action will be applied. - session: The WorkflowSession corresponding to the backing WorkflowNode . - Returns: An optional closure to be called immediately after the action is applied to the State , and an optional Output has been produced. The closure takes the updated state and optional output as its arguments.","title":"workflowWillApplyAction(_:workflow:state:session:)"},{"location":"swift/api/Workflow/structs/AnyWorkflow/","text":"STRUCT AnyWorkflow \u00b6 A type-erased wrapper that contains a workflow with the given Rendering and Output types. Properties \u00b6 base \u00b6 The underlying erased workflow instance workflowType \u00b6 The underlying workflow\u2019s implementation type. Methods \u00b6 init(_:) \u00b6 Initializes a new type-erased wrapper for the given workflow.","title":"AnyWorkflow"},{"location":"swift/api/Workflow/structs/AnyWorkflow/#anyworkflow","text":"A type-erased wrapper that contains a workflow with the given Rendering and Output types.","title":"AnyWorkflow"},{"location":"swift/api/Workflow/structs/AnyWorkflow/#properties","text":"","title":"Properties"},{"location":"swift/api/Workflow/structs/AnyWorkflow/#base","text":"The underlying erased workflow instance","title":"base"},{"location":"swift/api/Workflow/structs/AnyWorkflow/#workflowtype","text":"The underlying workflow\u2019s implementation type.","title":"workflowType"},{"location":"swift/api/Workflow/structs/AnyWorkflow/#methods","text":"","title":"Methods"},{"location":"swift/api/Workflow/structs/AnyWorkflow/#init_","text":"Initializes a new type-erased wrapper for the given workflow.","title":"init(_:)"},{"location":"swift/api/Workflow/structs/AnyWorkflowAction/","text":"STRUCT AnyWorkflowAction \u00b6 A type-erased workflow action. The AnyWorkflowAction type forwards apply to an underlying workflow action, hiding its specific underlying type. Properties \u00b6 base \u00b6 The underlying type-erased WorkflowAction isClosureBased \u00b6 True iff the underlying apply implementation is defined by a closure vs wrapping a WorkflowAction conformance Methods \u00b6 init(_:) \u00b6 Creates a type-erased workflow action that wraps the given instance. Parameter base: A workflow action to wrap. init(_:fileID:line:) \u00b6 Creates a type-erased workflow action with the given apply implementation. Parameter apply: the apply function for the resulting action. apply(toState:) \u00b6","title":"AnyWorkflowAction"},{"location":"swift/api/Workflow/structs/AnyWorkflowAction/#anyworkflowaction","text":"A type-erased workflow action. The AnyWorkflowAction type forwards apply to an underlying workflow action, hiding its specific underlying type.","title":"AnyWorkflowAction"},{"location":"swift/api/Workflow/structs/AnyWorkflowAction/#properties","text":"","title":"Properties"},{"location":"swift/api/Workflow/structs/AnyWorkflowAction/#base","text":"The underlying type-erased WorkflowAction","title":"base"},{"location":"swift/api/Workflow/structs/AnyWorkflowAction/#isclosurebased","text":"True iff the underlying apply implementation is defined by a closure vs wrapping a WorkflowAction conformance","title":"isClosureBased"},{"location":"swift/api/Workflow/structs/AnyWorkflowAction/#methods","text":"","title":"Methods"},{"location":"swift/api/Workflow/structs/AnyWorkflowAction/#init_","text":"Creates a type-erased workflow action that wraps the given instance. Parameter base: A workflow action to wrap.","title":"init(_:)"},{"location":"swift/api/Workflow/structs/AnyWorkflowAction/#init_fileidline","text":"Creates a type-erased workflow action with the given apply implementation. Parameter apply: the apply function for the resulting action.","title":"init(_:fileID:line:)"},{"location":"swift/api/Workflow/structs/AnyWorkflowAction/#applytostate","text":"","title":"apply(toState:)"},{"location":"swift/api/Workflow/structs/Sink/","text":"STRUCT Sink \u00b6 Sink is a type that receives incoming values (commonly events or WorkflowAction ) Use RenderContext.makeSink to create instances. Methods \u00b6 init(_:) \u00b6 Initializes a new sink with the given closure. send(_:) \u00b6 Sends a new event into the sink. Parameter event: The value to send into the sink. contraMap(_:) \u00b6 Generates a new sink of type NewValue. Given a transform closure, the following code is functionally equivalent: sink.send(transform(value)) sink.contraMap(transform).send(value) Trivia : Why is this called contraMap ? - map turns Type<T> into Type<U> via (T)->U . - contraMap turns Type<T> into Type<U> via (U)->T Another way to think about this is: map transforms a type by changing the output types of its API, while contraMap transforms a type by changing the input types of its API. Parameter transform: An escaping closure that transforms T into Event .","title":"Sink"},{"location":"swift/api/Workflow/structs/Sink/#sink","text":"Sink is a type that receives incoming values (commonly events or WorkflowAction ) Use RenderContext.makeSink to create instances.","title":"Sink"},{"location":"swift/api/Workflow/structs/Sink/#methods","text":"","title":"Methods"},{"location":"swift/api/Workflow/structs/Sink/#init_","text":"Initializes a new sink with the given closure.","title":"init(_:)"},{"location":"swift/api/Workflow/structs/Sink/#send_","text":"Sends a new event into the sink. Parameter event: The value to send into the sink.","title":"send(_:)"},{"location":"swift/api/Workflow/structs/Sink/#contramap_","text":"Generates a new sink of type NewValue. Given a transform closure, the following code is functionally equivalent: sink.send(transform(value)) sink.contraMap(transform).send(value) Trivia : Why is this called contraMap ? - map turns Type<T> into Type<U> via (T)->U . - contraMap turns Type<T> into Type<U> via (U)->T Another way to think about this is: map transforms a type by changing the output types of its API, while contraMap transforms a type by changing the input types of its API. Parameter transform: An escaping closure that transforms T into Event .","title":"contraMap(_:)"},{"location":"swift/api/Workflow/structs/StateMutationSink/","text":"STRUCT StateMutationSink \u00b6 StateMutationSink provides a Sink that helps mutate State using it\u2019s KeyPath . Methods \u00b6 send(_:) \u00b6 Sends message to StateMutationSink to update State \u2018s value using the provided closure. Parameters: update: The `State`` mutation to perform. send(_:value:) \u00b6 Sends message to StateMutationSink to update State \u2018s value at KeyPath with Value . Parameters: keyPath: Key path of State whose value needs to be mutated. value: Value to update State with.","title":"StateMutationSink"},{"location":"swift/api/Workflow/structs/StateMutationSink/#statemutationsink","text":"StateMutationSink provides a Sink that helps mutate State using it\u2019s KeyPath .","title":"StateMutationSink"},{"location":"swift/api/Workflow/structs/StateMutationSink/#methods","text":"","title":"Methods"},{"location":"swift/api/Workflow/structs/StateMutationSink/#send_","text":"Sends message to StateMutationSink to update State \u2018s value using the provided closure. Parameters: update: The `State`` mutation to perform.","title":"send(_:)"},{"location":"swift/api/Workflow/structs/StateMutationSink/#send_value","text":"Sends message to StateMutationSink to update State \u2018s value at KeyPath with Value . Parameters: keyPath: Key path of State whose value needs to be mutated. value: Value to update State with.","title":"send(_:value:)"},{"location":"swift/api/Workflow/structs/WorkflowHierarchyDebugSnapshot.Child/","text":"STRUCT WorkflowHierarchyDebugSnapshot.Child \u00b6 Properties \u00b6 key \u00b6 snapshot \u00b6","title":"WorkflowHierarchyDebugSnapshot.Child"},{"location":"swift/api/Workflow/structs/WorkflowHierarchyDebugSnapshot.Child/#workflowhierarchydebugsnapshotchild","text":"","title":"WorkflowHierarchyDebugSnapshot.Child"},{"location":"swift/api/Workflow/structs/WorkflowHierarchyDebugSnapshot.Child/#properties","text":"","title":"Properties"},{"location":"swift/api/Workflow/structs/WorkflowHierarchyDebugSnapshot.Child/#key","text":"","title":"key"},{"location":"swift/api/Workflow/structs/WorkflowHierarchyDebugSnapshot.Child/#snapshot","text":"","title":"snapshot"},{"location":"swift/api/Workflow/structs/WorkflowHierarchyDebugSnapshot/","text":"STRUCT WorkflowHierarchyDebugSnapshot \u00b6 Properties \u00b6 workflowType \u00b6 stateDescription \u00b6 children \u00b6","title":"WorkflowHierarchyDebugSnapshot"},{"location":"swift/api/Workflow/structs/WorkflowHierarchyDebugSnapshot/#workflowhierarchydebugsnapshot","text":"","title":"WorkflowHierarchyDebugSnapshot"},{"location":"swift/api/Workflow/structs/WorkflowHierarchyDebugSnapshot/#properties","text":"","title":"Properties"},{"location":"swift/api/Workflow/structs/WorkflowHierarchyDebugSnapshot/#workflowtype","text":"","title":"workflowType"},{"location":"swift/api/Workflow/structs/WorkflowHierarchyDebugSnapshot/#statedescription","text":"","title":"stateDescription"},{"location":"swift/api/Workflow/structs/WorkflowHierarchyDebugSnapshot/#children","text":"","title":"children"},{"location":"swift/api/Workflow/structs/WorkflowLogging.Config/","text":"STRUCT WorkflowLogging.Config \u00b6 Properties \u00b6 renderLoggingMode \u00b6 logLifetimes \u00b6 When true , the interval spanning a WorkflowNode\u2019s lifetime will be recorded. logActions \u00b6 When true , action events will be recorded.","title":"WorkflowLogging.Config"},{"location":"swift/api/Workflow/structs/WorkflowLogging.Config/#workflowloggingconfig","text":"","title":"WorkflowLogging.Config"},{"location":"swift/api/Workflow/structs/WorkflowLogging.Config/#properties","text":"","title":"Properties"},{"location":"swift/api/Workflow/structs/WorkflowLogging.Config/#renderloggingmode","text":"","title":"renderLoggingMode"},{"location":"swift/api/Workflow/structs/WorkflowLogging.Config/#loglifetimes","text":"When true , the interval spanning a WorkflowNode\u2019s lifetime will be recorded.","title":"logLifetimes"},{"location":"swift/api/Workflow/structs/WorkflowLogging.Config/#logactions","text":"When true , action events will be recorded.","title":"logActions"},{"location":"swift/api/Workflow/structs/WorkflowSession.Identifier/","text":"STRUCT WorkflowSession.Identifier \u00b6","title":"WorkflowSession.Identifier"},{"location":"swift/api/Workflow/structs/WorkflowSession.Identifier/#workflowsessionidentifier","text":"","title":"WorkflowSession.Identifier"},{"location":"swift/api/Workflow/structs/WorkflowSession/","text":"STRUCT WorkflowSession \u00b6 A WorkflowSession encapsulates the information that gives a WorkflowNode its identity. In particular, it captures: - The type of the corresponding Workflow conformance. - The String key used when the workflow was rendered. - An Identifier type that is unique across program execution. - An optional reference to a parent WorkflowSession , to differentiate root nodes. Properties \u00b6 workflowType \u00b6 renderKey \u00b6 sessionID \u00b6 parent \u00b6","title":"WorkflowSession"},{"location":"swift/api/Workflow/structs/WorkflowSession/#workflowsession","text":"A WorkflowSession encapsulates the information that gives a WorkflowNode its identity. In particular, it captures: - The type of the corresponding Workflow conformance. - The String key used when the workflow was rendered. - An Identifier type that is unique across program execution. - An optional reference to a parent WorkflowSession , to differentiate root nodes.","title":"WorkflowSession"},{"location":"swift/api/Workflow/structs/WorkflowSession/#properties","text":"","title":"Properties"},{"location":"swift/api/Workflow/structs/WorkflowSession/#workflowtype","text":"","title":"workflowType"},{"location":"swift/api/Workflow/structs/WorkflowSession/#renderkey","text":"","title":"renderKey"},{"location":"swift/api/Workflow/structs/WorkflowSession/#sessionid","text":"","title":"sessionID"},{"location":"swift/api/Workflow/structs/WorkflowSession/#parent","text":"","title":"parent"},{"location":"swift/api/Workflow/structs/WorkflowUpdateDebugInfo/","text":"STRUCT WorkflowUpdateDebugInfo \u00b6 Properties \u00b6 workflowType \u00b6 kind \u00b6","title":"WorkflowUpdateDebugInfo"},{"location":"swift/api/Workflow/structs/WorkflowUpdateDebugInfo/#workflowupdatedebuginfo","text":"","title":"WorkflowUpdateDebugInfo"},{"location":"swift/api/Workflow/structs/WorkflowUpdateDebugInfo/#properties","text":"","title":"Properties"},{"location":"swift/api/Workflow/structs/WorkflowUpdateDebugInfo/#workflowtype","text":"","title":"workflowType"},{"location":"swift/api/Workflow/structs/WorkflowUpdateDebugInfo/#kind","text":"","title":"kind"},{"location":"swift/api/Workflow/typealiases/AnyWorkflow.Output/","text":"TYPEALIAS AnyWorkflow.Output \u00b6","title":"AnyWorkflow.Output"},{"location":"swift/api/Workflow/typealiases/AnyWorkflow.Output/#anyworkflowoutput","text":"","title":"AnyWorkflow.Output"},{"location":"swift/api/Workflow/typealiases/AnyWorkflow.Rendering/","text":"TYPEALIAS AnyWorkflow.Rendering \u00b6","title":"AnyWorkflow.Rendering"},{"location":"swift/api/Workflow/typealiases/AnyWorkflow.Rendering/#anyworkflowrendering","text":"","title":"AnyWorkflow.Rendering"},{"location":"swift/api/Workflow/typealiases/AnyWorkflow.State/","text":"TYPEALIAS AnyWorkflow.State \u00b6","title":"AnyWorkflow.State"},{"location":"swift/api/Workflow/typealiases/AnyWorkflow.State/#anyworkflowstate","text":"","title":"AnyWorkflow.State"},{"location":"swift/api/WorkflowReactiveSwift/","text":"Reference Documentation \u00b6 Protocols \u00b6 Worker Enums \u00b6 WorkerLogging Extensions \u00b6 Signal SignalProducer Worker WorkerLogging Typealiases \u00b6 SignalProducerWorkflow.Output SignalProducerWorkflow.Rendering SignalProducerWorkflow.State This file was generated by SourceDocs on 2023-06-06 23:40:41 +0000","title":"WorkflowReactiveSwift"},{"location":"swift/api/WorkflowReactiveSwift/#reference-documentation","text":"","title":"Reference Documentation"},{"location":"swift/api/WorkflowReactiveSwift/#protocols","text":"Worker","title":"Protocols"},{"location":"swift/api/WorkflowReactiveSwift/#enums","text":"WorkerLogging","title":"Enums"},{"location":"swift/api/WorkflowReactiveSwift/#extensions","text":"Signal SignalProducer Worker WorkerLogging","title":"Extensions"},{"location":"swift/api/WorkflowReactiveSwift/#typealiases","text":"SignalProducerWorkflow.Output SignalProducerWorkflow.Rendering SignalProducerWorkflow.State This file was generated by SourceDocs on 2023-06-06 23:40:41 +0000","title":"Typealiases"},{"location":"swift/api/WorkflowReactiveSwift/enums/WorkerLogging/","text":"ENUM WorkerLogging \u00b6","title":"WorkerLogging"},{"location":"swift/api/WorkflowReactiveSwift/enums/WorkerLogging/#workerlogging","text":"","title":"WorkerLogging"},{"location":"swift/api/WorkflowReactiveSwift/extensions/Signal/","text":"EXTENSION Signal \u00b6 Methods \u00b6 asAnyWorkflow() \u00b6","title":"Signal"},{"location":"swift/api/WorkflowReactiveSwift/extensions/Signal/#signal","text":"","title":"Signal"},{"location":"swift/api/WorkflowReactiveSwift/extensions/Signal/#methods","text":"","title":"Methods"},{"location":"swift/api/WorkflowReactiveSwift/extensions/Signal/#asanyworkflow","text":"","title":"asAnyWorkflow()"},{"location":"swift/api/WorkflowReactiveSwift/extensions/SignalProducer/","text":"EXTENSION SignalProducer \u00b6 Methods \u00b6 asAnyWorkflow() \u00b6","title":"SignalProducer"},{"location":"swift/api/WorkflowReactiveSwift/extensions/SignalProducer/#signalproducer","text":"","title":"SignalProducer"},{"location":"swift/api/WorkflowReactiveSwift/extensions/SignalProducer/#methods","text":"","title":"Methods"},{"location":"swift/api/WorkflowReactiveSwift/extensions/SignalProducer/#asanyworkflow","text":"","title":"asAnyWorkflow()"},{"location":"swift/api/WorkflowReactiveSwift/extensions/Worker/","text":"EXTENSION Worker \u00b6 Methods \u00b6 asAnyWorkflow() \u00b6 isEquivalent(to:) \u00b6","title":"Worker"},{"location":"swift/api/WorkflowReactiveSwift/extensions/Worker/#worker","text":"","title":"Worker"},{"location":"swift/api/WorkflowReactiveSwift/extensions/Worker/#methods","text":"","title":"Methods"},{"location":"swift/api/WorkflowReactiveSwift/extensions/Worker/#asanyworkflow","text":"","title":"asAnyWorkflow()"},{"location":"swift/api/WorkflowReactiveSwift/extensions/Worker/#isequivalentto","text":"","title":"isEquivalent(to:)"},{"location":"swift/api/WorkflowReactiveSwift/extensions/WorkerLogging/","text":"EXTENSION WorkerLogging \u00b6 Properties \u00b6 enabled \u00b6","title":"WorkerLogging"},{"location":"swift/api/WorkflowReactiveSwift/extensions/WorkerLogging/#workerlogging","text":"","title":"WorkerLogging"},{"location":"swift/api/WorkflowReactiveSwift/extensions/WorkerLogging/#properties","text":"","title":"Properties"},{"location":"swift/api/WorkflowReactiveSwift/extensions/WorkerLogging/#enabled","text":"","title":"enabled"},{"location":"swift/api/WorkflowReactiveSwift/protocols/Worker/","text":"PROTOCOL Worker \u00b6 Workers define a unit of asynchronous work. During a render pass, a workflow can ask the context to await the result of a worker. When this occurs, the context checks to see if there is already a running worker of the same type. If there is, and if the workers are \u2018equivalent\u2019, the context leaves the existing worker running. If there is not an existing worker of this type, the context will kick off the new worker (via run ). Methods \u00b6 run() \u00b6 Returns a signal producer to execute the work represented by this worker. isEquivalent(to:) \u00b6 Returns true if the other worker should be considered equivalent to self . Equivalence should take into account whatever data is meaningful to the task. For example, a worker that loads a user account from a server would not be equivalent to another worker with a different user ID.","title":"Worker"},{"location":"swift/api/WorkflowReactiveSwift/protocols/Worker/#worker","text":"Workers define a unit of asynchronous work. During a render pass, a workflow can ask the context to await the result of a worker. When this occurs, the context checks to see if there is already a running worker of the same type. If there is, and if the workers are \u2018equivalent\u2019, the context leaves the existing worker running. If there is not an existing worker of this type, the context will kick off the new worker (via run ).","title":"Worker"},{"location":"swift/api/WorkflowReactiveSwift/protocols/Worker/#methods","text":"","title":"Methods"},{"location":"swift/api/WorkflowReactiveSwift/protocols/Worker/#run","text":"Returns a signal producer to execute the work represented by this worker.","title":"run()"},{"location":"swift/api/WorkflowReactiveSwift/protocols/Worker/#isequivalentto","text":"Returns true if the other worker should be considered equivalent to self . Equivalence should take into account whatever data is meaningful to the task. For example, a worker that loads a user account from a server would not be equivalent to another worker with a different user ID.","title":"isEquivalent(to:)"},{"location":"swift/api/WorkflowReactiveSwift/typealiases/SignalProducerWorkflow.Output/","text":"TYPEALIAS SignalProducerWorkflow.Output \u00b6","title":"SignalProducerWorkflow.Output"},{"location":"swift/api/WorkflowReactiveSwift/typealiases/SignalProducerWorkflow.Output/#signalproducerworkflowoutput","text":"","title":"SignalProducerWorkflow.Output"},{"location":"swift/api/WorkflowReactiveSwift/typealiases/SignalProducerWorkflow.Rendering/","text":"TYPEALIAS SignalProducerWorkflow.Rendering \u00b6","title":"SignalProducerWorkflow.Rendering"},{"location":"swift/api/WorkflowReactiveSwift/typealiases/SignalProducerWorkflow.Rendering/#signalproducerworkflowrendering","text":"","title":"SignalProducerWorkflow.Rendering"},{"location":"swift/api/WorkflowReactiveSwift/typealiases/SignalProducerWorkflow.State/","text":"TYPEALIAS SignalProducerWorkflow.State \u00b6","title":"SignalProducerWorkflow.State"},{"location":"swift/api/WorkflowReactiveSwift/typealiases/SignalProducerWorkflow.State/#signalproducerworkflowstate","text":"","title":"SignalProducerWorkflow.State"},{"location":"swift/api/WorkflowTesting/","text":"Reference Documentation \u00b6 Structs \u00b6 RenderTester RenderTesterResult WorkflowActionTester Extensions \u00b6 RenderTesterResult Workflow WorkflowAction WorkflowActionTester This file was generated by SourceDocs on 2023-06-06 23:40:07 +0000","title":"WorkflowTesting "},{"location":"swift/api/WorkflowTesting/#reference-documentation","text":"","title":"Reference Documentation"},{"location":"swift/api/WorkflowTesting/#structs","text":"RenderTester RenderTesterResult WorkflowActionTester","title":"Structs"},{"location":"swift/api/WorkflowTesting/#extensions","text":"RenderTesterResult Workflow WorkflowAction WorkflowActionTester This file was generated by SourceDocs on 2023-06-06 23:40:07 +0000","title":"Extensions"},{"location":"swift/api/WorkflowTesting/extensions/RenderTesterResult/","text":"EXTENSION RenderTesterResult \u00b6 Methods \u00b6 assert(state:file:line:) \u00b6 Verifies that the resulting state is equal to the given state. assert(output:file:line:) \u00b6 Verifies that the resulting output is equal to the given output.","title":"RenderTesterResult"},{"location":"swift/api/WorkflowTesting/extensions/RenderTesterResult/#rendertesterresult","text":"","title":"RenderTesterResult"},{"location":"swift/api/WorkflowTesting/extensions/RenderTesterResult/#methods","text":"","title":"Methods"},{"location":"swift/api/WorkflowTesting/extensions/RenderTesterResult/#assertstatefileline","text":"Verifies that the resulting state is equal to the given state.","title":"assert(state:file:line:)"},{"location":"swift/api/WorkflowTesting/extensions/RenderTesterResult/#assertoutputfileline","text":"Verifies that the resulting output is equal to the given output.","title":"assert(output:file:line:)"},{"location":"swift/api/WorkflowTesting/extensions/Workflow/","text":"EXTENSION Workflow \u00b6 Methods \u00b6 renderTester(initialState:) \u00b6 Returns a RenderTester with a specified initial state. renderTester() \u00b6 Returns a RenderTester with an initial state provided by self.makeInitialState()","title":"Workflow"},{"location":"swift/api/WorkflowTesting/extensions/Workflow/#workflow","text":"","title":"Workflow"},{"location":"swift/api/WorkflowTesting/extensions/Workflow/#methods","text":"","title":"Methods"},{"location":"swift/api/WorkflowTesting/extensions/Workflow/#rendertesterinitialstate","text":"Returns a RenderTester with a specified initial state.","title":"renderTester(initialState:)"},{"location":"swift/api/WorkflowTesting/extensions/Workflow/#rendertester","text":"Returns a RenderTester with an initial state provided by self.makeInitialState()","title":"renderTester()"},{"location":"swift/api/WorkflowTesting/extensions/WorkflowAction/","text":"EXTENSION WorkflowAction \u00b6 Methods \u00b6 tester(withState:) \u00b6 Returns a state tester containing self .","title":"WorkflowAction"},{"location":"swift/api/WorkflowTesting/extensions/WorkflowAction/#workflowaction","text":"","title":"WorkflowAction"},{"location":"swift/api/WorkflowTesting/extensions/WorkflowAction/#methods","text":"","title":"Methods"},{"location":"swift/api/WorkflowTesting/extensions/WorkflowAction/#testerwithstate","text":"Returns a state tester containing self .","title":"tester(withState:)"},{"location":"swift/api/WorkflowTesting/extensions/WorkflowActionTester/","text":"EXTENSION WorkflowActionTester \u00b6 Methods \u00b6 assert(state:file:line:) \u00b6 Triggers a test failure if the current state does not match the given expected state Parameters: expectedState: The expected state returns: A tester containing the current state and output. assert(output:file:line:) \u00b6 Triggers a test failure if the produced output does not match the given expected output Parameters: expectedState: The expected output returns: A tester containing the current state and output.","title":"WorkflowActionTester"},{"location":"swift/api/WorkflowTesting/extensions/WorkflowActionTester/#workflowactiontester","text":"","title":"WorkflowActionTester"},{"location":"swift/api/WorkflowTesting/extensions/WorkflowActionTester/#methods","text":"","title":"Methods"},{"location":"swift/api/WorkflowTesting/extensions/WorkflowActionTester/#assertstatefileline","text":"Triggers a test failure if the current state does not match the given expected state Parameters: expectedState: The expected state returns: A tester containing the current state and output.","title":"assert(state:file:line:)"},{"location":"swift/api/WorkflowTesting/extensions/WorkflowActionTester/#assertoutputfileline","text":"Triggers a test failure if the produced output does not match the given expected output Parameters: expectedState: The expected output returns: A tester containing the current state and output.","title":"assert(output:file:line:)"},{"location":"swift/api/WorkflowTesting/structs/RenderTester/","text":"STRUCT RenderTester \u00b6 Testing helper for validating the behavior of calls to render . Usage: expect workflows and side effects then validate with a call to render and the resulting RenderTesterResult . Side-effects may be performed against the rendering to validate the behavior of actions. To directly test actions and their effects, use the WorkflowActionTester . workflow .renderTester(initialState: TestWorkflow.State()) .expect( worker: TestWorker(), producingOutput: TestWorker.Output.success ) .expectWorkflow( type: ChildWorkflow.self, key: \"key\", rendering: \"rendering\", // \u26a0\ufe0f N.B. Only one output per call to `render` may be produced, // even if multiple child Workflows are expected in a call // to `render`. This is an invariant enforced by `RenderTester` // and the real runtime. producingOutput: nil ) .render { rendering in XCTAssertEqual(\"expected text on rendering\", rendering.text) } .assert(state: TestWorkflow.State()) .assert(output: TestWorkflow.Output.finished) Validating the rendering only from the initial state provided by the workflow: workflow .renderTester() .render { rendering in XCTAssertEqual(\"expected text on rendering\", rendering.text) } Validate the state was updated from a callback on the rendering: workflow .renderTester() .render { rendering in XCTAssertEqual(\"expected text on rendering\", rendering.text) rendering.updateText(\"updated\") } .assert( state: TestWorkflow.State(text: \"updated\") ) Validate an output was received from the workflow. The action() on the rendering will cause an action that will return an output. workflow .renderTester() .render { rendering in rendering.action() } .assert( output: .success ) Validate a worker is running, and simulate the effect of its output: workflow .renderTester(initialState: TestWorkflow.State(loadingState: .loading)) .expect( worker: TestWorker(), output: TestWorker.Output.success ) .render { _ in } Validate a child workflow is run, and simulate the effect of its output: workflow .renderTester(initialState: TestWorkflow.State(loadingState: .loading)) .expectWorkflow( type: ChildWorkflow.self, rendering: \"rendering\", producingOutput: ChildWorkflow.Output.success ) .render { _ in } Methods \u00b6 expectWorkflow(type:key:producingRendering:producingOutput:file:line:assertions:) \u00b6 Expect the given workflow type in the next rendering. Parameters: type: The type of the expected workflow. key: The key of the expected workflow (if specified). rendering: The rendering result that should be returned when the workflow of this type is rendered. output: An output that should be returned after the workflow of this type is rendered, if any. assertions: Additional assertions for the given workflow, if any. You may use this to assert the properties of the requested workflow are as expected. expectWorkflowIgnoringOutput(type:key:producingRendering:file:line:assertions:) \u00b6 Expect the given workflow type in the next rendering, with its output being ignored by a call to ignoringOutput() . Parameters: type: The type of the expected workflow. key: The key of the expected workflow (if specified). rendering: The rendering result that should be returned when the workflow of this type is rendered. assertions: Additional assertions for the given workflow, if any. You may use this to assert the properties of the requested workflow are as expected. expectSideEffect(key:file:line:) \u00b6 Expect a side-effect for the given key. Parameter key: The key to expect. expectSideEffect(key:producingAction:file:line:) \u00b6 Expect a side-effect for the given key, and produce the given action when it is requested. Parameters: key: The key to expect. action: The action to produce when this side-effect is requested. render(file:line:assertions:) \u00b6 Render the workflow under test. At this point, you should have set up all expectations. The given assertions closure will be called with the produced rendering, allowing you to assert its properties or perform actions on it (such as closures that are wired up to a Sink inside the workflow. Parameters: assertions: A closure called with the produced rendering for verification Returns: A RenderTesterResult that can be used to verify expected resulting state or outputs.","title":"RenderTester"},{"location":"swift/api/WorkflowTesting/structs/RenderTester/#rendertester","text":"Testing helper for validating the behavior of calls to render . Usage: expect workflows and side effects then validate with a call to render and the resulting RenderTesterResult . Side-effects may be performed against the rendering to validate the behavior of actions. To directly test actions and their effects, use the WorkflowActionTester . workflow .renderTester(initialState: TestWorkflow.State()) .expect( worker: TestWorker(), producingOutput: TestWorker.Output.success ) .expectWorkflow( type: ChildWorkflow.self, key: \"key\", rendering: \"rendering\", // \u26a0\ufe0f N.B. Only one output per call to `render` may be produced, // even if multiple child Workflows are expected in a call // to `render`. This is an invariant enforced by `RenderTester` // and the real runtime. producingOutput: nil ) .render { rendering in XCTAssertEqual(\"expected text on rendering\", rendering.text) } .assert(state: TestWorkflow.State()) .assert(output: TestWorkflow.Output.finished) Validating the rendering only from the initial state provided by the workflow: workflow .renderTester() .render { rendering in XCTAssertEqual(\"expected text on rendering\", rendering.text) } Validate the state was updated from a callback on the rendering: workflow .renderTester() .render { rendering in XCTAssertEqual(\"expected text on rendering\", rendering.text) rendering.updateText(\"updated\") } .assert( state: TestWorkflow.State(text: \"updated\") ) Validate an output was received from the workflow. The action() on the rendering will cause an action that will return an output. workflow .renderTester() .render { rendering in rendering.action() } .assert( output: .success ) Validate a worker is running, and simulate the effect of its output: workflow .renderTester(initialState: TestWorkflow.State(loadingState: .loading)) .expect( worker: TestWorker(), output: TestWorker.Output.success ) .render { _ in } Validate a child workflow is run, and simulate the effect of its output: workflow .renderTester(initialState: TestWorkflow.State(loadingState: .loading)) .expectWorkflow( type: ChildWorkflow.self, rendering: \"rendering\", producingOutput: ChildWorkflow.Output.success ) .render { _ in }","title":"RenderTester"},{"location":"swift/api/WorkflowTesting/structs/RenderTester/#methods","text":"","title":"Methods"},{"location":"swift/api/WorkflowTesting/structs/RenderTester/#expectworkflowtypekeyproducingrenderingproducingoutputfilelineassertions","text":"Expect the given workflow type in the next rendering. Parameters: type: The type of the expected workflow. key: The key of the expected workflow (if specified). rendering: The rendering result that should be returned when the workflow of this type is rendered. output: An output that should be returned after the workflow of this type is rendered, if any. assertions: Additional assertions for the given workflow, if any. You may use this to assert the properties of the requested workflow are as expected.","title":"expectWorkflow(type:key:producingRendering:producingOutput:file:line:assertions:)"},{"location":"swift/api/WorkflowTesting/structs/RenderTester/#expectworkflowignoringoutputtypekeyproducingrenderingfilelineassertions","text":"Expect the given workflow type in the next rendering, with its output being ignored by a call to ignoringOutput() . Parameters: type: The type of the expected workflow. key: The key of the expected workflow (if specified). rendering: The rendering result that should be returned when the workflow of this type is rendered. assertions: Additional assertions for the given workflow, if any. You may use this to assert the properties of the requested workflow are as expected.","title":"expectWorkflowIgnoringOutput(type:key:producingRendering:file:line:assertions:)"},{"location":"swift/api/WorkflowTesting/structs/RenderTester/#expectsideeffectkeyfileline","text":"Expect a side-effect for the given key. Parameter key: The key to expect.","title":"expectSideEffect(key:file:line:)"},{"location":"swift/api/WorkflowTesting/structs/RenderTester/#expectsideeffectkeyproducingactionfileline","text":"Expect a side-effect for the given key, and produce the given action when it is requested. Parameters: key: The key to expect. action: The action to produce when this side-effect is requested.","title":"expectSideEffect(key:producingAction:file:line:)"},{"location":"swift/api/WorkflowTesting/structs/RenderTester/#renderfilelineassertions","text":"Render the workflow under test. At this point, you should have set up all expectations. The given assertions closure will be called with the produced rendering, allowing you to assert its properties or perform actions on it (such as closures that are wired up to a Sink inside the workflow. Parameters: assertions: A closure called with the produced rendering for verification Returns: A RenderTesterResult that can be used to verify expected resulting state or outputs.","title":"render(file:line:assertions:)"},{"location":"swift/api/WorkflowTesting/structs/RenderTesterResult/","text":"STRUCT RenderTesterResult \u00b6 The result of a RenderTester rendering. Used to verify state, output, and actions that were produced as a result of actions performed during the render (such as child workflow output being produced). Methods \u00b6 verifyState(file:line:assertions:) \u00b6 Allows for assertions against the resulting state. assertNoAction(file:line:) \u00b6 Asserts that no actions were produced verifyAction(type:file:line:assertions:) \u00b6 Allows for assertions agains the resulting action assert(action:file:line:) \u00b6 Asserts that the resulting action is equal to the given action. assertNoOutput(file:line:) \u00b6 Asserts that no output was produced. verifyOutput(file:line:assertions:) \u00b6 Allows for assertions agains the resulting output","title":"RenderTesterResult"},{"location":"swift/api/WorkflowTesting/structs/RenderTesterResult/#rendertesterresult","text":"The result of a RenderTester rendering. Used to verify state, output, and actions that were produced as a result of actions performed during the render (such as child workflow output being produced).","title":"RenderTesterResult"},{"location":"swift/api/WorkflowTesting/structs/RenderTesterResult/#methods","text":"","title":"Methods"},{"location":"swift/api/WorkflowTesting/structs/RenderTesterResult/#verifystatefilelineassertions","text":"Allows for assertions against the resulting state.","title":"verifyState(file:line:assertions:)"},{"location":"swift/api/WorkflowTesting/structs/RenderTesterResult/#assertnoactionfileline","text":"Asserts that no actions were produced","title":"assertNoAction(file:line:)"},{"location":"swift/api/WorkflowTesting/structs/RenderTesterResult/#verifyactiontypefilelineassertions","text":"Allows for assertions agains the resulting action","title":"verifyAction(type:file:line:assertions:)"},{"location":"swift/api/WorkflowTesting/structs/RenderTesterResult/#assertactionfileline","text":"Asserts that the resulting action is equal to the given action.","title":"assert(action:file:line:)"},{"location":"swift/api/WorkflowTesting/structs/RenderTesterResult/#assertnooutputfileline","text":"Asserts that no output was produced.","title":"assertNoOutput(file:line:)"},{"location":"swift/api/WorkflowTesting/structs/RenderTesterResult/#verifyoutputfilelineassertions","text":"Allows for assertions agains the resulting output","title":"verifyOutput(file:line:assertions:)"},{"location":"swift/api/WorkflowTesting/structs/WorkflowActionTester/","text":"STRUCT WorkflowActionTester \u00b6 Testing helper that chains action sending and state/output assertions to make tests easier to write. MyWorkflow.Action .tester(withState: .firstState) .send(action: .exampleAction) .verifyOutput { output in XCTAssertEqual(.finished, output) } .verifyState { state in XCTAssertEqual(.differentState, state) } Or to assert that an action produces no output: MyWorkflow.Action .tester(withState: .firstState) .send(action: .actionProducingNoOutput) .assertNoOutput() .verifyState { state in XCTAssertEqual(.differentState, state) } If your State or Output are Equatable , you can use the convenience assertion methods: MyWorkflow.Action .tester(withState: .firstState) .send(action: .exampleAction) .assert(output: .finished) .assert(state: .differentState) Methods \u00b6 send(action:) \u00b6 Sends an action to the reducer. parameter action: The action to send. returns: A new state tester containing the state and output (if any) after the update. assertNoOutput(file:line:) \u00b6 Asserts that the action produced no output returns: A tester containing the current state and output. verifyOutput(file:line:_:) \u00b6 Invokes the given closure (which is intended to contain test assertions) with the produced output. If the previous action produced no output, the triggers a test failure and does not execute the closure. parameter assertions: A closure that accepts a single output value. returns: A tester containing the current state and output. verifyState(_:) \u00b6 Invokes the given closure (which is intended to contain test assertions) with the current state. parameter assertions: A closure that accepts a single state value. returns: A tester containing the current state and output.","title":"WorkflowActionTester"},{"location":"swift/api/WorkflowTesting/structs/WorkflowActionTester/#workflowactiontester","text":"Testing helper that chains action sending and state/output assertions to make tests easier to write. MyWorkflow.Action .tester(withState: .firstState) .send(action: .exampleAction) .verifyOutput { output in XCTAssertEqual(.finished, output) } .verifyState { state in XCTAssertEqual(.differentState, state) } Or to assert that an action produces no output: MyWorkflow.Action .tester(withState: .firstState) .send(action: .actionProducingNoOutput) .assertNoOutput() .verifyState { state in XCTAssertEqual(.differentState, state) } If your State or Output are Equatable , you can use the convenience assertion methods: MyWorkflow.Action .tester(withState: .firstState) .send(action: .exampleAction) .assert(output: .finished) .assert(state: .differentState)","title":"WorkflowActionTester"},{"location":"swift/api/WorkflowTesting/structs/WorkflowActionTester/#methods","text":"","title":"Methods"},{"location":"swift/api/WorkflowTesting/structs/WorkflowActionTester/#sendaction","text":"Sends an action to the reducer. parameter action: The action to send. returns: A new state tester containing the state and output (if any) after the update.","title":"send(action:)"},{"location":"swift/api/WorkflowTesting/structs/WorkflowActionTester/#assertnooutputfileline","text":"Asserts that the action produced no output returns: A tester containing the current state and output.","title":"assertNoOutput(file:line:)"},{"location":"swift/api/WorkflowTesting/structs/WorkflowActionTester/#verifyoutputfileline_","text":"Invokes the given closure (which is intended to contain test assertions) with the produced output. If the previous action produced no output, the triggers a test failure and does not execute the closure. parameter assertions: A closure that accepts a single output value. returns: A tester containing the current state and output.","title":"verifyOutput(file:line:_:)"},{"location":"swift/api/WorkflowTesting/structs/WorkflowActionTester/#verifystate_","text":"Invokes the given closure (which is intended to contain test assertions) with the current state. parameter assertions: A closure that accepts a single state value. returns: A tester containing the current state and output.","title":"verifyState(_:)"},{"location":"swift/api/WorkflowUI/","text":"Reference Documentation \u00b6 Protocols \u00b6 Screen UpdateChildScreenViewController Structs \u00b6 AdaptedEnvironmentScreen AnyScreen ViewControllerDescription ViewControllerDescription.KindIdentifier Classes \u00b6 DescribedViewController ScreenViewController WorkflowHostingController Extensions \u00b6 AdaptedEnvironmentScreen Screen ScreenViewController UpdateChildScreenViewController Typealiases \u00b6 AdaptedEnvironmentScreen.Adapter This file was generated by SourceDocs on 2023-06-06 23:39:46 +0000","title":"WorkflowUI "},{"location":"swift/api/WorkflowUI/#reference-documentation","text":"","title":"Reference Documentation"},{"location":"swift/api/WorkflowUI/#protocols","text":"Screen UpdateChildScreenViewController","title":"Protocols"},{"location":"swift/api/WorkflowUI/#structs","text":"AdaptedEnvironmentScreen AnyScreen ViewControllerDescription ViewControllerDescription.KindIdentifier","title":"Structs"},{"location":"swift/api/WorkflowUI/#classes","text":"DescribedViewController ScreenViewController WorkflowHostingController","title":"Classes"},{"location":"swift/api/WorkflowUI/#extensions","text":"AdaptedEnvironmentScreen Screen ScreenViewController UpdateChildScreenViewController","title":"Extensions"},{"location":"swift/api/WorkflowUI/#typealiases","text":"AdaptedEnvironmentScreen.Adapter This file was generated by SourceDocs on 2023-06-06 23:39:46 +0000","title":"Typealiases"},{"location":"swift/api/WorkflowUI/classes/DescribedViewController/","text":"CLASS DescribedViewController \u00b6 Properties \u00b6 childForStatusBarStyle \u00b6 childForStatusBarHidden \u00b6 childForHomeIndicatorAutoHidden \u00b6 childForScreenEdgesDeferringSystemGestures \u00b6 supportedInterfaceOrientations \u00b6 preferredStatusBarUpdateAnimation \u00b6 childViewControllerForPointerLock \u00b6 Methods \u00b6 init(description:) \u00b6 init(screen:environment:) \u00b6 update(description:) \u00b6 update(screen:environment:) \u00b6 viewDidLoad() \u00b6 viewDidLayoutSubviews() \u00b6 preferredContentSizeDidChange(forChildContentContainer:) \u00b6","title":"DescribedViewController"},{"location":"swift/api/WorkflowUI/classes/DescribedViewController/#describedviewcontroller","text":"","title":"DescribedViewController"},{"location":"swift/api/WorkflowUI/classes/DescribedViewController/#properties","text":"","title":"Properties"},{"location":"swift/api/WorkflowUI/classes/DescribedViewController/#childforstatusbarstyle","text":"","title":"childForStatusBarStyle"},{"location":"swift/api/WorkflowUI/classes/DescribedViewController/#childforstatusbarhidden","text":"","title":"childForStatusBarHidden"},{"location":"swift/api/WorkflowUI/classes/DescribedViewController/#childforhomeindicatorautohidden","text":"","title":"childForHomeIndicatorAutoHidden"},{"location":"swift/api/WorkflowUI/classes/DescribedViewController/#childforscreenedgesdeferringsystemgestures","text":"","title":"childForScreenEdgesDeferringSystemGestures"},{"location":"swift/api/WorkflowUI/classes/DescribedViewController/#supportedinterfaceorientations","text":"","title":"supportedInterfaceOrientations"},{"location":"swift/api/WorkflowUI/classes/DescribedViewController/#preferredstatusbarupdateanimation","text":"","title":"preferredStatusBarUpdateAnimation"},{"location":"swift/api/WorkflowUI/classes/DescribedViewController/#childviewcontrollerforpointerlock","text":"","title":"childViewControllerForPointerLock"},{"location":"swift/api/WorkflowUI/classes/DescribedViewController/#methods","text":"","title":"Methods"},{"location":"swift/api/WorkflowUI/classes/DescribedViewController/#initdescription","text":"","title":"init(description:)"},{"location":"swift/api/WorkflowUI/classes/DescribedViewController/#initscreenenvironment","text":"","title":"init(screen:environment:)"},{"location":"swift/api/WorkflowUI/classes/DescribedViewController/#updatedescription","text":"","title":"update(description:)"},{"location":"swift/api/WorkflowUI/classes/DescribedViewController/#updatescreenenvironment","text":"","title":"update(screen:environment:)"},{"location":"swift/api/WorkflowUI/classes/DescribedViewController/#viewdidload","text":"","title":"viewDidLoad()"},{"location":"swift/api/WorkflowUI/classes/DescribedViewController/#viewdidlayoutsubviews","text":"","title":"viewDidLayoutSubviews()"},{"location":"swift/api/WorkflowUI/classes/DescribedViewController/#preferredcontentsizedidchangeforchildcontentcontainer","text":"","title":"preferredContentSizeDidChange(forChildContentContainer:)"},{"location":"swift/api/WorkflowUI/classes/ScreenViewController/","text":"CLASS ScreenViewController \u00b6 Generic base class that can be subclassed in order to to define a UI implementation that is powered by the given screen type. Using this base class, a screen can be implemented as: struct MyScreen: Screen { func viewControllerDescription(environment: ViewEnvironment) -> ViewControllerDescription { return MyScreenViewController.description(for: self) } } private class MyScreenViewController: ScreenViewController<MyScreen> { override func screenDidChange(from previousScreen: MyScreen, previousEnvironment: ViewEnvironment) { // \u2026 update views as necessary } } Properties \u00b6 screen \u00b6 screenType \u00b6 environment \u00b6 Methods \u00b6 init(screen:environment:) \u00b6 init(coder:) \u00b6 update(screen:environment:) \u00b6 screenDidChange(from:previousEnvironment:) \u00b6 Subclasses should override this method in order to update any relevant UI bits when the screen model changes.","title":"ScreenViewController"},{"location":"swift/api/WorkflowUI/classes/ScreenViewController/#screenviewcontroller","text":"Generic base class that can be subclassed in order to to define a UI implementation that is powered by the given screen type. Using this base class, a screen can be implemented as: struct MyScreen: Screen { func viewControllerDescription(environment: ViewEnvironment) -> ViewControllerDescription { return MyScreenViewController.description(for: self) } } private class MyScreenViewController: ScreenViewController<MyScreen> { override func screenDidChange(from previousScreen: MyScreen, previousEnvironment: ViewEnvironment) { // \u2026 update views as necessary } }","title":"ScreenViewController"},{"location":"swift/api/WorkflowUI/classes/ScreenViewController/#properties","text":"","title":"Properties"},{"location":"swift/api/WorkflowUI/classes/ScreenViewController/#screen","text":"","title":"screen"},{"location":"swift/api/WorkflowUI/classes/ScreenViewController/#screentype","text":"","title":"screenType"},{"location":"swift/api/WorkflowUI/classes/ScreenViewController/#environment","text":"","title":"environment"},{"location":"swift/api/WorkflowUI/classes/ScreenViewController/#methods","text":"","title":"Methods"},{"location":"swift/api/WorkflowUI/classes/ScreenViewController/#initscreenenvironment","text":"","title":"init(screen:environment:)"},{"location":"swift/api/WorkflowUI/classes/ScreenViewController/#initcoder","text":"","title":"init(coder:)"},{"location":"swift/api/WorkflowUI/classes/ScreenViewController/#updatescreenenvironment","text":"","title":"update(screen:environment:)"},{"location":"swift/api/WorkflowUI/classes/ScreenViewController/#screendidchangefrompreviousenvironment","text":"Subclasses should override this method in order to update any relevant UI bits when the screen model changes.","title":"screenDidChange(from:previousEnvironment:)"},{"location":"swift/api/WorkflowUI/classes/WorkflowHostingController/","text":"CLASS WorkflowHostingController \u00b6 Drives view controllers from a root Workflow. Properties \u00b6 output \u00b6 Emits output events from the bound workflow. rootViewEnvironment \u00b6 childForStatusBarStyle \u00b6 childForStatusBarHidden \u00b6 childForHomeIndicatorAutoHidden \u00b6 childForScreenEdgesDeferringSystemGestures \u00b6 supportedInterfaceOrientations \u00b6 preferredStatusBarUpdateAnimation \u00b6 childViewControllerForPointerLock \u00b6 Methods \u00b6 init(workflow:rootViewEnvironment:observers:) \u00b6 update(workflow:) \u00b6 Updates the root Workflow in this container. init(coder:) \u00b6 viewDidLoad() \u00b6 viewDidLayoutSubviews() \u00b6 preferredContentSizeDidChange(forChildContentContainer:) \u00b6","title":"WorkflowHostingController"},{"location":"swift/api/WorkflowUI/classes/WorkflowHostingController/#workflowhostingcontroller","text":"Drives view controllers from a root Workflow.","title":"WorkflowHostingController"},{"location":"swift/api/WorkflowUI/classes/WorkflowHostingController/#properties","text":"","title":"Properties"},{"location":"swift/api/WorkflowUI/classes/WorkflowHostingController/#output","text":"Emits output events from the bound workflow.","title":"output"},{"location":"swift/api/WorkflowUI/classes/WorkflowHostingController/#rootviewenvironment","text":"","title":"rootViewEnvironment"},{"location":"swift/api/WorkflowUI/classes/WorkflowHostingController/#childforstatusbarstyle","text":"","title":"childForStatusBarStyle"},{"location":"swift/api/WorkflowUI/classes/WorkflowHostingController/#childforstatusbarhidden","text":"","title":"childForStatusBarHidden"},{"location":"swift/api/WorkflowUI/classes/WorkflowHostingController/#childforhomeindicatorautohidden","text":"","title":"childForHomeIndicatorAutoHidden"},{"location":"swift/api/WorkflowUI/classes/WorkflowHostingController/#childforscreenedgesdeferringsystemgestures","text":"","title":"childForScreenEdgesDeferringSystemGestures"},{"location":"swift/api/WorkflowUI/classes/WorkflowHostingController/#supportedinterfaceorientations","text":"","title":"supportedInterfaceOrientations"},{"location":"swift/api/WorkflowUI/classes/WorkflowHostingController/#preferredstatusbarupdateanimation","text":"","title":"preferredStatusBarUpdateAnimation"},{"location":"swift/api/WorkflowUI/classes/WorkflowHostingController/#childviewcontrollerforpointerlock","text":"","title":"childViewControllerForPointerLock"},{"location":"swift/api/WorkflowUI/classes/WorkflowHostingController/#methods","text":"","title":"Methods"},{"location":"swift/api/WorkflowUI/classes/WorkflowHostingController/#initworkflowrootviewenvironmentobservers","text":"","title":"init(workflow:rootViewEnvironment:observers:)"},{"location":"swift/api/WorkflowUI/classes/WorkflowHostingController/#updateworkflow","text":"Updates the root Workflow in this container.","title":"update(workflow:)"},{"location":"swift/api/WorkflowUI/classes/WorkflowHostingController/#initcoder","text":"","title":"init(coder:)"},{"location":"swift/api/WorkflowUI/classes/WorkflowHostingController/#viewdidload","text":"","title":"viewDidLoad()"},{"location":"swift/api/WorkflowUI/classes/WorkflowHostingController/#viewdidlayoutsubviews","text":"","title":"viewDidLayoutSubviews()"},{"location":"swift/api/WorkflowUI/classes/WorkflowHostingController/#preferredcontentsizedidchangeforchildcontentcontainer","text":"","title":"preferredContentSizeDidChange(forChildContentContainer:)"},{"location":"swift/api/WorkflowUI/extensions/AdaptedEnvironmentScreen/","text":"EXTENSION AdaptedEnvironmentScreen \u00b6 Methods \u00b6 viewControllerDescription(environment:) \u00b6","title":"AdaptedEnvironmentScreen"},{"location":"swift/api/WorkflowUI/extensions/AdaptedEnvironmentScreen/#adaptedenvironmentscreen","text":"","title":"AdaptedEnvironmentScreen"},{"location":"swift/api/WorkflowUI/extensions/AdaptedEnvironmentScreen/#methods","text":"","title":"Methods"},{"location":"swift/api/WorkflowUI/extensions/AdaptedEnvironmentScreen/#viewcontrollerdescriptionenvironment","text":"","title":"viewControllerDescription(environment:)"},{"location":"swift/api/WorkflowUI/extensions/Screen/","text":"EXTENSION Screen \u00b6 Methods \u00b6 adaptedEnvironment(key:value:) \u00b6 Wraps this screen in an AdaptedEnvironmentScreen with the given environment key and value. asAnyScreen() \u00b6 Wraps the screen in an AnyScreen canUpdate(viewController:with:) \u00b6 If the given view controller is of the correct type to be updated by this screen. If your view controller type can change between updates, call this method before invoking update(viewController:with:) . update(viewController:with:) \u00b6 Update the given view controller with the content from the screen. Note \u00b6 You must pass a view controller previously created by a compatible ViewControllerDescription that passes canUpdate(viewController:with:) . Failure to do so will result in a fatal precondition. buildViewController(in:) \u00b6 Construct and update a new view controller as described by this Screen. The view controller will be updated before it is returned, so it is fully configured and prepared for display.","title":"Screen"},{"location":"swift/api/WorkflowUI/extensions/Screen/#screen","text":"","title":"Screen"},{"location":"swift/api/WorkflowUI/extensions/Screen/#methods","text":"","title":"Methods"},{"location":"swift/api/WorkflowUI/extensions/Screen/#adaptedenvironmentkeyvalue","text":"Wraps this screen in an AdaptedEnvironmentScreen with the given environment key and value.","title":"adaptedEnvironment(key:value:)"},{"location":"swift/api/WorkflowUI/extensions/Screen/#asanyscreen","text":"Wraps the screen in an AnyScreen","title":"asAnyScreen()"},{"location":"swift/api/WorkflowUI/extensions/Screen/#canupdateviewcontrollerwith","text":"If the given view controller is of the correct type to be updated by this screen. If your view controller type can change between updates, call this method before invoking update(viewController:with:) .","title":"canUpdate(viewController:with:)"},{"location":"swift/api/WorkflowUI/extensions/Screen/#updateviewcontrollerwith","text":"Update the given view controller with the content from the screen.","title":"update(viewController:with:)"},{"location":"swift/api/WorkflowUI/extensions/Screen/#note","text":"You must pass a view controller previously created by a compatible ViewControllerDescription that passes canUpdate(viewController:with:) . Failure to do so will result in a fatal precondition.","title":"Note"},{"location":"swift/api/WorkflowUI/extensions/Screen/#buildviewcontrollerin","text":"Construct and update a new view controller as described by this Screen. The view controller will be updated before it is returned, so it is fully configured and prepared for display.","title":"buildViewController(in:)"},{"location":"swift/api/WorkflowUI/extensions/ScreenViewController/","text":"EXTENSION ScreenViewController \u00b6 Methods \u00b6 description(for:environment:performInitialUpdate:) \u00b6 Convenience to create a view controller description for the given screen value. See the example on the comment for ScreenViewController for usage.","title":"ScreenViewController"},{"location":"swift/api/WorkflowUI/extensions/ScreenViewController/#screenviewcontroller","text":"","title":"ScreenViewController"},{"location":"swift/api/WorkflowUI/extensions/ScreenViewController/#methods","text":"","title":"Methods"},{"location":"swift/api/WorkflowUI/extensions/ScreenViewController/#descriptionforenvironmentperforminitialupdate","text":"Convenience to create a view controller description for the given screen value. See the example on the comment for ScreenViewController for usage.","title":"description(for:environment:performInitialUpdate:)"},{"location":"swift/api/WorkflowUI/extensions/UpdateChildScreenViewController/","text":"EXTENSION UpdateChildScreenViewController \u00b6 Methods \u00b6 update(child:with:in:onChange:) \u00b6 Updates the view controller at the given child key path with the ViewControllerDescription from screen . If the type of the underlying view controller changes between update passes, this method will remove the old view controller, create a new one, update it, and insert it into the view controller hierarchy. The view controller at child must be a child of self . Parameters: parameter child: The KeyPath which describes what view controller to update. This view controller must be a direct child of self . parameter screen: The Screen instance to apply to the view controller. parameter environment: The environment to used when updating the view controller. parameter onChange: A callback called if the view controller instance changed.","title":"UpdateChildScreenViewController"},{"location":"swift/api/WorkflowUI/extensions/UpdateChildScreenViewController/#updatechildscreenviewcontroller","text":"","title":"UpdateChildScreenViewController"},{"location":"swift/api/WorkflowUI/extensions/UpdateChildScreenViewController/#methods","text":"","title":"Methods"},{"location":"swift/api/WorkflowUI/extensions/UpdateChildScreenViewController/#updatechildwithinonchange","text":"Updates the view controller at the given child key path with the ViewControllerDescription from screen . If the type of the underlying view controller changes between update passes, this method will remove the old view controller, create a new one, update it, and insert it into the view controller hierarchy. The view controller at child must be a child of self . Parameters: parameter child: The KeyPath which describes what view controller to update. This view controller must be a direct child of self . parameter screen: The Screen instance to apply to the view controller. parameter environment: The environment to used when updating the view controller. parameter onChange: A callback called if the view controller instance changed.","title":"update(child:with:in:onChange:)"},{"location":"swift/api/WorkflowUI/protocols/Screen/","text":"PROTOCOL Screen \u00b6 Screens are the building blocks of an interactive application. Conforming types contain any information needed to populate a screen: data, styling, event handlers, etc. Methods \u00b6 viewControllerDescription(environment:) \u00b6 A view controller description that acts as a recipe to either build or update a previously-built view controller to match this screen.","title":"Screen"},{"location":"swift/api/WorkflowUI/protocols/Screen/#screen","text":"Screens are the building blocks of an interactive application. Conforming types contain any information needed to populate a screen: data, styling, event handlers, etc.","title":"Screen"},{"location":"swift/api/WorkflowUI/protocols/Screen/#methods","text":"","title":"Methods"},{"location":"swift/api/WorkflowUI/protocols/Screen/#viewcontrollerdescriptionenvironment","text":"A view controller description that acts as a recipe to either build or update a previously-built view controller to match this screen.","title":"viewControllerDescription(environment:)"},{"location":"swift/api/WorkflowUI/protocols/UpdateChildScreenViewController/","text":"PROTOCOL UpdateChildScreenViewController \u00b6","title":"UpdateChildScreenViewController"},{"location":"swift/api/WorkflowUI/protocols/UpdateChildScreenViewController/#updatechildscreenviewcontroller","text":"","title":"UpdateChildScreenViewController"},{"location":"swift/api/WorkflowUI/structs/AdaptedEnvironmentScreen/","text":"STRUCT AdaptedEnvironmentScreen \u00b6 Wraps a Screen tree with a modified ViewEnvironment . By specifying environmental values with this Screen , all child screens nested will inherit those values automatically. Values can be changed anywhere in a sub-tree by inserting another AdaptedEnvironmentScreen . MyScreen (...) . adaptedEnvironment ( keyPath : \\ . myValue , to : newValue ) Properties \u00b6 wrapped \u00b6 The screen wrapped by this screen. Methods \u00b6 init(wrapping:adapting:) \u00b6 Wraps a Screen with an environment that is modified using the given configuration block. Parameters: wrapping: The screen to be wrapped. adapting: A block that will set environmental values. init(wrapping:key:value:) \u00b6 Wraps a Screen with an environment that is modified for a single key and value. Parameters: wrapping: The screen to be wrapped. key: The environment key to modify. value: The new environment value to cascade. init(wrapping:keyPath:value:) \u00b6 Wraps a Screen with an environment that is modified for a single value. Parameters: wrapping: The screen to be wrapped. keyPath: The keypath of the environment value to modify. value: The new environment value to cascade.","title":"AdaptedEnvironmentScreen"},{"location":"swift/api/WorkflowUI/structs/AdaptedEnvironmentScreen/#adaptedenvironmentscreen","text":"Wraps a Screen tree with a modified ViewEnvironment . By specifying environmental values with this Screen , all child screens nested will inherit those values automatically. Values can be changed anywhere in a sub-tree by inserting another AdaptedEnvironmentScreen . MyScreen (...) . adaptedEnvironment ( keyPath : \\ . myValue , to : newValue )","title":"AdaptedEnvironmentScreen"},{"location":"swift/api/WorkflowUI/structs/AdaptedEnvironmentScreen/#properties","text":"","title":"Properties"},{"location":"swift/api/WorkflowUI/structs/AdaptedEnvironmentScreen/#wrapped","text":"The screen wrapped by this screen.","title":"wrapped"},{"location":"swift/api/WorkflowUI/structs/AdaptedEnvironmentScreen/#methods","text":"","title":"Methods"},{"location":"swift/api/WorkflowUI/structs/AdaptedEnvironmentScreen/#initwrappingadapting","text":"Wraps a Screen with an environment that is modified using the given configuration block. Parameters: wrapping: The screen to be wrapped. adapting: A block that will set environmental values.","title":"init(wrapping:adapting:)"},{"location":"swift/api/WorkflowUI/structs/AdaptedEnvironmentScreen/#initwrappingkeyvalue","text":"Wraps a Screen with an environment that is modified for a single key and value. Parameters: wrapping: The screen to be wrapped. key: The environment key to modify. value: The new environment value to cascade.","title":"init(wrapping:key:value:)"},{"location":"swift/api/WorkflowUI/structs/AdaptedEnvironmentScreen/#initwrappingkeypathvalue","text":"Wraps a Screen with an environment that is modified for a single value. Parameters: wrapping: The screen to be wrapped. keyPath: The keypath of the environment value to modify. value: The new environment value to cascade.","title":"init(wrapping:keyPath:value:)"},{"location":"swift/api/WorkflowUI/structs/AnyScreen/","text":"STRUCT AnyScreen \u00b6 Properties \u00b6 wrappedScreen \u00b6 The original screen, retained for debugging Methods \u00b6 init(_:) \u00b6 viewControllerDescription(environment:) \u00b6","title":"AnyScreen"},{"location":"swift/api/WorkflowUI/structs/AnyScreen/#anyscreen","text":"","title":"AnyScreen"},{"location":"swift/api/WorkflowUI/structs/AnyScreen/#properties","text":"","title":"Properties"},{"location":"swift/api/WorkflowUI/structs/AnyScreen/#wrappedscreen","text":"The original screen, retained for debugging","title":"wrappedScreen"},{"location":"swift/api/WorkflowUI/structs/AnyScreen/#methods","text":"","title":"Methods"},{"location":"swift/api/WorkflowUI/structs/AnyScreen/#init_","text":"","title":"init(_:)"},{"location":"swift/api/WorkflowUI/structs/AnyScreen/#viewcontrollerdescriptionenvironment","text":"","title":"viewControllerDescription(environment:)"},{"location":"swift/api/WorkflowUI/structs/ViewControllerDescription.KindIdentifier/","text":"STRUCT ViewControllerDescription.KindIdentifier \u00b6 Describes the UIViewController type that backs the ViewControllerDescription in a way that is Equatable and Hashable . When implementing view controller updating and diffing, you can use this type to identify if the backing view controller type changed. Methods \u00b6 init(_:) \u00b6 Creates a new kind for the given view controller type. canUpdate(viewController:) \u00b6 If the given view controller is of the correct type to be updated by this view controller description. If your view controller type can change between updates, call this method before invoking update(viewController:) . hash(into:) \u00b6 ==(_:_:) \u00b6","title":"ViewControllerDescription.KindIdentifier"},{"location":"swift/api/WorkflowUI/structs/ViewControllerDescription.KindIdentifier/#viewcontrollerdescriptionkindidentifier","text":"Describes the UIViewController type that backs the ViewControllerDescription in a way that is Equatable and Hashable . When implementing view controller updating and diffing, you can use this type to identify if the backing view controller type changed.","title":"ViewControllerDescription.KindIdentifier"},{"location":"swift/api/WorkflowUI/structs/ViewControllerDescription.KindIdentifier/#methods","text":"","title":"Methods"},{"location":"swift/api/WorkflowUI/structs/ViewControllerDescription.KindIdentifier/#init_","text":"Creates a new kind for the given view controller type.","title":"init(_:)"},{"location":"swift/api/WorkflowUI/structs/ViewControllerDescription.KindIdentifier/#canupdateviewcontroller","text":"If the given view controller is of the correct type to be updated by this view controller description. If your view controller type can change between updates, call this method before invoking update(viewController:) .","title":"canUpdate(viewController:)"},{"location":"swift/api/WorkflowUI/structs/ViewControllerDescription.KindIdentifier/#hashinto","text":"","title":"hash(into:)"},{"location":"swift/api/WorkflowUI/structs/ViewControllerDescription.KindIdentifier/#__","text":"","title":"==(_:_:)"},{"location":"swift/api/WorkflowUI/structs/ViewControllerDescription/","text":"STRUCT ViewControllerDescription \u00b6 A ViewControllerDescription acts as a \u201crecipe\u201d for building and updating a specific UIViewController . It describes how to create and later update a given view controller instance, without creating one itself. This means it is a lightweight currency you can create and pass around to describe a view controller, without needing to create one. The most common use case for a ViewControllerDescription is to return it from your Screen \u2018s viewControllerDescription(environment:) method. The WorkflowUI machinery (or your custom container view controller) will then use this view controller description to create or update the on-screen presented view controller. As a creator of a custom container view controller, you will usually pass this view controller description to a DescribedViewController , which will internally create and manage the described view controller for its current view controller description. However, you can also directly invoke the public methods such as buildViewController() , update(viewController:) , if you are manually managing your own view controller hierarchy. Properties \u00b6 performInitialUpdate \u00b6 If an initial call to update(viewController:) will be performed when the view controller is created. Defaults to true . Note \u00b6 When creating container view controllers that contain other view controllers (eg, a navigation stack), you usually want to set this value to false to avoid duplicate updates to your children if they are created in init . kind \u00b6 Describes the UIViewController type that backs the ViewControllerDescription in a way that is Equatable and Hashable . When implementing view controller updating and diffing, you can use this type to identify if the backing view controller type changed. Methods \u00b6 init(performInitialUpdate:type:build:update:) \u00b6 Constructs a view controller description by providing closures used to build and update a specific view controller type. Parameters: performInitialUpdate: If an initial call to update(viewController:) will be performed when the view controller is created. Defaults to true . type: The type of view controller produced by this description. Typically, should should be able to omit this parameter, but in cases where type inference has trouble, it\u2019s offered as an escape hatch. build: Closure that produces a new instance of the view controller update: Closure that updates the given view controller buildViewController() \u00b6 Construct and update a new view controller as described by this view controller description. The view controller will be updated before it is returned, so it is fully configured and prepared for display. canUpdate(viewController:) \u00b6 If the given view controller is of the correct type to be updated by this view controller description. If your view controller type can change between updates, call this method before invoking update(viewController:) . update(viewController:) \u00b6 Update the given view controller with the content from the view controller description. Parameters: viewController: The view controller to update. Note \u00b6 You must pass a view controller previously created by a compatible ViewControllerDescription that passes canUpdate(viewController:) . Failure to do so will result in a fatal precondition.","title":"ViewControllerDescription"},{"location":"swift/api/WorkflowUI/structs/ViewControllerDescription/#viewcontrollerdescription","text":"A ViewControllerDescription acts as a \u201crecipe\u201d for building and updating a specific UIViewController . It describes how to create and later update a given view controller instance, without creating one itself. This means it is a lightweight currency you can create and pass around to describe a view controller, without needing to create one. The most common use case for a ViewControllerDescription is to return it from your Screen \u2018s viewControllerDescription(environment:) method. The WorkflowUI machinery (or your custom container view controller) will then use this view controller description to create or update the on-screen presented view controller. As a creator of a custom container view controller, you will usually pass this view controller description to a DescribedViewController , which will internally create and manage the described view controller for its current view controller description. However, you can also directly invoke the public methods such as buildViewController() , update(viewController:) , if you are manually managing your own view controller hierarchy.","title":"ViewControllerDescription"},{"location":"swift/api/WorkflowUI/structs/ViewControllerDescription/#properties","text":"","title":"Properties"},{"location":"swift/api/WorkflowUI/structs/ViewControllerDescription/#performinitialupdate","text":"If an initial call to update(viewController:) will be performed when the view controller is created. Defaults to true .","title":"performInitialUpdate"},{"location":"swift/api/WorkflowUI/structs/ViewControllerDescription/#note","text":"When creating container view controllers that contain other view controllers (eg, a navigation stack), you usually want to set this value to false to avoid duplicate updates to your children if they are created in init .","title":"Note"},{"location":"swift/api/WorkflowUI/structs/ViewControllerDescription/#kind","text":"Describes the UIViewController type that backs the ViewControllerDescription in a way that is Equatable and Hashable . When implementing view controller updating and diffing, you can use this type to identify if the backing view controller type changed.","title":"kind"},{"location":"swift/api/WorkflowUI/structs/ViewControllerDescription/#methods","text":"","title":"Methods"},{"location":"swift/api/WorkflowUI/structs/ViewControllerDescription/#initperforminitialupdatetypebuildupdate","text":"Constructs a view controller description by providing closures used to build and update a specific view controller type. Parameters: performInitialUpdate: If an initial call to update(viewController:) will be performed when the view controller is created. Defaults to true . type: The type of view controller produced by this description. Typically, should should be able to omit this parameter, but in cases where type inference has trouble, it\u2019s offered as an escape hatch. build: Closure that produces a new instance of the view controller update: Closure that updates the given view controller","title":"init(performInitialUpdate:type:build:update:)"},{"location":"swift/api/WorkflowUI/structs/ViewControllerDescription/#buildviewcontroller","text":"Construct and update a new view controller as described by this view controller description. The view controller will be updated before it is returned, so it is fully configured and prepared for display.","title":"buildViewController()"},{"location":"swift/api/WorkflowUI/structs/ViewControllerDescription/#canupdateviewcontroller","text":"If the given view controller is of the correct type to be updated by this view controller description. If your view controller type can change between updates, call this method before invoking update(viewController:) .","title":"canUpdate(viewController:)"},{"location":"swift/api/WorkflowUI/structs/ViewControllerDescription/#updateviewcontroller","text":"Update the given view controller with the content from the view controller description. Parameters: viewController: The view controller to update.","title":"update(viewController:)"},{"location":"swift/api/WorkflowUI/structs/ViewControllerDescription/#note_1","text":"You must pass a view controller previously created by a compatible ViewControllerDescription that passes canUpdate(viewController:) . Failure to do so will result in a fatal precondition.","title":"Note"},{"location":"swift/api/WorkflowUI/typealiases/AdaptedEnvironmentScreen.Adapter/","text":"TYPEALIAS AdaptedEnvironmentScreen.Adapter \u00b6 Takes in a mutable ViewEnvironment which can be mutated to add or override values.","title":"AdaptedEnvironmentScreen.Adapter"},{"location":"swift/api/WorkflowUI/typealiases/AdaptedEnvironmentScreen.Adapter/#adaptedenvironmentscreenadapter","text":"Takes in a mutable ViewEnvironment which can be mutated to add or override values.","title":"AdaptedEnvironmentScreen.Adapter"},{"location":"userguide/common-patterns/","text":"Common Patterns \u00b6 There are a lot associated/generic types in workflow code \u2013 that doesn\u2019t mean you always need to use all of them. Here are some common configurations we\u2019ve seen. Stateless Workflows \u00b6 Remember that workflow state is made up of public and private parts. When a workflow\u2019s state consists entirely of public state (i.e. it\u2019s initializer arguments in Swift or PropsT in Kotlin), it can ignore all the machinery for private state. In Swift, the State type can be Void , and in Kotlin it can be Unit \u2013 such workflows are often referred to as \u201cstateless\u201d, since they have no state of their own. Props-less Workflows \u00b6 Some workflows manage all of their state internally, and have no public state (aka props). In Swift, this just means the workflow implementation has no parameters (although this is rare, see Injecting Dependencies below). In Kotlin, the PropsT type can be Unit . RenderContext has convenience overloads of most of its functions to implicitly pass Unit for these workflows. Outputless Workflows \u00b6 Workflows that only talk to their parent via their Rendering , and never emit any output, are encouraged to indicate that by using the bottom type as their Output type. In addition to documenting the fact that the workflow will never output, using the bottom type also lets the compiler enforce it \u2013 code that tries to emit outputs will not compile. In Swift, the Output type is specified as Never . In Kotlin, use Nothing . Composite Workflows \u00b6 Composition is a powerful tool for working with Workflows. A workflow can often accomplish a lot simply by rendering various children. It may just combine the renderings of multiple children, or use its props to determine which of a set of children to render. Such workflows can often be stateless. One-and-done Workflows (RenderingT v. OutputT) \u00b6 A common question is \u201cwhy can\u2019t I emit output from initialState ,\u201d or \u201cwhat if my Workflow realizes it doesn\u2019t actually need to run? The most efficient, and most expressive, way to handle this is to use an optional or conditional Rendering type, and an Output of Never / Nothing . Imagine a PromptForPermissionMaybeWorkflow , that renders a UI to get a passcode, but only if that permission has not already been granted. If you make its RenderingT nullable (e.g. Screen? ), it can return null to indicate that its job is done. Its callers will be synchronously informed that the coast is clear, and can immediately render what they actually care about. Another variation of this pattern is to use a sealed class / enum type for Rendering , with a Working type that implements Screen , and a unviewable Finished type that carries the work product. A good rule of thumb for choosing between using Rendering or Output is to remember that Output is event-like, and is always asynchronous. A parent waiting for an output must be given something to render in the meantime. Using Rendering is a great idiom for a one-and-done workflow tasked with providing a single product, especially one that might be available instantly. Props values v. Injected Dependencies \u00b6 Dependency injection is a technique for making code less coupled and more testable. In short, it\u2019s better for classes/structs to accept their dependencies when they\u2019re created instead of hard-coding them. Workflows typically have dependencies like specific Workers they need to perform some tasks, child workflows to delegate rendering to, or helpers for things like network requests, formatting and logging. Swift \u00b6 A Swift workflow typically receives its dependencies as initializer arguments, just like its input values, and is normally instantiated anew by its parent in each call to the parent\u2019s render method. The factory pattern can be employed to keep knowledge of children\u2019s implementation details from leaking into their parents. Kotlin \u00b6 Kotlin workflows make a more formal distinction between dependencies and props, via the PropsT parameter type on the Kotlin Workflow interface. Dependencies (e.g. a network service) are typically provided as constructor parameters, while props values (e.g. a record locator) are provided by the parent as an argument to the RenderContext.renderChild method. This works seamlessly with DI libraries like Dagger . The careful reader will note that this is technically storing \u201cstate\u201d in the workflow instance \u2013 something that is generally discouraged. However, since this \u201cstate\u201d is never changed, we can make an exception for this case. If a workflow has properties, they should only be used to store injected dependencies or dependencies derived from injected ones (e.g. Worker s created from Observable s). Info This difference between Swift and Kotlin practices is a side effect of Kotlin\u2019s lack of a parallel to Swift\u2019s Self type. Kotlin has no practical way to provide a method like Swift\u2019s Workflow.workflowDidChange , which accepts a strongly typed reference to the instance from the previous run of a parent\u2019s Render method. Kotlin\u2019s alternative, StatefulWorkflow.onPropsChanged , requires the extra PropsT type parameter.","title":"Common Patterns"},{"location":"userguide/common-patterns/#common-patterns","text":"There are a lot associated/generic types in workflow code \u2013 that doesn\u2019t mean you always need to use all of them. Here are some common configurations we\u2019ve seen.","title":"Common Patterns"},{"location":"userguide/common-patterns/#stateless-workflows","text":"Remember that workflow state is made up of public and private parts. When a workflow\u2019s state consists entirely of public state (i.e. it\u2019s initializer arguments in Swift or PropsT in Kotlin), it can ignore all the machinery for private state. In Swift, the State type can be Void , and in Kotlin it can be Unit \u2013 such workflows are often referred to as \u201cstateless\u201d, since they have no state of their own.","title":"Stateless Workflows"},{"location":"userguide/common-patterns/#props-less-workflows","text":"Some workflows manage all of their state internally, and have no public state (aka props). In Swift, this just means the workflow implementation has no parameters (although this is rare, see Injecting Dependencies below). In Kotlin, the PropsT type can be Unit . RenderContext has convenience overloads of most of its functions to implicitly pass Unit for these workflows.","title":"Props-less Workflows"},{"location":"userguide/common-patterns/#outputless-workflows","text":"Workflows that only talk to their parent via their Rendering , and never emit any output, are encouraged to indicate that by using the bottom type as their Output type. In addition to documenting the fact that the workflow will never output, using the bottom type also lets the compiler enforce it \u2013 code that tries to emit outputs will not compile. In Swift, the Output type is specified as Never . In Kotlin, use Nothing .","title":"Outputless Workflows"},{"location":"userguide/common-patterns/#composite-workflows","text":"Composition is a powerful tool for working with Workflows. A workflow can often accomplish a lot simply by rendering various children. It may just combine the renderings of multiple children, or use its props to determine which of a set of children to render. Such workflows can often be stateless.","title":"Composite Workflows"},{"location":"userguide/common-patterns/#one-and-done-workflows-renderingt-v-outputt","text":"A common question is \u201cwhy can\u2019t I emit output from initialState ,\u201d or \u201cwhat if my Workflow realizes it doesn\u2019t actually need to run? The most efficient, and most expressive, way to handle this is to use an optional or conditional Rendering type, and an Output of Never / Nothing . Imagine a PromptForPermissionMaybeWorkflow , that renders a UI to get a passcode, but only if that permission has not already been granted. If you make its RenderingT nullable (e.g. Screen? ), it can return null to indicate that its job is done. Its callers will be synchronously informed that the coast is clear, and can immediately render what they actually care about. Another variation of this pattern is to use a sealed class / enum type for Rendering , with a Working type that implements Screen , and a unviewable Finished type that carries the work product. A good rule of thumb for choosing between using Rendering or Output is to remember that Output is event-like, and is always asynchronous. A parent waiting for an output must be given something to render in the meantime. Using Rendering is a great idiom for a one-and-done workflow tasked with providing a single product, especially one that might be available instantly.","title":"One-and-done Workflows (RenderingT v. OutputT)"},{"location":"userguide/common-patterns/#props-values-v-injected-dependencies","text":"Dependency injection is a technique for making code less coupled and more testable. In short, it\u2019s better for classes/structs to accept their dependencies when they\u2019re created instead of hard-coding them. Workflows typically have dependencies like specific Workers they need to perform some tasks, child workflows to delegate rendering to, or helpers for things like network requests, formatting and logging.","title":"Props values v. Injected Dependencies"},{"location":"userguide/common-patterns/#swift","text":"A Swift workflow typically receives its dependencies as initializer arguments, just like its input values, and is normally instantiated anew by its parent in each call to the parent\u2019s render method. The factory pattern can be employed to keep knowledge of children\u2019s implementation details from leaking into their parents.","title":"Swift"},{"location":"userguide/common-patterns/#kotlin","text":"Kotlin workflows make a more formal distinction between dependencies and props, via the PropsT parameter type on the Kotlin Workflow interface. Dependencies (e.g. a network service) are typically provided as constructor parameters, while props values (e.g. a record locator) are provided by the parent as an argument to the RenderContext.renderChild method. This works seamlessly with DI libraries like Dagger . The careful reader will note that this is technically storing \u201cstate\u201d in the workflow instance \u2013 something that is generally discouraged. However, since this \u201cstate\u201d is never changed, we can make an exception for this case. If a workflow has properties, they should only be used to store injected dependencies or dependencies derived from injected ones (e.g. Worker s created from Observable s). Info This difference between Swift and Kotlin practices is a side effect of Kotlin\u2019s lack of a parallel to Swift\u2019s Self type. Kotlin has no practical way to provide a method like Swift\u2019s Workflow.workflowDidChange , which accepts a strongly typed reference to the instance from the previous run of a parent\u2019s Render method. Kotlin\u2019s alternative, StatefulWorkflow.onPropsChanged , requires the extra PropsT type parameter.","title":"Kotlin"},{"location":"userguide/concepts/","text":"Workflow Core \u00b6 This page provides a high level overview of Workflow Core, the UI-agnostic Swift and Kotlin runtimes at the heart of the Workflow libraries. See Workflow UI to learn about the companion Android and iOS specific modules. What is a Workflow? \u00b6 A Workflow defines the possible states and behaviors of components of a particular type. The overall state of a Workflow has two parts: Props , configuration information provided by whatever is running the Workflow And the private State managed by the Workflow itself At any time, a Workflow can be asked to transform its current Props and State into a Rendering that is suitable for external consumption. A Rendering is typically a simple struct with display data, and event handler functions that can enqueue Workflow Actions \u2014 functions that update State, and which may at the same time emit Output events. For example, a Workflow running a simple game might be configured with a description of the participating Players as its Props, build GameScreen structs when asked to render, and emit a GameOver event as Output to signal that is finished. A workflow Rendering usually serves as a view model in iOS or Android apps, but that is not a requirement. Again, this page includes no details about how platform specific UI code is driven. See Workflow UI for that discussion. Note Readers with an Android background should note the lower case v and m of \u201cview model\u201d \u2014 this notion has nothing to do with Jetpack ViewModel . Composing Workflows \u00b6 Workflows run in a tree, with a single root Workflow declaring it has any number of children for a particular state, each of which can declare children of their own, and so on. The most common reason to compose Workflows this way is to build big view models (Renderings) out of small ones. For example, consider an overview / detail split screen, like an email app with a list of messages on the left, and the body of the selected message on the right. This could be modeled as a trio of Workflows: InboxWorkflow Expects a List<MessageId> as its Props Rendering is an InboxScreen , a struct with displayable information derived from its Props, and an onMessageSelected() function When onMessageSelected() is called, a WorkflowAction is executed which emits the given MessageId as Output Has no private State MessageWorkflow Requires a MessageId Props value to produce a MessageScreen Rendering Has no private State, and emits no Output EmailBrowserWorkflow State includes a List<MessageId> , and the selected MessageId Rendering is a SplitScreen view model, to be assembled from the renderings of the other two Workflows Accepts no Props, and emits no Output When EmailBrowserWorkflow is asked to provide its Rendering, it in turn asks for Renderings from its two children. It provides the List<MessageId> from its state as the Props for EmailInboxWorkflow and receives an InBoxScreen rendering in return. That InboxScreen becomes the left pane of a SplitScreen Rendering. For the SplitScreen \u2018s right pane, the browser Workflow provides the currently selected MessageId as input to EmailMessageWorkflow , to get a MessageScreen rendering. Note Note that the two children, EmailInboxWorkflow and EmailMessageWorkflow , have no knowledge of each other, nor of the context in which they are run. The InboxScreen rendering includes an onMessageSelected(MessageId) function. When that is called, EmailInboxWorkflow enqueues an Action function that emits the given MessageId as Output. EmailBrowserWorkflow receives that Output, and enqueues another Action that updates the selection: MessageId of its State accordingly. Whenever such a Workflow Action cascade fires, the root Workflow is asked for a new Rendering. Just as before, EmailInboxWorkflow delegates to its two children for their Renderings, this time providing the new value of selection as the updated Props for MessageWorkflow . Why does Workflow work this way? \u00b6 Workflow was built to tame the composition and navigation challenges presented by Square\u2019s massive Android and iOS apps. It lets us write intricate, centralized, well tested code encapsulating the flow through literally hundreds of individual screens. These days we are able to see and shape the forest, despite all of the trees. We built it with two core design principals in mind: Unidirectional data flow is the best way to stay sane when building UI Declarative programming is the best way to define unidirectional data flows What does that actually mean? Unidirectional Data Flow \u00b6 There is a wealth of information on the web about Unidirectional Data Flow , but it very simply means that there is a single path along which data travel from your business logic to your UI, and events travel to your business logic from your UI, and they always and only travel in one direction along that path. For Workflow, this also implies that the UI is (almost) stateless, and that the interesting state for your app is centralized and not duplicated. In practice, this makes program flow much easier to reason about because anytime something happens in an app, it removes the questions of where the state came from that caused it, which components got which events, and which sequences of cause and effect actually occurred. It makes unit testing easier because state and events are explicit, and always live in the same place and flow through the same APIs, so unit tests only need to test state transitions, for the most part. Declarative vs Imperative \u00b6 Traditionally, most mobile code is \u201cimperative\u201d \u2013 it consists of instructions for how to build and display the UI. These instructions can include control flow like loops. Imperative code is usually stateful, state is usually sprinkled all over the place, and tends to care about instances and identity. When reading imperative code, you almost have to run an interpreter and keep all the pieces of state in your head to figure out what it does. Web UI is traditionally declarative \u2013 it describes what to render, and some aspects of how to render it (style), but doesn\u2019t say how to actually draw it. Declarative code is usually easier to read than imperative code. It describes what it produces, not how to generate it. Declarative code usually cares more about pure values than instance identities. However, since computers still need actual instructions at some point, declarative code requires something else, usually imperative, either a compiler or interpreter, to actually do something with it. Workflow code is written in regular Kotlin or Swift, which are both imperative languages, but the library encourages you to write your logic in a declarative and functional style. The library manages state and wiring up event handling for you, so the only code you need to write is code that is actually interesting for your particular problem. A note about functional programming Kotlin and Swift are not strictly functional programming languages, but both have features that allow you to write functional -style code. Functional code discourages side effects and is generally much easier to test than object-oriented code. Functional and declarative programming go very well together, and Workflow encourages you to write such code.","title":"Workflow Core"},{"location":"userguide/concepts/#workflow-core","text":"This page provides a high level overview of Workflow Core, the UI-agnostic Swift and Kotlin runtimes at the heart of the Workflow libraries. See Workflow UI to learn about the companion Android and iOS specific modules.","title":"Workflow Core"},{"location":"userguide/concepts/#what-is-a-workflow","text":"A Workflow defines the possible states and behaviors of components of a particular type. The overall state of a Workflow has two parts: Props , configuration information provided by whatever is running the Workflow And the private State managed by the Workflow itself At any time, a Workflow can be asked to transform its current Props and State into a Rendering that is suitable for external consumption. A Rendering is typically a simple struct with display data, and event handler functions that can enqueue Workflow Actions \u2014 functions that update State, and which may at the same time emit Output events. For example, a Workflow running a simple game might be configured with a description of the participating Players as its Props, build GameScreen structs when asked to render, and emit a GameOver event as Output to signal that is finished. A workflow Rendering usually serves as a view model in iOS or Android apps, but that is not a requirement. Again, this page includes no details about how platform specific UI code is driven. See Workflow UI for that discussion. Note Readers with an Android background should note the lower case v and m of \u201cview model\u201d \u2014 this notion has nothing to do with Jetpack ViewModel .","title":"What is a Workflow?"},{"location":"userguide/concepts/#composing-workflows","text":"Workflows run in a tree, with a single root Workflow declaring it has any number of children for a particular state, each of which can declare children of their own, and so on. The most common reason to compose Workflows this way is to build big view models (Renderings) out of small ones. For example, consider an overview / detail split screen, like an email app with a list of messages on the left, and the body of the selected message on the right. This could be modeled as a trio of Workflows: InboxWorkflow Expects a List<MessageId> as its Props Rendering is an InboxScreen , a struct with displayable information derived from its Props, and an onMessageSelected() function When onMessageSelected() is called, a WorkflowAction is executed which emits the given MessageId as Output Has no private State MessageWorkflow Requires a MessageId Props value to produce a MessageScreen Rendering Has no private State, and emits no Output EmailBrowserWorkflow State includes a List<MessageId> , and the selected MessageId Rendering is a SplitScreen view model, to be assembled from the renderings of the other two Workflows Accepts no Props, and emits no Output When EmailBrowserWorkflow is asked to provide its Rendering, it in turn asks for Renderings from its two children. It provides the List<MessageId> from its state as the Props for EmailInboxWorkflow and receives an InBoxScreen rendering in return. That InboxScreen becomes the left pane of a SplitScreen Rendering. For the SplitScreen \u2018s right pane, the browser Workflow provides the currently selected MessageId as input to EmailMessageWorkflow , to get a MessageScreen rendering. Note Note that the two children, EmailInboxWorkflow and EmailMessageWorkflow , have no knowledge of each other, nor of the context in which they are run. The InboxScreen rendering includes an onMessageSelected(MessageId) function. When that is called, EmailInboxWorkflow enqueues an Action function that emits the given MessageId as Output. EmailBrowserWorkflow receives that Output, and enqueues another Action that updates the selection: MessageId of its State accordingly. Whenever such a Workflow Action cascade fires, the root Workflow is asked for a new Rendering. Just as before, EmailInboxWorkflow delegates to its two children for their Renderings, this time providing the new value of selection as the updated Props for MessageWorkflow .","title":"Composing Workflows"},{"location":"userguide/concepts/#why-does-workflow-work-this-way","text":"Workflow was built to tame the composition and navigation challenges presented by Square\u2019s massive Android and iOS apps. It lets us write intricate, centralized, well tested code encapsulating the flow through literally hundreds of individual screens. These days we are able to see and shape the forest, despite all of the trees. We built it with two core design principals in mind: Unidirectional data flow is the best way to stay sane when building UI Declarative programming is the best way to define unidirectional data flows What does that actually mean?","title":"Why does Workflow work this way?"},{"location":"userguide/concepts/#unidirectional-data-flow","text":"There is a wealth of information on the web about Unidirectional Data Flow , but it very simply means that there is a single path along which data travel from your business logic to your UI, and events travel to your business logic from your UI, and they always and only travel in one direction along that path. For Workflow, this also implies that the UI is (almost) stateless, and that the interesting state for your app is centralized and not duplicated. In practice, this makes program flow much easier to reason about because anytime something happens in an app, it removes the questions of where the state came from that caused it, which components got which events, and which sequences of cause and effect actually occurred. It makes unit testing easier because state and events are explicit, and always live in the same place and flow through the same APIs, so unit tests only need to test state transitions, for the most part.","title":"Unidirectional Data Flow"},{"location":"userguide/concepts/#declarative-vs-imperative","text":"Traditionally, most mobile code is \u201cimperative\u201d \u2013 it consists of instructions for how to build and display the UI. These instructions can include control flow like loops. Imperative code is usually stateful, state is usually sprinkled all over the place, and tends to care about instances and identity. When reading imperative code, you almost have to run an interpreter and keep all the pieces of state in your head to figure out what it does. Web UI is traditionally declarative \u2013 it describes what to render, and some aspects of how to render it (style), but doesn\u2019t say how to actually draw it. Declarative code is usually easier to read than imperative code. It describes what it produces, not how to generate it. Declarative code usually cares more about pure values than instance identities. However, since computers still need actual instructions at some point, declarative code requires something else, usually imperative, either a compiler or interpreter, to actually do something with it. Workflow code is written in regular Kotlin or Swift, which are both imperative languages, but the library encourages you to write your logic in a declarative and functional style. The library manages state and wiring up event handling for you, so the only code you need to write is code that is actually interesting for your particular problem. A note about functional programming Kotlin and Swift are not strictly functional programming languages, but both have features that allow you to write functional -style code. Functional code discourages side effects and is generally much easier to test than object-oriented code. Functional and declarative programming go very well together, and Workflow encourages you to write such code.","title":"Declarative vs Imperative"},{"location":"userguide/implementation/","text":"Implementation Notes \u00b6 Work in progress\u2026 So far we only have notes on the implementation of the Swift runtime. They\u2019re actually pretty close to what goes on in Kotlin, the WorkflowNode and SubtreeManager classes in particular. Swift \u00b6 The Render loop \u00b6 Initial pass \u00b6 The root of your workflow hierarchy gets put into a WorkflowHost (if you\u2019re using ContainerViewController this is created for you). As part of its initializer, WorkflowHost creates a WorkflowNode that wraps the given root Workflow (and keeps track of the Workflow \u2018s State ). It then calls render() on the node: // WorkflowHost public init ( workflow : WorkflowType , debugger : WorkflowDebugger ? = nil ) { self . debugger = debugger self . rootNode = WorkflowNode ( workflow : workflow ) // 1. Create the node self . mutableRendering = MutableProperty ( self . rootNode . render ()) // 2. Call render() WorkflowNode contains a SubtreeManager , whose primary purpose is to manage child workflows (more on this later). When render() gets invoked on the node, it calls render on the SubtreeManager and passes a closure that takes a RenderContext and returns a Rendering for the Workflow associated with the node. // WorkflowNode func render () -> WorkflowType . Rendering { return subtreeManager . render { context in return workflow . render ( state : state , context : context ) } } The SubtreeManager instantiates a RenderContext and invokes the closure that was passed in. This last step generates the Rendering . This Rendering then gets passed back up the call stack until it reaches the WorkflowHost . Composition \u00b6 In cases where a Workflow has child Workflow s, the render sequence is similar. The [tutorial] (../tutorial/building-a-workflow/#the-render-context) goes through this in more detail. Essentially, a Workflow containing child Workflow s calls render(context:key:outputMap:) on each child Workflow and passes in the RenderContext . The context does some bookkeeping for the child Workflow (creating or updating a ChildWorkflow<T> ) and then calls render() . ChildWorkflow<T>.render() calls render() on its WorkflowNode and we recurse back to step 2.","title":"Implementation Notes"},{"location":"userguide/implementation/#implementation-notes","text":"Work in progress\u2026 So far we only have notes on the implementation of the Swift runtime. They\u2019re actually pretty close to what goes on in Kotlin, the WorkflowNode and SubtreeManager classes in particular.","title":"Implementation Notes"},{"location":"userguide/implementation/#swift","text":"","title":"Swift"},{"location":"userguide/implementation/#the-render-loop","text":"","title":"The Render loop"},{"location":"userguide/implementation/#initial-pass","text":"The root of your workflow hierarchy gets put into a WorkflowHost (if you\u2019re using ContainerViewController this is created for you). As part of its initializer, WorkflowHost creates a WorkflowNode that wraps the given root Workflow (and keeps track of the Workflow \u2018s State ). It then calls render() on the node: // WorkflowHost public init ( workflow : WorkflowType , debugger : WorkflowDebugger ? = nil ) { self . debugger = debugger self . rootNode = WorkflowNode ( workflow : workflow ) // 1. Create the node self . mutableRendering = MutableProperty ( self . rootNode . render ()) // 2. Call render() WorkflowNode contains a SubtreeManager , whose primary purpose is to manage child workflows (more on this later). When render() gets invoked on the node, it calls render on the SubtreeManager and passes a closure that takes a RenderContext and returns a Rendering for the Workflow associated with the node. // WorkflowNode func render () -> WorkflowType . Rendering { return subtreeManager . render { context in return workflow . render ( state : state , context : context ) } } The SubtreeManager instantiates a RenderContext and invokes the closure that was passed in. This last step generates the Rendering . This Rendering then gets passed back up the call stack until it reaches the WorkflowHost .","title":"Initial pass"},{"location":"userguide/implementation/#composition","text":"In cases where a Workflow has child Workflow s, the render sequence is similar. The [tutorial] (../tutorial/building-a-workflow/#the-render-context) goes through this in more detail. Essentially, a Workflow containing child Workflow s calls render(context:key:outputMap:) on each child Workflow and passes in the RenderContext . The context does some bookkeeping for the child Workflow (creating or updating a ChildWorkflow<T> ) and then calls render() . ChildWorkflow<T>.render() calls render() on its WorkflowNode and we recurse back to step 2.","title":"Composition"},{"location":"userguide/testing-concepts/","text":"Workflow Testing \u00b6 Coming soon!","title":"Testing (TBD)"},{"location":"userguide/testing-concepts/#workflow-testing","text":"Coming soon!","title":"Workflow Testing"},{"location":"userguide/ui-concepts/","text":"Workflow UI \u00b6 This page provides a high level overview of Workflow UI, the companion that allows Workflow Core to drive Android and iOS apps. To see how these ideas are realized in code, move on to Coding Workflow UI . Warning The Screen interface that is so central to this discussion has reached Kotlin very recently, via v1.8.0-beta01 . Thus, if you are working against the most recent non-beta release, you will find the code blocks here don\u2019t match what you\u2019re seeing. Square is using the Screen machinery introduced with the beta at the heart of our Android app suite, and we expect the beta period to be a short one. The Swift Screen protocol et al. have been in steady use for years. What\u2019s a Screen? \u00b6 Most Workflow implementations produce struct / data class renderings that can serve as view models. Such a rendering provides enough data to paint a complete UI, including functions to be called in response to UI events. These view model renderings implement the Screen protocol / interface to advertise that this is their intended use. The core service provided by Workflow UI is to transform Screen types into platform-specific view objects, and to keep those views updated as new Screen renderings are emitted. Screen is the lynch pin that ties the Workflow Core and Workflow UI worlds together, the basic UI building block for Workflow-driven apps. A Screen is an object that can be presented as a basic 2D UI box, like an android.view.View or a UIViewController . And Workflow UI provides the glue that allows you to declare (at compile time!) that instances of FooScreen : Screen are used to drive FooViewController , layout/foo_screen.xml , or @Composable fun Content(FooScreen, ViewEnvironment) . Why \"Screen\"? We chose the name \u201cScreen\u201d because \u201cView\u201d would invite confusion with the like-named Android and iOS classes, and because \u201cBox\u201d didn\u2019t occur to us. (No one seems to have been bothered by the fact that Screen and iOS\u2019s UIScreen are unrelated.) And really, we went with \u201cScreen\u201d because it\u2019s the nebulous term that we and our users have always used to discuss our apps: \u201cGo to the Settings screen.\u201d \u201cHow do I get to the Tipping screen?\u201d \u201cThe Cart screen is shown in a modal over the Home screen on tablets.\u201d It\u2019s a safe bet you understood each of those sentences. Workflow Tree, Rendering Tree, View Tree \u00b6 In the Workflow Core page we discussed how Workflows can be composed as trees , like this email app driven by a trio of Workflows that assemble a composite SplitScreen rendering. Let\u2019s take a look at how Workflow UI transforms such a container screen into a container view . The main connection between the Workflow Core runtime and a native view system is the stream of Rendering objects from the root Workflow, EmailBrowserWorkflow in this discussion. From that point on, the flow of control is entirely in view-land. The precise details of that journey vary between Android and iOS in terms of naming, subclassing v. delegating, and so on, mainly to ensure that the API is idiomatic for each audience. None the less, the broad strokes are the same. (Move on to Coding Workflow UI to drill into the platform-specific details.) Each flavor of Workflow UI provides two core container helpers, both pictured below: A \u201cworkflow container\u201d, able to instantiate and update a view that can display Screen instances of the given type In iOS this is DescribedViewController For Android Classic we provide WorkflowViewStub , very similar to android.view.ViewStub . Android Jetpack Compose code can call @Compose fun WorkflowRendering() . A \u201cworkflow root container\u201d, able to field a stream of renderings from the Workflow Core runtime, and pass them on to a workflow container ContainerViewController for iOS WorkflowLayout for Android Classic @Compose fun Workflow.renderAsState() for Android Jetpack Compose When the runtime in our example is started, the flow is something like this: EmailBrowserWorkflow is asked for its first Rendering, a SplitScreen wrapping an InboxScreen and a MessageScreen . The Workflow root container receives that, and hands it off to its Workflow container . The container is able to resolve that SplitScreen instances can be displayed by views of the associated type Custom split view . The container builds that view, and passes it the SplitScreen . Custom split view is written with two Workflow containers of its own, one for the left side and for the right. The left hand container resolves InboxScreen to Custom inbox view , builds one, and hands the rendering that new view. The right hand container does the same for the MessageScreen , creating a Custom message view to display it. Sooner or later the state of EmailBrowserWorkflow or one of its children will change. Perhaps a new message has been received. Perhaps an event handler function on InboxScreen has been called because the user wants to read something else now. Regardless of where in the Workflow hierarchy the update happens, the entire tree will be re-rendered: EmailBrowserWorkflow will be asked for a new Rendering, it will ask its children for the same, and so on. Yes, everything renders when anything changes New Workflow developers generally freak out when they hear that the entire tree is re-rendered when any state anywhere updates. Remember that render() implementations are expected to be idempotent, and that their job is strictly declarative: render() effectively means \u201cI assume these children are running, and that I am subscribed to these work streams. Please make sure that stays the case, or fire up some new ones if needed.\u201d Another way is to think of them as declaring how to adapt the internal State into the external Rendering. These calls should be cheap, with all real work happening outside of the render() call. Optimizations may prevent rendering calls that are clearly redundant from being made, but semantically one should assume that the whole world is rendered when any part of the world changes. Once the runtime\u2019s Workflow tree finishes re-rendering, the new SplitScreen is passed through the native view system like so: The Workflow root container once again passes the new SplitScreen to its Workflow container , because that is the only trick it knows. That container recognizes that SplitScreen can be accepted by the Custom split view it created last time, and so there is no work to be done. The existing Custom split view receives the new SplitScreen . Just like last time, Custom split view passes InboxScreen to the Workflow container on its left, and MessageScreen to that on its right. The left hand Workflow container sees that it is already showing a Custom inbox view and passes InboxScreen rendering through. The same things happens with MessageScreen , and the Custom message view previously built by the right hand Workflow container . As is always the case with view code, Custom inbox view and Custom message view should be written with care to avoid redundant work, comparing what they are already showing with what they are being asked to show now. (A simple way to do this is to keep a Screen type\u2019s display data in a separate object from its event handlers, as an Equatable Swift struct, or as a Kotlin data class. Always hold on to the latest Screen in a var , and write UI click handlers and to reference it.) The update scenario would be different if the types of any of the Screen Renderings changed. Suppose our email app is able to host both email and voice mail in its inbox, and that the MessageScreen from the previous update is replaced with a VoicemailScreen this time. In that case, Custom message view would refuse the new Rendering, and the right hand Workflow container that created it would destroy it. A Custom voicemail view would be created in its stead, and that new view would paint itself with the information from the VoicemailScreen . So just how do these containers know what views to create for what Screen types? Those details are very language and platform specific, and are covered in the next page, under Building views from Screens . ViewEnvironment \u00b6 TK","title":"Workflow UI (in progress)"},{"location":"userguide/ui-concepts/#workflow-ui","text":"This page provides a high level overview of Workflow UI, the companion that allows Workflow Core to drive Android and iOS apps. To see how these ideas are realized in code, move on to Coding Workflow UI . Warning The Screen interface that is so central to this discussion has reached Kotlin very recently, via v1.8.0-beta01 . Thus, if you are working against the most recent non-beta release, you will find the code blocks here don\u2019t match what you\u2019re seeing. Square is using the Screen machinery introduced with the beta at the heart of our Android app suite, and we expect the beta period to be a short one. The Swift Screen protocol et al. have been in steady use for years.","title":"Workflow UI"},{"location":"userguide/ui-concepts/#whats-a-screen","text":"Most Workflow implementations produce struct / data class renderings that can serve as view models. Such a rendering provides enough data to paint a complete UI, including functions to be called in response to UI events. These view model renderings implement the Screen protocol / interface to advertise that this is their intended use. The core service provided by Workflow UI is to transform Screen types into platform-specific view objects, and to keep those views updated as new Screen renderings are emitted. Screen is the lynch pin that ties the Workflow Core and Workflow UI worlds together, the basic UI building block for Workflow-driven apps. A Screen is an object that can be presented as a basic 2D UI box, like an android.view.View or a UIViewController . And Workflow UI provides the glue that allows you to declare (at compile time!) that instances of FooScreen : Screen are used to drive FooViewController , layout/foo_screen.xml , or @Composable fun Content(FooScreen, ViewEnvironment) . Why \"Screen\"? We chose the name \u201cScreen\u201d because \u201cView\u201d would invite confusion with the like-named Android and iOS classes, and because \u201cBox\u201d didn\u2019t occur to us. (No one seems to have been bothered by the fact that Screen and iOS\u2019s UIScreen are unrelated.) And really, we went with \u201cScreen\u201d because it\u2019s the nebulous term that we and our users have always used to discuss our apps: \u201cGo to the Settings screen.\u201d \u201cHow do I get to the Tipping screen?\u201d \u201cThe Cart screen is shown in a modal over the Home screen on tablets.\u201d It\u2019s a safe bet you understood each of those sentences.","title":"What's a Screen?"},{"location":"userguide/ui-concepts/#workflow-tree-rendering-tree-view-tree","text":"In the Workflow Core page we discussed how Workflows can be composed as trees , like this email app driven by a trio of Workflows that assemble a composite SplitScreen rendering. Let\u2019s take a look at how Workflow UI transforms such a container screen into a container view . The main connection between the Workflow Core runtime and a native view system is the stream of Rendering objects from the root Workflow, EmailBrowserWorkflow in this discussion. From that point on, the flow of control is entirely in view-land. The precise details of that journey vary between Android and iOS in terms of naming, subclassing v. delegating, and so on, mainly to ensure that the API is idiomatic for each audience. None the less, the broad strokes are the same. (Move on to Coding Workflow UI to drill into the platform-specific details.) Each flavor of Workflow UI provides two core container helpers, both pictured below: A \u201cworkflow container\u201d, able to instantiate and update a view that can display Screen instances of the given type In iOS this is DescribedViewController For Android Classic we provide WorkflowViewStub , very similar to android.view.ViewStub . Android Jetpack Compose code can call @Compose fun WorkflowRendering() . A \u201cworkflow root container\u201d, able to field a stream of renderings from the Workflow Core runtime, and pass them on to a workflow container ContainerViewController for iOS WorkflowLayout for Android Classic @Compose fun Workflow.renderAsState() for Android Jetpack Compose When the runtime in our example is started, the flow is something like this: EmailBrowserWorkflow is asked for its first Rendering, a SplitScreen wrapping an InboxScreen and a MessageScreen . The Workflow root container receives that, and hands it off to its Workflow container . The container is able to resolve that SplitScreen instances can be displayed by views of the associated type Custom split view . The container builds that view, and passes it the SplitScreen . Custom split view is written with two Workflow containers of its own, one for the left side and for the right. The left hand container resolves InboxScreen to Custom inbox view , builds one, and hands the rendering that new view. The right hand container does the same for the MessageScreen , creating a Custom message view to display it. Sooner or later the state of EmailBrowserWorkflow or one of its children will change. Perhaps a new message has been received. Perhaps an event handler function on InboxScreen has been called because the user wants to read something else now. Regardless of where in the Workflow hierarchy the update happens, the entire tree will be re-rendered: EmailBrowserWorkflow will be asked for a new Rendering, it will ask its children for the same, and so on. Yes, everything renders when anything changes New Workflow developers generally freak out when they hear that the entire tree is re-rendered when any state anywhere updates. Remember that render() implementations are expected to be idempotent, and that their job is strictly declarative: render() effectively means \u201cI assume these children are running, and that I am subscribed to these work streams. Please make sure that stays the case, or fire up some new ones if needed.\u201d Another way is to think of them as declaring how to adapt the internal State into the external Rendering. These calls should be cheap, with all real work happening outside of the render() call. Optimizations may prevent rendering calls that are clearly redundant from being made, but semantically one should assume that the whole world is rendered when any part of the world changes. Once the runtime\u2019s Workflow tree finishes re-rendering, the new SplitScreen is passed through the native view system like so: The Workflow root container once again passes the new SplitScreen to its Workflow container , because that is the only trick it knows. That container recognizes that SplitScreen can be accepted by the Custom split view it created last time, and so there is no work to be done. The existing Custom split view receives the new SplitScreen . Just like last time, Custom split view passes InboxScreen to the Workflow container on its left, and MessageScreen to that on its right. The left hand Workflow container sees that it is already showing a Custom inbox view and passes InboxScreen rendering through. The same things happens with MessageScreen , and the Custom message view previously built by the right hand Workflow container . As is always the case with view code, Custom inbox view and Custom message view should be written with care to avoid redundant work, comparing what they are already showing with what they are being asked to show now. (A simple way to do this is to keep a Screen type\u2019s display data in a separate object from its event handlers, as an Equatable Swift struct, or as a Kotlin data class. Always hold on to the latest Screen in a var , and write UI click handlers and to reference it.) The update scenario would be different if the types of any of the Screen Renderings changed. Suppose our email app is able to host both email and voice mail in its inbox, and that the MessageScreen from the previous update is replaced with a VoicemailScreen this time. In that case, Custom message view would refuse the new Rendering, and the right hand Workflow container that created it would destroy it. A Custom voicemail view would be created in its stead, and that new view would paint itself with the information from the VoicemailScreen . So just how do these containers know what views to create for what Screen types? Those details are very language and platform specific, and are covered in the next page, under Building views from Screens .","title":"Workflow Tree, Rendering Tree, View Tree"},{"location":"userguide/ui-concepts/#viewenvironment","text":"TK","title":"ViewEnvironment"},{"location":"userguide/ui-in-code/","text":"Coding Workflow UI \u00b6 This page translates the high level discussion of Workflow UI into Android and iOS code. Separation of Concerns \u00b6 Workflow maintains a rigid separation between its core runtime and its UI support. The Workflow Core modules are strictly Swift and Kotlin, with no dependencies on any UI framework. Dependencies on Android and iOS are restricted to the Workflow UI modules, as you would expect. This innate separation naturally puts developers on a path to avoid entangling view concerns with their app logic. And note that we say \u201capp logic\u201d rather than \u201cbusiness logic.\u201d In any interesting app, the code that manages navigation and other UI-releated behavior is likely to dwarf that for what we typically think of as model concerns, in both size and complexity. We\u2019re all pretty good at capturing business concerns in tidy object-oriented models of items for sale, shopping carts, payment cards and the like, nicely decoupled from the UI world. But the rest of the app, and in particular the bits about how our users navigate it? Traditionally it\u2019s hard to keep that app-specific logic centralized, so that you can see what\u2019s going on; and even harder to keep it decoupled from your view system, so that it\u2019s easy to test. The strict divide between Workflow UI and Workflow Core leads you to maintain that separation by accident. Bootstrapping \u00b6 The following snippets demonstrate using Workflow to drive the root views of iOS and Android apps. But really, you can host a Workflow driven UI anywhere you can show a view, whatever \u201cview\u201d means on your platform. iOS @UIApplicationMain class AppDelegate : UIResponder , UIApplicationDelegate { var window : UIWindow ? func application ( _ application : UIApplication , didFinishLaunchingWithOptions launchOptions : [ UIApplication . LaunchOptionsKey : Any ]?) -> Bool { window = UIWindow ( frame : UIScreen . main . bounds ) window ?. rootViewController = ContainerViewController ( workflow : RootWorkflow ()) window ?. makeKeyAndVisible () return true } } Android Classic Android classic makes things a little complicated (naturally), as your Workflow runtime has to survive configuration changes. Our habit is use a Jetpack ViewModel to solve that problem, on what is typically the only line of code in a Workflow app that deals with the Jetpack Lifecycle at all. HelloWorkflowActivity.kt class HelloWorkflowActivity : AppCompatActivity () { override fun onCreate ( savedInstanceState : Bundle?) { super . onCreate ( savedInstanceState ) // This ViewModel will survive configuration changes. It's instantiated // by the first call to androidx.activity.viewModels(), and that // original instance is returned by succeeding calls. val model : HelloViewModel by viewModels () setContentView ( WorkflowLayout ( this ). apply { take ( lifecycle , model . renderings ) } ) } } class HelloViewModel ( savedState : SavedStateHandle ) : ViewModel () { val renderings : StateFlow < HelloRendering > by lazy { renderWorkflowIn ( workflow = HelloWorkflow , scope = viewModelScope , savedStateHandle = savedState ) } } Android Jetpack Compose HelloComposeActivity.kt class HelloComposeActivity : AppCompatActivity () { override fun onCreate ( savedInstanceState : Bundle?) { super . onCreate ( savedInstanceState ) setContent { val rendering by HelloWorkflow . renderAsState ( props = Unit , onOutput = {}) WorkflowRendering ( rendering , ViewEnvironment . EMPTY ) } } } Android developers should note that classic and Compose bootstrapping are completely interchangeable. Each style is able to display Screens of any type, regardless of whether they are set up to inflate View instances or to run @Composeable functions. Building views from Screens \u00b6 Hello, Screen world. iOS WelcomeScreen.swift struct WelcomeScreen : Screen { var name : String var onNameChanged : ( String ) -> Void var onLoginTapped : () -> Void func viewControllerDescription ( environment : ViewEnvironment ) -> ViewControllerDescription { return WelcomeViewController . description ( for : self , environment : environment ) } } private final class WelcomeViewController : ScreenViewController < WelcomeScreen > { override func viewDidLoad () { \u2026 } override func viewDidLayoutSubviews () { \u2026 } override func screenDidChange ( from previousScreen : WelcomeScreen , previousEnvironment : ViewEnvironment ) { super . screenDidChange ( from : previousScreen , previousEnvironment : previousEnvironment ) nameField . text = screen . name } } iOS Screen classes are expected to provide matching ViewControllerDescription instances. A ViewControllerDescription can build a UIViewController on demand, or update an existing one if it\u2019s recognized by ViewControllerDescription.canUpdate(UIViewController) . These duties are all fullfilled by the provided open class ScreenViewController . It\u2019s like any other ViewController , with the addition of: an open screenDidChange() method that the Workflow UI runtime calls with a series of Screen instances of the specified type a description() class method, perfect for calling from Screen.viewcontrollerDescription() Android Classic HelloScreen.kt data class HelloScreen ( val message : String , val onClick : () -> Unit ) : AndroidScreen < HelloScreen > { override val viewFactory : ScreenViewFactory < HelloScreen > = fromViewBinding ( HelloViewBinding :: inflate ) { helloScreen , viewEnvironment -> helloMessage . text = helloScreen . message helloMessage . setOnClickListener { helloScreen . onClick () } } } The Android Screen interface is purely a marker type. It defines no Android-specific methods to ensure you have the option of keeping your app logic pure. If you don\u2019t need that rigor, life is simpler (and safer, no runtime errors) if your Screen renderings implement AndroidScreen instead. An AndroidScreen is required to provide a matching ScreenViewFactory . ScreenViewFactory returns View instances wrapped in ScreenViewHolder objects. ScreenViewHolder.show is called by the Workflow UI runtime to update the view with Screen instances that are deemed acceptible by ScreenViewHolder.canShow . In this example the fromViewBinding function creates a ScreenViewFactory that builds View instances using a Jetpack View Binding , HelloViewBinding , presumably derived from hello_view_binding.xml . The lamda argument to the fromViewBinding provides the implementation for ScreenViewHolder.show , and is guaranteed that the given helloScreen parameter is of the appropriate type. Other factory functions are provided to work with layout resources directly, or to build views entirely from code. Android Jetpack Compose HelloScreen.kt data class HelloScreen ( val message : String , val onClick : () -> Unit ) : ComposeScreen < HelloScreen > { @Composable override fun Content ( viewEnvironment : ViewEnvironment ) { Button ( onClick ) { Text ( message ) } } } Here, HelloScreen is implementing ComposeScreen . ComposeScreen extends the same AndroidScreen class used for classic Android, defining @Composable fun Content() to get its work done. Content is always called from a @Composable Box() context. It\u2019s context aware Even though AndroidScreen provides a thing called ScreenViewFactory to do its work, the factories built by ComposeScreen are able to recognize whether they\u2019re being called from a classic View or from a @Composeable function, and do the right thing. Workflow UI only creates ComposeView instances as needed: when a @Composeable needs to be shown in a View . If the factory is to be used in a @Composable context, Content() is called directly. Where is that \u201cseparation of concerns\u201d you promised? \u00b6 After all the chest-thumping above about Separation of Concerns , the code samples above probably look pretty entangled. That\u2019s because, while the Workflow libraries themselves are completely decoupled, they don\u2019t force that strict rigor on your app code. If you aren\u2019t building, say, a core Workflow module that you want to ship separately from its Android and command line interfaces, you\u2019d probably gain nothing from enforced separation but boilerplate and runtime errors. And in practice, your Workflow unit tests won\u2019t call viewFactory and will build and run just fine against the JVM. Likewise, at this point we\u2019ve been building apps this way for hundreds of engineering years, and so far no one has called viewControllerDescription() and stashed a UIViewController in their workflow state. (This is not a challenge.) If you are one of the few who truly do need impermeable boundaries between your core and UI modules, they aren\u2019t hard to get. Your Screen implementations can be defined completely separately from their view code and bound later. iOS WelcomeScreen.swift struct WelcomeScreen { var name : String var onNameChanged : ( String ) -> Void var onLoginTapped : () -> Void } WelcomeViewController.swift extension WelcomeScreen : Screen { func viewControllerDescription ( environment : ViewEnvironment ) -> ViewControllerDescription { return WelcomeViewController . description ( for : self , environment : environment ) } } private final class WelcomeViewController : ScreenViewController < WelcomeScreen > { // ... Android HelloScreen.kt data class HelloScreen ( val message : String , val onClick : () -> Unit ) : Screen HelloWorkflowGreenTheme.kt private object HelloScreenGreenThemeViewFactory : ScreenViewFactory < HelloScreen > by ScreenViewFactory . fromViewBinding ( GreenHelloViewBinding :: inflate ) { r , _ -> helloMessage . text = r . message helloMessage . setOnClickListener { r . onClick () } } } private val viewRegistry = ViewRegistry ( HelloScreenGreenThemeViewFactory ) val HelloWorkflowGreenTheme = HelloWorkflow . mapRenderings { it . withRegistry ( viewRegistry ) } Container screens make container views \u00b6 A container screen is one that is built out of other Screens. And naturally enough, the thing that a container screen drives is a container view : one that is able to host child views that are driven by Screen instances of arbitrary type. Workflow UI provides two root container views out of the box, the ContainerViewController and WorkflowLayout classes discussed above, under Bootstrapping . They do most of their work by delegating to another pair of support view classes: ScreenViewController for iOS and WorkflowViewStub for Android. Android also provides @Composable fun WorkflowRendering() for use with Jetpack Compose. For something like a SplitScreen rendering, you\u2019ll write your own view code that does the same. iOS SplitScreen.swift public struct SplitScreen < LeadingScreenType : Screen , TrailingScreenType : Screen >: Screen { public let leadingScreen : LeadingScreenType public let trailingScreen : TrailingScreenType public func viewControllerDescription ( environment : ViewEnvironment ) -> ViewControllerDescription { return SplitScreenViewController . description ( for : self , environment : environment ) } SplitScreenViewController.swift internal final class SplitScreenViewController < LeadingScreenType : Screen , TrailingScreenType : Screen >: ScreenViewController < SplitScreenViewController . ContainerScreen > { internal typealias ContainerScreen = SplitScreen < LeadingScreenType , TrailingScreenType > private var leadingContentViewController : DescribedViewController private lazy var leadingContainerView : ContainerView = . init () private lazy var separatorView : UIView = . init () private var trailingContentViewController : DescribedViewController private lazy var trailingContainerView : ContainerView = . init () required init ( screen : ContainerScreen , environment : ViewEnvironment ) { self . leadingContentViewController = DescribedViewController ( screen : screen . leadingScreen , environment : environment ) self . trailingContentViewController = DescribedViewController ( screen : screen . trailingScreen , environment : environment ) super . init ( screen : screen , environment : environment ) } override internal func screenDidChange ( from previousScreen : ContainerScreen , previousEnvironment : ViewEnvironment ) { super . screenDidChange ( from : previousScreen , previousEnvironment : previousEnvironment ) update ( with : screen ) } private func update ( with screen : ContainerScreen ) { leadingContentViewController . update ( screen : screen . leadingScreen , environment : environment ) trailingContentViewController . update ( screen : screen . trailingScreen , environment : environment ) // Intentional force of layout pass after updating the child view controllers view . layoutIfNeeded () } override internal func viewDidLoad () { /** Lay out the two children horizontally, nothing workflow specific here. */ update ( with : screen ) } override internal func viewDidLayoutSubviews () { /** Calculate the layout, nothing workflow specific here. */ } The interesting thing here is the use of DescribedViewController to display the nested leadingContent and trailingContent Screens. DescribedViewController uses Screen.viewControllerDescription to build a new UIViewController if it needs to, or update an existing one if it can. Everything else is just run of the mill iOS view code. Android Classic SplitScreen.kt data class SplitScreen < L : Screen , T : Screen > ( val leadingScreen : L , val trailingScreen : T ): AndroidScreen < SplitScreen < L , T >> { override val viewFactory : ScreenViewFactory < SplitScreen < L , T >> = fromViewBinding ( SplitScreenBinding :: inflate ) { screen , _ -> leadingStub . show ( leadingScreen ) trailingStub . show ( trailingScreen ) } } split_screen.xml <?xml version=\"1.0\" encoding=\"utf-8\"?> <LinearLayout xmlns:android= \"http://schemas.android.com/apk/res/android\" android:layout_width= \"match_parent\" android:layout_height= \"match_parent\" android:orientation= \"horizontal\" > <com.squareup.workflow1.ui.WorkflowViewStub android:id= \"@+id/leading_stub\" android:layout_width= \"0dp\" android:layout_height= \"match_parent\" android:layout_weight= \"30\" /> <View android:layout_width= \"1dp\" android:layout_height= \"match_parent\" android:background= \"@android:drawable/divider_horizontal_bright\" /> <com.squareup.workflow1.ui.WorkflowViewStub android:id= \"@+id/trailing_stub\" android:layout_width= \"0dp\" android:layout_height= \"match_parent\" android:layout_weight= \"70\" /> </LinearLayout> Android Jetpack Compose SplitScreen.kt data class SplitScreen < L : Screen , T : Screen > ( val leadingScreen : L , val trailingScreen : T ): ComposeScreen < SplitScreen < L , T >> { @Composable override fun Content ( viewEnvironment : ViewEnvironment ) { Row { WorkflowRendering ( rendering = leadingScreen , modifier = Modifier . weight ( 1 / 3f ) . fillMaxHeight () ) WorkflowRendering ( rendering = trailingScreen , modifier = Modifier . weight ( 2 / 3f ) . fillMaxHeight () ) } } }","title":"Coding Workflow UI (in progress)"},{"location":"userguide/ui-in-code/#coding-workflow-ui","text":"This page translates the high level discussion of Workflow UI into Android and iOS code.","title":"Coding Workflow UI"},{"location":"userguide/ui-in-code/#separation-of-concerns","text":"Workflow maintains a rigid separation between its core runtime and its UI support. The Workflow Core modules are strictly Swift and Kotlin, with no dependencies on any UI framework. Dependencies on Android and iOS are restricted to the Workflow UI modules, as you would expect. This innate separation naturally puts developers on a path to avoid entangling view concerns with their app logic. And note that we say \u201capp logic\u201d rather than \u201cbusiness logic.\u201d In any interesting app, the code that manages navigation and other UI-releated behavior is likely to dwarf that for what we typically think of as model concerns, in both size and complexity. We\u2019re all pretty good at capturing business concerns in tidy object-oriented models of items for sale, shopping carts, payment cards and the like, nicely decoupled from the UI world. But the rest of the app, and in particular the bits about how our users navigate it? Traditionally it\u2019s hard to keep that app-specific logic centralized, so that you can see what\u2019s going on; and even harder to keep it decoupled from your view system, so that it\u2019s easy to test. The strict divide between Workflow UI and Workflow Core leads you to maintain that separation by accident.","title":"Separation of Concerns"},{"location":"userguide/ui-in-code/#bootstrapping","text":"The following snippets demonstrate using Workflow to drive the root views of iOS and Android apps. But really, you can host a Workflow driven UI anywhere you can show a view, whatever \u201cview\u201d means on your platform. iOS @UIApplicationMain class AppDelegate : UIResponder , UIApplicationDelegate { var window : UIWindow ? func application ( _ application : UIApplication , didFinishLaunchingWithOptions launchOptions : [ UIApplication . LaunchOptionsKey : Any ]?) -> Bool { window = UIWindow ( frame : UIScreen . main . bounds ) window ?. rootViewController = ContainerViewController ( workflow : RootWorkflow ()) window ?. makeKeyAndVisible () return true } } Android Classic Android classic makes things a little complicated (naturally), as your Workflow runtime has to survive configuration changes. Our habit is use a Jetpack ViewModel to solve that problem, on what is typically the only line of code in a Workflow app that deals with the Jetpack Lifecycle at all. HelloWorkflowActivity.kt class HelloWorkflowActivity : AppCompatActivity () { override fun onCreate ( savedInstanceState : Bundle?) { super . onCreate ( savedInstanceState ) // This ViewModel will survive configuration changes. It's instantiated // by the first call to androidx.activity.viewModels(), and that // original instance is returned by succeeding calls. val model : HelloViewModel by viewModels () setContentView ( WorkflowLayout ( this ). apply { take ( lifecycle , model . renderings ) } ) } } class HelloViewModel ( savedState : SavedStateHandle ) : ViewModel () { val renderings : StateFlow < HelloRendering > by lazy { renderWorkflowIn ( workflow = HelloWorkflow , scope = viewModelScope , savedStateHandle = savedState ) } } Android Jetpack Compose HelloComposeActivity.kt class HelloComposeActivity : AppCompatActivity () { override fun onCreate ( savedInstanceState : Bundle?) { super . onCreate ( savedInstanceState ) setContent { val rendering by HelloWorkflow . renderAsState ( props = Unit , onOutput = {}) WorkflowRendering ( rendering , ViewEnvironment . EMPTY ) } } } Android developers should note that classic and Compose bootstrapping are completely interchangeable. Each style is able to display Screens of any type, regardless of whether they are set up to inflate View instances or to run @Composeable functions.","title":"Bootstrapping"},{"location":"userguide/ui-in-code/#building-views-from-screens","text":"Hello, Screen world. iOS WelcomeScreen.swift struct WelcomeScreen : Screen { var name : String var onNameChanged : ( String ) -> Void var onLoginTapped : () -> Void func viewControllerDescription ( environment : ViewEnvironment ) -> ViewControllerDescription { return WelcomeViewController . description ( for : self , environment : environment ) } } private final class WelcomeViewController : ScreenViewController < WelcomeScreen > { override func viewDidLoad () { \u2026 } override func viewDidLayoutSubviews () { \u2026 } override func screenDidChange ( from previousScreen : WelcomeScreen , previousEnvironment : ViewEnvironment ) { super . screenDidChange ( from : previousScreen , previousEnvironment : previousEnvironment ) nameField . text = screen . name } } iOS Screen classes are expected to provide matching ViewControllerDescription instances. A ViewControllerDescription can build a UIViewController on demand, or update an existing one if it\u2019s recognized by ViewControllerDescription.canUpdate(UIViewController) . These duties are all fullfilled by the provided open class ScreenViewController . It\u2019s like any other ViewController , with the addition of: an open screenDidChange() method that the Workflow UI runtime calls with a series of Screen instances of the specified type a description() class method, perfect for calling from Screen.viewcontrollerDescription() Android Classic HelloScreen.kt data class HelloScreen ( val message : String , val onClick : () -> Unit ) : AndroidScreen < HelloScreen > { override val viewFactory : ScreenViewFactory < HelloScreen > = fromViewBinding ( HelloViewBinding :: inflate ) { helloScreen , viewEnvironment -> helloMessage . text = helloScreen . message helloMessage . setOnClickListener { helloScreen . onClick () } } } The Android Screen interface is purely a marker type. It defines no Android-specific methods to ensure you have the option of keeping your app logic pure. If you don\u2019t need that rigor, life is simpler (and safer, no runtime errors) if your Screen renderings implement AndroidScreen instead. An AndroidScreen is required to provide a matching ScreenViewFactory . ScreenViewFactory returns View instances wrapped in ScreenViewHolder objects. ScreenViewHolder.show is called by the Workflow UI runtime to update the view with Screen instances that are deemed acceptible by ScreenViewHolder.canShow . In this example the fromViewBinding function creates a ScreenViewFactory that builds View instances using a Jetpack View Binding , HelloViewBinding , presumably derived from hello_view_binding.xml . The lamda argument to the fromViewBinding provides the implementation for ScreenViewHolder.show , and is guaranteed that the given helloScreen parameter is of the appropriate type. Other factory functions are provided to work with layout resources directly, or to build views entirely from code. Android Jetpack Compose HelloScreen.kt data class HelloScreen ( val message : String , val onClick : () -> Unit ) : ComposeScreen < HelloScreen > { @Composable override fun Content ( viewEnvironment : ViewEnvironment ) { Button ( onClick ) { Text ( message ) } } } Here, HelloScreen is implementing ComposeScreen . ComposeScreen extends the same AndroidScreen class used for classic Android, defining @Composable fun Content() to get its work done. Content is always called from a @Composable Box() context. It\u2019s context aware Even though AndroidScreen provides a thing called ScreenViewFactory to do its work, the factories built by ComposeScreen are able to recognize whether they\u2019re being called from a classic View or from a @Composeable function, and do the right thing. Workflow UI only creates ComposeView instances as needed: when a @Composeable needs to be shown in a View . If the factory is to be used in a @Composable context, Content() is called directly.","title":"Building views from Screens"},{"location":"userguide/ui-in-code/#where-is-that-separation-of-concerns-you-promised","text":"After all the chest-thumping above about Separation of Concerns , the code samples above probably look pretty entangled. That\u2019s because, while the Workflow libraries themselves are completely decoupled, they don\u2019t force that strict rigor on your app code. If you aren\u2019t building, say, a core Workflow module that you want to ship separately from its Android and command line interfaces, you\u2019d probably gain nothing from enforced separation but boilerplate and runtime errors. And in practice, your Workflow unit tests won\u2019t call viewFactory and will build and run just fine against the JVM. Likewise, at this point we\u2019ve been building apps this way for hundreds of engineering years, and so far no one has called viewControllerDescription() and stashed a UIViewController in their workflow state. (This is not a challenge.) If you are one of the few who truly do need impermeable boundaries between your core and UI modules, they aren\u2019t hard to get. Your Screen implementations can be defined completely separately from their view code and bound later. iOS WelcomeScreen.swift struct WelcomeScreen { var name : String var onNameChanged : ( String ) -> Void var onLoginTapped : () -> Void } WelcomeViewController.swift extension WelcomeScreen : Screen { func viewControllerDescription ( environment : ViewEnvironment ) -> ViewControllerDescription { return WelcomeViewController . description ( for : self , environment : environment ) } } private final class WelcomeViewController : ScreenViewController < WelcomeScreen > { // ... Android HelloScreen.kt data class HelloScreen ( val message : String , val onClick : () -> Unit ) : Screen HelloWorkflowGreenTheme.kt private object HelloScreenGreenThemeViewFactory : ScreenViewFactory < HelloScreen > by ScreenViewFactory . fromViewBinding ( GreenHelloViewBinding :: inflate ) { r , _ -> helloMessage . text = r . message helloMessage . setOnClickListener { r . onClick () } } } private val viewRegistry = ViewRegistry ( HelloScreenGreenThemeViewFactory ) val HelloWorkflowGreenTheme = HelloWorkflow . mapRenderings { it . withRegistry ( viewRegistry ) }","title":"Where is that \"separation of concerns\" you promised?"},{"location":"userguide/ui-in-code/#container-screens-make-container-views","text":"A container screen is one that is built out of other Screens. And naturally enough, the thing that a container screen drives is a container view : one that is able to host child views that are driven by Screen instances of arbitrary type. Workflow UI provides two root container views out of the box, the ContainerViewController and WorkflowLayout classes discussed above, under Bootstrapping . They do most of their work by delegating to another pair of support view classes: ScreenViewController for iOS and WorkflowViewStub for Android. Android also provides @Composable fun WorkflowRendering() for use with Jetpack Compose. For something like a SplitScreen rendering, you\u2019ll write your own view code that does the same. iOS SplitScreen.swift public struct SplitScreen < LeadingScreenType : Screen , TrailingScreenType : Screen >: Screen { public let leadingScreen : LeadingScreenType public let trailingScreen : TrailingScreenType public func viewControllerDescription ( environment : ViewEnvironment ) -> ViewControllerDescription { return SplitScreenViewController . description ( for : self , environment : environment ) } SplitScreenViewController.swift internal final class SplitScreenViewController < LeadingScreenType : Screen , TrailingScreenType : Screen >: ScreenViewController < SplitScreenViewController . ContainerScreen > { internal typealias ContainerScreen = SplitScreen < LeadingScreenType , TrailingScreenType > private var leadingContentViewController : DescribedViewController private lazy var leadingContainerView : ContainerView = . init () private lazy var separatorView : UIView = . init () private var trailingContentViewController : DescribedViewController private lazy var trailingContainerView : ContainerView = . init () required init ( screen : ContainerScreen , environment : ViewEnvironment ) { self . leadingContentViewController = DescribedViewController ( screen : screen . leadingScreen , environment : environment ) self . trailingContentViewController = DescribedViewController ( screen : screen . trailingScreen , environment : environment ) super . init ( screen : screen , environment : environment ) } override internal func screenDidChange ( from previousScreen : ContainerScreen , previousEnvironment : ViewEnvironment ) { super . screenDidChange ( from : previousScreen , previousEnvironment : previousEnvironment ) update ( with : screen ) } private func update ( with screen : ContainerScreen ) { leadingContentViewController . update ( screen : screen . leadingScreen , environment : environment ) trailingContentViewController . update ( screen : screen . trailingScreen , environment : environment ) // Intentional force of layout pass after updating the child view controllers view . layoutIfNeeded () } override internal func viewDidLoad () { /** Lay out the two children horizontally, nothing workflow specific here. */ update ( with : screen ) } override internal func viewDidLayoutSubviews () { /** Calculate the layout, nothing workflow specific here. */ } The interesting thing here is the use of DescribedViewController to display the nested leadingContent and trailingContent Screens. DescribedViewController uses Screen.viewControllerDescription to build a new UIViewController if it needs to, or update an existing one if it can. Everything else is just run of the mill iOS view code. Android Classic SplitScreen.kt data class SplitScreen < L : Screen , T : Screen > ( val leadingScreen : L , val trailingScreen : T ): AndroidScreen < SplitScreen < L , T >> { override val viewFactory : ScreenViewFactory < SplitScreen < L , T >> = fromViewBinding ( SplitScreenBinding :: inflate ) { screen , _ -> leadingStub . show ( leadingScreen ) trailingStub . show ( trailingScreen ) } } split_screen.xml <?xml version=\"1.0\" encoding=\"utf-8\"?> <LinearLayout xmlns:android= \"http://schemas.android.com/apk/res/android\" android:layout_width= \"match_parent\" android:layout_height= \"match_parent\" android:orientation= \"horizontal\" > <com.squareup.workflow1.ui.WorkflowViewStub android:id= \"@+id/leading_stub\" android:layout_width= \"0dp\" android:layout_height= \"match_parent\" android:layout_weight= \"30\" /> <View android:layout_width= \"1dp\" android:layout_height= \"match_parent\" android:background= \"@android:drawable/divider_horizontal_bright\" /> <com.squareup.workflow1.ui.WorkflowViewStub android:id= \"@+id/trailing_stub\" android:layout_width= \"0dp\" android:layout_height= \"match_parent\" android:layout_weight= \"70\" /> </LinearLayout> Android Jetpack Compose SplitScreen.kt data class SplitScreen < L : Screen , T : Screen > ( val leadingScreen : L , val trailingScreen : T ): ComposeScreen < SplitScreen < L , T >> { @Composable override fun Content ( viewEnvironment : ViewEnvironment ) { Row { WorkflowRendering ( rendering = leadingScreen , modifier = Modifier . weight ( 1 / 3f ) . fillMaxHeight () ) WorkflowRendering ( rendering = trailingScreen , modifier = Modifier . weight ( 2 / 3f ) . fillMaxHeight () ) } } }","title":"Container screens make container views"},{"location":"userguide/whyworkflow/","text":"Why Workflow? \u00b6 So you want me to take the application feature I have to develop and break it down into separate components? And then enumerate every possible state for each of those components? As well as writing classes or structs that represent each of these states in addition to the collection of objects that each component might pass to another? That sounds like a lot of work just to help the seller order a set of gift cards! Why make something simple so complicated? Why should I use Workflow? I think even those of us who use Workflow all the time end up asking this question. It\u2019s a very reasonable question that we try to answer here. At the heart of the matter, there are two complementary justifications for Workflow, which we will expand on below: Software clarity, correctness, and testability (especially at scale). Encouraging programming paradigms that are best practices for the mobile domain. Software clarity, correctness, and testability (at scale) \u00b6 I like to think that most of us have been there: It\u2019s our second straight day staring at the logs from over 200 customers. We know what the problem is : the user gets to screen Y and object foo\u2019s state is bar, but foo should not be bar while in screen Y. Why is foo bar? Unfortunately we don\u2019t have any debug log for foo\u2019s state at the time we start screen Y. We only have one when the user tries to click on button Z, and at that point the state is already bar even though it should only ever be baz or buz. What happened? How did foo get to state bar on screen Y? Looking at the code, foo is shared state with 15 other screens, and it is mutable in all of them. The logic to update foo\u2019s state in screen Y happens in code that is coupled to interaction with button Z, so we cannot simply add a unit test for this, we need a complex UI test to reproduce screen Y. We don\u2019t know how the problem happened and it almost seems like we can\u2019t know how without significant effort! The story above is a little dramatic but I hope the feeling it invokes is familiar. It is a daunting task to reason through application code and build up a sufficient mental model of all possible side effects in any one feature area. Now scale up the numbers a bit \u2014 foo is shared by 150 other screens \u2014 and the once daunting task seems almost impossible. All mobile developers face some form of the above problem, and at Square within our Point of Sale applications we face the scaled up version every day. What do we want? \u00b6 Clear boundaries between each feature\u2019s software components that can be instrumented with logs and that have contracts that can be tested. Clear expectations for outcomes within a particular feature\u2019s software component that can be verified for correctness with tests. Immutable State within any particular scope (e.g. Screen Y in the context above) so that the code handling mutations to provide a new State as a result of some event is in a \u201cprotected area\u201d that can be instrumented and tested. A clear separation of the State updates from the presentation of the UI. We want the conditions above because we want: Not to have bugs like the one we started this discussion with. In other words, we want our tests to give us confidence in our application logic. In the inevitable case that we do have a bug, we want to be able to isolate the scenario, reproduce the exact conditions, fix the bug and write a test so that it doesn\u2019t happen again. Workflow facilitates these goals for native mobile applications by providing a pattern (and a supporting application Runtime) similar to React, Elm, or any number of other web application JavaScript frameworks (not to mention forthcoming native mobile frameworks such as Jetpack Compose and SwiftUI). Each logical component area is separated into a Workflow with a finite set of states and the logic to transition between them. Workflows can be composed together for a full feature with each Workflow\u2019s signature specifying a clear contract. The Workflow Runtime\u2019s event loop handles the production of new immutable states for each Workflow so that within the Workflow render logic it is immutable. Workflows can be executed and instrumented in a testable way with extra hooks for simple verification of outcomes in unit tests. On an even simpler level Workflow improves clarity by giving a large team of developers a shared idiom of software components with which to discuss business logic across feature areas, and across mobile platforms (Android, iOS). Further, as the application is composed with multiple Workflows, the framework enables loose coupling between features to focus the impact of code changes. Encouraging programming paradigms that are best practices for the mobile domain \u00b6 Mobile applications receive and display a lot of data! Our applications at Square certainly do. As a result of this, there is a growing trend towards reactive programming for mobile applications. In this paradigm, the application logic subscribes to a stream of data which is then pushed to the logic rather than having to be periodically pulled and operated on. This has the profound effect of ensuring that the data shown to the application user is never stale. This style of programming also makes clear that most mobile applications are a series of mapping operations on a stream of data that is eventually mapped into some UI. Another mobile programming best practice (arising out of a long tradition) is to favor declarative programming over imperative programming . With this style choice, the code for a feature declares what should be occurring for a particular state, rather than consisting of a series of statements that are essentially how to make that occur. This is a best practice because when a program\u2019s logic is defined in this way, it is very simple to test (so more likely to be tested!): \u201cFor state Y we expect Rendering Z;\u201d \u201cFrom state Y given input A we expect Rendering Z+.\u201d Possibly more important, it is easier to read, comprehend quickly, and to reason about than a series of complex commands for the computer. Workflows encourage a declarative style because each state of a particular component must be enumerated and then the Rendering (representation that gets passed to the UI framework) is declared for that particular state, alongside a declaration of what children and side effects should be running in that state. The well-tested and reliable Workflow runtime loop itself handles how to start and stop the children and side effects, reducing resource leaks. By requiring these formal definitions of each State, Rendering, and the Actions that will change the current state, Workflow naturally encourages declarative programming. While reactive and declarative programming may be current best practices, there is one Software Engineering principle that has proven over and over again to be the most universal and the most important for systems of scale: Separation of Concerns . Any system of scale requires multiple separate components that can be worked on, tested, improved, and refactored independently by multiple teams of people. A system of multiple components requires communication and any good communication begs explicit structure and contracts. For mobile applications at Square we have settled on the Model-View-ViewModel (MVVM) architecture as the structure for the topical separation of concerns of the layers of the application. MVVM\u2019s unidirectional layered communication is the same as that of Model-View-Presenter (MVP), as opposed to the \u2018circular\u2019 communication of Model-View-Controller (MVC). MVVM\u2019s use of a strict binding between the ViewModel and the View is the same as MVC, as opposed to the imperative interpretation of the Model in MVP. MVVM provides the reasoning and comprehension benefits of unidirectional data flow while also eliminating as much business logic as possible from the view layer and encouraging declarative ViewModels. At Square this works well because we have UI design frameworks that change infrequently (so keeping bindings up-to-date is not much overhead), but business logic that is constantly being updated (so emphasizing low coupling is important). Workflows embrace MVVM because the Rendering produced by a Workflow tree is the ViewModel, which can then be bound to any native mobile UI framework. For feature based separation of concerns we lean on Workflow\u2019s facility for composition at scale via strong parent-child contracts and a hierarchical tree organization. While building a Hello World Workflow may seem like overkill (although it\u2019s really not that bad!), the explicitness and contracts that Workflows require of the developer lay the structure for good communication. The composability of Workflows encourages reuse and encourages separation of concerns into the most appropriate reusable components. There are even more platform-specific best practices that Workflow dovetails well with, such as structured concurrency with Kotlin coroutines, as each Worker or side effect can define a specific coroutine scope for the operations. What about the next 10 years? Jetpack Compose UI and SwiftUI are establishing themselves as the native mobile UI toolkits of the future. They both embrace the same MVVM approach that Workflow does, and encourage thinking about the \u201ccomposability\u201d of separate components of your application. With this resonance, Workflows help you to prepare your mental model to adapt to these new UI toolkits, and shapes our codebase in a way that will ease our adoption of them. To learn more about Compose and Workflow see this post .","title":"Why Workflow?"},{"location":"userguide/whyworkflow/#why-workflow","text":"So you want me to take the application feature I have to develop and break it down into separate components? And then enumerate every possible state for each of those components? As well as writing classes or structs that represent each of these states in addition to the collection of objects that each component might pass to another? That sounds like a lot of work just to help the seller order a set of gift cards! Why make something simple so complicated? Why should I use Workflow? I think even those of us who use Workflow all the time end up asking this question. It\u2019s a very reasonable question that we try to answer here. At the heart of the matter, there are two complementary justifications for Workflow, which we will expand on below: Software clarity, correctness, and testability (especially at scale). Encouraging programming paradigms that are best practices for the mobile domain.","title":"Why Workflow?"},{"location":"userguide/whyworkflow/#software-clarity-correctness-and-testability-at-scale","text":"I like to think that most of us have been there: It\u2019s our second straight day staring at the logs from over 200 customers. We know what the problem is : the user gets to screen Y and object foo\u2019s state is bar, but foo should not be bar while in screen Y. Why is foo bar? Unfortunately we don\u2019t have any debug log for foo\u2019s state at the time we start screen Y. We only have one when the user tries to click on button Z, and at that point the state is already bar even though it should only ever be baz or buz. What happened? How did foo get to state bar on screen Y? Looking at the code, foo is shared state with 15 other screens, and it is mutable in all of them. The logic to update foo\u2019s state in screen Y happens in code that is coupled to interaction with button Z, so we cannot simply add a unit test for this, we need a complex UI test to reproduce screen Y. We don\u2019t know how the problem happened and it almost seems like we can\u2019t know how without significant effort! The story above is a little dramatic but I hope the feeling it invokes is familiar. It is a daunting task to reason through application code and build up a sufficient mental model of all possible side effects in any one feature area. Now scale up the numbers a bit \u2014 foo is shared by 150 other screens \u2014 and the once daunting task seems almost impossible. All mobile developers face some form of the above problem, and at Square within our Point of Sale applications we face the scaled up version every day.","title":"Software clarity, correctness, and testability (at scale)"},{"location":"userguide/whyworkflow/#what-do-we-want","text":"Clear boundaries between each feature\u2019s software components that can be instrumented with logs and that have contracts that can be tested. Clear expectations for outcomes within a particular feature\u2019s software component that can be verified for correctness with tests. Immutable State within any particular scope (e.g. Screen Y in the context above) so that the code handling mutations to provide a new State as a result of some event is in a \u201cprotected area\u201d that can be instrumented and tested. A clear separation of the State updates from the presentation of the UI. We want the conditions above because we want: Not to have bugs like the one we started this discussion with. In other words, we want our tests to give us confidence in our application logic. In the inevitable case that we do have a bug, we want to be able to isolate the scenario, reproduce the exact conditions, fix the bug and write a test so that it doesn\u2019t happen again. Workflow facilitates these goals for native mobile applications by providing a pattern (and a supporting application Runtime) similar to React, Elm, or any number of other web application JavaScript frameworks (not to mention forthcoming native mobile frameworks such as Jetpack Compose and SwiftUI). Each logical component area is separated into a Workflow with a finite set of states and the logic to transition between them. Workflows can be composed together for a full feature with each Workflow\u2019s signature specifying a clear contract. The Workflow Runtime\u2019s event loop handles the production of new immutable states for each Workflow so that within the Workflow render logic it is immutable. Workflows can be executed and instrumented in a testable way with extra hooks for simple verification of outcomes in unit tests. On an even simpler level Workflow improves clarity by giving a large team of developers a shared idiom of software components with which to discuss business logic across feature areas, and across mobile platforms (Android, iOS). Further, as the application is composed with multiple Workflows, the framework enables loose coupling between features to focus the impact of code changes.","title":"What do we want?"},{"location":"userguide/whyworkflow/#encouraging-programming-paradigms-that-are-best-practices-for-the-mobile-domain","text":"Mobile applications receive and display a lot of data! Our applications at Square certainly do. As a result of this, there is a growing trend towards reactive programming for mobile applications. In this paradigm, the application logic subscribes to a stream of data which is then pushed to the logic rather than having to be periodically pulled and operated on. This has the profound effect of ensuring that the data shown to the application user is never stale. This style of programming also makes clear that most mobile applications are a series of mapping operations on a stream of data that is eventually mapped into some UI. Another mobile programming best practice (arising out of a long tradition) is to favor declarative programming over imperative programming . With this style choice, the code for a feature declares what should be occurring for a particular state, rather than consisting of a series of statements that are essentially how to make that occur. This is a best practice because when a program\u2019s logic is defined in this way, it is very simple to test (so more likely to be tested!): \u201cFor state Y we expect Rendering Z;\u201d \u201cFrom state Y given input A we expect Rendering Z+.\u201d Possibly more important, it is easier to read, comprehend quickly, and to reason about than a series of complex commands for the computer. Workflows encourage a declarative style because each state of a particular component must be enumerated and then the Rendering (representation that gets passed to the UI framework) is declared for that particular state, alongside a declaration of what children and side effects should be running in that state. The well-tested and reliable Workflow runtime loop itself handles how to start and stop the children and side effects, reducing resource leaks. By requiring these formal definitions of each State, Rendering, and the Actions that will change the current state, Workflow naturally encourages declarative programming. While reactive and declarative programming may be current best practices, there is one Software Engineering principle that has proven over and over again to be the most universal and the most important for systems of scale: Separation of Concerns . Any system of scale requires multiple separate components that can be worked on, tested, improved, and refactored independently by multiple teams of people. A system of multiple components requires communication and any good communication begs explicit structure and contracts. For mobile applications at Square we have settled on the Model-View-ViewModel (MVVM) architecture as the structure for the topical separation of concerns of the layers of the application. MVVM\u2019s unidirectional layered communication is the same as that of Model-View-Presenter (MVP), as opposed to the \u2018circular\u2019 communication of Model-View-Controller (MVC). MVVM\u2019s use of a strict binding between the ViewModel and the View is the same as MVC, as opposed to the imperative interpretation of the Model in MVP. MVVM provides the reasoning and comprehension benefits of unidirectional data flow while also eliminating as much business logic as possible from the view layer and encouraging declarative ViewModels. At Square this works well because we have UI design frameworks that change infrequently (so keeping bindings up-to-date is not much overhead), but business logic that is constantly being updated (so emphasizing low coupling is important). Workflows embrace MVVM because the Rendering produced by a Workflow tree is the ViewModel, which can then be bound to any native mobile UI framework. For feature based separation of concerns we lean on Workflow\u2019s facility for composition at scale via strong parent-child contracts and a hierarchical tree organization. While building a Hello World Workflow may seem like overkill (although it\u2019s really not that bad!), the explicitness and contracts that Workflows require of the developer lay the structure for good communication. The composability of Workflows encourages reuse and encourages separation of concerns into the most appropriate reusable components. There are even more platform-specific best practices that Workflow dovetails well with, such as structured concurrency with Kotlin coroutines, as each Worker or side effect can define a specific coroutine scope for the operations. What about the next 10 years? Jetpack Compose UI and SwiftUI are establishing themselves as the native mobile UI toolkits of the future. They both embrace the same MVVM approach that Workflow does, and encourage thinking about the \u201ccomposability\u201d of separate components of your application. With this resonance, Workflows help you to prepare your mental model to adapt to these new UI toolkits, and shapes our codebase in a way that will ease our adoption of them. To learn more about Compose and Workflow see this post .","title":"Encouraging programming paradigms that are best practices for the mobile domain"},{"location":"userguide/worker-in-code/","text":"Coding a Worker \u00b6 Worker is a protocol (in Swift) and interface (in Kotlin) that defines an asynchronous task that can be performed by a Workflow . Worker s only emit outputs, they do not have a Rendering type. They are similar to child workflows with Void / Unit rendering types. A workflow can ask the infrastructure to await the result of a worker by passing that worker to the RenderContext.runningWorker method within a call to the render method. A workflow can handle outputs from a Worker . Workers provide a declarative window into the imperative world \u00b6 As nice as it is to write declarative code, real apps need to interact with imperative APIs. Workers allow wrapping imperative APIs so that Workflows can interact with them in a declarative fashion. Instead of making imperative \u201cstart this, do that, now stop\u201d calls, a Workflow can say \u201cI declare that this task should now be running\u201d and let the infrastructure worry about ensuring the task is actually started when necessary, continues running if it was already in flight, and torn down when it\u2019s not needed anymore. Workers can perform side effects \u00b6 Unlike workflows\u2019 render method, which can be called many times and must be idempotent, workers are started and then ran until completion (or cancellation) \u2013 independently of how many times the workflow running them is actually rendered. This means that side effects that should be performed only once when a workflow enters a particular state, for example, should be placed into a Worker that the workflow runs while in that state. Workers are cold reactive streams \u00b6 Workers are effectively simple wrappers around asynchronous streams with explicit equivalence. In Swift, workers are backed by ReactiveSwift SignalProducer s . In Kotlin, they\u2019re backed by Kotlin Flow s . They are also easily derived from Reactive Streams Publishers , including RxJava Observable , Flowable , or Single instances. Worker subscriptions are managed automatically \u00b6 While Workers are backed by reactive streams with library-specific subscription APIs, you never actually subscribe directly to a worker yourself. Instead, a Workflow asks the infrastructure to run a worker, and the infrastructure will take care of initializing and tearing down the subscription as appropriate \u2013 much like how child workflows\u2019 lifetimes are automatically managed by the runtime. This makes it impossible to accidentally leak a subscription to a worker. Workers manage their own internal state \u00b6 Unlike Workflows, which are effectively collections of functions defining state transitions, Workers represent long-running tasks. For example, Workers commonly execute network requests. The worker\u2019s stream will open a socket and, either blocking on a background thread or asynchronously, read from that socket and eventually emit data to the workflow that is running it. Workers define their own equivalence \u00b6 Since Workers represent ongoing tasks, the infrastructure needs to be able to tell when two workers represent the same task (so it doesn\u2019t perform the task twice), or when a worker has changed between render passes such that it needs to be torn down and re-started for the new work. For these reasons, any time a workflow requests that a worker be run in sequential render passes, it is asked to compare itself with its last instance and determine if they are equivalent. In Swift, this is determined by the Worker isEquivalent:to: method. Worker s that conform to Equatable will automatically get an isEquivalent:to: method based on the Equatable implementation. In Kotlin, the Worker interface defines the doesSameWorkAs method which is passed the previous worker. Kotlin: Why don\u2019t Workers use equals ? Worker equivalence is a key part of the Worker API. The default implementation of equals , which just compares object identity, is almost always incorrect for workers. Defining a separate method forces implementers to think about how equivalence is defined. Workers are lifecycle-aware \u00b6 Workers are aware of when they\u2019re started (just like Workflows), but they are also aware of when they are torn down. This makes them handy for managing resources as well.","title":"Coding a Worker (stale)"},{"location":"userguide/worker-in-code/#coding-a-worker","text":"Worker is a protocol (in Swift) and interface (in Kotlin) that defines an asynchronous task that can be performed by a Workflow . Worker s only emit outputs, they do not have a Rendering type. They are similar to child workflows with Void / Unit rendering types. A workflow can ask the infrastructure to await the result of a worker by passing that worker to the RenderContext.runningWorker method within a call to the render method. A workflow can handle outputs from a Worker .","title":"Coding a Worker"},{"location":"userguide/worker-in-code/#workers-provide-a-declarative-window-into-the-imperative-world","text":"As nice as it is to write declarative code, real apps need to interact with imperative APIs. Workers allow wrapping imperative APIs so that Workflows can interact with them in a declarative fashion. Instead of making imperative \u201cstart this, do that, now stop\u201d calls, a Workflow can say \u201cI declare that this task should now be running\u201d and let the infrastructure worry about ensuring the task is actually started when necessary, continues running if it was already in flight, and torn down when it\u2019s not needed anymore.","title":"Workers provide a declarative window into the imperative world"},{"location":"userguide/worker-in-code/#workers-can-perform-side-effects","text":"Unlike workflows\u2019 render method, which can be called many times and must be idempotent, workers are started and then ran until completion (or cancellation) \u2013 independently of how many times the workflow running them is actually rendered. This means that side effects that should be performed only once when a workflow enters a particular state, for example, should be placed into a Worker that the workflow runs while in that state.","title":"Workers can perform side effects"},{"location":"userguide/worker-in-code/#workers-are-cold-reactive-streams","text":"Workers are effectively simple wrappers around asynchronous streams with explicit equivalence. In Swift, workers are backed by ReactiveSwift SignalProducer s . In Kotlin, they\u2019re backed by Kotlin Flow s . They are also easily derived from Reactive Streams Publishers , including RxJava Observable , Flowable , or Single instances.","title":"Workers are cold reactive streams"},{"location":"userguide/worker-in-code/#worker-subscriptions-are-managed-automatically","text":"While Workers are backed by reactive streams with library-specific subscription APIs, you never actually subscribe directly to a worker yourself. Instead, a Workflow asks the infrastructure to run a worker, and the infrastructure will take care of initializing and tearing down the subscription as appropriate \u2013 much like how child workflows\u2019 lifetimes are automatically managed by the runtime. This makes it impossible to accidentally leak a subscription to a worker.","title":"Worker subscriptions are managed automatically"},{"location":"userguide/worker-in-code/#workers-manage-their-own-internal-state","text":"Unlike Workflows, which are effectively collections of functions defining state transitions, Workers represent long-running tasks. For example, Workers commonly execute network requests. The worker\u2019s stream will open a socket and, either blocking on a background thread or asynchronously, read from that socket and eventually emit data to the workflow that is running it.","title":"Workers manage their own internal state"},{"location":"userguide/worker-in-code/#workers-define-their-own-equivalence","text":"Since Workers represent ongoing tasks, the infrastructure needs to be able to tell when two workers represent the same task (so it doesn\u2019t perform the task twice), or when a worker has changed between render passes such that it needs to be torn down and re-started for the new work. For these reasons, any time a workflow requests that a worker be run in sequential render passes, it is asked to compare itself with its last instance and determine if they are equivalent. In Swift, this is determined by the Worker isEquivalent:to: method. Worker s that conform to Equatable will automatically get an isEquivalent:to: method based on the Equatable implementation. In Kotlin, the Worker interface defines the doesSameWorkAs method which is passed the previous worker. Kotlin: Why don\u2019t Workers use equals ? Worker equivalence is a key part of the Worker API. The default implementation of equals , which just compares object identity, is almost always incorrect for workers. Defining a separate method forces implementers to think about how equivalence is defined.","title":"Workers define their own equivalence"},{"location":"userguide/worker-in-code/#workers-are-lifecycle-aware","text":"Workers are aware of when they\u2019re started (just like Workflows), but they are also aware of when they are torn down. This makes them handy for managing resources as well.","title":"Workers are lifecycle-aware"},{"location":"userguide/workflow-in-code/","text":"Coding a Workflow \u00b6 In code, Workflow is a Swift protocol or Kotlin interface with State, Rendering and Output parameter types. The Kotlin interface also defines a Props type. In Swift, props are implicit as properties of the struct implementing Workflow. Swift public protocol Workflow : AnyWorkflowConvertible { associatedtype State associatedtype Output = Never associatedtype Rendering func makeInitialState () -> State func workflowDidChange ( from previousWorkflow : Self , state : inout State ) func render ( state : State , context : RenderContext < Self >) -> Rendering } Kotlin abstract class StatefulWorkflow < in PropsT , StateT , out OutputT : Any , out RenderingT > : Workflow < PropsT , OutputT , RenderingT > { abstract fun initialState ( props : PropsT , initialSnapshot : Snapshot? ): StateT open fun onPropsChanged ( old : PropsT , new : PropsT , state : StateT ): StateT = state abstract fun render ( props : PropsT , state : StateT , context : RenderContext < StateT , OutputT > ): RenderingT abstract fun snapshotState ( state : StateT ): Snapshot } Swift: What is AnyWorkflowConvertible ? When a protocol has an associated Self type, Swift requires the use of a type-erasing wrapper to store references to instances of that protocol. AnyWorkflow is such a wrapper for Workflow . AnyWorkflowConvertible is a protocol with a single method that returns an AnyWorkflow . It is useful as a base type because it allows instances of Workflow to be used directly by any code that requires the type-erased AnyWorkflow . Kotlin: StatefulWorkflow vs Workflow It is a common practice in Kotlin to divide types into two parts: an interface for public API, and a class for private implementation. The Workflow library defines a Workflow interface, which should be used as the type of properties and parameters by code that needs to refer to a particular Workflow interface. The Workflow interface contains a single method, which simply returns a StatefulWorkflow \u2013 a Workflow can be described as \u201canything that can be expressed as a StatefulWorkflow .\u201d The library also defines two abstract classes which define the contract for workflows and should be subclassed to implement your workflows: StatefulWorkflow should be subclassed to implement Workflows that have private state . StatelessWorkflow should be subclassed to implement Workflows that don\u2019t have any private state. See Stateless Workflows . Workflows have several responsibilities: Workflows have state \u00b6 Once a Workflow has been started, it always operates in the context of some state. This state is divided into two parts: private state, which only the Workflow implementation itself knows about, which is defined by the State type, and properties (or \u201cprops\u201d), which is passed to the Workflow from its parent (more on hierarchical workflows below). Private state \u00b6 Every Workflow implementation defines a State type to maintain any necessary state while the workflow is running. For example, a tic-tac-toe game might have a state like this: Swift struct State { enum Player { case x case o } enum Space { case unfilled filled ( Player ) } // 3 rows * 3 columns = 9 spaces var spaces : [ Space ] = Array ( repeating : . unfilled , count : 9 ) var currentTurn : Player = . x } Kotlin data class State ( // 3 rows * 3 columns = 9 spaces val spaces : List < Space > = List ( 9 ) { Unfilled }, val currentTurn : Player = X ) { enum class Player { X , O } sealed class Space { object Unfilled : Space () data class Filled ( val player : Player ) : Space () } } When the workflow is first started, it is queried for an initial state value. From that point forward, the workflow may advance to a new state as the result of events occurring from various sources (which will be covered below). Stateless Workflows If a workflow does not have any private state, it is often referred to as a \u201cstateless workflow\u201d. A stateless Workflow is simply a Workflow that has a Void or Unit State type. See more . Public Props \u00b6 Every Workflow implementation also defines data that is passed into it. The Workflow is not able to modify this state itself, but it may change between render passes. This public state is called Props . In Swift, the props are simply defined as properties of the struct implementing Workflow itself. In Kotlin, the Workflow interface defines a separate PropsT type parameter. (This additional type parameter is necessary due to Kotlin\u2019s lack of the Self type that Swift workflow\u2019s workflowDidChange method relies upon.) Swift TK Kotlin data class Props ( val playerXName : String val playerOName : String ) Workflows are advanced by WorkflowAction s \u00b6 Any time something happens that should advance a workflow \u2013 a UI event, a network response, a child\u2019s output event \u2013 actions are used to perform the update. For example, a workflow may respond to UI events by mapping those events into a type conforming to/implementing WorkflowAction . These types implement the logic to advance a workflow by: Advancing to a new state (Optionally) emitting an output event up the tree. WorkflowAction s are typically defined as enums with associated types (Swift) or sealed classes (Kotlin), and can include data from the event \u2013 for example, the ID of the item in the list that was clicked. Side effects such as logging button clicks to an analytics framework are also typically performed in actions. If you\u2019re familiar with React/Redux, WorkflowAction s are essentially reducers. Workflows can emit output events up the hierarchy to their parent \u00b6 When a workflow is advanced by an action, an optional output event can be sent up the workflow hierarchy. This is the opportunity for a workflow to notify its parent that something has happened (and the parent\u2019s opportunity to respond to that event by dispatching its own action, continuing up the tree as long as output events are emitted). Workflows produce an external representation of their state via Rendering \u00b6 Immediately after starting up, or after a state transition occurs, a workflow will have its render method called. This method is responsible for creating and returning a value of type Rendering . You can think of Rendering as the \u201cexternal published state\u201d of the workflow, and the render function as a map of ( Props + State + childrens\u2019 Rendering s) -> Rendering . While a workflow\u2019s internal state may contain more detailed or comprehensive state, the Rendering (external state) is a type that is useful outside of the workflow. Because a workflow\u2019s render method may be called by infrastructure for a variety of reasons, it\u2019s important to not perform side effects when rendering \u2014 render methods must be idempotent. Event-based side effects should use Actions and state-based side effects should use Workers. When building an interactive application, the Rendering type is commonly (but not always) a view model that will drive the UI layer. Workflows can respond to UI events \u00b6 The RenderContext that is passed into render as the last parameter provides some useful tools to assist in creating the Rendering value. If a workflow is producing a view model, it is common to need an event handler to respond to UI events. The RenderContext has API to create an event handler, called a Sink , that when called will advance the workflow by dispatching an action back to the workflow (for more on actions, see above ). Swift func render ( state : State , context : RenderContext < DemoWorkflow >) -> DemoScreen { // Create a sink of our Action type so we can send actions back to the workflow. let sink = context . makeSink ( of : Action . self ) return DemoScreen ( title : \"A nice title\" , onTap : { sink . send ( Action . refreshButtonTapped ) } } Kotlin TK Workflows form a hierarchy (they may have children) \u00b6 As they produce a Rendering value, it is common for workflows to delegate some portion of that work to a child workflow . This is done via the RenderContext that is passed into the render method. In order to delegate to a child, the parent calls renderChild on the context, with the child workflow as the single argument. The infrastructure will spin up the child workflow (including initializing its initial state) if this is the first time this child has been used, or, if the child was also used on the previous render pass, the existing child will be updated. Either way, render will immediately be called on the child (by the Workflow infrastructure), and the resulting child\u2019s Rendering value will be returned to the parent. This allows a parent to return complex Rendering types (such as a view model representing the entire UI state of an application) without needing to model all of that complexity within a single workflow. Workflow Identity The Workflow infrastructure automatically detects the first time and the last subsequent time you\u2019ve asked to render a child workflow, and will automatically initialize the child and clean it up. In both Swift and Kotlin, this is done using the workflow\u2019s concrete type. Both languages use reflection to do this comparison (e.g. in Kotlin, the workflows\u2019 KClass es are compared). It is an error to render workflows of the same type more than once in the same render pass. Since type is used for workflow identity, the child rendering APIs take an optional string key to differentiate between multiple child workflows of the same type. Workflows can subscribe to external event sources \u00b6 If a workflow needs to respond to some external event source (e.g. push notifications), the workflow can ask the context to listen to those events from within the render method. Swift vs Kotlin In the Swift library, there is a special API for subscribing to hot streams ( Signal in ReactiveSwift). The Kotlin library does not have any special API for subscribing to hot streams (channels), though it does have extension methods to convert ReceiveChannel s , and RxJava Flowable s and Observables , to Worker s . The reason for this discrepancy is simply that we don\u2019t have any uses of channels yet in production, and so we\u2019ve decided to keep the API simpler. If we start using channels in the future, it may make sense to make subscribing to them a first-class API like in Swift. Workflows can perform asynchronous tasks (Workers) \u00b6 Workers are very similar in concept to child workflows. Unlike child workflows, however, workers do not have a Rendering type; they only exist to perform a single asynchronous task before sending zero or more output events back up the tree to their parent. For more information about workers, see the Worker section below. Workflows can be saved to and restored from a snapshot (Kotlin only) \u00b6 On every render pass, each workflow is asked to create a \u201csnapshot\u201d of its state \u2013 a lazily-produced serialization of the workflow\u2019s State as a binary blob. These Snapshot s are aggregated into a single Snapshot for the entire workflow tree and emitted along with the root workflow\u2019s Rendering . When the workflow runtime is started, it can be passed an optional Snapshot to restore the tree from. When non-null, the root workflow\u2019s snapshot is extracted and passed to the root workflow\u2019s initialState . The workflow can choose to either ignore the snapshot or use it to restore its State . On the first render pass, if the root workflow renders any children that were also being rendered when the snapshot was taken, those children\u2019s snapshots are also extracted from the aggregate and used to initialize their states. Why don\u2019t Swift Workflows support snapshotting? Snapshotting was built into Kotlin workflows specifically to support Android\u2019s app lifecycle, which requires apps to serialize their current state before being backgrounded so that they can be restored in case the system needs to kill the hosting process. iOS apps don\u2019t have this requirement, so the Swift library doesn\u2019t need to support it.","title":"Coding a Workflow (stale)"},{"location":"userguide/workflow-in-code/#coding-a-workflow","text":"In code, Workflow is a Swift protocol or Kotlin interface with State, Rendering and Output parameter types. The Kotlin interface also defines a Props type. In Swift, props are implicit as properties of the struct implementing Workflow. Swift public protocol Workflow : AnyWorkflowConvertible { associatedtype State associatedtype Output = Never associatedtype Rendering func makeInitialState () -> State func workflowDidChange ( from previousWorkflow : Self , state : inout State ) func render ( state : State , context : RenderContext < Self >) -> Rendering } Kotlin abstract class StatefulWorkflow < in PropsT , StateT , out OutputT : Any , out RenderingT > : Workflow < PropsT , OutputT , RenderingT > { abstract fun initialState ( props : PropsT , initialSnapshot : Snapshot? ): StateT open fun onPropsChanged ( old : PropsT , new : PropsT , state : StateT ): StateT = state abstract fun render ( props : PropsT , state : StateT , context : RenderContext < StateT , OutputT > ): RenderingT abstract fun snapshotState ( state : StateT ): Snapshot } Swift: What is AnyWorkflowConvertible ? When a protocol has an associated Self type, Swift requires the use of a type-erasing wrapper to store references to instances of that protocol. AnyWorkflow is such a wrapper for Workflow . AnyWorkflowConvertible is a protocol with a single method that returns an AnyWorkflow . It is useful as a base type because it allows instances of Workflow to be used directly by any code that requires the type-erased AnyWorkflow . Kotlin: StatefulWorkflow vs Workflow It is a common practice in Kotlin to divide types into two parts: an interface for public API, and a class for private implementation. The Workflow library defines a Workflow interface, which should be used as the type of properties and parameters by code that needs to refer to a particular Workflow interface. The Workflow interface contains a single method, which simply returns a StatefulWorkflow \u2013 a Workflow can be described as \u201canything that can be expressed as a StatefulWorkflow .\u201d The library also defines two abstract classes which define the contract for workflows and should be subclassed to implement your workflows: StatefulWorkflow should be subclassed to implement Workflows that have private state . StatelessWorkflow should be subclassed to implement Workflows that don\u2019t have any private state. See Stateless Workflows . Workflows have several responsibilities:","title":"Coding a Workflow"},{"location":"userguide/workflow-in-code/#workflows-have-state","text":"Once a Workflow has been started, it always operates in the context of some state. This state is divided into two parts: private state, which only the Workflow implementation itself knows about, which is defined by the State type, and properties (or \u201cprops\u201d), which is passed to the Workflow from its parent (more on hierarchical workflows below).","title":"Workflows have state"},{"location":"userguide/workflow-in-code/#private-state","text":"Every Workflow implementation defines a State type to maintain any necessary state while the workflow is running. For example, a tic-tac-toe game might have a state like this: Swift struct State { enum Player { case x case o } enum Space { case unfilled filled ( Player ) } // 3 rows * 3 columns = 9 spaces var spaces : [ Space ] = Array ( repeating : . unfilled , count : 9 ) var currentTurn : Player = . x } Kotlin data class State ( // 3 rows * 3 columns = 9 spaces val spaces : List < Space > = List ( 9 ) { Unfilled }, val currentTurn : Player = X ) { enum class Player { X , O } sealed class Space { object Unfilled : Space () data class Filled ( val player : Player ) : Space () } } When the workflow is first started, it is queried for an initial state value. From that point forward, the workflow may advance to a new state as the result of events occurring from various sources (which will be covered below). Stateless Workflows If a workflow does not have any private state, it is often referred to as a \u201cstateless workflow\u201d. A stateless Workflow is simply a Workflow that has a Void or Unit State type. See more .","title":"Private state"},{"location":"userguide/workflow-in-code/#public-props","text":"Every Workflow implementation also defines data that is passed into it. The Workflow is not able to modify this state itself, but it may change between render passes. This public state is called Props . In Swift, the props are simply defined as properties of the struct implementing Workflow itself. In Kotlin, the Workflow interface defines a separate PropsT type parameter. (This additional type parameter is necessary due to Kotlin\u2019s lack of the Self type that Swift workflow\u2019s workflowDidChange method relies upon.) Swift TK Kotlin data class Props ( val playerXName : String val playerOName : String )","title":"Public Props"},{"location":"userguide/workflow-in-code/#workflows-are-advanced-by-workflowactions","text":"Any time something happens that should advance a workflow \u2013 a UI event, a network response, a child\u2019s output event \u2013 actions are used to perform the update. For example, a workflow may respond to UI events by mapping those events into a type conforming to/implementing WorkflowAction . These types implement the logic to advance a workflow by: Advancing to a new state (Optionally) emitting an output event up the tree. WorkflowAction s are typically defined as enums with associated types (Swift) or sealed classes (Kotlin), and can include data from the event \u2013 for example, the ID of the item in the list that was clicked. Side effects such as logging button clicks to an analytics framework are also typically performed in actions. If you\u2019re familiar with React/Redux, WorkflowAction s are essentially reducers.","title":"Workflows are advanced by WorkflowActions"},{"location":"userguide/workflow-in-code/#workflows-can-emit-output-events-up-the-hierarchy-to-their-parent","text":"When a workflow is advanced by an action, an optional output event can be sent up the workflow hierarchy. This is the opportunity for a workflow to notify its parent that something has happened (and the parent\u2019s opportunity to respond to that event by dispatching its own action, continuing up the tree as long as output events are emitted).","title":"Workflows can emit output events up the hierarchy to their parent"},{"location":"userguide/workflow-in-code/#workflows-produce-an-external-representation-of-their-state-via-rendering","text":"Immediately after starting up, or after a state transition occurs, a workflow will have its render method called. This method is responsible for creating and returning a value of type Rendering . You can think of Rendering as the \u201cexternal published state\u201d of the workflow, and the render function as a map of ( Props + State + childrens\u2019 Rendering s) -> Rendering . While a workflow\u2019s internal state may contain more detailed or comprehensive state, the Rendering (external state) is a type that is useful outside of the workflow. Because a workflow\u2019s render method may be called by infrastructure for a variety of reasons, it\u2019s important to not perform side effects when rendering \u2014 render methods must be idempotent. Event-based side effects should use Actions and state-based side effects should use Workers. When building an interactive application, the Rendering type is commonly (but not always) a view model that will drive the UI layer.","title":"Workflows produce an external representation of their state via Rendering"},{"location":"userguide/workflow-in-code/#workflows-can-respond-to-ui-events","text":"The RenderContext that is passed into render as the last parameter provides some useful tools to assist in creating the Rendering value. If a workflow is producing a view model, it is common to need an event handler to respond to UI events. The RenderContext has API to create an event handler, called a Sink , that when called will advance the workflow by dispatching an action back to the workflow (for more on actions, see above ). Swift func render ( state : State , context : RenderContext < DemoWorkflow >) -> DemoScreen { // Create a sink of our Action type so we can send actions back to the workflow. let sink = context . makeSink ( of : Action . self ) return DemoScreen ( title : \"A nice title\" , onTap : { sink . send ( Action . refreshButtonTapped ) } } Kotlin TK","title":"Workflows can respond to UI events"},{"location":"userguide/workflow-in-code/#workflows-form-a-hierarchy-they-may-have-children","text":"As they produce a Rendering value, it is common for workflows to delegate some portion of that work to a child workflow . This is done via the RenderContext that is passed into the render method. In order to delegate to a child, the parent calls renderChild on the context, with the child workflow as the single argument. The infrastructure will spin up the child workflow (including initializing its initial state) if this is the first time this child has been used, or, if the child was also used on the previous render pass, the existing child will be updated. Either way, render will immediately be called on the child (by the Workflow infrastructure), and the resulting child\u2019s Rendering value will be returned to the parent. This allows a parent to return complex Rendering types (such as a view model representing the entire UI state of an application) without needing to model all of that complexity within a single workflow. Workflow Identity The Workflow infrastructure automatically detects the first time and the last subsequent time you\u2019ve asked to render a child workflow, and will automatically initialize the child and clean it up. In both Swift and Kotlin, this is done using the workflow\u2019s concrete type. Both languages use reflection to do this comparison (e.g. in Kotlin, the workflows\u2019 KClass es are compared). It is an error to render workflows of the same type more than once in the same render pass. Since type is used for workflow identity, the child rendering APIs take an optional string key to differentiate between multiple child workflows of the same type.","title":"Workflows form a hierarchy (they may have children)"},{"location":"userguide/workflow-in-code/#workflows-can-subscribe-to-external-event-sources","text":"If a workflow needs to respond to some external event source (e.g. push notifications), the workflow can ask the context to listen to those events from within the render method. Swift vs Kotlin In the Swift library, there is a special API for subscribing to hot streams ( Signal in ReactiveSwift). The Kotlin library does not have any special API for subscribing to hot streams (channels), though it does have extension methods to convert ReceiveChannel s , and RxJava Flowable s and Observables , to Worker s . The reason for this discrepancy is simply that we don\u2019t have any uses of channels yet in production, and so we\u2019ve decided to keep the API simpler. If we start using channels in the future, it may make sense to make subscribing to them a first-class API like in Swift.","title":"Workflows can subscribe to external event sources"},{"location":"userguide/workflow-in-code/#workflows-can-perform-asynchronous-tasks-workers","text":"Workers are very similar in concept to child workflows. Unlike child workflows, however, workers do not have a Rendering type; they only exist to perform a single asynchronous task before sending zero or more output events back up the tree to their parent. For more information about workers, see the Worker section below.","title":"Workflows can perform asynchronous tasks (Workers)"},{"location":"userguide/workflow-in-code/#workflows-can-be-saved-to-and-restored-from-a-snapshot-kotlin-only","text":"On every render pass, each workflow is asked to create a \u201csnapshot\u201d of its state \u2013 a lazily-produced serialization of the workflow\u2019s State as a binary blob. These Snapshot s are aggregated into a single Snapshot for the entire workflow tree and emitted along with the root workflow\u2019s Rendering . When the workflow runtime is started, it can be passed an optional Snapshot to restore the tree from. When non-null, the root workflow\u2019s snapshot is extracted and passed to the root workflow\u2019s initialState . The workflow can choose to either ignore the snapshot or use it to restore its State . On the first render pass, if the root workflow renders any children that were also being rendered when the snapshot was taken, those children\u2019s snapshots are also extracted from the aggregate and used to initialize their states. Why don\u2019t Swift Workflows support snapshotting? Snapshotting was built into Kotlin workflows specifically to support Android\u2019s app lifecycle, which requires apps to serialize their current state before being backgrounded so that they can be restored in case the system needs to kill the hosting process. iOS apps don\u2019t have this requirement, so the Swift library doesn\u2019t need to support it.","title":"Workflows can be saved to and restored from a snapshot (Kotlin only)"}]}