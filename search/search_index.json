{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Square Workflow \u00b6 Workflow is an application framework that provides architectural primitives. Workflow is: Written in and used for Kotlin and Swift A unidirectional data flow library that uses immutable data within each Workflow. Data flows in a single direction from source to UI, and events in a single direction from the UI to the business logic. A library that supports writing business logic and complex UI navigation logic as state machines, thereby enabling confident reasoning about state and validation of correctness. Optimized for composability and scalability of features and screens. Corresponding UI frameworks that bind Rendering data classes for \u201cviews\u201d (including event callbacks) to Mobile UI frameworks for Android and iOS. A corresponding testing framework that facilitates simple-to-write unit tests for all application business logic and helps ensure correctness. Using Workflows in your project \u00b6 Swift \u00b6 See the square/workflow-swift repository. Kotlin \u00b6 See the square/workflow-kotlin repository. Resources \u00b6 Wondering why to use Workflow? See \u201cWhy Workflow\u201d There is a Glossary of Terms We have a User Guide describing core concepts. For Kotlin (and Android), there is a codelab style tutorial in the repo. For Swift (and iOS), there is also a Getting Started tutorial in the repo. There are also a number of Kotlin samples and Swift samples . Support & Contact \u00b6 Workflow discussion happens in the Workflow Community slack. Use this open invitation . Workflow maintainers also hang out in the #squarelibraries channel on the Kotlin Slack . Releasing and Deploying \u00b6 See RELEASING.md . License \u00b6 Copyright 2019 Square Inc. Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"Overview"},{"location":"#square-workflow","text":"Workflow is an application framework that provides architectural primitives. Workflow is: Written in and used for Kotlin and Swift A unidirectional data flow library that uses immutable data within each Workflow. Data flows in a single direction from source to UI, and events in a single direction from the UI to the business logic. A library that supports writing business logic and complex UI navigation logic as state machines, thereby enabling confident reasoning about state and validation of correctness. Optimized for composability and scalability of features and screens. Corresponding UI frameworks that bind Rendering data classes for \u201cviews\u201d (including event callbacks) to Mobile UI frameworks for Android and iOS. A corresponding testing framework that facilitates simple-to-write unit tests for all application business logic and helps ensure correctness.","title":"Square Workflow"},{"location":"#using-workflows-in-your-project","text":"","title":"Using Workflows in your project"},{"location":"#swift","text":"See the square/workflow-swift repository.","title":"Swift"},{"location":"#kotlin","text":"See the square/workflow-kotlin repository.","title":"Kotlin"},{"location":"#resources","text":"Wondering why to use Workflow? See \u201cWhy Workflow\u201d There is a Glossary of Terms We have a User Guide describing core concepts. For Kotlin (and Android), there is a codelab style tutorial in the repo. For Swift (and iOS), there is also a Getting Started tutorial in the repo. There are also a number of Kotlin samples and Swift samples .","title":"Resources"},{"location":"#support-contact","text":"Workflow discussion happens in the Workflow Community slack. Use this open invitation . Workflow maintainers also hang out in the #squarelibraries channel on the Kotlin Slack .","title":"Support &amp; Contact"},{"location":"#releasing-and-deploying","text":"See RELEASING.md .","title":"Releasing and Deploying"},{"location":"#license","text":"Copyright 2019 Square Inc. Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"License"},{"location":"CHANGELOG/","text":"Changelog \u00b6 You can find the changelogs for the library in the respective language repositories: Kotlin Swift","title":"Changelog"},{"location":"CHANGELOG/#changelog","text":"You can find the changelogs for the library in the respective language repositories: Kotlin Swift","title":"Changelog"},{"location":"CODE_OF_CONDUCT/","text":"Open Source Code of Conduct \u00b6 At Square, we are committed to contributing to the open source community and simplifying the process of releasing and managing open source software. We\u2019ve seen incredible support and enthusiasm from thousands of people who have already contributed to our projects\u200a\u2014\u200aand we want to ensure ourcommunity continues to be truly open for everyone. This code of conduct outlines our expectations for participants, as well as steps to reporting unacceptable behavior. We are committed to providing a welcoming and inspiring community for all and expect our code of conduct to be honored. Square\u2019s open source community strives to: Be open : We invite anyone to participate in any aspect of our projects. Our community is open, and any responsibility can be carried by a contributor who demonstrates the required capacity and competence. Be considerate : People use our work, and we depend on the work of others. Consider users and colleagues before taking action. For example, changes to code, infrastructure, policy, and documentation may negatively impact others. Be respectful : We expect people to work together to resolve conflict, assume good intentions, and act with empathy. Do not turn disagreements into personal attacks. Be collaborative : Collaboration reduces redundancy and improves the quality of our work. We strive for transparency within our open source community, and we work closely with upstream developers and others in the free software community to coordinate our efforts. Be pragmatic : Questions are encouraged and should be asked early in the process to avoid problems later. Be thoughtful and considerate when seeking out the appropriate forum for your questions. Those who are asked should be responsive and helpful. Step down considerately : Members of every project come and go. When somebody leaves or disengages from the project, they should make it known and take the proper steps to ensure that others can pick up where they left off. This code is not exhaustive or complete. It serves to distill our common understanding of a collaborative, shared environment, and goals. We expect it to be followed in spirit as much as in the letter. Diversity Statement \u00b6 We encourage everyone to participate and are committed to building a community for all. Although we may not be able to satisfy everyone, we all agree that everyone is equal. Whenever a participant has made a mistake, we expect them to take responsibility for it. If someone has been harmed or offended, it is our responsibility to listen carefully and respectfully, and do our best to right the wrong. Although this list cannot be exhaustive, we explicitly honor diversity in age, culture, ethnicity, gender identity or expression, language, national origin, political beliefs, profession, race, religion, sexual orientation, socioeconomic status, and technical ability. We will not tolerate discrimination based on any of the protected characteristics above, including participants with disabilities. Reporting Issues \u00b6 If you experience or witness unacceptable behavior\u200a\u2014\u200aor have any other concerns\u200a\u2014\u200aplease report it by emailing codeofconduct@squareup.com . For more details, please see our Reporting Guidelines below. Thanks \u00b6 Some of the ideas and wording for the statements and guidelines above were based on work by the Twitter , Ubuntu , GDC , and Django communities. We are thankful for their work. Reporting Guide \u00b6 If you experience or witness unacceptable behavior\u200a\u2014\u200aor have any other concerns\u200a\u2014\u200aplease report it by emailing codeofconduct@squareup.com . All reports will be handled with discretion. In your report please include: Your contact information. Names (real, nicknames, or pseudonyms) of any individuals involved. If there are additional witnesses, please include them as well. Your account of what occurred, and if you believe the incident is ongoing. If there is a publicly available record (e.g. a mailing list archive or a public IRC logger), please include a link. Any additional information that may be helpful. After filing a report, a representative from the Square Code of Conduct committee will contact you personally. The committee will then review the incident, follow up with any additional questions, and make a decision as to how to respond. Anyone asked to stop unacceptable behavior is expected to comply immediately. If an individual engages in unacceptable behavior, the Square Code of Conduct committee may take any action they deem appropriate, up to and including a permanent ban from all of Square spaces without warning.","title":"Code of Conduct"},{"location":"CODE_OF_CONDUCT/#open-source-code-of-conduct","text":"At Square, we are committed to contributing to the open source community and simplifying the process of releasing and managing open source software. We\u2019ve seen incredible support and enthusiasm from thousands of people who have already contributed to our projects\u200a\u2014\u200aand we want to ensure ourcommunity continues to be truly open for everyone. This code of conduct outlines our expectations for participants, as well as steps to reporting unacceptable behavior. We are committed to providing a welcoming and inspiring community for all and expect our code of conduct to be honored. Square\u2019s open source community strives to: Be open : We invite anyone to participate in any aspect of our projects. Our community is open, and any responsibility can be carried by a contributor who demonstrates the required capacity and competence. Be considerate : People use our work, and we depend on the work of others. Consider users and colleagues before taking action. For example, changes to code, infrastructure, policy, and documentation may negatively impact others. Be respectful : We expect people to work together to resolve conflict, assume good intentions, and act with empathy. Do not turn disagreements into personal attacks. Be collaborative : Collaboration reduces redundancy and improves the quality of our work. We strive for transparency within our open source community, and we work closely with upstream developers and others in the free software community to coordinate our efforts. Be pragmatic : Questions are encouraged and should be asked early in the process to avoid problems later. Be thoughtful and considerate when seeking out the appropriate forum for your questions. Those who are asked should be responsive and helpful. Step down considerately : Members of every project come and go. When somebody leaves or disengages from the project, they should make it known and take the proper steps to ensure that others can pick up where they left off. This code is not exhaustive or complete. It serves to distill our common understanding of a collaborative, shared environment, and goals. We expect it to be followed in spirit as much as in the letter.","title":"Open Source Code of Conduct"},{"location":"CODE_OF_CONDUCT/#diversity-statement","text":"We encourage everyone to participate and are committed to building a community for all. Although we may not be able to satisfy everyone, we all agree that everyone is equal. Whenever a participant has made a mistake, we expect them to take responsibility for it. If someone has been harmed or offended, it is our responsibility to listen carefully and respectfully, and do our best to right the wrong. Although this list cannot be exhaustive, we explicitly honor diversity in age, culture, ethnicity, gender identity or expression, language, national origin, political beliefs, profession, race, religion, sexual orientation, socioeconomic status, and technical ability. We will not tolerate discrimination based on any of the protected characteristics above, including participants with disabilities.","title":"Diversity Statement"},{"location":"CODE_OF_CONDUCT/#reporting-issues","text":"If you experience or witness unacceptable behavior\u200a\u2014\u200aor have any other concerns\u200a\u2014\u200aplease report it by emailing codeofconduct@squareup.com . For more details, please see our Reporting Guidelines below.","title":"Reporting Issues"},{"location":"CODE_OF_CONDUCT/#thanks","text":"Some of the ideas and wording for the statements and guidelines above were based on work by the Twitter , Ubuntu , GDC , and Django communities. We are thankful for their work.","title":"Thanks"},{"location":"CODE_OF_CONDUCT/#reporting-guide","text":"If you experience or witness unacceptable behavior\u200a\u2014\u200aor have any other concerns\u200a\u2014\u200aplease report it by emailing codeofconduct@squareup.com . All reports will be handled with discretion. In your report please include: Your contact information. Names (real, nicknames, or pseudonyms) of any individuals involved. If there are additional witnesses, please include them as well. Your account of what occurred, and if you believe the incident is ongoing. If there is a publicly available record (e.g. a mailing list archive or a public IRC logger), please include a link. Any additional information that may be helpful. After filing a report, a representative from the Square Code of Conduct committee will contact you personally. The committee will then review the incident, follow up with any additional questions, and make a decision as to how to respond. Anyone asked to stop unacceptable behavior is expected to comply immediately. If an individual engages in unacceptable behavior, the Square Code of Conduct committee may take any action they deem appropriate, up to and including a permanent ban from all of Square spaces without warning.","title":"Reporting Guide"},{"location":"CONTRIBUTING/","text":"Contributing \u00b6 If you would like to contribute code to Workflow you can do so through GitHub by forking the repository and sending a pull request. When submitting code, please make every effort to follow existing conventions and style in order to keep the code as readable as possible. Please also make sure your code compiles. Before your code can be accepted into the project you must also sign the Individual Contributor License Agreement (CLA) .","title":"Contributing"},{"location":"CONTRIBUTING/#contributing","text":"If you would like to contribute code to Workflow you can do so through GitHub by forking the repository and sending a pull request. When submitting code, please make every effort to follow existing conventions and style in order to keep the code as readable as possible. Please also make sure your code compiles. Before your code can be accepted into the project you must also sign the Individual Contributor License Agreement (CLA) .","title":"Contributing"},{"location":"RELEASING/","text":"Releasing workflow \u00b6 Deploying the documentation website \u00b6 Official Workflow documentation lives at https://square.github.io/workflow . The website content consists of three parts: Markdown documentation: Lives in the docs/ folder, and consists of a set of hand-written Markdown files that document high-level concepts. The static site generator mkdocs (with Material theming) is used to convert the Markdown to static, styled HTML. Kotlin API reference: Kdoc embedded in Kotlin source files is converted to GitHub-flavored Markdown by Dokka and then included in the statically-generated website. Swift API reference: Markup comments from Swift files are converted Markdown by Sourcedocs and then included in the statically-generated website. Note: The documentation site is automatically built and deployed whenever a version tag is pushed. You only need these steps if you want to work on the site locally. Setting up the site generators \u00b6 If you\u2019ve already done this, you can skip to Deploying the website to production below. Kotlin: Dokka \u00b6 Dokka runs as a Gradle plugin, so you need to be able to build the Kotlin source with Gradle, but that\u2019s it. To generate the docs manually, run: cd kotlin ./gradlew dokka Swift: Sourcedocs \u00b6 Sourcedocs generates a Markdown site from Swift files. You need Ruby, rubygems, bundler (2.x), Xcode 10.2+, CocoaPods, and of course Sourcedocs itself, to run it. Assuming you\u2019ve already got Xcode, Ruby, and rubygems set up, install the rest of the dependencies: gem install bundler cocoapods brew install sourcedocs You will also need a checkout of the Swift repo: git clone https://github.com/square/workflow-swift.git cd workflow-swift Then generate an Xcode project before running Sourcedocs: cd Samples/SampleApp/ bundle exec pod install # If this is your first time running CocoaPods, that will fail and you'll need to run this instead: #bundle exec pod install --repo-update You can manually generate the docs to verify everything is working correctly by running: #cd Samples/SampleApp/ sourcedocs generate -- -scheme Workflow -workspace SampleApp.xcworkspace sourcedocs generate -- -scheme WorkflowUI -workspace SampleApp.xcworkspace sourcedocs generate -- -scheme WorkflowTesting -workspace SampleApp.xcworkspace Note that currently sourcedocs only supports Xcode 10, if you run it with Xcode 11 you might see an error about Catalyst and only empty READMEs will get generated. mkdocs \u00b6 Mkdocs is written in Python, so you\u2019ll need Python 3 and pip in order to run it. Assuming those are set up, run: pip install -r requirements.txt Generate the site manually with: mkdocs build While you\u2019re working on the documentation files, you can run the site locally with: mkdocs serve Deploying the website to production \u00b6 Note: The documentation site is automatically built and deployed by a Github Workflow whenever a version tag is pushed. You only need these steps if you want to publish the site manually. Before deploying the website for real, you need to export our Google Analytics key in an environment variable so that it will get added to the HTML. Get the key from one of the project maintainers, then add the following to your .bashrc and re-source it: export WORKFLOW_GOOGLE_ANALYTICS_KEY = UA-__________-1 Now you\u2019re ready to publish the site! Just choose a tag or SHA to deploy from, and run: ./deploy_website.sh TAG_OR_SHA # For example: #./deploy_website.sh v0.18.0 This will clone the repo to a temporary directory, checkout the right SHA, build Kotlin and Swift API docs, generate HTML, and push the newly-generated content to the gh-pages branch on GitHub. Validating Markdown \u00b6 Since all of our high-level documentation is written in Markdown, we run a linter in CI to ensure we use consistent formatting. Lint errors will fail your PR builds, so to run locally, install markdownlint : gem install mdl Run the linter using the lint_docs.sh : ./lint_docs.sh Rules can be configured by editing .markdownlint.rb . Kotlin Notes \u00b6 Development \u00b6 To build and install the current version to your local Maven repository ( ~/.m2 ), run: ./gradlew clean installArchives Deploying \u00b6 Configuration \u00b6 In order to deploy artifacts to a Maven repository, you\u2019ll need to set 4 properties in your private Gradle properties file ( ~/.gradle/gradle.properties ): RELEASE_REPOSITORY_URL=<url of release repository> SNAPSHOT_REPOSITORY_URL=<url of snapshot repository SONATYPE_NEXUS_USERNAME=<username> SONATYPE_NEXUS_PASSWORD=<password> Snapshot Releases \u00b6 Double-check that gradle.properties correctly contains the -SNAPSHOT suffix, then upload snapshot artifacts to Sonatype just like you would for a production release: ./gradlew clean build && ./gradlew uploadArchives --no-parallel --no-daemon You can verify the artifacts are available by visiting https://oss.sonatype.org/content/repositories/snapshots/com/squareup/workflow/ .","title":"Releasing workflow"},{"location":"RELEASING/#releasing-workflow","text":"","title":"Releasing workflow"},{"location":"RELEASING/#deploying-the-documentation-website","text":"Official Workflow documentation lives at https://square.github.io/workflow . The website content consists of three parts: Markdown documentation: Lives in the docs/ folder, and consists of a set of hand-written Markdown files that document high-level concepts. The static site generator mkdocs (with Material theming) is used to convert the Markdown to static, styled HTML. Kotlin API reference: Kdoc embedded in Kotlin source files is converted to GitHub-flavored Markdown by Dokka and then included in the statically-generated website. Swift API reference: Markup comments from Swift files are converted Markdown by Sourcedocs and then included in the statically-generated website. Note: The documentation site is automatically built and deployed whenever a version tag is pushed. You only need these steps if you want to work on the site locally.","title":"Deploying the documentation website"},{"location":"RELEASING/#setting-up-the-site-generators","text":"If you\u2019ve already done this, you can skip to Deploying the website to production below.","title":"Setting up the site generators"},{"location":"RELEASING/#kotlin-dokka","text":"Dokka runs as a Gradle plugin, so you need to be able to build the Kotlin source with Gradle, but that\u2019s it. To generate the docs manually, run: cd kotlin ./gradlew dokka","title":"Kotlin: Dokka"},{"location":"RELEASING/#swift-sourcedocs","text":"Sourcedocs generates a Markdown site from Swift files. You need Ruby, rubygems, bundler (2.x), Xcode 10.2+, CocoaPods, and of course Sourcedocs itself, to run it. Assuming you\u2019ve already got Xcode, Ruby, and rubygems set up, install the rest of the dependencies: gem install bundler cocoapods brew install sourcedocs You will also need a checkout of the Swift repo: git clone https://github.com/square/workflow-swift.git cd workflow-swift Then generate an Xcode project before running Sourcedocs: cd Samples/SampleApp/ bundle exec pod install # If this is your first time running CocoaPods, that will fail and you'll need to run this instead: #bundle exec pod install --repo-update You can manually generate the docs to verify everything is working correctly by running: #cd Samples/SampleApp/ sourcedocs generate -- -scheme Workflow -workspace SampleApp.xcworkspace sourcedocs generate -- -scheme WorkflowUI -workspace SampleApp.xcworkspace sourcedocs generate -- -scheme WorkflowTesting -workspace SampleApp.xcworkspace Note that currently sourcedocs only supports Xcode 10, if you run it with Xcode 11 you might see an error about Catalyst and only empty READMEs will get generated.","title":"Swift: Sourcedocs"},{"location":"RELEASING/#mkdocs","text":"Mkdocs is written in Python, so you\u2019ll need Python 3 and pip in order to run it. Assuming those are set up, run: pip install -r requirements.txt Generate the site manually with: mkdocs build While you\u2019re working on the documentation files, you can run the site locally with: mkdocs serve","title":"mkdocs"},{"location":"RELEASING/#deploying-the-website-to-production","text":"Note: The documentation site is automatically built and deployed by a Github Workflow whenever a version tag is pushed. You only need these steps if you want to publish the site manually. Before deploying the website for real, you need to export our Google Analytics key in an environment variable so that it will get added to the HTML. Get the key from one of the project maintainers, then add the following to your .bashrc and re-source it: export WORKFLOW_GOOGLE_ANALYTICS_KEY = UA-__________-1 Now you\u2019re ready to publish the site! Just choose a tag or SHA to deploy from, and run: ./deploy_website.sh TAG_OR_SHA # For example: #./deploy_website.sh v0.18.0 This will clone the repo to a temporary directory, checkout the right SHA, build Kotlin and Swift API docs, generate HTML, and push the newly-generated content to the gh-pages branch on GitHub.","title":"Deploying the website to production"},{"location":"RELEASING/#validating-markdown","text":"Since all of our high-level documentation is written in Markdown, we run a linter in CI to ensure we use consistent formatting. Lint errors will fail your PR builds, so to run locally, install markdownlint : gem install mdl Run the linter using the lint_docs.sh : ./lint_docs.sh Rules can be configured by editing .markdownlint.rb .","title":"Validating Markdown"},{"location":"RELEASING/#kotlin-notes","text":"","title":"Kotlin Notes"},{"location":"RELEASING/#development","text":"To build and install the current version to your local Maven repository ( ~/.m2 ), run: ./gradlew clean installArchives","title":"Development"},{"location":"RELEASING/#deploying","text":"","title":"Deploying"},{"location":"RELEASING/#configuration","text":"In order to deploy artifacts to a Maven repository, you\u2019ll need to set 4 properties in your private Gradle properties file ( ~/.gradle/gradle.properties ): RELEASE_REPOSITORY_URL=<url of release repository> SNAPSHOT_REPOSITORY_URL=<url of snapshot repository SONATYPE_NEXUS_USERNAME=<username> SONATYPE_NEXUS_PASSWORD=<password>","title":"Configuration"},{"location":"RELEASING/#snapshot-releases","text":"Double-check that gradle.properties correctly contains the -SNAPSHOT suffix, then upload snapshot artifacts to Sonatype just like you would for a production release: ./gradlew clean build && ./gradlew uploadArchives --no-parallel --no-daemon You can verify the artifacts are available by visiting https://oss.sonatype.org/content/repositories/snapshots/com/squareup/workflow/ .","title":"Snapshot Releases"},{"location":"code-recipes/","text":"Code Receipes \u00b6 Coming soon!","title":"Code Receipes"},{"location":"code-recipes/#code-receipes","text":"Coming soon!","title":"Code Receipes"},{"location":"development-process/","text":"Development Process \u00b6 Coming soon!","title":"Development Process"},{"location":"development-process/#development-process","text":"Coming soon!","title":"Development Process"},{"location":"faq/","text":"Frequently Asked Questions \u00b6 Why do we need another architecture? \u00b6 We ask this question too! So we wrote a longer answer for it: \u201cWhy Workflow?\u201d . How do I get involved and/or contribute? \u00b6 Workflow is open source! See our CONTRIBUTING doc to get started. Stay tuned! We\u2019re considering hosting a public Slack channel for open source contributors. Isn\u2019t this basically React/Elm? \u00b6 React and the Elm architecture were both strong influences for this library. However both those libraries are written for JavaScript. Workflows are written in and for both Kotlin and Swift, making use of features of those languages, and with usability from those languages as a major design goal. There are some architectural differences which we can see briefly in the following table: React Elm Workflow Modularity Component Module s for code organization, but not \u2018composable\u2019 in the same way. A Workflow is analogous to React\u2019s Component State Each Component has a state property that is read directly and updated via a setState method. State is called Model in Elm. Workflow s have an associated state type. The state can only be updated when the props change, or with a WorkflowAction . Views Component s have a render method that returns a tree of elements. Elm applications have a view function that returns a tree of elements. Since workflows are not tied to any particular UI view layer, they can have an arbitrary rendering type. The render() method returns this type. Injected Dependencies React allows parent components to pass \u201cprops\u201d down to their children. N/A In Swift, Workflow s are often structs that need to be initialized with their dependencies and configuration data from their parent. In Kotlin, they have a separate type parameter ( PropsT ) that is always passed down from the parent. Workflow instances can also inject dependencies, and play nicely with dependency injection frameworks. Composability Component s are composed of other Component s. N/A Workflow s can have children; they control their lifecycle and can choose to incorporate child renderings into their own. Event Handling DOM event listeners are hooked up to functions on the Component . The update function takes a Msg to modify state based on events. action can be sent to the Sink to update State . How is this different than MvRx? \u00b6 Besides being very Android and Rx specific, MvRx solves view modeling problems only per screen. Workflow was mainly inspired by the need to manage and compose navigation in apps with dozens or hundreds of screens. This seems clever. Can I stick with a traditional development approach? \u00b6 Of course! Workflow was designed to make complex application architecture predictable and safe for large development teams. We\u2019re confident that it brings benefits even to smaller projects, but there is never only one right way to build software. We recommend to follow good practices and use an architecture that makes sense for your project .","title":"FAQ"},{"location":"faq/#frequently-asked-questions","text":"","title":"Frequently Asked Questions"},{"location":"faq/#why-do-we-need-another-architecture","text":"We ask this question too! So we wrote a longer answer for it: \u201cWhy Workflow?\u201d .","title":"Why do we need another architecture?"},{"location":"faq/#how-do-i-get-involved-andor-contribute","text":"Workflow is open source! See our CONTRIBUTING doc to get started. Stay tuned! We\u2019re considering hosting a public Slack channel for open source contributors.","title":"How do I get involved and/or contribute?"},{"location":"faq/#isnt-this-basically-reactelm","text":"React and the Elm architecture were both strong influences for this library. However both those libraries are written for JavaScript. Workflows are written in and for both Kotlin and Swift, making use of features of those languages, and with usability from those languages as a major design goal. There are some architectural differences which we can see briefly in the following table: React Elm Workflow Modularity Component Module s for code organization, but not \u2018composable\u2019 in the same way. A Workflow is analogous to React\u2019s Component State Each Component has a state property that is read directly and updated via a setState method. State is called Model in Elm. Workflow s have an associated state type. The state can only be updated when the props change, or with a WorkflowAction . Views Component s have a render method that returns a tree of elements. Elm applications have a view function that returns a tree of elements. Since workflows are not tied to any particular UI view layer, they can have an arbitrary rendering type. The render() method returns this type. Injected Dependencies React allows parent components to pass \u201cprops\u201d down to their children. N/A In Swift, Workflow s are often structs that need to be initialized with their dependencies and configuration data from their parent. In Kotlin, they have a separate type parameter ( PropsT ) that is always passed down from the parent. Workflow instances can also inject dependencies, and play nicely with dependency injection frameworks. Composability Component s are composed of other Component s. N/A Workflow s can have children; they control their lifecycle and can choose to incorporate child renderings into their own. Event Handling DOM event listeners are hooked up to functions on the Component . The update function takes a Msg to modify state based on events. action can be sent to the Sink to update State .","title":"Isn't this basically React/Elm?"},{"location":"faq/#how-is-this-different-than-mvrx","text":"Besides being very Android and Rx specific, MvRx solves view modeling problems only per screen. Workflow was mainly inspired by the need to manage and compose navigation in apps with dozens or hundreds of screens.","title":"How is this different than MvRx?"},{"location":"faq/#this-seems-clever-can-i-stick-with-a-traditional-development-approach","text":"Of course! Workflow was designed to make complex application architecture predictable and safe for large development teams. We\u2019re confident that it brings benefits even to smaller projects, but there is never only one right way to build software. We recommend to follow good practices and use an architecture that makes sense for your project .","title":"This seems clever. Can I stick with a traditional development approach?"},{"location":"glossary/","text":"Glossary of Terms \u00b6 Term Definition Reactive Programming A style of programming where data or events are pushed to the logic processing them rather than having the logic pull the data and events from a source. A representation of program logic as a series of operations on a stream of data that is performed while a subscription to that stream is active. Unidirectional Data Flow Data travels a single path from business logic to UI, and travels the entirety of that path in a single direction. Events travel a single path from UI to business logic and they travel the entirety of that path in a single direction. There are thus 2 sets of directed edges in the graph that are handled separately and neither set has any cycles or back edges on its own. Declarative Programming A declarative program declares the state it wants the system to be in rather than how that is accomplished. Imperative Programming An imperative program\u2019s code is a series of statements that directly change a program\u2019s state as a result of certain events. State Machine An abstraction that models a program\u2019s logic as a graph of a set of states and the transitions between them (edges). See: https://en.wikipedia.org/wiki/Finite-state_machine Idempotent A function whose side effects won\u2019t be repeated with multiple invocations, the result is purely a function of the input. In other words, if called multiple times with the same input, the result is the same. For Workflows, the render() function must be idempotent, as the runtime offers no guarantees for how many times it may be called. Workflow Runtime An event loop that executes a Workflow Tree. On each pass: 1. A Rendering is assembled by calling render() on each Node of the Workflow Tree with each parent Workflow given the option to incorporate the Renderings of its children into its own. 2. The event loop waits for an Action to be sent to the Sink. 3. This Action provides a (possibly updated) State for the Workflow that created it and possibly an Output. 4. Any Output emitted is processed in turn by an Action defined by the updated Workflow\u2019s parent again possibly updating its State and emitting an Output cascading up the hierarchy. 5. A new render() pass is made against the entire Workflow Tree with the updated States. We use the term Workflow Runtime to refer to the core code in the framework that executes this event loop, responding to Actions and invoking render(). Workflow (Instance) An object that defines the transitions and side effects of a state machine as, effectively, two functions: 1. Providing the first state: () -> State 2. Providing a rendering: (Props and State) -> (Rendering and Side Effect Invocations and Child Workflow Invocations) The Child Workflow Invocations declared by the render function result in calls to the children\u2019s render() functions in turn, allowing the parent render function to choose to incorporate child Rendering values into its own. A Workflow is not itself a state machine, and ideally has no state of its own. It is rather a schema that identifies a particular type of state machine that can be started in initialState() by the Workflow Runtime, and advanced by repeated invocations of render(). Note: there is significant fuzziness in using the term \u2018Workflow\u2019, as it can mean at times the class/struct that declares the Workflow behavior as well as the object representing the running Workflow Node. To understand the Runtime behavior, grasping this distinction is necessary and valuable, however, when using a Workflow, the formal distinction is less valuable than the mental model of how a Workflow will be run. Workflow (Node) An active state machine whose behavior is defined by a Workflow Instance. This is the object that is held by the Workflow Runtime and whose state is updated (or \u201cdriven\u201d) according to the behavior declared in the Workflow Instance. In Kotlin and Swift a Workflow Node is implemented with the private WorkflowNode class/struct. Workflow Lifecycle Every Workflow or Side Effect Node has a lifecycle that is determined by its parent. In the case of the root Workflow, this lifecycle is determined by how long the host of the root chooses to use the stream of Renderings from the root Workflow. In the case of a non-root Workflow or Side Effect \u2014 that is, in the case of a Child \u2014 its lifecycle is determined as follows: \u2022 Start: the first time its parent invokes the Child in the parent\u2019s own render() pass. \u2022 End: the first subsequent render() pass that does not invoke the Child. Note that in between Start and End, the Workflow, or Side Effect is not \u201cre-invoked\u201d in the sense of starting again with each render() pass, but rather the originally invoked instance continues to run until a render() call is made without invoking it. Workflow Tree The tree of Workflow Nodes sharing a root. Workflow Nodes can have children and form a hierarchy. Workflow Root The root of a Workflow Tree. This is owned by a host which starts the Workflow Runtime with a particular Workflow instance. RenderContext The object which provides access to the Workflow Runtime from a Workflow render method. Provides three services: \u2022 a Sink for accepting WorkflowActions \u2022 recursively rendering Workflow children \u2022 executing Side Effects Action Cascade When an event occurs and the handler provides an Action, this Action may possibly produce an Output for the parent Workflow which in turn has its own handler provide an Action that may produce an Output and onwards up the Workflow Tree. This is an Action Cascade. Render Pass The portion of the Workflow Runtime event loop which traverses the Workflow tree, calling render() on each Workflow Node. When the RenderContext Sink receives an Action an Action Cascade occurs and at the completion of the Action Cascade the Render Pass occurs. Output Event When a Child Workflow emits an Output value, this is an Output Event. Handlers are registered when a Child Workflow is invoked to transform the child\u2019s Output values to Actions, which can advance the state of the parent. UI Event Any occurrence in the UI of a program - e.g. click, drag, keypress - the listener for which has been connected to a callback in the Rendering of a Workflow. UI Event callbacks typically add Actions to the Sink, to advance the state of the Workflow. Action A type associated with a particular Workflow (Instance) that is responsible for transforming a given State into a new State and optionally emitting an Output. Actions are sent to the Sink to be processed by the Workflow Runtime. Sink The handle provided by the RenderContext to send Actions to the Workflow Runtime. These Actions are applied by the Workflow Runtime to advance a Workflow\u2019s State, and optionally produce an Output to be processed by the handler its parent registered. Props The set of input properties for a particular Workflow. This is the public state which is provided to a child Workflow by its parent, or to the root Workflow by its host. For Swift: The set of properties on the struct implementing the Workflow. For Kotlin: Parameter type PropsT type in the Workflow signature. In Kotlin there is a formal distinction between Props and other dependencies, typically provided as constructor parameters. State The type of the internal state of a Workflow implementation. Immutable State: The State object itself is immutable, in other words, its property values cannot be changed. What this means for Workflows is that the Workflow Runtime holds a canonical instance of the internal State of each Workflow. A Workflow\u2019s state is \u201cadvanced\u201d when that canonical instance is atomically replaced by one returned when an Action is invoked. State can only be mutated through WorkflowAction Rendering The externally available public representation of the state of a Workflow. It may include event handling functions. It is given a concrete type in the Workflow signature. Note that this \u201cRendering\u201d does not have to represent the UI of a program. The \u201cRendering\u201d is simply the published state of the Workflow, and could simply be data. Often that data is used to render UI, but it can be used in other ways \u2014 for example, as the implementation of a service API. Output The type of the object that can optionally be delivered to the Workflow\u2019s parent or the host of the root Workflow by an Action. Child Workflow A Workflow which has a parent. A parent may compose a child Workflow\u2019s Rendering into its own Rendering. Side Effect From render(), runningSideEffect() can be called with a given key and a function that will be called once by the Workflow Runtime. In Swift, a Lifetime object is also passed to runningSideEffect() which has an onEnded() closure that can be used for cleanup. In Kotlin, a coroutine scope is used to execute the function so it can be cancelled() at cleanup time. Given that any property (including the Sink) could be captured by the closure of the Side Effect this is the basic building block that can be used to interact with asynchronous (and often imperative) Workflow Children Worker A Child Workflow that provides only output, with no rendering \u2014 a pattern for doing asynchronous work in Workflows. In Kotlin, this is an actual Interface which provides a convenient way to specify asynchronous work that produces an Output and a handler for that Output which can provide an Action. There are Kotlin extensions to map Rx Observables and Kotlin Flows to create Worker implementations. In Swift, there are at least 3 different Worker types which are convenience wrappers around reactive APIs that facilitate performing work.","title":"Glossary"},{"location":"glossary/#glossary-of-terms","text":"Term Definition Reactive Programming A style of programming where data or events are pushed to the logic processing them rather than having the logic pull the data and events from a source. A representation of program logic as a series of operations on a stream of data that is performed while a subscription to that stream is active. Unidirectional Data Flow Data travels a single path from business logic to UI, and travels the entirety of that path in a single direction. Events travel a single path from UI to business logic and they travel the entirety of that path in a single direction. There are thus 2 sets of directed edges in the graph that are handled separately and neither set has any cycles or back edges on its own. Declarative Programming A declarative program declares the state it wants the system to be in rather than how that is accomplished. Imperative Programming An imperative program\u2019s code is a series of statements that directly change a program\u2019s state as a result of certain events. State Machine An abstraction that models a program\u2019s logic as a graph of a set of states and the transitions between them (edges). See: https://en.wikipedia.org/wiki/Finite-state_machine Idempotent A function whose side effects won\u2019t be repeated with multiple invocations, the result is purely a function of the input. In other words, if called multiple times with the same input, the result is the same. For Workflows, the render() function must be idempotent, as the runtime offers no guarantees for how many times it may be called. Workflow Runtime An event loop that executes a Workflow Tree. On each pass: 1. A Rendering is assembled by calling render() on each Node of the Workflow Tree with each parent Workflow given the option to incorporate the Renderings of its children into its own. 2. The event loop waits for an Action to be sent to the Sink. 3. This Action provides a (possibly updated) State for the Workflow that created it and possibly an Output. 4. Any Output emitted is processed in turn by an Action defined by the updated Workflow\u2019s parent again possibly updating its State and emitting an Output cascading up the hierarchy. 5. A new render() pass is made against the entire Workflow Tree with the updated States. We use the term Workflow Runtime to refer to the core code in the framework that executes this event loop, responding to Actions and invoking render(). Workflow (Instance) An object that defines the transitions and side effects of a state machine as, effectively, two functions: 1. Providing the first state: () -> State 2. Providing a rendering: (Props and State) -> (Rendering and Side Effect Invocations and Child Workflow Invocations) The Child Workflow Invocations declared by the render function result in calls to the children\u2019s render() functions in turn, allowing the parent render function to choose to incorporate child Rendering values into its own. A Workflow is not itself a state machine, and ideally has no state of its own. It is rather a schema that identifies a particular type of state machine that can be started in initialState() by the Workflow Runtime, and advanced by repeated invocations of render(). Note: there is significant fuzziness in using the term \u2018Workflow\u2019, as it can mean at times the class/struct that declares the Workflow behavior as well as the object representing the running Workflow Node. To understand the Runtime behavior, grasping this distinction is necessary and valuable, however, when using a Workflow, the formal distinction is less valuable than the mental model of how a Workflow will be run. Workflow (Node) An active state machine whose behavior is defined by a Workflow Instance. This is the object that is held by the Workflow Runtime and whose state is updated (or \u201cdriven\u201d) according to the behavior declared in the Workflow Instance. In Kotlin and Swift a Workflow Node is implemented with the private WorkflowNode class/struct. Workflow Lifecycle Every Workflow or Side Effect Node has a lifecycle that is determined by its parent. In the case of the root Workflow, this lifecycle is determined by how long the host of the root chooses to use the stream of Renderings from the root Workflow. In the case of a non-root Workflow or Side Effect \u2014 that is, in the case of a Child \u2014 its lifecycle is determined as follows: \u2022 Start: the first time its parent invokes the Child in the parent\u2019s own render() pass. \u2022 End: the first subsequent render() pass that does not invoke the Child. Note that in between Start and End, the Workflow, or Side Effect is not \u201cre-invoked\u201d in the sense of starting again with each render() pass, but rather the originally invoked instance continues to run until a render() call is made without invoking it. Workflow Tree The tree of Workflow Nodes sharing a root. Workflow Nodes can have children and form a hierarchy. Workflow Root The root of a Workflow Tree. This is owned by a host which starts the Workflow Runtime with a particular Workflow instance. RenderContext The object which provides access to the Workflow Runtime from a Workflow render method. Provides three services: \u2022 a Sink for accepting WorkflowActions \u2022 recursively rendering Workflow children \u2022 executing Side Effects Action Cascade When an event occurs and the handler provides an Action, this Action may possibly produce an Output for the parent Workflow which in turn has its own handler provide an Action that may produce an Output and onwards up the Workflow Tree. This is an Action Cascade. Render Pass The portion of the Workflow Runtime event loop which traverses the Workflow tree, calling render() on each Workflow Node. When the RenderContext Sink receives an Action an Action Cascade occurs and at the completion of the Action Cascade the Render Pass occurs. Output Event When a Child Workflow emits an Output value, this is an Output Event. Handlers are registered when a Child Workflow is invoked to transform the child\u2019s Output values to Actions, which can advance the state of the parent. UI Event Any occurrence in the UI of a program - e.g. click, drag, keypress - the listener for which has been connected to a callback in the Rendering of a Workflow. UI Event callbacks typically add Actions to the Sink, to advance the state of the Workflow. Action A type associated with a particular Workflow (Instance) that is responsible for transforming a given State into a new State and optionally emitting an Output. Actions are sent to the Sink to be processed by the Workflow Runtime. Sink The handle provided by the RenderContext to send Actions to the Workflow Runtime. These Actions are applied by the Workflow Runtime to advance a Workflow\u2019s State, and optionally produce an Output to be processed by the handler its parent registered. Props The set of input properties for a particular Workflow. This is the public state which is provided to a child Workflow by its parent, or to the root Workflow by its host. For Swift: The set of properties on the struct implementing the Workflow. For Kotlin: Parameter type PropsT type in the Workflow signature. In Kotlin there is a formal distinction between Props and other dependencies, typically provided as constructor parameters. State The type of the internal state of a Workflow implementation. Immutable State: The State object itself is immutable, in other words, its property values cannot be changed. What this means for Workflows is that the Workflow Runtime holds a canonical instance of the internal State of each Workflow. A Workflow\u2019s state is \u201cadvanced\u201d when that canonical instance is atomically replaced by one returned when an Action is invoked. State can only be mutated through WorkflowAction Rendering The externally available public representation of the state of a Workflow. It may include event handling functions. It is given a concrete type in the Workflow signature. Note that this \u201cRendering\u201d does not have to represent the UI of a program. The \u201cRendering\u201d is simply the published state of the Workflow, and could simply be data. Often that data is used to render UI, but it can be used in other ways \u2014 for example, as the implementation of a service API. Output The type of the object that can optionally be delivered to the Workflow\u2019s parent or the host of the root Workflow by an Action. Child Workflow A Workflow which has a parent. A parent may compose a child Workflow\u2019s Rendering into its own Rendering. Side Effect From render(), runningSideEffect() can be called with a given key and a function that will be called once by the Workflow Runtime. In Swift, a Lifetime object is also passed to runningSideEffect() which has an onEnded() closure that can be used for cleanup. In Kotlin, a coroutine scope is used to execute the function so it can be cancelled() at cleanup time. Given that any property (including the Sink) could be captured by the closure of the Side Effect this is the basic building block that can be used to interact with asynchronous (and often imperative) Workflow Children Worker A Child Workflow that provides only output, with no rendering \u2014 a pattern for doing asynchronous work in Workflows. In Kotlin, this is an actual Interface which provides a convenient way to specify asynchronous work that produces an Output and a handler for that Output which can provide an Action. There are Kotlin extensions to map Rx Observables and Kotlin Flows to create Worker implementations. In Swift, there are at least 3 different Worker types which are convenience wrappers around reactive APIs that facilitate performing work.","title":"Glossary of Terms"},{"location":"historical/","text":"Pre-1.0 Presentations and Resources \u00b6 Square Workflow \u2013 Droidcon NYC 2019 ( slides ) SF Android GDG @ Square 2019 - Hello Workflow (live coding) Android Dialogs 5-part Coding Series 1 , 2 , 3 , 4 , 5 Reactive Workflows a Year Later \u2013 Droidcon NYC 2018 The Reactive Workflow Pattern \u2013 Fragmented Podcast The Reactive Workflow Pattern Update \u2013 Droidcon SF 2017 The Rx Workflow Pattern \u2013 Droidcon NYC 2017 ( slides )","title":"Pre-1.0 Resources"},{"location":"historical/#pre-10-presentations-and-resources","text":"Square Workflow \u2013 Droidcon NYC 2019 ( slides ) SF Android GDG @ Square 2019 - Hello Workflow (live coding) Android Dialogs 5-part Coding Series 1 , 2 , 3 , 4 , 5 Reactive Workflows a Year Later \u2013 Droidcon NYC 2018 The Reactive Workflow Pattern \u2013 Fragmented Podcast The Reactive Workflow Pattern Update \u2013 Droidcon SF 2017 The Rx Workflow Pattern \u2013 Droidcon NYC 2017 ( slides )","title":"Pre-1.0 Presentations and Resources"},{"location":"kotlin/api/workflow/com.squareup.workflow1/","text":"// workflow / com.squareup.workflow1 Package com.squareup.workflow1 \u00b6 Types \u00b6 Name Summary BaseRenderContext [jvm] interface BaseRenderContext <out PropsT , StateT , in OutputT > Facilities for a Workflow to interact with other Workflow s and the outside world from inside a render function. ImpostorWorkflow [jvm] interface ImpostorWorkflow Optional interface that Workflow s should implement if they need the runtime to consider their identity to include a child workflow\u2019s identity. Two ImpostorWorkflow s with the same concrete class, but different realIdentifier s will be considered different workflows by the runtime. LifecycleWorker [jvm] abstract class LifecycleWorker : Worker < Nothing > Worker that performs some action when the worker is started and/or stopped. NoopWorkflowInterceptor [jvm] object NoopWorkflowInterceptor : WorkflowInterceptor A WorkflowInterceptor that does not intercept anything. RenderingAndSnapshot [jvm] class RenderingAndSnapshot <out RenderingT >(rendering: RenderingT , snapshot: TreeSnapshot ) Tuple of rendering and snapshot used by renderWorkflowIn . SimpleLoggingWorkflowInterceptor [jvm] open class SimpleLoggingWorkflowInterceptor : WorkflowInterceptor A WorkflowInterceptor that just prints all method calls using log. Sink [jvm] fun interface Sink <in T > An object that receives values (commonly events or WorkflowAction ). BaseRenderContext.actionSink implements this interface. Snapshot [jvm] class Snapshot A lazy wrapper of ByteString. Allows Workflow s to capture their state frequently, without worrying about performing unnecessary serialization work. StatefulWorkflow [jvm] abstract class StatefulWorkflow <in PropsT , StateT , out OutputT , out RenderingT > : Workflow < PropsT , OutputT , RenderingT > A composable, stateful object that can handle events, delegate to children, subscribe to arbitrary asynchronous events from the outside world, and be saved to a serialized form to be restored later. StatelessWorkflow [jvm] abstract class StatelessWorkflow <in PropsT , out OutputT , out RenderingT > : Workflow < PropsT , OutputT , RenderingT > Minimal implementation of Workflow that maintains no state of its own. TreeSnapshot [jvm] class TreeSnapshot Aggregate of all the snapshots of a tree of workflows. Worker [jvm] interface Worker <out OutputT > Represents a unit of asynchronous work that can have zero, one, or multiple outputs. Workflow [jvm] interface Workflow <in PropsT , out OutputT , out RenderingT > A composable, optionally-stateful object that can handle events , delegate to children , subscribe to arbitrary asynchronous events from the outside world. WorkflowAction [jvm] abstract class WorkflowAction <in PropsT , StateT , out OutputT > An atomic operation that updates the state of a Workflow , and also optionally emits an output. WorkflowIdentifier [jvm] class WorkflowIdentifier Represents a Workflow \u2018s \u201cidentity\u201d and is used by the runtime to determine whether a workflow is the same as one that was rendered in a previous render pass, in which case its state should be re-used; or if it\u2019s a new workflow and needs to be started. WorkflowInterceptor [jvm] interface WorkflowInterceptor Provides hooks into the workflow runtime that can be used to instrument or modify the behavior of workflows. WorkflowOutput [jvm] class WorkflowOutput <out OutputT >(value: OutputT ) Wrapper around a potentially-nullable OutputT value. Functions \u00b6 Name Summary action [jvm] fun < PropsT , StateT , OutputT > action (name: () -> String , apply: WorkflowAction.Updater < PropsT , StateT , OutputT >.() -> Unit ): WorkflowAction < PropsT , StateT , OutputT > fun < PropsT , StateT , OutputT > action (name: String = \u201c\u201d, apply: WorkflowAction.Updater < PropsT , StateT , OutputT >.() -> Unit ): WorkflowAction < PropsT , StateT , OutputT > Creates a WorkflowAction from the apply lambda. The returned object will include the string returned from name in its toString. [jvm] fun < PropsT , StateT , OutputT , RenderingT > StatefulWorkflow < PropsT , StateT , OutputT , RenderingT >. action (name: () -> String , update: WorkflowAction.Updater < PropsT , StateT , OutputT >.() -> Unit ): WorkflowAction < PropsT , StateT , OutputT > fun < PropsT , StateT , OutputT , RenderingT > StatefulWorkflow < PropsT , StateT , OutputT , RenderingT >. action (name: String = \u201c\u201d, update: WorkflowAction.Updater < PropsT , StateT , OutputT >.() -> Unit ): WorkflowAction < PropsT , StateT , OutputT > fun < PropsT , OutputT , RenderingT > StatelessWorkflow < PropsT , OutputT , RenderingT >. action (name: () -> String , update: WorkflowAction.Updater < PropsT , *, OutputT >.() -> Unit ): WorkflowAction < PropsT , Nothing , OutputT > fun < PropsT , OutputT , RenderingT > StatelessWorkflow < PropsT , OutputT , RenderingT >. action (name: String = \u201c\u201d, update: WorkflowAction.Updater < PropsT , *, OutputT >.() -> Unit ): WorkflowAction < PropsT , Nothing , OutputT > Convenience to create a WorkflowAction with parameter types matching those of the receiving StatefulWorkflow . The action will invoke the given lambda when it is applied . applyTo [jvm] fun < PropsT , StateT , OutputT > WorkflowAction < PropsT , StateT , OutputT >. applyTo (props: PropsT , state: StateT ): Pair < StateT , WorkflowOutput < OutputT >?> Applies this WorkflowAction to state . asWorker [jvm] inline fun < OutputT > Flow< OutputT >. asWorker (): Worker < OutputT > Returns a Worker that will, when performed, emit whatever this Flow receives. contraMap [jvm] fun < T1 , T2 > Sink < T1 >. contraMap (transform: ( T2 ) -> T1 ): Sink < T2 > Generates a new sink of type T2 . mapRendering [jvm] fun < PropsT , OutputT , FromRenderingT , ToRenderingT > Workflow < PropsT , OutputT , FromRenderingT >. mapRendering (transform: ( FromRenderingT ) -> ToRenderingT ): Workflow < PropsT , OutputT , ToRenderingT > Uses the given function to transform a Workflow that renders FromRenderingT to one renders ToRenderingT , parse [jvm] inline fun < T > ByteString. parse (block: (BufferedSource) -> T ): T Runs block with a BufferedSource that will read from this ByteString. readBooleanFromInt [jvm] fun BufferedSource. readBooleanFromInt (): Boolean readByteStringWithLength [jvm] fun BufferedSource. readByteStringWithLength (): ByteString readEnumByOrdinal [jvm] inline fun < T : Enum < T >> BufferedSource. readEnumByOrdinal (): T readFloat [jvm] fun BufferedSource. readFloat (): Float readList [jvm] inline fun < T > BufferedSource. readList (reader: BufferedSource.() -> T ): List < T > readNullable [jvm] fun < T : Any > BufferedSource. readNullable (reader: BufferedSource.() -> T ): T ? readOptionalEnumByOrdinal [jvm] inline fun < T : Enum < T >> BufferedSource. readOptionalEnumByOrdinal (): T ? readOptionalUtf8WithLength [jvm] fun BufferedSource. readOptionalUtf8WithLength (): String ? readUtf8WithLength [jvm] fun BufferedSource. readUtf8WithLength (): String renderChild [jvm] fun < PropsT , StateT , OutputT , ChildRenderingT > BaseRenderContext < PropsT , StateT , OutputT >. renderChild (child: Workflow < Unit , Nothing , ChildRenderingT >, key: String = \u201c\u201d): ChildRenderingT Convenience alias of BaseRenderContext.renderChild for children that don\u2019t take props or emit output. [jvm] fun < PropsT , ChildPropsT , StateT , OutputT , ChildRenderingT > BaseRenderContext < PropsT , StateT , OutputT >. renderChild (child: Workflow < ChildPropsT , Nothing , ChildRenderingT >, props: ChildPropsT , key: String = \u201c\u201d): ChildRenderingT Convenience alias of BaseRenderContext.renderChild for workflows that don\u2019t emit output. [jvm] fun < PropsT , StateT , OutputT , ChildOutputT , ChildRenderingT > BaseRenderContext < PropsT , StateT , OutputT >. renderChild (child: Workflow < Unit , ChildOutputT , ChildRenderingT >, key: String = \u201c\u201d, handler: ( ChildOutputT ) -> WorkflowAction < PropsT , StateT , OutputT >): ChildRenderingT Convenience alias of BaseRenderContext.renderChild for workflows that don\u2019t take props. RenderContext [jvm] fun < PropsT , OutputT , RenderingT > RenderContext (baseContext: BaseRenderContext < PropsT , *, OutputT >, workflow: StatelessWorkflow < PropsT , OutputT , RenderingT >): StatelessWorkflow.RenderContext < PropsT , OutputT , RenderingT > Creates a RenderContext from a BaseRenderContext for the given StatelessWorkflow . [jvm] fun < PropsT , StateT , OutputT , RenderingT > RenderContext (baseContext: BaseRenderContext < PropsT , StateT , OutputT >, workflow: StatefulWorkflow < PropsT , StateT , OutputT , RenderingT >): StatefulWorkflow.RenderContext < PropsT , StateT , OutputT , RenderingT > Creates a RenderContext from a BaseRenderContext for the given StatefulWorkflow . rendering [jvm] fun < RenderingT > Workflow.Companion . rendering (rendering: RenderingT ): Workflow < Unit , Nothing , RenderingT > Returns a workflow that does nothing but echo the given rendering . Handy for testing. renderWorkflowIn [jvm] fun < PropsT , OutputT , RenderingT > renderWorkflowIn (workflow: Workflow < PropsT , OutputT , RenderingT >, scope: CoroutineScope, props: StateFlow< PropsT >, initialSnapshot: TreeSnapshot ? = null, interceptors: List < WorkflowInterceptor > = emptyList(), onOutput: suspend ( OutputT ) -> Unit ): StateFlow< RenderingAndSnapshot < RenderingT >> Launches the workflow in a new coroutine in scope and returns a StateFlow of its renderings and snapshots . The workflow tree is seeded with initialSnapshot and the current value value of props . Subsequent values emitted from props will be used to re-render the workflow. runningWorker [jvm] inline fun < W : Worker < Nothing >, PropsT , StateT , OutputT > BaseRenderContext < PropsT , StateT , OutputT >. runningWorker (worker: W , key: String = \u201c\u201d) Ensures a Worker that never emits anything is running. Since worker can\u2019t emit anything, it can\u2019t trigger any WorkflowAction s. [jvm] inline fun < T , W : Worker < T >, PropsT , StateT , OutputT > BaseRenderContext < PropsT , StateT , OutputT >. runningWorker (worker: W , key: String = \u201c\u201d, noinline handler: ( T ) -> WorkflowAction < PropsT , StateT , OutputT >) Ensures worker is running. When the Worker emits an output, handler is called to determine the WorkflowAction to take. When the worker finishes, nothing happens (although another render pass may be triggered). stateful [jvm] inline fun < StateT , OutputT , RenderingT > Workflow.Companion . stateful (initialState: StateT , crossinline render: BaseRenderContext < Unit , StateT , OutputT >.( StateT ) -> RenderingT ): StatefulWorkflow < Unit , StateT , OutputT , RenderingT > Returns a stateful Workflow , with no props, implemented via the given function. [jvm] inline fun < PropsT , StateT , OutputT , RenderingT > Workflow.Companion . stateful (crossinline initialState: ( PropsT ) -> StateT , crossinline render: BaseRenderContext < PropsT , StateT , OutputT >.( PropsT , StateT ) -> RenderingT , crossinline onPropsChanged: ( PropsT , PropsT , StateT ) -> StateT = { _, _, state -> state }): StatefulWorkflow < PropsT , StateT , OutputT , RenderingT > inline fun < PropsT , StateT , OutputT , RenderingT > Workflow.Companion . stateful (crossinline initialState: ( PropsT , Snapshot ?) -> StateT , crossinline render: BaseRenderContext < PropsT , StateT , OutputT >.( PropsT , StateT ) -> RenderingT , crossinline snapshot: ( StateT ) -> Snapshot ?, crossinline onPropsChanged: ( PropsT , PropsT , StateT ) -> StateT = { _, _, state -> state }): StatefulWorkflow < PropsT , StateT , OutputT , RenderingT > Returns a stateful Workflow implemented via the given functions. [jvm] inline fun < StateT , OutputT , RenderingT > Workflow.Companion . stateful (crossinline initialState: ( Snapshot ?) -> StateT , crossinline render: BaseRenderContext < Unit , StateT , OutputT >.( StateT ) -> RenderingT , crossinline snapshot: ( StateT ) -> Snapshot ?): StatefulWorkflow < Unit , StateT , OutputT , RenderingT > Returns a stateful Workflow , with no props, implemented via the given functions. stateless [jvm] inline fun < PropsT , OutputT , RenderingT > Workflow.Companion . stateless (crossinline render: BaseRenderContext < PropsT , Nothing , OutputT >.( PropsT ) -> RenderingT ): Workflow < PropsT , OutputT , RenderingT > Returns a stateless Workflow via the given render function. transform [jvm] fun < T , R > Worker < T >. transform (transform: (Flow< T >) -> Flow< R >): Worker < R > Returns a Worker that transforms this Worker \u2018s Flow by calling transform . unsnapshottableIdentifier [jvm] fun unsnapshottableIdentifier (type: KType ): WorkflowIdentifier Creates a WorkflowIdentifier that is not capable of being snapshotted and will cause any ImpostorWorkflow workflow identified by it to also not be snapshotted. writeBooleanAsInt [jvm] fun BufferedSink. writeBooleanAsInt (bool: Boolean ): BufferedSink writeByteStringWithLength [jvm] fun BufferedSink. writeByteStringWithLength (bytes: ByteString): BufferedSink writeEnumByOrdinal [jvm] fun < T : Enum < T >> BufferedSink. writeEnumByOrdinal (enumVal: T ): BufferedSink writeFloat [jvm] fun BufferedSink. writeFloat (float: Float ): BufferedSink writeList [jvm] inline fun < T > BufferedSink. writeList (values: List < T >, writer: BufferedSink.( T ) -> Unit ): BufferedSink writeNullable [jvm] fun < T : Any > BufferedSink. writeNullable (obj: T ?, writer: BufferedSink.( T ) -> Unit ): BufferedSink writeOptionalEnumByOrdinal [jvm] fun < T : Enum < T >> BufferedSink. writeOptionalEnumByOrdinal (enumVal: T ?): BufferedSink writeOptionalUtf8WithLength [jvm] fun BufferedSink. writeOptionalUtf8WithLength (str: String ?): BufferedSink writeUtf8WithLength [jvm] fun BufferedSink. writeUtf8WithLength (str: String ): BufferedSink Properties \u00b6 Name Summary identifier [jvm] val Workflow <*, *, *>. identifier : WorkflowIdentifier The WorkflowIdentifier that identifies this Workflow . workflowIdentifier [jvm] @get:TestOnly val KClass <out Workflow <*, *, *>>. workflowIdentifier : WorkflowIdentifier The WorkflowIdentifier that identifies the workflow this KClass represents.","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1/#package-comsquareupworkflow1","text":"","title":"Package com.squareup.workflow1"},{"location":"kotlin/api/workflow/com.squareup.workflow1/#types","text":"Name Summary BaseRenderContext [jvm] interface BaseRenderContext <out PropsT , StateT , in OutputT > Facilities for a Workflow to interact with other Workflow s and the outside world from inside a render function. ImpostorWorkflow [jvm] interface ImpostorWorkflow Optional interface that Workflow s should implement if they need the runtime to consider their identity to include a child workflow\u2019s identity. Two ImpostorWorkflow s with the same concrete class, but different realIdentifier s will be considered different workflows by the runtime. LifecycleWorker [jvm] abstract class LifecycleWorker : Worker < Nothing > Worker that performs some action when the worker is started and/or stopped. NoopWorkflowInterceptor [jvm] object NoopWorkflowInterceptor : WorkflowInterceptor A WorkflowInterceptor that does not intercept anything. RenderingAndSnapshot [jvm] class RenderingAndSnapshot <out RenderingT >(rendering: RenderingT , snapshot: TreeSnapshot ) Tuple of rendering and snapshot used by renderWorkflowIn . SimpleLoggingWorkflowInterceptor [jvm] open class SimpleLoggingWorkflowInterceptor : WorkflowInterceptor A WorkflowInterceptor that just prints all method calls using log. Sink [jvm] fun interface Sink <in T > An object that receives values (commonly events or WorkflowAction ). BaseRenderContext.actionSink implements this interface. Snapshot [jvm] class Snapshot A lazy wrapper of ByteString. Allows Workflow s to capture their state frequently, without worrying about performing unnecessary serialization work. StatefulWorkflow [jvm] abstract class StatefulWorkflow <in PropsT , StateT , out OutputT , out RenderingT > : Workflow < PropsT , OutputT , RenderingT > A composable, stateful object that can handle events, delegate to children, subscribe to arbitrary asynchronous events from the outside world, and be saved to a serialized form to be restored later. StatelessWorkflow [jvm] abstract class StatelessWorkflow <in PropsT , out OutputT , out RenderingT > : Workflow < PropsT , OutputT , RenderingT > Minimal implementation of Workflow that maintains no state of its own. TreeSnapshot [jvm] class TreeSnapshot Aggregate of all the snapshots of a tree of workflows. Worker [jvm] interface Worker <out OutputT > Represents a unit of asynchronous work that can have zero, one, or multiple outputs. Workflow [jvm] interface Workflow <in PropsT , out OutputT , out RenderingT > A composable, optionally-stateful object that can handle events , delegate to children , subscribe to arbitrary asynchronous events from the outside world. WorkflowAction [jvm] abstract class WorkflowAction <in PropsT , StateT , out OutputT > An atomic operation that updates the state of a Workflow , and also optionally emits an output. WorkflowIdentifier [jvm] class WorkflowIdentifier Represents a Workflow \u2018s \u201cidentity\u201d and is used by the runtime to determine whether a workflow is the same as one that was rendered in a previous render pass, in which case its state should be re-used; or if it\u2019s a new workflow and needs to be started. WorkflowInterceptor [jvm] interface WorkflowInterceptor Provides hooks into the workflow runtime that can be used to instrument or modify the behavior of workflows. WorkflowOutput [jvm] class WorkflowOutput <out OutputT >(value: OutputT ) Wrapper around a potentially-nullable OutputT value.","title":"Types"},{"location":"kotlin/api/workflow/com.squareup.workflow1/#functions","text":"Name Summary action [jvm] fun < PropsT , StateT , OutputT > action (name: () -> String , apply: WorkflowAction.Updater < PropsT , StateT , OutputT >.() -> Unit ): WorkflowAction < PropsT , StateT , OutputT > fun < PropsT , StateT , OutputT > action (name: String = \u201c\u201d, apply: WorkflowAction.Updater < PropsT , StateT , OutputT >.() -> Unit ): WorkflowAction < PropsT , StateT , OutputT > Creates a WorkflowAction from the apply lambda. The returned object will include the string returned from name in its toString. [jvm] fun < PropsT , StateT , OutputT , RenderingT > StatefulWorkflow < PropsT , StateT , OutputT , RenderingT >. action (name: () -> String , update: WorkflowAction.Updater < PropsT , StateT , OutputT >.() -> Unit ): WorkflowAction < PropsT , StateT , OutputT > fun < PropsT , StateT , OutputT , RenderingT > StatefulWorkflow < PropsT , StateT , OutputT , RenderingT >. action (name: String = \u201c\u201d, update: WorkflowAction.Updater < PropsT , StateT , OutputT >.() -> Unit ): WorkflowAction < PropsT , StateT , OutputT > fun < PropsT , OutputT , RenderingT > StatelessWorkflow < PropsT , OutputT , RenderingT >. action (name: () -> String , update: WorkflowAction.Updater < PropsT , *, OutputT >.() -> Unit ): WorkflowAction < PropsT , Nothing , OutputT > fun < PropsT , OutputT , RenderingT > StatelessWorkflow < PropsT , OutputT , RenderingT >. action (name: String = \u201c\u201d, update: WorkflowAction.Updater < PropsT , *, OutputT >.() -> Unit ): WorkflowAction < PropsT , Nothing , OutputT > Convenience to create a WorkflowAction with parameter types matching those of the receiving StatefulWorkflow . The action will invoke the given lambda when it is applied . applyTo [jvm] fun < PropsT , StateT , OutputT > WorkflowAction < PropsT , StateT , OutputT >. applyTo (props: PropsT , state: StateT ): Pair < StateT , WorkflowOutput < OutputT >?> Applies this WorkflowAction to state . asWorker [jvm] inline fun < OutputT > Flow< OutputT >. asWorker (): Worker < OutputT > Returns a Worker that will, when performed, emit whatever this Flow receives. contraMap [jvm] fun < T1 , T2 > Sink < T1 >. contraMap (transform: ( T2 ) -> T1 ): Sink < T2 > Generates a new sink of type T2 . mapRendering [jvm] fun < PropsT , OutputT , FromRenderingT , ToRenderingT > Workflow < PropsT , OutputT , FromRenderingT >. mapRendering (transform: ( FromRenderingT ) -> ToRenderingT ): Workflow < PropsT , OutputT , ToRenderingT > Uses the given function to transform a Workflow that renders FromRenderingT to one renders ToRenderingT , parse [jvm] inline fun < T > ByteString. parse (block: (BufferedSource) -> T ): T Runs block with a BufferedSource that will read from this ByteString. readBooleanFromInt [jvm] fun BufferedSource. readBooleanFromInt (): Boolean readByteStringWithLength [jvm] fun BufferedSource. readByteStringWithLength (): ByteString readEnumByOrdinal [jvm] inline fun < T : Enum < T >> BufferedSource. readEnumByOrdinal (): T readFloat [jvm] fun BufferedSource. readFloat (): Float readList [jvm] inline fun < T > BufferedSource. readList (reader: BufferedSource.() -> T ): List < T > readNullable [jvm] fun < T : Any > BufferedSource. readNullable (reader: BufferedSource.() -> T ): T ? readOptionalEnumByOrdinal [jvm] inline fun < T : Enum < T >> BufferedSource. readOptionalEnumByOrdinal (): T ? readOptionalUtf8WithLength [jvm] fun BufferedSource. readOptionalUtf8WithLength (): String ? readUtf8WithLength [jvm] fun BufferedSource. readUtf8WithLength (): String renderChild [jvm] fun < PropsT , StateT , OutputT , ChildRenderingT > BaseRenderContext < PropsT , StateT , OutputT >. renderChild (child: Workflow < Unit , Nothing , ChildRenderingT >, key: String = \u201c\u201d): ChildRenderingT Convenience alias of BaseRenderContext.renderChild for children that don\u2019t take props or emit output. [jvm] fun < PropsT , ChildPropsT , StateT , OutputT , ChildRenderingT > BaseRenderContext < PropsT , StateT , OutputT >. renderChild (child: Workflow < ChildPropsT , Nothing , ChildRenderingT >, props: ChildPropsT , key: String = \u201c\u201d): ChildRenderingT Convenience alias of BaseRenderContext.renderChild for workflows that don\u2019t emit output. [jvm] fun < PropsT , StateT , OutputT , ChildOutputT , ChildRenderingT > BaseRenderContext < PropsT , StateT , OutputT >. renderChild (child: Workflow < Unit , ChildOutputT , ChildRenderingT >, key: String = \u201c\u201d, handler: ( ChildOutputT ) -> WorkflowAction < PropsT , StateT , OutputT >): ChildRenderingT Convenience alias of BaseRenderContext.renderChild for workflows that don\u2019t take props. RenderContext [jvm] fun < PropsT , OutputT , RenderingT > RenderContext (baseContext: BaseRenderContext < PropsT , *, OutputT >, workflow: StatelessWorkflow < PropsT , OutputT , RenderingT >): StatelessWorkflow.RenderContext < PropsT , OutputT , RenderingT > Creates a RenderContext from a BaseRenderContext for the given StatelessWorkflow . [jvm] fun < PropsT , StateT , OutputT , RenderingT > RenderContext (baseContext: BaseRenderContext < PropsT , StateT , OutputT >, workflow: StatefulWorkflow < PropsT , StateT , OutputT , RenderingT >): StatefulWorkflow.RenderContext < PropsT , StateT , OutputT , RenderingT > Creates a RenderContext from a BaseRenderContext for the given StatefulWorkflow . rendering [jvm] fun < RenderingT > Workflow.Companion . rendering (rendering: RenderingT ): Workflow < Unit , Nothing , RenderingT > Returns a workflow that does nothing but echo the given rendering . Handy for testing. renderWorkflowIn [jvm] fun < PropsT , OutputT , RenderingT > renderWorkflowIn (workflow: Workflow < PropsT , OutputT , RenderingT >, scope: CoroutineScope, props: StateFlow< PropsT >, initialSnapshot: TreeSnapshot ? = null, interceptors: List < WorkflowInterceptor > = emptyList(), onOutput: suspend ( OutputT ) -> Unit ): StateFlow< RenderingAndSnapshot < RenderingT >> Launches the workflow in a new coroutine in scope and returns a StateFlow of its renderings and snapshots . The workflow tree is seeded with initialSnapshot and the current value value of props . Subsequent values emitted from props will be used to re-render the workflow. runningWorker [jvm] inline fun < W : Worker < Nothing >, PropsT , StateT , OutputT > BaseRenderContext < PropsT , StateT , OutputT >. runningWorker (worker: W , key: String = \u201c\u201d) Ensures a Worker that never emits anything is running. Since worker can\u2019t emit anything, it can\u2019t trigger any WorkflowAction s. [jvm] inline fun < T , W : Worker < T >, PropsT , StateT , OutputT > BaseRenderContext < PropsT , StateT , OutputT >. runningWorker (worker: W , key: String = \u201c\u201d, noinline handler: ( T ) -> WorkflowAction < PropsT , StateT , OutputT >) Ensures worker is running. When the Worker emits an output, handler is called to determine the WorkflowAction to take. When the worker finishes, nothing happens (although another render pass may be triggered). stateful [jvm] inline fun < StateT , OutputT , RenderingT > Workflow.Companion . stateful (initialState: StateT , crossinline render: BaseRenderContext < Unit , StateT , OutputT >.( StateT ) -> RenderingT ): StatefulWorkflow < Unit , StateT , OutputT , RenderingT > Returns a stateful Workflow , with no props, implemented via the given function. [jvm] inline fun < PropsT , StateT , OutputT , RenderingT > Workflow.Companion . stateful (crossinline initialState: ( PropsT ) -> StateT , crossinline render: BaseRenderContext < PropsT , StateT , OutputT >.( PropsT , StateT ) -> RenderingT , crossinline onPropsChanged: ( PropsT , PropsT , StateT ) -> StateT = { _, _, state -> state }): StatefulWorkflow < PropsT , StateT , OutputT , RenderingT > inline fun < PropsT , StateT , OutputT , RenderingT > Workflow.Companion . stateful (crossinline initialState: ( PropsT , Snapshot ?) -> StateT , crossinline render: BaseRenderContext < PropsT , StateT , OutputT >.( PropsT , StateT ) -> RenderingT , crossinline snapshot: ( StateT ) -> Snapshot ?, crossinline onPropsChanged: ( PropsT , PropsT , StateT ) -> StateT = { _, _, state -> state }): StatefulWorkflow < PropsT , StateT , OutputT , RenderingT > Returns a stateful Workflow implemented via the given functions. [jvm] inline fun < StateT , OutputT , RenderingT > Workflow.Companion . stateful (crossinline initialState: ( Snapshot ?) -> StateT , crossinline render: BaseRenderContext < Unit , StateT , OutputT >.( StateT ) -> RenderingT , crossinline snapshot: ( StateT ) -> Snapshot ?): StatefulWorkflow < Unit , StateT , OutputT , RenderingT > Returns a stateful Workflow , with no props, implemented via the given functions. stateless [jvm] inline fun < PropsT , OutputT , RenderingT > Workflow.Companion . stateless (crossinline render: BaseRenderContext < PropsT , Nothing , OutputT >.( PropsT ) -> RenderingT ): Workflow < PropsT , OutputT , RenderingT > Returns a stateless Workflow via the given render function. transform [jvm] fun < T , R > Worker < T >. transform (transform: (Flow< T >) -> Flow< R >): Worker < R > Returns a Worker that transforms this Worker \u2018s Flow by calling transform . unsnapshottableIdentifier [jvm] fun unsnapshottableIdentifier (type: KType ): WorkflowIdentifier Creates a WorkflowIdentifier that is not capable of being snapshotted and will cause any ImpostorWorkflow workflow identified by it to also not be snapshotted. writeBooleanAsInt [jvm] fun BufferedSink. writeBooleanAsInt (bool: Boolean ): BufferedSink writeByteStringWithLength [jvm] fun BufferedSink. writeByteStringWithLength (bytes: ByteString): BufferedSink writeEnumByOrdinal [jvm] fun < T : Enum < T >> BufferedSink. writeEnumByOrdinal (enumVal: T ): BufferedSink writeFloat [jvm] fun BufferedSink. writeFloat (float: Float ): BufferedSink writeList [jvm] inline fun < T > BufferedSink. writeList (values: List < T >, writer: BufferedSink.( T ) -> Unit ): BufferedSink writeNullable [jvm] fun < T : Any > BufferedSink. writeNullable (obj: T ?, writer: BufferedSink.( T ) -> Unit ): BufferedSink writeOptionalEnumByOrdinal [jvm] fun < T : Enum < T >> BufferedSink. writeOptionalEnumByOrdinal (enumVal: T ?): BufferedSink writeOptionalUtf8WithLength [jvm] fun BufferedSink. writeOptionalUtf8WithLength (str: String ?): BufferedSink writeUtf8WithLength [jvm] fun BufferedSink. writeUtf8WithLength (str: String ): BufferedSink","title":"Functions"},{"location":"kotlin/api/workflow/com.squareup.workflow1/#properties","text":"Name Summary identifier [jvm] val Workflow <*, *, *>. identifier : WorkflowIdentifier The WorkflowIdentifier that identifies this Workflow . workflowIdentifier [jvm] @get:TestOnly val KClass <out Workflow <*, *, *>>. workflowIdentifier : WorkflowIdentifier The WorkflowIdentifier that identifies the workflow this KClass represents.","title":"Properties"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-render-context/","text":"// workflow / com.squareup.workflow1 / RenderContext RenderContext \u00b6 [jvm]\\ fun < PropsT , StateT , OutputT , RenderingT > RenderContext (baseContext: BaseRenderContext < PropsT , StateT , OutputT >, workflow: StatefulWorkflow < PropsT , StateT , OutputT , RenderingT >): StatefulWorkflow.RenderContext < PropsT , StateT , OutputT , RenderingT > Creates a RenderContext from a BaseRenderContext for the given StatefulWorkflow . [jvm]\\ fun < PropsT , OutputT , RenderingT > RenderContext (baseContext: BaseRenderContext < PropsT , *, OutputT >, workflow: StatelessWorkflow < PropsT , OutputT , RenderingT >): StatelessWorkflow.RenderContext < PropsT , OutputT , RenderingT > Creates a RenderContext from a BaseRenderContext for the given StatelessWorkflow .","title":" render context"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-render-context/#rendercontext","text":"[jvm]\\ fun < PropsT , StateT , OutputT , RenderingT > RenderContext (baseContext: BaseRenderContext < PropsT , StateT , OutputT >, workflow: StatefulWorkflow < PropsT , StateT , OutputT , RenderingT >): StatefulWorkflow.RenderContext < PropsT , StateT , OutputT , RenderingT > Creates a RenderContext from a BaseRenderContext for the given StatefulWorkflow . [jvm]\\ fun < PropsT , OutputT , RenderingT > RenderContext (baseContext: BaseRenderContext < PropsT , *, OutputT >, workflow: StatelessWorkflow < PropsT , OutputT , RenderingT >): StatelessWorkflow.RenderContext < PropsT , OutputT , RenderingT > Creates a RenderContext from a BaseRenderContext for the given StatelessWorkflow .","title":"RenderContext"},{"location":"kotlin/api/workflow/com.squareup.workflow1/action/","text":"// workflow / com.squareup.workflow1 / action action \u00b6 [jvm]\\ fun < PropsT , StateT , OutputT , RenderingT > StatefulWorkflow < PropsT , StateT , OutputT , RenderingT >. action (name: String = \u201c\u201d, update: WorkflowAction.Updater < PropsT , StateT , OutputT >.() -> Unit ): WorkflowAction < PropsT , StateT , OutputT > Convenience to create a WorkflowAction with parameter types matching those of the receiving StatefulWorkflow . The action will invoke the given lambda when it is applied . Parameters \u00b6 jvm name A string describing the update for debugging, included in toString. update Function that defines the workflow update. [jvm]\\ fun < PropsT , StateT , OutputT , RenderingT > StatefulWorkflow < PropsT , StateT , OutputT , RenderingT >. action (name: () -> String , update: WorkflowAction.Updater < PropsT , StateT , OutputT >.() -> Unit ): WorkflowAction < PropsT , StateT , OutputT > Convenience to create a WorkflowAction with parameter types matching those of the receiving StatefulWorkflow . The action will invoke the given lambda when it is applied . Parameters \u00b6 jvm name Function that returns a string describing the update for debugging, included in toString. update Function that defines the workflow update. [jvm]\\ fun < PropsT , OutputT , RenderingT > StatelessWorkflow < PropsT , OutputT , RenderingT >. action (name: String = \u201c\u201d, update: WorkflowAction.Updater < PropsT , *, OutputT >.() -> Unit ): WorkflowAction < PropsT , Nothing , OutputT > Convenience to create a WorkflowAction with parameter types matching those of the receiving StatefulWorkflow . The action will invoke the given lambda when it is applied . Parameters \u00b6 jvm name A string describing the update for debugging, included in toString . update Function that defines the workflow update. [jvm]\\ fun < PropsT , OutputT , RenderingT > StatelessWorkflow < PropsT , OutputT , RenderingT >. action (name: () -> String , update: WorkflowAction.Updater < PropsT , *, OutputT >.() -> Unit ): WorkflowAction < PropsT , Nothing , OutputT > Convenience to create a WorkflowAction with parameter types matching those of the receiving StatefulWorkflow . The action will invoke the given lambda when it is applied . Parameters \u00b6 jvm name Function that returns a string describing the update for debugging, included in toString . update Function that defines the workflow update. [jvm]\\ fun < PropsT , StateT , OutputT > action (name: String = \u201c\u201d, apply: WorkflowAction.Updater < PropsT , StateT , OutputT >.() -> Unit ): WorkflowAction < PropsT , StateT , OutputT > Creates a WorkflowAction from the apply lambda. The returned object will include the string returned from name in its toString. It is more common to use StatefulWorkflow.action or StatelessWorkflow.action instead of this function directly, to avoid repeating its parameter types. See also \u00b6 jvm StatelessWorkflow.action StatefulWorkflow.action Parameters \u00b6 jvm name A string describing the update for debugging. apply Function that defines the workflow update. [jvm]\\ fun < PropsT , StateT , OutputT > action (name: () -> String , apply: WorkflowAction.Updater < PropsT , StateT , OutputT >.() -> Unit ): WorkflowAction < PropsT , StateT , OutputT > Creates a WorkflowAction from the apply lambda. The returned object will include the string returned from name in its toString. It is more common to use StatefulWorkflow.action or StatelessWorkflow.action instead of this function directly, to avoid repeating its parameter types. See also \u00b6 jvm StatelessWorkflow.action StatefulWorkflow.action Parameters \u00b6 jvm name Function that returns a string describing the update for debugging. apply Function that defines the workflow update.","title":"Action"},{"location":"kotlin/api/workflow/com.squareup.workflow1/action/#action","text":"[jvm]\\ fun < PropsT , StateT , OutputT , RenderingT > StatefulWorkflow < PropsT , StateT , OutputT , RenderingT >. action (name: String = \u201c\u201d, update: WorkflowAction.Updater < PropsT , StateT , OutputT >.() -> Unit ): WorkflowAction < PropsT , StateT , OutputT > Convenience to create a WorkflowAction with parameter types matching those of the receiving StatefulWorkflow . The action will invoke the given lambda when it is applied .","title":"action"},{"location":"kotlin/api/workflow/com.squareup.workflow1/action/#parameters","text":"jvm name A string describing the update for debugging, included in toString. update Function that defines the workflow update. [jvm]\\ fun < PropsT , StateT , OutputT , RenderingT > StatefulWorkflow < PropsT , StateT , OutputT , RenderingT >. action (name: () -> String , update: WorkflowAction.Updater < PropsT , StateT , OutputT >.() -> Unit ): WorkflowAction < PropsT , StateT , OutputT > Convenience to create a WorkflowAction with parameter types matching those of the receiving StatefulWorkflow . The action will invoke the given lambda when it is applied .","title":"Parameters"},{"location":"kotlin/api/workflow/com.squareup.workflow1/action/#parameters_1","text":"jvm name Function that returns a string describing the update for debugging, included in toString. update Function that defines the workflow update. [jvm]\\ fun < PropsT , OutputT , RenderingT > StatelessWorkflow < PropsT , OutputT , RenderingT >. action (name: String = \u201c\u201d, update: WorkflowAction.Updater < PropsT , *, OutputT >.() -> Unit ): WorkflowAction < PropsT , Nothing , OutputT > Convenience to create a WorkflowAction with parameter types matching those of the receiving StatefulWorkflow . The action will invoke the given lambda when it is applied .","title":"Parameters"},{"location":"kotlin/api/workflow/com.squareup.workflow1/action/#parameters_2","text":"jvm name A string describing the update for debugging, included in toString . update Function that defines the workflow update. [jvm]\\ fun < PropsT , OutputT , RenderingT > StatelessWorkflow < PropsT , OutputT , RenderingT >. action (name: () -> String , update: WorkflowAction.Updater < PropsT , *, OutputT >.() -> Unit ): WorkflowAction < PropsT , Nothing , OutputT > Convenience to create a WorkflowAction with parameter types matching those of the receiving StatefulWorkflow . The action will invoke the given lambda when it is applied .","title":"Parameters"},{"location":"kotlin/api/workflow/com.squareup.workflow1/action/#parameters_3","text":"jvm name Function that returns a string describing the update for debugging, included in toString . update Function that defines the workflow update. [jvm]\\ fun < PropsT , StateT , OutputT > action (name: String = \u201c\u201d, apply: WorkflowAction.Updater < PropsT , StateT , OutputT >.() -> Unit ): WorkflowAction < PropsT , StateT , OutputT > Creates a WorkflowAction from the apply lambda. The returned object will include the string returned from name in its toString. It is more common to use StatefulWorkflow.action or StatelessWorkflow.action instead of this function directly, to avoid repeating its parameter types.","title":"Parameters"},{"location":"kotlin/api/workflow/com.squareup.workflow1/action/#see-also","text":"jvm StatelessWorkflow.action StatefulWorkflow.action","title":"See also"},{"location":"kotlin/api/workflow/com.squareup.workflow1/action/#parameters_4","text":"jvm name A string describing the update for debugging. apply Function that defines the workflow update. [jvm]\\ fun < PropsT , StateT , OutputT > action (name: () -> String , apply: WorkflowAction.Updater < PropsT , StateT , OutputT >.() -> Unit ): WorkflowAction < PropsT , StateT , OutputT > Creates a WorkflowAction from the apply lambda. The returned object will include the string returned from name in its toString. It is more common to use StatefulWorkflow.action or StatelessWorkflow.action instead of this function directly, to avoid repeating its parameter types.","title":"Parameters"},{"location":"kotlin/api/workflow/com.squareup.workflow1/action/#see-also_1","text":"jvm StatelessWorkflow.action StatefulWorkflow.action","title":"See also"},{"location":"kotlin/api/workflow/com.squareup.workflow1/action/#parameters_5","text":"jvm name Function that returns a string describing the update for debugging. apply Function that defines the workflow update.","title":"Parameters"},{"location":"kotlin/api/workflow/com.squareup.workflow1/apply-to/","text":"// workflow / com.squareup.workflow1 / applyTo applyTo \u00b6 [jvm]\\ fun < PropsT , StateT , OutputT > WorkflowAction < PropsT , StateT , OutputT >. applyTo (props: PropsT , state: StateT ): Pair < StateT , WorkflowOutput < OutputT >?> Applies this WorkflowAction to state .","title":"Apply to"},{"location":"kotlin/api/workflow/com.squareup.workflow1/apply-to/#applyto","text":"[jvm]\\ fun < PropsT , StateT , OutputT > WorkflowAction < PropsT , StateT , OutputT >. applyTo (props: PropsT , state: StateT ): Pair < StateT , WorkflowOutput < OutputT >?> Applies this WorkflowAction to state .","title":"applyTo"},{"location":"kotlin/api/workflow/com.squareup.workflow1/as-worker/","text":"// workflow / com.squareup.workflow1 / asWorker asWorker \u00b6 [jvm]\\ inline fun < OutputT > Flow< OutputT >. asWorker (): Worker < OutputT > Returns a Worker that will, when performed, emit whatever this Flow receives.","title":"As worker"},{"location":"kotlin/api/workflow/com.squareup.workflow1/as-worker/#asworker","text":"[jvm]\\ inline fun < OutputT > Flow< OutputT >. asWorker (): Worker < OutputT > Returns a Worker that will, when performed, emit whatever this Flow receives.","title":"asWorker"},{"location":"kotlin/api/workflow/com.squareup.workflow1/contra-map/","text":"// workflow / com.squareup.workflow1 / contraMap contraMap \u00b6 [jvm]\\ fun < T1 , T2 > Sink < T1 >. contraMap (transform: ( T2 ) -> T1 ): Sink < T2 > Generates a new sink of type T2 . Given a transform closure, the following code is functionally equivalent: 1 2 3 sink.send(transform(value)) sink.contraMap(transform).send(value) Trivia : Why is this called contraMap? - map turns Type<T> into Type<U> via (T)->U. - contraMap turns Type<T> into Type<U> via (U)->T Another way to think about this is: map transforms a type by changing the output types of its API, while contraMap transforms a type by changing the input types of its API.","title":"Contra map"},{"location":"kotlin/api/workflow/com.squareup.workflow1/contra-map/#contramap","text":"[jvm]\\ fun < T1 , T2 > Sink < T1 >. contraMap (transform: ( T2 ) -> T1 ): Sink < T2 > Generates a new sink of type T2 . Given a transform closure, the following code is functionally equivalent: 1 2 3 sink.send(transform(value)) sink.contraMap(transform).send(value) Trivia : Why is this called contraMap? - map turns Type<T> into Type<U> via (T)->U. - contraMap turns Type<T> into Type<U> via (U)->T Another way to think about this is: map transforms a type by changing the output types of its API, while contraMap transforms a type by changing the input types of its API.","title":"contraMap"},{"location":"kotlin/api/workflow/com.squareup.workflow1/identifier/","text":"// workflow / com.squareup.workflow1 / identifier identifier \u00b6 [jvm]\\ val Workflow <*, *, *>. identifier : WorkflowIdentifier The WorkflowIdentifier that identifies this Workflow .","title":"Identifier"},{"location":"kotlin/api/workflow/com.squareup.workflow1/identifier/#identifier","text":"[jvm]\\ val Workflow <*, *, *>. identifier : WorkflowIdentifier The WorkflowIdentifier that identifies this Workflow .","title":"identifier"},{"location":"kotlin/api/workflow/com.squareup.workflow1/map-rendering/","text":"// workflow / com.squareup.workflow1 / mapRendering mapRendering \u00b6 [jvm]\\ fun < PropsT , OutputT , FromRenderingT , ToRenderingT > Workflow < PropsT , OutputT , FromRenderingT >. mapRendering (transform: ( FromRenderingT ) -> ToRenderingT ): Workflow < PropsT , OutputT , ToRenderingT > Uses the given function to transform a Workflow that renders FromRenderingT to one renders ToRenderingT ,","title":"Map rendering"},{"location":"kotlin/api/workflow/com.squareup.workflow1/map-rendering/#maprendering","text":"[jvm]\\ fun < PropsT , OutputT , FromRenderingT , ToRenderingT > Workflow < PropsT , OutputT , FromRenderingT >. mapRendering (transform: ( FromRenderingT ) -> ToRenderingT ): Workflow < PropsT , OutputT , ToRenderingT > Uses the given function to transform a Workflow that renders FromRenderingT to one renders ToRenderingT ,","title":"mapRendering"},{"location":"kotlin/api/workflow/com.squareup.workflow1/parse/","text":"// workflow / com.squareup.workflow1 / parse parse \u00b6 [jvm]\\ inline fun < T > ByteString. parse (block: (BufferedSource) -> T ): T Runs block with a BufferedSource that will read from this ByteString. Lets you do stuff like: myBlob.parse {\\ MyValueObject(\\ name = it.readUtf8WithLength(),\\ age = it.readInt()\\ )\\ }","title":"Parse"},{"location":"kotlin/api/workflow/com.squareup.workflow1/parse/#parse","text":"[jvm]\\ inline fun < T > ByteString. parse (block: (BufferedSource) -> T ): T Runs block with a BufferedSource that will read from this ByteString. Lets you do stuff like: myBlob.parse {\\ MyValueObject(\\ name = it.readUtf8WithLength(),\\ age = it.readInt()\\ )\\ }","title":"parse"},{"location":"kotlin/api/workflow/com.squareup.workflow1/read-boolean-from-int/","text":"// workflow / com.squareup.workflow1 / readBooleanFromInt readBooleanFromInt \u00b6 [jvm]\\ fun BufferedSource. readBooleanFromInt (): Boolean","title":"Read boolean from int"},{"location":"kotlin/api/workflow/com.squareup.workflow1/read-boolean-from-int/#readbooleanfromint","text":"[jvm]\\ fun BufferedSource. readBooleanFromInt (): Boolean","title":"readBooleanFromInt"},{"location":"kotlin/api/workflow/com.squareup.workflow1/read-byte-string-with-length/","text":"// workflow / com.squareup.workflow1 / readByteStringWithLength readByteStringWithLength \u00b6 [jvm]\\ fun BufferedSource. readByteStringWithLength (): ByteString","title":"Read byte string with length"},{"location":"kotlin/api/workflow/com.squareup.workflow1/read-byte-string-with-length/#readbytestringwithlength","text":"[jvm]\\ fun BufferedSource. readByteStringWithLength (): ByteString","title":"readByteStringWithLength"},{"location":"kotlin/api/workflow/com.squareup.workflow1/read-enum-by-ordinal/","text":"// workflow / com.squareup.workflow1 / readEnumByOrdinal readEnumByOrdinal \u00b6 [jvm]\\ inline fun < T : Enum < T >> BufferedSource. readEnumByOrdinal (): T","title":"Read enum by ordinal"},{"location":"kotlin/api/workflow/com.squareup.workflow1/read-enum-by-ordinal/#readenumbyordinal","text":"[jvm]\\ inline fun < T : Enum < T >> BufferedSource. readEnumByOrdinal (): T","title":"readEnumByOrdinal"},{"location":"kotlin/api/workflow/com.squareup.workflow1/read-float/","text":"// workflow / com.squareup.workflow1 / readFloat readFloat \u00b6 [jvm]\\ fun BufferedSource. readFloat (): Float","title":"Read float"},{"location":"kotlin/api/workflow/com.squareup.workflow1/read-float/#readfloat","text":"[jvm]\\ fun BufferedSource. readFloat (): Float","title":"readFloat"},{"location":"kotlin/api/workflow/com.squareup.workflow1/read-list/","text":"// workflow / com.squareup.workflow1 / readList readList \u00b6 [jvm]\\ inline fun < T > BufferedSource. readList (reader: BufferedSource.() -> T ): List < T >","title":"Read list"},{"location":"kotlin/api/workflow/com.squareup.workflow1/read-list/#readlist","text":"[jvm]\\ inline fun < T > BufferedSource. readList (reader: BufferedSource.() -> T ): List < T >","title":"readList"},{"location":"kotlin/api/workflow/com.squareup.workflow1/read-nullable/","text":"// workflow / com.squareup.workflow1 / readNullable readNullable \u00b6 [jvm]\\ fun < T : Any > BufferedSource. readNullable (reader: BufferedSource.() -> T ): T ?","title":"Read nullable"},{"location":"kotlin/api/workflow/com.squareup.workflow1/read-nullable/#readnullable","text":"[jvm]\\ fun < T : Any > BufferedSource. readNullable (reader: BufferedSource.() -> T ): T ?","title":"readNullable"},{"location":"kotlin/api/workflow/com.squareup.workflow1/read-optional-enum-by-ordinal/","text":"// workflow / com.squareup.workflow1 / readOptionalEnumByOrdinal readOptionalEnumByOrdinal \u00b6 [jvm]\\ inline fun < T : Enum < T >> BufferedSource. readOptionalEnumByOrdinal (): T ?","title":"Read optional enum by ordinal"},{"location":"kotlin/api/workflow/com.squareup.workflow1/read-optional-enum-by-ordinal/#readoptionalenumbyordinal","text":"[jvm]\\ inline fun < T : Enum < T >> BufferedSource. readOptionalEnumByOrdinal (): T ?","title":"readOptionalEnumByOrdinal"},{"location":"kotlin/api/workflow/com.squareup.workflow1/read-optional-utf8-with-length/","text":"// workflow / com.squareup.workflow1 / readOptionalUtf8WithLength readOptionalUtf8WithLength \u00b6 [jvm]\\ fun BufferedSource. readOptionalUtf8WithLength (): String ?","title":"Read optional utf8 with length"},{"location":"kotlin/api/workflow/com.squareup.workflow1/read-optional-utf8-with-length/#readoptionalutf8withlength","text":"[jvm]\\ fun BufferedSource. readOptionalUtf8WithLength (): String ?","title":"readOptionalUtf8WithLength"},{"location":"kotlin/api/workflow/com.squareup.workflow1/read-utf8-with-length/","text":"// workflow / com.squareup.workflow1 / readUtf8WithLength readUtf8WithLength \u00b6 [jvm]\\ fun BufferedSource. readUtf8WithLength (): String","title":"Read utf8 with length"},{"location":"kotlin/api/workflow/com.squareup.workflow1/read-utf8-with-length/#readutf8withlength","text":"[jvm]\\ fun BufferedSource. readUtf8WithLength (): String","title":"readUtf8WithLength"},{"location":"kotlin/api/workflow/com.squareup.workflow1/render-child/","text":"// workflow / com.squareup.workflow1 / renderChild renderChild \u00b6 [jvm]\\ fun < PropsT , StateT , OutputT , ChildOutputT , ChildRenderingT > BaseRenderContext < PropsT , StateT , OutputT >. renderChild (child: Workflow < Unit , ChildOutputT , ChildRenderingT >, key: String = \u201c\u201d, handler: ( ChildOutputT ) -> WorkflowAction < PropsT , StateT , OutputT >): ChildRenderingT Convenience alias of BaseRenderContext.renderChild for workflows that don\u2019t take props. [jvm]\\ fun < PropsT , ChildPropsT , StateT , OutputT , ChildRenderingT > BaseRenderContext < PropsT , StateT , OutputT >. renderChild (child: Workflow < ChildPropsT , Nothing , ChildRenderingT >, props: ChildPropsT , key: String = \u201c\u201d): ChildRenderingT Convenience alias of BaseRenderContext.renderChild for workflows that don\u2019t emit output. [jvm]\\ fun < PropsT , StateT , OutputT , ChildRenderingT > BaseRenderContext < PropsT , StateT , OutputT >. renderChild (child: Workflow < Unit , Nothing , ChildRenderingT >, key: String = \u201c\u201d): ChildRenderingT Convenience alias of BaseRenderContext.renderChild for children that don\u2019t take props or emit output.","title":"Render child"},{"location":"kotlin/api/workflow/com.squareup.workflow1/render-child/#renderchild","text":"[jvm]\\ fun < PropsT , StateT , OutputT , ChildOutputT , ChildRenderingT > BaseRenderContext < PropsT , StateT , OutputT >. renderChild (child: Workflow < Unit , ChildOutputT , ChildRenderingT >, key: String = \u201c\u201d, handler: ( ChildOutputT ) -> WorkflowAction < PropsT , StateT , OutputT >): ChildRenderingT Convenience alias of BaseRenderContext.renderChild for workflows that don\u2019t take props. [jvm]\\ fun < PropsT , ChildPropsT , StateT , OutputT , ChildRenderingT > BaseRenderContext < PropsT , StateT , OutputT >. renderChild (child: Workflow < ChildPropsT , Nothing , ChildRenderingT >, props: ChildPropsT , key: String = \u201c\u201d): ChildRenderingT Convenience alias of BaseRenderContext.renderChild for workflows that don\u2019t emit output. [jvm]\\ fun < PropsT , StateT , OutputT , ChildRenderingT > BaseRenderContext < PropsT , StateT , OutputT >. renderChild (child: Workflow < Unit , Nothing , ChildRenderingT >, key: String = \u201c\u201d): ChildRenderingT Convenience alias of BaseRenderContext.renderChild for children that don\u2019t take props or emit output.","title":"renderChild"},{"location":"kotlin/api/workflow/com.squareup.workflow1/render-workflow-in/","text":"// workflow / com.squareup.workflow1 / renderWorkflowIn renderWorkflowIn \u00b6 [jvm]\\ fun < PropsT , OutputT , RenderingT > renderWorkflowIn (workflow: Workflow < PropsT , OutputT , RenderingT >, scope: CoroutineScope, props: StateFlow< PropsT >, initialSnapshot: TreeSnapshot ? = null, interceptors: List < WorkflowInterceptor > = emptyList(), onOutput: suspend ( OutputT ) -> Unit ): StateFlow< RenderingAndSnapshot < RenderingT >> Launches the workflow in a new coroutine in scope and returns a StateFlow of its renderings and snapshots . The workflow tree is seeded with initialSnapshot and the current value value of props . Subsequent values emitted from props will be used to re-render the workflow. This is the primary low-level entry point into the workflow runtime. If you are writing an app, you should probably be using a higher-level entry point that will also let you define UI bindings for your renderings. Initialization \u00b6 When this function is called, the workflow runtime is started immediately, before the function even returns. The current value of the props is used to perform the initial render pass. The result of this render pass is used to initialize the StateFlow of renderings and snapshots that is returned. Once the initial render pass is complete, the workflow runtime will continue executing in a new coroutine launched in scope . Scoping \u00b6 The workflow runtime makes use of structured concurrency . The runtime is started in scope , which defines the context for the entire workflow tree \u2013 most importantly, the Job that governs the runtime\u2019s lifetime and exception reporting path, and the CoroutineDispatcher that decides on what thread(s) to run workflow code. Note that if the scope\u2019s dispatcher executes on threads different than the caller, then the initial render pass will occur on the current thread but all subsequent render passes, and actions, will be executed on that dispatcher. This shouldn\u2019t affect well-written workflows, since the render method should not perform side effects anyway. All workers that are run by this runtime will be collected in coroutines that are children of scope . When the root workflow emits an output, onOutput will be invoked in a child of scope . To stop the workflow runtime, simply cancel scope . Any running workers will be cancelled, and if onOutput is currently running it will be cancelled as well. Error handling \u00b6 If the initial render pass throws an exception, that exception will be thrown from this function. Any exceptions thrown from the runtime (and any workflows or workers) after that will bubble up and be handled by scope (usually by cancelling it). Since the onOutput function is executed in scope , any exceptions it throws will also bubble up to scope . Any exceptions thrown by subscribers of the returned StateFlow will not cancel scope or cancel the runtime, but will be handled in the CoroutineScope of the subscriber. Return \u00b6 A StateFlow of RenderingAndSnapshot s that will emit any time the root workflow creates a new rendering. Parameters \u00b6 jvm workflow The root workflow to render. scope The CoroutineScope in which to launch the workflow runtime. Any exceptions thrown in any workflows, after the initial render pass, will be handled by this scope, and cancelling this scope will cancel the workflow runtime and any running workers. Note that any dispatcher in this scope will not be used to execute the very first render pass. props Specifies the initial PropsT to use to render the root workflow, and will cause a re-render when new props are emitted. If this flow completes after emitting at least one value, the runtime will not fail or stop, it will continue running with the last-emitted input. To only pass a single props value, simply create a MutableStateFlow with the value. initialSnapshot If not null or empty, used to restore the workflow. Should be obtained from a previous runtime\u2019s RenderingAndSnapshot . interceptors An optional list of WorkflowInterceptor s that will wrap every workflow rendered by the runtime. Interceptors will be invoked in 0-to-length order: the interceptor at index 0 will process the workflow first, then the interceptor at index 1, etc. onOutput A function that will be called whenever the root workflow emits an OutputT . This is a suspend function, and is invoked synchronously within the runtime: if it suspends, the workflow runtime will effectively be paused until it returns. This means that it will propagate backpressure if used to forward outputs to a Flow or Channel, for example.","title":"Render workflow in"},{"location":"kotlin/api/workflow/com.squareup.workflow1/render-workflow-in/#renderworkflowin","text":"[jvm]\\ fun < PropsT , OutputT , RenderingT > renderWorkflowIn (workflow: Workflow < PropsT , OutputT , RenderingT >, scope: CoroutineScope, props: StateFlow< PropsT >, initialSnapshot: TreeSnapshot ? = null, interceptors: List < WorkflowInterceptor > = emptyList(), onOutput: suspend ( OutputT ) -> Unit ): StateFlow< RenderingAndSnapshot < RenderingT >> Launches the workflow in a new coroutine in scope and returns a StateFlow of its renderings and snapshots . The workflow tree is seeded with initialSnapshot and the current value value of props . Subsequent values emitted from props will be used to re-render the workflow. This is the primary low-level entry point into the workflow runtime. If you are writing an app, you should probably be using a higher-level entry point that will also let you define UI bindings for your renderings.","title":"renderWorkflowIn"},{"location":"kotlin/api/workflow/com.squareup.workflow1/render-workflow-in/#initialization","text":"When this function is called, the workflow runtime is started immediately, before the function even returns. The current value of the props is used to perform the initial render pass. The result of this render pass is used to initialize the StateFlow of renderings and snapshots that is returned. Once the initial render pass is complete, the workflow runtime will continue executing in a new coroutine launched in scope .","title":"Initialization"},{"location":"kotlin/api/workflow/com.squareup.workflow1/render-workflow-in/#scoping","text":"The workflow runtime makes use of structured concurrency . The runtime is started in scope , which defines the context for the entire workflow tree \u2013 most importantly, the Job that governs the runtime\u2019s lifetime and exception reporting path, and the CoroutineDispatcher that decides on what thread(s) to run workflow code. Note that if the scope\u2019s dispatcher executes on threads different than the caller, then the initial render pass will occur on the current thread but all subsequent render passes, and actions, will be executed on that dispatcher. This shouldn\u2019t affect well-written workflows, since the render method should not perform side effects anyway. All workers that are run by this runtime will be collected in coroutines that are children of scope . When the root workflow emits an output, onOutput will be invoked in a child of scope . To stop the workflow runtime, simply cancel scope . Any running workers will be cancelled, and if onOutput is currently running it will be cancelled as well.","title":"Scoping"},{"location":"kotlin/api/workflow/com.squareup.workflow1/render-workflow-in/#error-handling","text":"If the initial render pass throws an exception, that exception will be thrown from this function. Any exceptions thrown from the runtime (and any workflows or workers) after that will bubble up and be handled by scope (usually by cancelling it). Since the onOutput function is executed in scope , any exceptions it throws will also bubble up to scope . Any exceptions thrown by subscribers of the returned StateFlow will not cancel scope or cancel the runtime, but will be handled in the CoroutineScope of the subscriber.","title":"Error handling"},{"location":"kotlin/api/workflow/com.squareup.workflow1/render-workflow-in/#return","text":"A StateFlow of RenderingAndSnapshot s that will emit any time the root workflow creates a new rendering.","title":"Return"},{"location":"kotlin/api/workflow/com.squareup.workflow1/render-workflow-in/#parameters","text":"jvm workflow The root workflow to render. scope The CoroutineScope in which to launch the workflow runtime. Any exceptions thrown in any workflows, after the initial render pass, will be handled by this scope, and cancelling this scope will cancel the workflow runtime and any running workers. Note that any dispatcher in this scope will not be used to execute the very first render pass. props Specifies the initial PropsT to use to render the root workflow, and will cause a re-render when new props are emitted. If this flow completes after emitting at least one value, the runtime will not fail or stop, it will continue running with the last-emitted input. To only pass a single props value, simply create a MutableStateFlow with the value. initialSnapshot If not null or empty, used to restore the workflow. Should be obtained from a previous runtime\u2019s RenderingAndSnapshot . interceptors An optional list of WorkflowInterceptor s that will wrap every workflow rendered by the runtime. Interceptors will be invoked in 0-to-length order: the interceptor at index 0 will process the workflow first, then the interceptor at index 1, etc. onOutput A function that will be called whenever the root workflow emits an OutputT . This is a suspend function, and is invoked synchronously within the runtime: if it suspends, the workflow runtime will effectively be paused until it returns. This means that it will propagate backpressure if used to forward outputs to a Flow or Channel, for example.","title":"Parameters"},{"location":"kotlin/api/workflow/com.squareup.workflow1/rendering/","text":"// workflow / com.squareup.workflow1 / rendering rendering \u00b6 [jvm]\\ fun < RenderingT > Workflow.Companion . rendering (rendering: RenderingT ): Workflow < Unit , Nothing , RenderingT > Returns a workflow that does nothing but echo the given rendering . Handy for testing.","title":"Rendering"},{"location":"kotlin/api/workflow/com.squareup.workflow1/rendering/#rendering","text":"[jvm]\\ fun < RenderingT > Workflow.Companion . rendering (rendering: RenderingT ): Workflow < Unit , Nothing , RenderingT > Returns a workflow that does nothing but echo the given rendering . Handy for testing.","title":"rendering"},{"location":"kotlin/api/workflow/com.squareup.workflow1/running-worker/","text":"// workflow / com.squareup.workflow1 / runningWorker runningWorker \u00b6 [jvm]\\ inline fun < W : Worker < Nothing >, PropsT , StateT , OutputT > BaseRenderContext < PropsT , StateT , OutputT >. runningWorker (worker: W , key: String = \u201c\u201d) Ensures a Worker that never emits anything is running. Since worker can\u2019t emit anything, it can\u2019t trigger any WorkflowAction s. If your Worker does not output anything, then simply use runningSideEffect. Parameters \u00b6 jvm key An optional string key that is used to distinguish between identical Worker s. [jvm]\\ inline fun < T , W : Worker < T >, PropsT , StateT , OutputT > BaseRenderContext < PropsT , StateT , OutputT >. runningWorker (worker: W , key: String = \u201c\u201d, noinline handler: ( T ) -> WorkflowAction < PropsT , StateT , OutputT >) Ensures worker is running. When the Worker emits an output, handler is called to determine the WorkflowAction to take. When the worker finishes, nothing happens (although another render pass may be triggered). Like workflows, workers are kept alive across multiple render passes if they\u2019re the same type, and different workers of distinct types can be run concurrently. However, unlike workflows, workers are compared by their declared type, not their actual type. This means that if you pass a worker stored in a variable to this function, the type that will be used to compare the worker will be the type of the variable, not the type of the object the variable refers to. Parameters \u00b6 jvm key An optional string key that is used to distinguish between identical Worker s.","title":"Running worker"},{"location":"kotlin/api/workflow/com.squareup.workflow1/running-worker/#runningworker","text":"[jvm]\\ inline fun < W : Worker < Nothing >, PropsT , StateT , OutputT > BaseRenderContext < PropsT , StateT , OutputT >. runningWorker (worker: W , key: String = \u201c\u201d) Ensures a Worker that never emits anything is running. Since worker can\u2019t emit anything, it can\u2019t trigger any WorkflowAction s. If your Worker does not output anything, then simply use runningSideEffect.","title":"runningWorker"},{"location":"kotlin/api/workflow/com.squareup.workflow1/running-worker/#parameters","text":"jvm key An optional string key that is used to distinguish between identical Worker s. [jvm]\\ inline fun < T , W : Worker < T >, PropsT , StateT , OutputT > BaseRenderContext < PropsT , StateT , OutputT >. runningWorker (worker: W , key: String = \u201c\u201d, noinline handler: ( T ) -> WorkflowAction < PropsT , StateT , OutputT >) Ensures worker is running. When the Worker emits an output, handler is called to determine the WorkflowAction to take. When the worker finishes, nothing happens (although another render pass may be triggered). Like workflows, workers are kept alive across multiple render passes if they\u2019re the same type, and different workers of distinct types can be run concurrently. However, unlike workflows, workers are compared by their declared type, not their actual type. This means that if you pass a worker stored in a variable to this function, the type that will be used to compare the worker will be the type of the variable, not the type of the object the variable refers to.","title":"Parameters"},{"location":"kotlin/api/workflow/com.squareup.workflow1/running-worker/#parameters_1","text":"jvm key An optional string key that is used to distinguish between identical Worker s.","title":"Parameters"},{"location":"kotlin/api/workflow/com.squareup.workflow1/stateful/","text":"// workflow / com.squareup.workflow1 / stateful stateful \u00b6 [jvm]\\ inline fun < PropsT , StateT , OutputT , RenderingT > Workflow.Companion . stateful (crossinline initialState: ( PropsT , Snapshot ?) -> StateT , crossinline render: BaseRenderContext < PropsT , StateT , OutputT >.( PropsT , StateT ) -> RenderingT , crossinline snapshot: ( StateT ) -> Snapshot ?, crossinline onPropsChanged: ( PropsT , PropsT , StateT ) -> StateT = { _, _, state -> state }): StatefulWorkflow < PropsT , StateT , OutputT , RenderingT > Returns a stateful Workflow implemented via the given functions. [jvm]\\ inline fun < StateT , OutputT , RenderingT > Workflow.Companion . stateful (crossinline initialState: ( Snapshot ?) -> StateT , crossinline render: BaseRenderContext < Unit , StateT , OutputT >.( StateT ) -> RenderingT , crossinline snapshot: ( StateT ) -> Snapshot ?): StatefulWorkflow < Unit , StateT , OutputT , RenderingT > Returns a stateful Workflow , with no props, implemented via the given functions. [jvm]\\ inline fun < PropsT , StateT , OutputT , RenderingT > Workflow.Companion . stateful (crossinline initialState: ( PropsT ) -> StateT , crossinline render: BaseRenderContext < PropsT , StateT , OutputT >.( PropsT , StateT ) -> RenderingT , crossinline onPropsChanged: ( PropsT , PropsT , StateT ) -> StateT = { _, _, state -> state }): StatefulWorkflow < PropsT , StateT , OutputT , RenderingT > Returns a stateful Workflow implemented via the given functions. This overload does not support snapshotting, but there are other overloads that do. [jvm]\\ inline fun < StateT , OutputT , RenderingT > Workflow.Companion . stateful (initialState: StateT , crossinline render: BaseRenderContext < Unit , StateT , OutputT >.( StateT ) -> RenderingT ): StatefulWorkflow < Unit , StateT , OutputT , RenderingT > Returns a stateful Workflow , with no props, implemented via the given function. This overload does not support snapshots, but there are others that do.","title":"Stateful"},{"location":"kotlin/api/workflow/com.squareup.workflow1/stateful/#stateful","text":"[jvm]\\ inline fun < PropsT , StateT , OutputT , RenderingT > Workflow.Companion . stateful (crossinline initialState: ( PropsT , Snapshot ?) -> StateT , crossinline render: BaseRenderContext < PropsT , StateT , OutputT >.( PropsT , StateT ) -> RenderingT , crossinline snapshot: ( StateT ) -> Snapshot ?, crossinline onPropsChanged: ( PropsT , PropsT , StateT ) -> StateT = { _, _, state -> state }): StatefulWorkflow < PropsT , StateT , OutputT , RenderingT > Returns a stateful Workflow implemented via the given functions. [jvm]\\ inline fun < StateT , OutputT , RenderingT > Workflow.Companion . stateful (crossinline initialState: ( Snapshot ?) -> StateT , crossinline render: BaseRenderContext < Unit , StateT , OutputT >.( StateT ) -> RenderingT , crossinline snapshot: ( StateT ) -> Snapshot ?): StatefulWorkflow < Unit , StateT , OutputT , RenderingT > Returns a stateful Workflow , with no props, implemented via the given functions. [jvm]\\ inline fun < PropsT , StateT , OutputT , RenderingT > Workflow.Companion . stateful (crossinline initialState: ( PropsT ) -> StateT , crossinline render: BaseRenderContext < PropsT , StateT , OutputT >.( PropsT , StateT ) -> RenderingT , crossinline onPropsChanged: ( PropsT , PropsT , StateT ) -> StateT = { _, _, state -> state }): StatefulWorkflow < PropsT , StateT , OutputT , RenderingT > Returns a stateful Workflow implemented via the given functions. This overload does not support snapshotting, but there are other overloads that do. [jvm]\\ inline fun < StateT , OutputT , RenderingT > Workflow.Companion . stateful (initialState: StateT , crossinline render: BaseRenderContext < Unit , StateT , OutputT >.( StateT ) -> RenderingT ): StatefulWorkflow < Unit , StateT , OutputT , RenderingT > Returns a stateful Workflow , with no props, implemented via the given function. This overload does not support snapshots, but there are others that do.","title":"stateful"},{"location":"kotlin/api/workflow/com.squareup.workflow1/stateless/","text":"// workflow / com.squareup.workflow1 / stateless stateless \u00b6 [jvm]\\ inline fun < PropsT , OutputT , RenderingT > Workflow.Companion . stateless (crossinline render: BaseRenderContext < PropsT , Nothing , OutputT >.( PropsT ) -> RenderingT ): Workflow < PropsT , OutputT , RenderingT > Returns a stateless Workflow via the given render function. Note that while the returned workflow doesn\u2019t have any internal state of its own, it may use props received from its parent, and it may render child workflows that do have their own internal state.","title":"Stateless"},{"location":"kotlin/api/workflow/com.squareup.workflow1/stateless/#stateless","text":"[jvm]\\ inline fun < PropsT , OutputT , RenderingT > Workflow.Companion . stateless (crossinline render: BaseRenderContext < PropsT , Nothing , OutputT >.( PropsT ) -> RenderingT ): Workflow < PropsT , OutputT , RenderingT > Returns a stateless Workflow via the given render function. Note that while the returned workflow doesn\u2019t have any internal state of its own, it may use props received from its parent, and it may render child workflows that do have their own internal state.","title":"stateless"},{"location":"kotlin/api/workflow/com.squareup.workflow1/transform/","text":"// workflow / com.squareup.workflow1 / transform transform \u00b6 [jvm]\\ fun < T , R > Worker < T >. transform (transform: (Flow< T >) -> Flow< R >): Worker < R > Returns a Worker that transforms this Worker \u2018s Flow by calling transform . The returned worker is considered equivalent with any other worker returned by this function with the same receiver. Examples \u00b6 Workers from the same source are equivalent \u00b6 val secondsWorker = millisWorker.transform {\\ it.map { millis -> millis / 1000 }.distinctUntilChanged()\\ }\\ \\ val otherSecondsWorker = millisWorker.transform {\\ it.map { millis -> millis.toSeconds() }\\ }\\ \\ assert(secondsWorker.doesSameWorkAs(otherSecondsWorker)) Workers from different sources are not equivalent \u00b6 val secondsWorker = millisWorker.transform {\\ it.map { millis -> millis / 1000 }.distinctUntilChanged()\\ }\\ \\ val otherSecondsWorker = secondsWorker.transform { it }\\ \\ assert(!secondsWorker.doesSameWorkAs(otherSecondsWorker))","title":"Transform"},{"location":"kotlin/api/workflow/com.squareup.workflow1/transform/#transform","text":"[jvm]\\ fun < T , R > Worker < T >. transform (transform: (Flow< T >) -> Flow< R >): Worker < R > Returns a Worker that transforms this Worker \u2018s Flow by calling transform . The returned worker is considered equivalent with any other worker returned by this function with the same receiver.","title":"transform"},{"location":"kotlin/api/workflow/com.squareup.workflow1/transform/#examples","text":"","title":"Examples"},{"location":"kotlin/api/workflow/com.squareup.workflow1/transform/#workers-from-the-same-source-are-equivalent","text":"val secondsWorker = millisWorker.transform {\\ it.map { millis -> millis / 1000 }.distinctUntilChanged()\\ }\\ \\ val otherSecondsWorker = millisWorker.transform {\\ it.map { millis -> millis.toSeconds() }\\ }\\ \\ assert(secondsWorker.doesSameWorkAs(otherSecondsWorker))","title":"Workers from the same source are equivalent"},{"location":"kotlin/api/workflow/com.squareup.workflow1/transform/#workers-from-different-sources-are-not-equivalent","text":"val secondsWorker = millisWorker.transform {\\ it.map { millis -> millis / 1000 }.distinctUntilChanged()\\ }\\ \\ val otherSecondsWorker = secondsWorker.transform { it }\\ \\ assert(!secondsWorker.doesSameWorkAs(otherSecondsWorker))","title":"Workers from different sources are not equivalent"},{"location":"kotlin/api/workflow/com.squareup.workflow1/unsnapshottable-identifier/","text":"// workflow / com.squareup.workflow1 / unsnapshottableIdentifier unsnapshottableIdentifier \u00b6 [jvm]\\ fun unsnapshottableIdentifier (type: KType ): WorkflowIdentifier Creates a WorkflowIdentifier that is not capable of being snapshotted and will cause any ImpostorWorkflow workflow identified by it to also not be snapshotted. This function should not be used for ImpostorWorkflow s that wrap arbitrary workflows , since those workflows may expect to be on snapshotted. Using such identifiers anywhere in the ImpostorWorkflow.realIdentifier chain will disable snapshotting for that workflow. This function should only be used for ImpostorWorkflow s that wrap a closed set of known workflow types.","title":"Unsnapshottable identifier"},{"location":"kotlin/api/workflow/com.squareup.workflow1/unsnapshottable-identifier/#unsnapshottableidentifier","text":"[jvm]\\ fun unsnapshottableIdentifier (type: KType ): WorkflowIdentifier Creates a WorkflowIdentifier that is not capable of being snapshotted and will cause any ImpostorWorkflow workflow identified by it to also not be snapshotted. This function should not be used for ImpostorWorkflow s that wrap arbitrary workflows , since those workflows may expect to be on snapshotted. Using such identifiers anywhere in the ImpostorWorkflow.realIdentifier chain will disable snapshotting for that workflow. This function should only be used for ImpostorWorkflow s that wrap a closed set of known workflow types.","title":"unsnapshottableIdentifier"},{"location":"kotlin/api/workflow/com.squareup.workflow1/workflow-identifier/","text":"// workflow / com.squareup.workflow1 / workflowIdentifier workflowIdentifier \u00b6 [jvm]\\ @get:TestOnly val KClass <out Workflow <*, *, *>>. workflowIdentifier : WorkflowIdentifier The WorkflowIdentifier that identifies the workflow this KClass represents. This workflow must not be an ImpostorWorkflow , or this property will throw an IllegalArgumentException .","title":"Workflow identifier"},{"location":"kotlin/api/workflow/com.squareup.workflow1/workflow-identifier/#workflowidentifier","text":"[jvm]\\ @get:TestOnly val KClass <out Workflow <*, *, *>>. workflowIdentifier : WorkflowIdentifier The WorkflowIdentifier that identifies the workflow this KClass represents. This workflow must not be an ImpostorWorkflow , or this property will throw an IllegalArgumentException .","title":"workflowIdentifier"},{"location":"kotlin/api/workflow/com.squareup.workflow1/write-boolean-as-int/","text":"// workflow / com.squareup.workflow1 / writeBooleanAsInt writeBooleanAsInt \u00b6 [jvm]\\ fun BufferedSink. writeBooleanAsInt (bool: Boolean ): BufferedSink","title":"Write boolean as int"},{"location":"kotlin/api/workflow/com.squareup.workflow1/write-boolean-as-int/#writebooleanasint","text":"[jvm]\\ fun BufferedSink. writeBooleanAsInt (bool: Boolean ): BufferedSink","title":"writeBooleanAsInt"},{"location":"kotlin/api/workflow/com.squareup.workflow1/write-byte-string-with-length/","text":"// workflow / com.squareup.workflow1 / writeByteStringWithLength writeByteStringWithLength \u00b6 [jvm]\\ fun BufferedSink. writeByteStringWithLength (bytes: ByteString): BufferedSink","title":"Write byte string with length"},{"location":"kotlin/api/workflow/com.squareup.workflow1/write-byte-string-with-length/#writebytestringwithlength","text":"[jvm]\\ fun BufferedSink. writeByteStringWithLength (bytes: ByteString): BufferedSink","title":"writeByteStringWithLength"},{"location":"kotlin/api/workflow/com.squareup.workflow1/write-enum-by-ordinal/","text":"// workflow / com.squareup.workflow1 / writeEnumByOrdinal writeEnumByOrdinal \u00b6 [jvm]\\ fun < T : Enum < T >> BufferedSink. writeEnumByOrdinal (enumVal: T ): BufferedSink","title":"Write enum by ordinal"},{"location":"kotlin/api/workflow/com.squareup.workflow1/write-enum-by-ordinal/#writeenumbyordinal","text":"[jvm]\\ fun < T : Enum < T >> BufferedSink. writeEnumByOrdinal (enumVal: T ): BufferedSink","title":"writeEnumByOrdinal"},{"location":"kotlin/api/workflow/com.squareup.workflow1/write-float/","text":"// workflow / com.squareup.workflow1 / writeFloat writeFloat \u00b6 [jvm]\\ fun BufferedSink. writeFloat (float: Float ): BufferedSink","title":"Write float"},{"location":"kotlin/api/workflow/com.squareup.workflow1/write-float/#writefloat","text":"[jvm]\\ fun BufferedSink. writeFloat (float: Float ): BufferedSink","title":"writeFloat"},{"location":"kotlin/api/workflow/com.squareup.workflow1/write-list/","text":"// workflow / com.squareup.workflow1 / writeList writeList \u00b6 [jvm]\\ inline fun < T > BufferedSink. writeList (values: List < T >, writer: BufferedSink.( T ) -> Unit ): BufferedSink","title":"Write list"},{"location":"kotlin/api/workflow/com.squareup.workflow1/write-list/#writelist","text":"[jvm]\\ inline fun < T > BufferedSink. writeList (values: List < T >, writer: BufferedSink.( T ) -> Unit ): BufferedSink","title":"writeList"},{"location":"kotlin/api/workflow/com.squareup.workflow1/write-nullable/","text":"// workflow / com.squareup.workflow1 / writeNullable writeNullable \u00b6 [jvm]\\ fun < T : Any > BufferedSink. writeNullable (obj: T ?, writer: BufferedSink.( T ) -> Unit ): BufferedSink","title":"Write nullable"},{"location":"kotlin/api/workflow/com.squareup.workflow1/write-nullable/#writenullable","text":"[jvm]\\ fun < T : Any > BufferedSink. writeNullable (obj: T ?, writer: BufferedSink.( T ) -> Unit ): BufferedSink","title":"writeNullable"},{"location":"kotlin/api/workflow/com.squareup.workflow1/write-optional-enum-by-ordinal/","text":"// workflow / com.squareup.workflow1 / writeOptionalEnumByOrdinal writeOptionalEnumByOrdinal \u00b6 [jvm]\\ fun < T : Enum < T >> BufferedSink. writeOptionalEnumByOrdinal (enumVal: T ?): BufferedSink","title":"Write optional enum by ordinal"},{"location":"kotlin/api/workflow/com.squareup.workflow1/write-optional-enum-by-ordinal/#writeoptionalenumbyordinal","text":"[jvm]\\ fun < T : Enum < T >> BufferedSink. writeOptionalEnumByOrdinal (enumVal: T ?): BufferedSink","title":"writeOptionalEnumByOrdinal"},{"location":"kotlin/api/workflow/com.squareup.workflow1/write-optional-utf8-with-length/","text":"// workflow / com.squareup.workflow1 / writeOptionalUtf8WithLength writeOptionalUtf8WithLength \u00b6 [jvm]\\ fun BufferedSink. writeOptionalUtf8WithLength (str: String ?): BufferedSink","title":"Write optional utf8 with length"},{"location":"kotlin/api/workflow/com.squareup.workflow1/write-optional-utf8-with-length/#writeoptionalutf8withlength","text":"[jvm]\\ fun BufferedSink. writeOptionalUtf8WithLength (str: String ?): BufferedSink","title":"writeOptionalUtf8WithLength"},{"location":"kotlin/api/workflow/com.squareup.workflow1/write-utf8-with-length/","text":"// workflow / com.squareup.workflow1 / writeUtf8WithLength writeUtf8WithLength \u00b6 [jvm]\\ fun BufferedSink. writeUtf8WithLength (str: String ): BufferedSink","title":"Write utf8 with length"},{"location":"kotlin/api/workflow/com.squareup.workflow1/write-utf8-with-length/#writeutf8withlength","text":"[jvm]\\ fun BufferedSink. writeUtf8WithLength (str: String ): BufferedSink","title":"writeUtf8WithLength"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-base-render-context/","text":"// workflow / com.squareup.workflow1 / BaseRenderContext BaseRenderContext \u00b6 [jvm]\\ interface BaseRenderContext <out PropsT , StateT , in OutputT > Facilities for a Workflow to interact with other Workflow s and the outside world from inside a render function. Handling events from the UI \u00b6 While a workflow\u2019s rendering can represent whatever you need it to, it is common for the rendering to contain the data for some part of your UI. In addition to shuttling data to the UI, the rendering can also contain functions that the UI can call to send events to the workflow. E.g. data class Rendering(\\ val radioButtonTexts: List<String>,\\ val onSelected: (index: Int) -> Unit\\ ) To create populate such functions from your render method, you first need to define a WorkflowAction to handle the event by changing state, emitting an output, or both. Then, just pass a lambda to your rendering that instantiates the action and passes it to actionSink.send . Performing asynchronous work \u00b6 See runningWorker . Composing children \u00b6 See renderChild . Functions \u00b6 Name Summary eventHandler [jvm] open fun < E1 , E2 , E3 , E4 , E5 , E6 , E7 , E8 , E9 > eventHandler (name: () -> String = { \u201ceventHandler\u201d }, update: WorkflowAction.Updater < PropsT , StateT , OutputT >.( E1 , E2 , E3 , E4 , E5 , E6 , E7 , E8 , E9 ) -> Unit ): ( E1 , E2 , E3 , E4 , E5 , E6 , E7 , E8 , E9 ) -> Unit open fun < E1 , E2 , E3 , E4 , E5 , E6 , E7 , E8 , E9 , E10 > eventHandler (name: () -> String = { \u201ceventHandler\u201d }, update: WorkflowAction.Updater < PropsT , StateT , OutputT >.( E1 , E2 , E3 , E4 , E5 , E6 , E7 , E8 , E9 , E10 ) -> Unit ): ( E1 , E2 , E3 , E4 , E5 , E6 , E7 , E8 , E9 , E10 ) -> Unit open fun < EventT > eventHandler (name: () -> String = { \u201ceventHandler\u201d }, update: WorkflowAction.Updater < PropsT , StateT , OutputT >.( EventT ) -> Unit ): ( EventT ) -> Unit open fun < E1 , E2 > eventHandler (name: () -> String = { \u201ceventHandler\u201d }, update: WorkflowAction.Updater < PropsT , StateT , OutputT >.( E1 , E2 ) -> Unit ): ( E1 , E2 ) -> Unit open fun < E1 , E2 , E3 > eventHandler (name: () -> String = { \u201ceventHandler\u201d }, update: WorkflowAction.Updater < PropsT , StateT , OutputT >.( E1 , E2 , E3 ) -> Unit ): ( E1 , E2 , E3 ) -> Unit open fun < E1 , E2 , E3 , E4 > eventHandler (name: () -> String = { \u201ceventHandler\u201d }, update: WorkflowAction.Updater < PropsT , StateT , OutputT >.( E1 , E2 , E3 , E4 ) -> Unit ): ( E1 , E2 , E3 , E4 ) -> Unit open fun < E1 , E2 , E3 , E4 , E5 > eventHandler (name: () -> String = { \u201ceventHandler\u201d }, update: WorkflowAction.Updater < PropsT , StateT , OutputT >.( E1 , E2 , E3 , E4 , E5 ) -> Unit ): ( E1 , E2 , E3 , E4 , E5 ) -> Unit open fun < E1 , E2 , E3 , E4 , E5 , E6 > eventHandler (name: () -> String = { \u201ceventHandler\u201d }, update: WorkflowAction.Updater < PropsT , StateT , OutputT >.( E1 , E2 , E3 , E4 , E5 , E6 ) -> Unit ): ( E1 , E2 , E3 , E4 , E5 , E6 ) -> Unit open fun < E1 , E2 , E3 , E4 , E5 , E6 , E7 > eventHandler (name: () -> String = { \u201ceventHandler\u201d }, update: WorkflowAction.Updater < PropsT , StateT , OutputT >.( E1 , E2 , E3 , E4 , E5 , E6 , E7 ) -> Unit ): ( E1 , E2 , E3 , E4 , E5 , E6 , E7 ) -> Unit open fun < E1 , E2 , E3 , E4 , E5 , E6 , E7 , E8 > eventHandler (name: () -> String = { \u201ceventHandler\u201d }, update: WorkflowAction.Updater < PropsT , StateT , OutputT >.( E1 , E2 , E3 , E4 , E5 , E6 , E7 , E8 ) -> Unit ): ( E1 , E2 , E3 , E4 , E5 , E6 , E7 , E8 ) -> Unit [jvm] open fun eventHandler (name: () -> String = { \u201ceventHandler\u201d }, update: WorkflowAction.Updater < PropsT , StateT , OutputT >.() -> Unit ): () -> Unit Creates a function which builds a WorkflowAction from the given update function, and immediately passes it to actionSink . Handy for attaching event handlers to renderings. renderChild [jvm] abstract fun < ChildPropsT , ChildOutputT , ChildRenderingT > renderChild (child: Workflow < ChildPropsT , ChildOutputT , ChildRenderingT >, props: ChildPropsT , key: String = \u201c\u201d, handler: ( ChildOutputT ) -> WorkflowAction < PropsT , StateT , OutputT >): ChildRenderingT Ensures child is running as a child of this workflow, and returns the result of its render method. runningSideEffect [jvm] abstract fun runningSideEffect (key: String , sideEffect: suspend CoroutineScope.() -> Unit ) Ensures sideEffect is running with the given key . Properties \u00b6 Name Summary actionSink [jvm] abstract val actionSink : Sink < WorkflowAction < PropsT , StateT , OutputT >> Accepts a single WorkflowAction , invokes that action by calling WorkflowAction.apply to update the current state, and optionally emits the returned output value if it is non-null. Inheritors \u00b6 Name StatefulWorkflow StatelessWorkflow Extensions \u00b6 Name Summary renderChild [jvm] fun < PropsT , StateT , OutputT , ChildOutputT , ChildRenderingT > BaseRenderContext < PropsT , StateT , OutputT >. renderChild (child: Workflow < Unit , ChildOutputT , ChildRenderingT >, key: String = \u201c\u201d, handler: ( ChildOutputT ) -> WorkflowAction < PropsT , StateT , OutputT >): ChildRenderingT Convenience alias of BaseRenderContext.renderChild for workflows that don\u2019t take props. [jvm] fun < PropsT , ChildPropsT , StateT , OutputT , ChildRenderingT > BaseRenderContext < PropsT , StateT , OutputT >. renderChild (child: Workflow < ChildPropsT , Nothing , ChildRenderingT >, props: ChildPropsT , key: String = \u201c\u201d): ChildRenderingT Convenience alias of BaseRenderContext.renderChild for workflows that don\u2019t emit output. [jvm] fun < PropsT , StateT , OutputT , ChildRenderingT > BaseRenderContext < PropsT , StateT , OutputT >. renderChild (child: Workflow < Unit , Nothing , ChildRenderingT >, key: String = \u201c\u201d): ChildRenderingT Convenience alias of BaseRenderContext.renderChild for children that don\u2019t take props or emit output. runningWorker [jvm] inline fun < W : Worker < Nothing >, PropsT , StateT , OutputT > BaseRenderContext < PropsT , StateT , OutputT >. runningWorker (worker: W , key: String = \u201c\u201d) Ensures a Worker that never emits anything is running. Since worker can\u2019t emit anything, it can\u2019t trigger any WorkflowAction s. [jvm] inline fun < T , W : Worker < T >, PropsT , StateT , OutputT > BaseRenderContext < PropsT , StateT , OutputT >. runningWorker (worker: W , key: String = \u201c\u201d, noinline handler: ( T ) -> WorkflowAction < PropsT , StateT , OutputT >) Ensures worker is running. When the Worker emits an output, handler is called to determine the WorkflowAction to take. When the worker finishes, nothing happens (although another render pass may be triggered).","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-base-render-context/#baserendercontext","text":"[jvm]\\ interface BaseRenderContext <out PropsT , StateT , in OutputT > Facilities for a Workflow to interact with other Workflow s and the outside world from inside a render function.","title":"BaseRenderContext"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-base-render-context/#handling-events-from-the-ui","text":"While a workflow\u2019s rendering can represent whatever you need it to, it is common for the rendering to contain the data for some part of your UI. In addition to shuttling data to the UI, the rendering can also contain functions that the UI can call to send events to the workflow. E.g. data class Rendering(\\ val radioButtonTexts: List<String>,\\ val onSelected: (index: Int) -> Unit\\ ) To create populate such functions from your render method, you first need to define a WorkflowAction to handle the event by changing state, emitting an output, or both. Then, just pass a lambda to your rendering that instantiates the action and passes it to actionSink.send .","title":"Handling events from the UI"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-base-render-context/#performing-asynchronous-work","text":"See runningWorker .","title":"Performing asynchronous work"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-base-render-context/#composing-children","text":"See renderChild .","title":"Composing children"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-base-render-context/#functions","text":"Name Summary eventHandler [jvm] open fun < E1 , E2 , E3 , E4 , E5 , E6 , E7 , E8 , E9 > eventHandler (name: () -> String = { \u201ceventHandler\u201d }, update: WorkflowAction.Updater < PropsT , StateT , OutputT >.( E1 , E2 , E3 , E4 , E5 , E6 , E7 , E8 , E9 ) -> Unit ): ( E1 , E2 , E3 , E4 , E5 , E6 , E7 , E8 , E9 ) -> Unit open fun < E1 , E2 , E3 , E4 , E5 , E6 , E7 , E8 , E9 , E10 > eventHandler (name: () -> String = { \u201ceventHandler\u201d }, update: WorkflowAction.Updater < PropsT , StateT , OutputT >.( E1 , E2 , E3 , E4 , E5 , E6 , E7 , E8 , E9 , E10 ) -> Unit ): ( E1 , E2 , E3 , E4 , E5 , E6 , E7 , E8 , E9 , E10 ) -> Unit open fun < EventT > eventHandler (name: () -> String = { \u201ceventHandler\u201d }, update: WorkflowAction.Updater < PropsT , StateT , OutputT >.( EventT ) -> Unit ): ( EventT ) -> Unit open fun < E1 , E2 > eventHandler (name: () -> String = { \u201ceventHandler\u201d }, update: WorkflowAction.Updater < PropsT , StateT , OutputT >.( E1 , E2 ) -> Unit ): ( E1 , E2 ) -> Unit open fun < E1 , E2 , E3 > eventHandler (name: () -> String = { \u201ceventHandler\u201d }, update: WorkflowAction.Updater < PropsT , StateT , OutputT >.( E1 , E2 , E3 ) -> Unit ): ( E1 , E2 , E3 ) -> Unit open fun < E1 , E2 , E3 , E4 > eventHandler (name: () -> String = { \u201ceventHandler\u201d }, update: WorkflowAction.Updater < PropsT , StateT , OutputT >.( E1 , E2 , E3 , E4 ) -> Unit ): ( E1 , E2 , E3 , E4 ) -> Unit open fun < E1 , E2 , E3 , E4 , E5 > eventHandler (name: () -> String = { \u201ceventHandler\u201d }, update: WorkflowAction.Updater < PropsT , StateT , OutputT >.( E1 , E2 , E3 , E4 , E5 ) -> Unit ): ( E1 , E2 , E3 , E4 , E5 ) -> Unit open fun < E1 , E2 , E3 , E4 , E5 , E6 > eventHandler (name: () -> String = { \u201ceventHandler\u201d }, update: WorkflowAction.Updater < PropsT , StateT , OutputT >.( E1 , E2 , E3 , E4 , E5 , E6 ) -> Unit ): ( E1 , E2 , E3 , E4 , E5 , E6 ) -> Unit open fun < E1 , E2 , E3 , E4 , E5 , E6 , E7 > eventHandler (name: () -> String = { \u201ceventHandler\u201d }, update: WorkflowAction.Updater < PropsT , StateT , OutputT >.( E1 , E2 , E3 , E4 , E5 , E6 , E7 ) -> Unit ): ( E1 , E2 , E3 , E4 , E5 , E6 , E7 ) -> Unit open fun < E1 , E2 , E3 , E4 , E5 , E6 , E7 , E8 > eventHandler (name: () -> String = { \u201ceventHandler\u201d }, update: WorkflowAction.Updater < PropsT , StateT , OutputT >.( E1 , E2 , E3 , E4 , E5 , E6 , E7 , E8 ) -> Unit ): ( E1 , E2 , E3 , E4 , E5 , E6 , E7 , E8 ) -> Unit [jvm] open fun eventHandler (name: () -> String = { \u201ceventHandler\u201d }, update: WorkflowAction.Updater < PropsT , StateT , OutputT >.() -> Unit ): () -> Unit Creates a function which builds a WorkflowAction from the given update function, and immediately passes it to actionSink . Handy for attaching event handlers to renderings. renderChild [jvm] abstract fun < ChildPropsT , ChildOutputT , ChildRenderingT > renderChild (child: Workflow < ChildPropsT , ChildOutputT , ChildRenderingT >, props: ChildPropsT , key: String = \u201c\u201d, handler: ( ChildOutputT ) -> WorkflowAction < PropsT , StateT , OutputT >): ChildRenderingT Ensures child is running as a child of this workflow, and returns the result of its render method. runningSideEffect [jvm] abstract fun runningSideEffect (key: String , sideEffect: suspend CoroutineScope.() -> Unit ) Ensures sideEffect is running with the given key .","title":"Functions"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-base-render-context/#properties","text":"Name Summary actionSink [jvm] abstract val actionSink : Sink < WorkflowAction < PropsT , StateT , OutputT >> Accepts a single WorkflowAction , invokes that action by calling WorkflowAction.apply to update the current state, and optionally emits the returned output value if it is non-null.","title":"Properties"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-base-render-context/#inheritors","text":"Name StatefulWorkflow StatelessWorkflow","title":"Inheritors"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-base-render-context/#extensions","text":"Name Summary renderChild [jvm] fun < PropsT , StateT , OutputT , ChildOutputT , ChildRenderingT > BaseRenderContext < PropsT , StateT , OutputT >. renderChild (child: Workflow < Unit , ChildOutputT , ChildRenderingT >, key: String = \u201c\u201d, handler: ( ChildOutputT ) -> WorkflowAction < PropsT , StateT , OutputT >): ChildRenderingT Convenience alias of BaseRenderContext.renderChild for workflows that don\u2019t take props. [jvm] fun < PropsT , ChildPropsT , StateT , OutputT , ChildRenderingT > BaseRenderContext < PropsT , StateT , OutputT >. renderChild (child: Workflow < ChildPropsT , Nothing , ChildRenderingT >, props: ChildPropsT , key: String = \u201c\u201d): ChildRenderingT Convenience alias of BaseRenderContext.renderChild for workflows that don\u2019t emit output. [jvm] fun < PropsT , StateT , OutputT , ChildRenderingT > BaseRenderContext < PropsT , StateT , OutputT >. renderChild (child: Workflow < Unit , Nothing , ChildRenderingT >, key: String = \u201c\u201d): ChildRenderingT Convenience alias of BaseRenderContext.renderChild for children that don\u2019t take props or emit output. runningWorker [jvm] inline fun < W : Worker < Nothing >, PropsT , StateT , OutputT > BaseRenderContext < PropsT , StateT , OutputT >. runningWorker (worker: W , key: String = \u201c\u201d) Ensures a Worker that never emits anything is running. Since worker can\u2019t emit anything, it can\u2019t trigger any WorkflowAction s. [jvm] inline fun < T , W : Worker < T >, PropsT , StateT , OutputT > BaseRenderContext < PropsT , StateT , OutputT >. runningWorker (worker: W , key: String = \u201c\u201d, noinline handler: ( T ) -> WorkflowAction < PropsT , StateT , OutputT >) Ensures worker is running. When the Worker emits an output, handler is called to determine the WorkflowAction to take. When the worker finishes, nothing happens (although another render pass may be triggered).","title":"Extensions"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-base-render-context/action-sink/","text":"// workflow / com.squareup.workflow1 / BaseRenderContext / actionSink actionSink \u00b6 [jvm]\\ abstract val actionSink : Sink < WorkflowAction < PropsT , StateT , OutputT >> Accepts a single WorkflowAction , invokes that action by calling WorkflowAction.apply to update the current state, and optionally emits the returned output value if it is non-null.","title":"Action sink"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-base-render-context/action-sink/#actionsink","text":"[jvm]\\ abstract val actionSink : Sink < WorkflowAction < PropsT , StateT , OutputT >> Accepts a single WorkflowAction , invokes that action by calling WorkflowAction.apply to update the current state, and optionally emits the returned output value if it is non-null.","title":"actionSink"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-base-render-context/event-handler/","text":"// workflow / com.squareup.workflow1 / BaseRenderContext / eventHandler eventHandler \u00b6 [jvm]\\ open fun eventHandler (name: () -> String = { \u201ceventHandler\u201d }, update: WorkflowAction.Updater < PropsT , StateT , OutputT >.() -> Unit ): () -> Unit Creates a function which builds a WorkflowAction from the given update function, and immediately passes it to actionSink . Handy for attaching event handlers to renderings. Parameters \u00b6 jvm name A string describing the update, included in the action\u2019s toString as a debugging aid update Function that defines the workflow update. [jvm]\\ open fun < EventT > eventHandler (name: () -> String = { \u201ceventHandler\u201d }, update: WorkflowAction.Updater < PropsT , StateT , OutputT >.( EventT ) -> Unit ): ( EventT ) -> Unit open fun < E1 , E2 > eventHandler (name: () -> String = { \u201ceventHandler\u201d }, update: WorkflowAction.Updater < PropsT , StateT , OutputT >.( E1 , E2 ) -> Unit ): ( E1 , E2 ) -> Unit open fun < E1 , E2 , E3 > eventHandler (name: () -> String = { \u201ceventHandler\u201d }, update: WorkflowAction.Updater < PropsT , StateT , OutputT >.( E1 , E2 , E3 ) -> Unit ): ( E1 , E2 , E3 ) -> Unit open fun < E1 , E2 , E3 , E4 > eventHandler (name: () -> String = { \u201ceventHandler\u201d }, update: WorkflowAction.Updater < PropsT , StateT , OutputT >.( E1 , E2 , E3 , E4 ) -> Unit ): ( E1 , E2 , E3 , E4 ) -> Unit open fun < E1 , E2 , E3 , E4 , E5 > eventHandler (name: () -> String = { \u201ceventHandler\u201d }, update: WorkflowAction.Updater < PropsT , StateT , OutputT >.( E1 , E2 , E3 , E4 , E5 ) -> Unit ): ( E1 , E2 , E3 , E4 , E5 ) -> Unit open fun < E1 , E2 , E3 , E4 , E5 , E6 > eventHandler (name: () -> String = { \u201ceventHandler\u201d }, update: WorkflowAction.Updater < PropsT , StateT , OutputT >.( E1 , E2 , E3 , E4 , E5 , E6 ) -> Unit ): ( E1 , E2 , E3 , E4 , E5 , E6 ) -> Unit open fun < E1 , E2 , E3 , E4 , E5 , E6 , E7 > eventHandler (name: () -> String = { \u201ceventHandler\u201d }, update: WorkflowAction.Updater < PropsT , StateT , OutputT >.( E1 , E2 , E3 , E4 , E5 , E6 , E7 ) -> Unit ): ( E1 , E2 , E3 , E4 , E5 , E6 , E7 ) -> Unit open fun < E1 , E2 , E3 , E4 , E5 , E6 , E7 , E8 > eventHandler (name: () -> String = { \u201ceventHandler\u201d }, update: WorkflowAction.Updater < PropsT , StateT , OutputT >.( E1 , E2 , E3 , E4 , E5 , E6 , E7 , E8 ) -> Unit ): ( E1 , E2 , E3 , E4 , E5 , E6 , E7 , E8 ) -> Unit open fun < E1 , E2 , E3 , E4 , E5 , E6 , E7 , E8 , E9 > eventHandler (name: () -> String = { \u201ceventHandler\u201d }, update: WorkflowAction.Updater < PropsT , StateT , OutputT >.( E1 , E2 , E3 , E4 , E5 , E6 , E7 , E8 , E9 ) -> Unit ): ( E1 , E2 , E3 , E4 , E5 , E6 , E7 , E8 , E9 ) -> Unit open fun < E1 , E2 , E3 , E4 , E5 , E6 , E7 , E8 , E9 , E10 > eventHandler (name: () -> String = { \u201ceventHandler\u201d }, update: WorkflowAction.Updater < PropsT , StateT , OutputT >.( E1 , E2 , E3 , E4 , E5 , E6 , E7 , E8 , E9 , E10 ) -> Unit ): ( E1 , E2 , E3 , E4 , E5 , E6 , E7 , E8 , E9 , E10 ) -> Unit","title":"Event handler"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-base-render-context/event-handler/#eventhandler","text":"[jvm]\\ open fun eventHandler (name: () -> String = { \u201ceventHandler\u201d }, update: WorkflowAction.Updater < PropsT , StateT , OutputT >.() -> Unit ): () -> Unit Creates a function which builds a WorkflowAction from the given update function, and immediately passes it to actionSink . Handy for attaching event handlers to renderings.","title":"eventHandler"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-base-render-context/event-handler/#parameters","text":"jvm name A string describing the update, included in the action\u2019s toString as a debugging aid update Function that defines the workflow update. [jvm]\\ open fun < EventT > eventHandler (name: () -> String = { \u201ceventHandler\u201d }, update: WorkflowAction.Updater < PropsT , StateT , OutputT >.( EventT ) -> Unit ): ( EventT ) -> Unit open fun < E1 , E2 > eventHandler (name: () -> String = { \u201ceventHandler\u201d }, update: WorkflowAction.Updater < PropsT , StateT , OutputT >.( E1 , E2 ) -> Unit ): ( E1 , E2 ) -> Unit open fun < E1 , E2 , E3 > eventHandler (name: () -> String = { \u201ceventHandler\u201d }, update: WorkflowAction.Updater < PropsT , StateT , OutputT >.( E1 , E2 , E3 ) -> Unit ): ( E1 , E2 , E3 ) -> Unit open fun < E1 , E2 , E3 , E4 > eventHandler (name: () -> String = { \u201ceventHandler\u201d }, update: WorkflowAction.Updater < PropsT , StateT , OutputT >.( E1 , E2 , E3 , E4 ) -> Unit ): ( E1 , E2 , E3 , E4 ) -> Unit open fun < E1 , E2 , E3 , E4 , E5 > eventHandler (name: () -> String = { \u201ceventHandler\u201d }, update: WorkflowAction.Updater < PropsT , StateT , OutputT >.( E1 , E2 , E3 , E4 , E5 ) -> Unit ): ( E1 , E2 , E3 , E4 , E5 ) -> Unit open fun < E1 , E2 , E3 , E4 , E5 , E6 > eventHandler (name: () -> String = { \u201ceventHandler\u201d }, update: WorkflowAction.Updater < PropsT , StateT , OutputT >.( E1 , E2 , E3 , E4 , E5 , E6 ) -> Unit ): ( E1 , E2 , E3 , E4 , E5 , E6 ) -> Unit open fun < E1 , E2 , E3 , E4 , E5 , E6 , E7 > eventHandler (name: () -> String = { \u201ceventHandler\u201d }, update: WorkflowAction.Updater < PropsT , StateT , OutputT >.( E1 , E2 , E3 , E4 , E5 , E6 , E7 ) -> Unit ): ( E1 , E2 , E3 , E4 , E5 , E6 , E7 ) -> Unit open fun < E1 , E2 , E3 , E4 , E5 , E6 , E7 , E8 > eventHandler (name: () -> String = { \u201ceventHandler\u201d }, update: WorkflowAction.Updater < PropsT , StateT , OutputT >.( E1 , E2 , E3 , E4 , E5 , E6 , E7 , E8 ) -> Unit ): ( E1 , E2 , E3 , E4 , E5 , E6 , E7 , E8 ) -> Unit open fun < E1 , E2 , E3 , E4 , E5 , E6 , E7 , E8 , E9 > eventHandler (name: () -> String = { \u201ceventHandler\u201d }, update: WorkflowAction.Updater < PropsT , StateT , OutputT >.( E1 , E2 , E3 , E4 , E5 , E6 , E7 , E8 , E9 ) -> Unit ): ( E1 , E2 , E3 , E4 , E5 , E6 , E7 , E8 , E9 ) -> Unit open fun < E1 , E2 , E3 , E4 , E5 , E6 , E7 , E8 , E9 , E10 > eventHandler (name: () -> String = { \u201ceventHandler\u201d }, update: WorkflowAction.Updater < PropsT , StateT , OutputT >.( E1 , E2 , E3 , E4 , E5 , E6 , E7 , E8 , E9 , E10 ) -> Unit ): ( E1 , E2 , E3 , E4 , E5 , E6 , E7 , E8 , E9 , E10 ) -> Unit","title":"Parameters"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-base-render-context/render-child/","text":"// workflow / com.squareup.workflow1 / BaseRenderContext / renderChild renderChild \u00b6 [jvm]\\ abstract fun < ChildPropsT , ChildOutputT , ChildRenderingT > renderChild (child: Workflow < ChildPropsT , ChildOutputT , ChildRenderingT >, props: ChildPropsT , key: String = \u201c\u201d, handler: ( ChildOutputT ) -> WorkflowAction < PropsT , StateT , OutputT >): ChildRenderingT Ensures child is running as a child of this workflow, and returns the result of its render method. Never call StatefulWorkflow.render or StatelessWorkflow.render directly, always do it through this context method. If the child *wasn't* already running, it will be started either from [initialState](../-stateful-workflow/initial-state.md) or its snapshot. If the child *was* already running, The workflow's [onPropsChanged](../-stateful-workflow/on-props-changed.md) method is invoked with the previous input and this one. The child's render method is invoked with input and the child's state. After this method returns, if something happens that trigger\u2019s one of child\u2019s handlers, and that handler emits an output, the function passed as handler will be invoked with that output. Parameters \u00b6 jvm key An optional string key that is used to distinguish between workflows of the same type.","title":"Render child"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-base-render-context/render-child/#renderchild","text":"[jvm]\\ abstract fun < ChildPropsT , ChildOutputT , ChildRenderingT > renderChild (child: Workflow < ChildPropsT , ChildOutputT , ChildRenderingT >, props: ChildPropsT , key: String = \u201c\u201d, handler: ( ChildOutputT ) -> WorkflowAction < PropsT , StateT , OutputT >): ChildRenderingT Ensures child is running as a child of this workflow, and returns the result of its render method. Never call StatefulWorkflow.render or StatelessWorkflow.render directly, always do it through this context method. If the child *wasn't* already running, it will be started either from [initialState](../-stateful-workflow/initial-state.md) or its snapshot. If the child *was* already running, The workflow's [onPropsChanged](../-stateful-workflow/on-props-changed.md) method is invoked with the previous input and this one. The child's render method is invoked with input and the child's state. After this method returns, if something happens that trigger\u2019s one of child\u2019s handlers, and that handler emits an output, the function passed as handler will be invoked with that output.","title":"renderChild"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-base-render-context/render-child/#parameters","text":"jvm key An optional string key that is used to distinguish between workflows of the same type.","title":"Parameters"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-base-render-context/running-side-effect/","text":"// workflow / com.squareup.workflow1 / BaseRenderContext / runningSideEffect runningSideEffect \u00b6 [jvm]\\ abstract fun runningSideEffect (key: String , sideEffect: suspend CoroutineScope.() -> Unit ) Ensures sideEffect is running with the given key . The first render pass in which this method is called, sideEffect will be launched in a new coroutine that will be scoped to the rendering Workflow . Subsequent render passes that invoke this method with the same key will not launch the coroutine again, but let it keep running. Note that if a different function is passed with the same key, the side effect will not be restarted, the new function will simply be ignored. The next render pass in which the workflow does not call this method with the same key, the coroutine running sideEffect will be cancelled . The coroutine will run with the same CoroutineContext that the workflow runtime is running in. The side effect coroutine will not be started until after the first render call than runs it returns. Parameters \u00b6 jvm key The string key that is used to distinguish between side effects. sideEffect The suspend function that will be launched in a coroutine to perform the side effect.","title":"Running side effect"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-base-render-context/running-side-effect/#runningsideeffect","text":"[jvm]\\ abstract fun runningSideEffect (key: String , sideEffect: suspend CoroutineScope.() -> Unit ) Ensures sideEffect is running with the given key . The first render pass in which this method is called, sideEffect will be launched in a new coroutine that will be scoped to the rendering Workflow . Subsequent render passes that invoke this method with the same key will not launch the coroutine again, but let it keep running. Note that if a different function is passed with the same key, the side effect will not be restarted, the new function will simply be ignored. The next render pass in which the workflow does not call this method with the same key, the coroutine running sideEffect will be cancelled . The coroutine will run with the same CoroutineContext that the workflow runtime is running in. The side effect coroutine will not be started until after the first render call than runs it returns.","title":"runningSideEffect"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-base-render-context/running-side-effect/#parameters","text":"jvm key The string key that is used to distinguish between side effects. sideEffect The suspend function that will be launched in a coroutine to perform the side effect.","title":"Parameters"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-impostor-workflow/","text":"// workflow / com.squareup.workflow1 / ImpostorWorkflow ImpostorWorkflow \u00b6 [jvm]\\ interface ImpostorWorkflow Optional interface that Workflow s should implement if they need the runtime to consider their identity to include a child workflow\u2019s identity. Two ImpostorWorkflow s with the same concrete class, but different realIdentifier s will be considered different workflows by the runtime. This is intended to be used for helper workflows that implement things like operators by wrapping and delegating to other workflows, and which need to be able to express that the identity of the operator workflow is derived from the identity of the wrapped workflow. Functions \u00b6 Name Summary describeRealIdentifier [jvm] open fun describeRealIdentifier (): String ? Returns a string that describes how this workflow is related to realIdentifier . Properties \u00b6 Name Summary realIdentifier [jvm] abstract val realIdentifier : WorkflowIdentifier The WorkflowIdentifier of another workflow to be combined with the identifier of this workflow, as obtained by Workflow.identifier .","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-impostor-workflow/#impostorworkflow","text":"[jvm]\\ interface ImpostorWorkflow Optional interface that Workflow s should implement if they need the runtime to consider their identity to include a child workflow\u2019s identity. Two ImpostorWorkflow s with the same concrete class, but different realIdentifier s will be considered different workflows by the runtime. This is intended to be used for helper workflows that implement things like operators by wrapping and delegating to other workflows, and which need to be able to express that the identity of the operator workflow is derived from the identity of the wrapped workflow.","title":"ImpostorWorkflow"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-impostor-workflow/#functions","text":"Name Summary describeRealIdentifier [jvm] open fun describeRealIdentifier (): String ? Returns a string that describes how this workflow is related to realIdentifier .","title":"Functions"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-impostor-workflow/#properties","text":"Name Summary realIdentifier [jvm] abstract val realIdentifier : WorkflowIdentifier The WorkflowIdentifier of another workflow to be combined with the identifier of this workflow, as obtained by Workflow.identifier .","title":"Properties"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-impostor-workflow/describe-real-identifier/","text":"// workflow / com.squareup.workflow1 / ImpostorWorkflow / describeRealIdentifier describeRealIdentifier \u00b6 [jvm]\\ open fun describeRealIdentifier (): String ? Returns a string that describes how this workflow is related to realIdentifier .","title":"Describe real identifier"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-impostor-workflow/describe-real-identifier/#describerealidentifier","text":"[jvm]\\ open fun describeRealIdentifier (): String ? Returns a string that describes how this workflow is related to realIdentifier .","title":"describeRealIdentifier"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-impostor-workflow/real-identifier/","text":"// workflow / com.squareup.workflow1 / ImpostorWorkflow / realIdentifier realIdentifier \u00b6 [jvm]\\ abstract val realIdentifier : WorkflowIdentifier The WorkflowIdentifier of another workflow to be combined with the identifier of this workflow, as obtained by Workflow.identifier . For workflows that implement operators, this should be the identifier of the upstream Workflow that this workflow wraps.","title":"Real identifier"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-impostor-workflow/real-identifier/#realidentifier","text":"[jvm]\\ abstract val realIdentifier : WorkflowIdentifier The WorkflowIdentifier of another workflow to be combined with the identifier of this workflow, as obtained by Workflow.identifier . For workflows that implement operators, this should be the identifier of the upstream Workflow that this workflow wraps.","title":"realIdentifier"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-lifecycle-worker/","text":"// workflow / com.squareup.workflow1 / LifecycleWorker LifecycleWorker \u00b6 [jvm]\\ abstract class LifecycleWorker : Worker < Nothing > Worker that performs some action when the worker is started and/or stopped. A Worker is stopped when its parent Workflow finishes a render pass without running the worker, or when the parent workflow is itself torn down. Constructors \u00b6 LifecycleWorker [jvm] fun LifecycleWorker () Functions \u00b6 Name Summary doesSameWorkAs [jvm] open override fun doesSameWorkAs (otherWorker: Worker <*>): Boolean Equates LifecycleWorker s that have the same concrete class. onStarted [jvm] open fun onStarted () Called when this worker is started. It is executed concurrently with the parent workflow \u2013 the first render pass that starts this worker will not wait for this method to return, and one or more additional render passes may occur before this method is called. This behavior may change to be more strict in the future. onStopped [jvm] open fun onStopped () Called when this worker has been torn down. It is executed concurrently with the parent workflow \u2013 the render pass that cancels (stops) this worker will not wait for this method to return, and one or more additional render passes may occur before this method is called. This behavior may change to be more strict in the future. run [jvm] override fun run (): Flow< Nothing > Returns a Flow to execute the work represented by this worker.","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-lifecycle-worker/#lifecycleworker","text":"[jvm]\\ abstract class LifecycleWorker : Worker < Nothing > Worker that performs some action when the worker is started and/or stopped. A Worker is stopped when its parent Workflow finishes a render pass without running the worker, or when the parent workflow is itself torn down.","title":"LifecycleWorker"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-lifecycle-worker/#constructors","text":"LifecycleWorker [jvm] fun LifecycleWorker ()","title":"Constructors"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-lifecycle-worker/#functions","text":"Name Summary doesSameWorkAs [jvm] open override fun doesSameWorkAs (otherWorker: Worker <*>): Boolean Equates LifecycleWorker s that have the same concrete class. onStarted [jvm] open fun onStarted () Called when this worker is started. It is executed concurrently with the parent workflow \u2013 the first render pass that starts this worker will not wait for this method to return, and one or more additional render passes may occur before this method is called. This behavior may change to be more strict in the future. onStopped [jvm] open fun onStopped () Called when this worker has been torn down. It is executed concurrently with the parent workflow \u2013 the render pass that cancels (stops) this worker will not wait for this method to return, and one or more additional render passes may occur before this method is called. This behavior may change to be more strict in the future. run [jvm] override fun run (): Flow< Nothing > Returns a Flow to execute the work represented by this worker.","title":"Functions"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-lifecycle-worker/-lifecycle-worker/","text":"// workflow / com.squareup.workflow1 / LifecycleWorker / LifecycleWorker LifecycleWorker \u00b6 [jvm]\\ fun LifecycleWorker ()","title":" lifecycle worker"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-lifecycle-worker/-lifecycle-worker/#lifecycleworker","text":"[jvm]\\ fun LifecycleWorker ()","title":"LifecycleWorker"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-lifecycle-worker/does-same-work-as/","text":"// workflow / com.squareup.workflow1 / LifecycleWorker / doesSameWorkAs doesSameWorkAs \u00b6 [jvm]\\ open override fun doesSameWorkAs (otherWorker: Worker <*>): Boolean Equates LifecycleWorker s that have the same concrete class.","title":"Does same work as"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-lifecycle-worker/does-same-work-as/#doessameworkas","text":"[jvm]\\ open override fun doesSameWorkAs (otherWorker: Worker <*>): Boolean Equates LifecycleWorker s that have the same concrete class.","title":"doesSameWorkAs"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-lifecycle-worker/on-started/","text":"// workflow / com.squareup.workflow1 / LifecycleWorker / onStarted onStarted \u00b6 [jvm]\\ open fun onStarted () Called when this worker is started. It is executed concurrently with the parent workflow \u2013 the first render pass that starts this worker will not wait for this method to return, and one or more additional render passes may occur before this method is called. This behavior may change to be more strict in the future. This method will be called exactly once for each matching call to onStopped , and it will always be called first. Invoked on the dispatcher running the workflow.","title":"On started"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-lifecycle-worker/on-started/#onstarted","text":"[jvm]\\ open fun onStarted () Called when this worker is started. It is executed concurrently with the parent workflow \u2013 the first render pass that starts this worker will not wait for this method to return, and one or more additional render passes may occur before this method is called. This behavior may change to be more strict in the future. This method will be called exactly once for each matching call to onStopped , and it will always be called first. Invoked on the dispatcher running the workflow.","title":"onStarted"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-lifecycle-worker/on-stopped/","text":"// workflow / com.squareup.workflow1 / LifecycleWorker / onStopped onStopped \u00b6 [jvm]\\ open fun onStopped () Called when this worker has been torn down. It is executed concurrently with the parent workflow \u2013 the render pass that cancels (stops) this worker will not wait for this method to return, and one or more additional render passes may occur before this method is called. This behavior may change to be more strict in the future. This method will be called exactly once for each matching call to onStarted , and it will always be called second. Invoked on the dispatcher running the workflow.","title":"On stopped"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-lifecycle-worker/on-stopped/#onstopped","text":"[jvm]\\ open fun onStopped () Called when this worker has been torn down. It is executed concurrently with the parent workflow \u2013 the render pass that cancels (stops) this worker will not wait for this method to return, and one or more additional render passes may occur before this method is called. This behavior may change to be more strict in the future. This method will be called exactly once for each matching call to onStarted , and it will always be called second. Invoked on the dispatcher running the workflow.","title":"onStopped"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-lifecycle-worker/run/","text":"// workflow / com.squareup.workflow1 / LifecycleWorker / run run \u00b6 [jvm]\\ override fun run (): Flow< Nothing > Returns a Flow to execute the work represented by this worker. Flow is \u201ca cold asynchronous data stream that sequentially emits values and completes normally or with an exception\u201d, although it may not emit any values. It is common to use workers to perform some side effect that should only be executed when a state is entered \u2013 in this case, the worker never emits anything (and will have type Worker<Nothing>). Coroutine Context \u00b6 When a worker is started, a coroutine is launched to collect the flow. When the worker is torn down, the coroutine is cancelled. This coroutine is launched in the same scope as the workflow runtime, with a few changes: The dispatcher is always set to Unconfined to minimize overhead for workers that don't care which thread they're executed on (e.g. logging side effects, workers that wrap third-party reactive libraries, etc.). If your work cares which thread it runs on, use withContext or flowOn to specify a dispatcher. A CoroutineName that describes the Worker instance (via toString) and the key specified by the workflow running the worker. Exceptions \u00b6 If a worker needs to report an error to the workflow running it, it must not throw it as an exception \u2013 any exceptions thrown by a worker\u2019s Flow will cancel the entire workflow runtime. Instead, the worker\u2019s OutputT type should be capable of expressing errors itself, and the worker\u2019s logic should wrap any relevant exceptions into an output value (e.g. using the catch operator). While this might seem restrictive, this design decision keeps the BaseRenderContext.runningWorker API simpler, since it does not need to handle exceptions itself. It also discourages the code smell of relying on exceptions to handle control flow.","title":"Run"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-lifecycle-worker/run/#run","text":"[jvm]\\ override fun run (): Flow< Nothing > Returns a Flow to execute the work represented by this worker. Flow is \u201ca cold asynchronous data stream that sequentially emits values and completes normally or with an exception\u201d, although it may not emit any values. It is common to use workers to perform some side effect that should only be executed when a state is entered \u2013 in this case, the worker never emits anything (and will have type Worker<Nothing>).","title":"run"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-lifecycle-worker/run/#coroutine-context","text":"When a worker is started, a coroutine is launched to collect the flow. When the worker is torn down, the coroutine is cancelled. This coroutine is launched in the same scope as the workflow runtime, with a few changes: The dispatcher is always set to Unconfined to minimize overhead for workers that don't care which thread they're executed on (e.g. logging side effects, workers that wrap third-party reactive libraries, etc.). If your work cares which thread it runs on, use withContext or flowOn to specify a dispatcher. A CoroutineName that describes the Worker instance (via toString) and the key specified by the workflow running the worker.","title":"Coroutine Context"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-lifecycle-worker/run/#exceptions","text":"If a worker needs to report an error to the workflow running it, it must not throw it as an exception \u2013 any exceptions thrown by a worker\u2019s Flow will cancel the entire workflow runtime. Instead, the worker\u2019s OutputT type should be capable of expressing errors itself, and the worker\u2019s logic should wrap any relevant exceptions into an output value (e.g. using the catch operator). While this might seem restrictive, this design decision keeps the BaseRenderContext.runningWorker API simpler, since it does not need to handle exceptions itself. It also discourages the code smell of relying on exceptions to handle control flow.","title":"Exceptions"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-noop-workflow-interceptor/","text":"// workflow / com.squareup.workflow1 / NoopWorkflowInterceptor NoopWorkflowInterceptor \u00b6 [jvm]\\ object NoopWorkflowInterceptor : WorkflowInterceptor A WorkflowInterceptor that does not intercept anything. Functions \u00b6 Name Summary onInitialState [jvm] open fun < P , S > onInitialState (props: P , snapshot: Snapshot ?, proceed: ( P , Snapshot ?) -> S , session: WorkflowInterceptor.WorkflowSession ): S Intercepts calls to StatefulWorkflow.initialState . onPropsChanged [jvm] open fun < P , S > onPropsChanged (old: P , new: P , state: S , proceed: ( P , P , S ) -> S , session: WorkflowInterceptor.WorkflowSession ): S Intercepts calls to StatefulWorkflow.onPropsChanged . onRender [jvm] open fun < P , S , O , R > onRender (renderProps: P , renderState: S , context: BaseRenderContext < P , S , O >, proceed: ( P , S , WorkflowInterceptor.RenderContextInterceptor < P , S , O >?) -> R , session: WorkflowInterceptor.WorkflowSession ): R Intercepts calls to StatefulWorkflow.render . onSessionStarted [jvm] open fun onSessionStarted (workflowScope: CoroutineScope, session: WorkflowInterceptor.WorkflowSession ) Called when the session is starting, before onInitialState . onSnapshotState [jvm] open fun < S > onSnapshotState (state: S , proceed: ( S ) -> Snapshot ?, session: WorkflowInterceptor.WorkflowSession ): Snapshot ? Intercepts calls to StatefulWorkflow.snapshotState .","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-noop-workflow-interceptor/#noopworkflowinterceptor","text":"[jvm]\\ object NoopWorkflowInterceptor : WorkflowInterceptor A WorkflowInterceptor that does not intercept anything.","title":"NoopWorkflowInterceptor"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-noop-workflow-interceptor/#functions","text":"Name Summary onInitialState [jvm] open fun < P , S > onInitialState (props: P , snapshot: Snapshot ?, proceed: ( P , Snapshot ?) -> S , session: WorkflowInterceptor.WorkflowSession ): S Intercepts calls to StatefulWorkflow.initialState . onPropsChanged [jvm] open fun < P , S > onPropsChanged (old: P , new: P , state: S , proceed: ( P , P , S ) -> S , session: WorkflowInterceptor.WorkflowSession ): S Intercepts calls to StatefulWorkflow.onPropsChanged . onRender [jvm] open fun < P , S , O , R > onRender (renderProps: P , renderState: S , context: BaseRenderContext < P , S , O >, proceed: ( P , S , WorkflowInterceptor.RenderContextInterceptor < P , S , O >?) -> R , session: WorkflowInterceptor.WorkflowSession ): R Intercepts calls to StatefulWorkflow.render . onSessionStarted [jvm] open fun onSessionStarted (workflowScope: CoroutineScope, session: WorkflowInterceptor.WorkflowSession ) Called when the session is starting, before onInitialState . onSnapshotState [jvm] open fun < S > onSnapshotState (state: S , proceed: ( S ) -> Snapshot ?, session: WorkflowInterceptor.WorkflowSession ): Snapshot ? Intercepts calls to StatefulWorkflow.snapshotState .","title":"Functions"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-rendering-and-snapshot/","text":"// workflow / com.squareup.workflow1 / RenderingAndSnapshot RenderingAndSnapshot \u00b6 [jvm]\\ class RenderingAndSnapshot <out RenderingT >(rendering: RenderingT , snapshot: TreeSnapshot ) Tuple of rendering and snapshot used by renderWorkflowIn . Note that this class keeps the default identity equality implementation it inherits from Any, rather than comparing its rendering or snapshot . Constructors \u00b6 RenderingAndSnapshot [jvm] fun <out RenderingT > RenderingAndSnapshot (rendering: RenderingT , snapshot: TreeSnapshot ) Functions \u00b6 Name Summary component1 [jvm] operator fun component1 (): RenderingT component2 [jvm] operator fun component2 (): TreeSnapshot Properties \u00b6 Name Summary rendering [jvm] val rendering : RenderingT snapshot [jvm] val snapshot : TreeSnapshot","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-rendering-and-snapshot/#renderingandsnapshot","text":"[jvm]\\ class RenderingAndSnapshot <out RenderingT >(rendering: RenderingT , snapshot: TreeSnapshot ) Tuple of rendering and snapshot used by renderWorkflowIn . Note that this class keeps the default identity equality implementation it inherits from Any, rather than comparing its rendering or snapshot .","title":"RenderingAndSnapshot"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-rendering-and-snapshot/#constructors","text":"RenderingAndSnapshot [jvm] fun <out RenderingT > RenderingAndSnapshot (rendering: RenderingT , snapshot: TreeSnapshot )","title":"Constructors"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-rendering-and-snapshot/#functions","text":"Name Summary component1 [jvm] operator fun component1 (): RenderingT component2 [jvm] operator fun component2 (): TreeSnapshot","title":"Functions"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-rendering-and-snapshot/#properties","text":"Name Summary rendering [jvm] val rendering : RenderingT snapshot [jvm] val snapshot : TreeSnapshot","title":"Properties"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-rendering-and-snapshot/-rendering-and-snapshot/","text":"// workflow / com.squareup.workflow1 / RenderingAndSnapshot / RenderingAndSnapshot RenderingAndSnapshot \u00b6 [jvm]\\ fun <out RenderingT > RenderingAndSnapshot (rendering: RenderingT , snapshot: TreeSnapshot )","title":" rendering and snapshot"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-rendering-and-snapshot/-rendering-and-snapshot/#renderingandsnapshot","text":"[jvm]\\ fun <out RenderingT > RenderingAndSnapshot (rendering: RenderingT , snapshot: TreeSnapshot )","title":"RenderingAndSnapshot"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-rendering-and-snapshot/component1/","text":"// workflow / com.squareup.workflow1 / RenderingAndSnapshot / component1 component1 \u00b6 [jvm]\\ operator fun component1 (): RenderingT","title":"Component1"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-rendering-and-snapshot/component1/#component1","text":"[jvm]\\ operator fun component1 (): RenderingT","title":"component1"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-rendering-and-snapshot/component2/","text":"// workflow / com.squareup.workflow1 / RenderingAndSnapshot / component2 component2 \u00b6 [jvm]\\ operator fun component2 (): TreeSnapshot","title":"Component2"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-rendering-and-snapshot/component2/#component2","text":"[jvm]\\ operator fun component2 (): TreeSnapshot","title":"component2"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-rendering-and-snapshot/rendering/","text":"// workflow / com.squareup.workflow1 / RenderingAndSnapshot / rendering rendering \u00b6 [jvm]\\ val rendering : RenderingT","title":"Rendering"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-rendering-and-snapshot/rendering/#rendering","text":"[jvm]\\ val rendering : RenderingT","title":"rendering"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-rendering-and-snapshot/snapshot/","text":"// workflow / com.squareup.workflow1 / RenderingAndSnapshot / snapshot snapshot \u00b6 [jvm]\\ val snapshot : TreeSnapshot","title":"Snapshot"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-rendering-and-snapshot/snapshot/#snapshot","text":"[jvm]\\ val snapshot : TreeSnapshot","title":"snapshot"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-simple-logging-workflow-interceptor/","text":"// workflow / com.squareup.workflow1 / SimpleLoggingWorkflowInterceptor SimpleLoggingWorkflowInterceptor \u00b6 [jvm]\\ open class SimpleLoggingWorkflowInterceptor : WorkflowInterceptor A WorkflowInterceptor that just prints all method calls using log. Constructors \u00b6 SimpleLoggingWorkflowInterceptor [jvm] fun SimpleLoggingWorkflowInterceptor () Functions \u00b6 Name Summary onInitialState [jvm] open override fun < P , S > onInitialState (props: P , snapshot: Snapshot ?, proceed: ( P , Snapshot ?) -> S , session: WorkflowInterceptor.WorkflowSession ): S Intercepts calls to StatefulWorkflow.initialState . onPropsChanged [jvm] open override fun < P , S > onPropsChanged (old: P , new: P , state: S , proceed: ( P , P , S ) -> S , session: WorkflowInterceptor.WorkflowSession ): S Intercepts calls to StatefulWorkflow.onPropsChanged . onRender [jvm] open override fun < P , S , O , R > onRender (renderProps: P , renderState: S , context: BaseRenderContext < P , S , O >, proceed: ( P , S , WorkflowInterceptor.RenderContextInterceptor < P , S , O >?) -> R , session: WorkflowInterceptor.WorkflowSession ): R Intercepts calls to StatefulWorkflow.render . onSessionStarted [jvm] open override fun onSessionStarted (workflowScope: CoroutineScope, session: WorkflowInterceptor.WorkflowSession ) Called when the session is starting, before onInitialState . onSnapshotState [jvm] open override fun < S > onSnapshotState (state: S , proceed: ( S ) -> Snapshot ?, session: WorkflowInterceptor.WorkflowSession ): Snapshot ? Intercepts calls to StatefulWorkflow.snapshotState .","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-simple-logging-workflow-interceptor/#simpleloggingworkflowinterceptor","text":"[jvm]\\ open class SimpleLoggingWorkflowInterceptor : WorkflowInterceptor A WorkflowInterceptor that just prints all method calls using log.","title":"SimpleLoggingWorkflowInterceptor"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-simple-logging-workflow-interceptor/#constructors","text":"SimpleLoggingWorkflowInterceptor [jvm] fun SimpleLoggingWorkflowInterceptor ()","title":"Constructors"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-simple-logging-workflow-interceptor/#functions","text":"Name Summary onInitialState [jvm] open override fun < P , S > onInitialState (props: P , snapshot: Snapshot ?, proceed: ( P , Snapshot ?) -> S , session: WorkflowInterceptor.WorkflowSession ): S Intercepts calls to StatefulWorkflow.initialState . onPropsChanged [jvm] open override fun < P , S > onPropsChanged (old: P , new: P , state: S , proceed: ( P , P , S ) -> S , session: WorkflowInterceptor.WorkflowSession ): S Intercepts calls to StatefulWorkflow.onPropsChanged . onRender [jvm] open override fun < P , S , O , R > onRender (renderProps: P , renderState: S , context: BaseRenderContext < P , S , O >, proceed: ( P , S , WorkflowInterceptor.RenderContextInterceptor < P , S , O >?) -> R , session: WorkflowInterceptor.WorkflowSession ): R Intercepts calls to StatefulWorkflow.render . onSessionStarted [jvm] open override fun onSessionStarted (workflowScope: CoroutineScope, session: WorkflowInterceptor.WorkflowSession ) Called when the session is starting, before onInitialState . onSnapshotState [jvm] open override fun < S > onSnapshotState (state: S , proceed: ( S ) -> Snapshot ?, session: WorkflowInterceptor.WorkflowSession ): Snapshot ? Intercepts calls to StatefulWorkflow.snapshotState .","title":"Functions"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-simple-logging-workflow-interceptor/-simple-logging-workflow-interceptor/","text":"// workflow / com.squareup.workflow1 / SimpleLoggingWorkflowInterceptor / SimpleLoggingWorkflowInterceptor SimpleLoggingWorkflowInterceptor \u00b6 [jvm]\\ fun SimpleLoggingWorkflowInterceptor ()","title":" simple logging workflow interceptor"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-simple-logging-workflow-interceptor/-simple-logging-workflow-interceptor/#simpleloggingworkflowinterceptor","text":"[jvm]\\ fun SimpleLoggingWorkflowInterceptor ()","title":"SimpleLoggingWorkflowInterceptor"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-simple-logging-workflow-interceptor/on-initial-state/","text":"// workflow / com.squareup.workflow1 / SimpleLoggingWorkflowInterceptor / onInitialState onInitialState \u00b6 [jvm]\\ open override fun < P , S > onInitialState (props: P , snapshot: Snapshot ?, proceed: ( P , Snapshot ?) -> S , session: WorkflowInterceptor.WorkflowSession ): S Intercepts calls to StatefulWorkflow.initialState .","title":"On initial state"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-simple-logging-workflow-interceptor/on-initial-state/#oninitialstate","text":"[jvm]\\ open override fun < P , S > onInitialState (props: P , snapshot: Snapshot ?, proceed: ( P , Snapshot ?) -> S , session: WorkflowInterceptor.WorkflowSession ): S Intercepts calls to StatefulWorkflow.initialState .","title":"onInitialState"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-simple-logging-workflow-interceptor/on-props-changed/","text":"// workflow / com.squareup.workflow1 / SimpleLoggingWorkflowInterceptor / onPropsChanged onPropsChanged \u00b6 [jvm]\\ open override fun < P , S > onPropsChanged (old: P , new: P , state: S , proceed: ( P , P , S ) -> S , session: WorkflowInterceptor.WorkflowSession ): S Intercepts calls to StatefulWorkflow.onPropsChanged .","title":"On props changed"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-simple-logging-workflow-interceptor/on-props-changed/#onpropschanged","text":"[jvm]\\ open override fun < P , S > onPropsChanged (old: P , new: P , state: S , proceed: ( P , P , S ) -> S , session: WorkflowInterceptor.WorkflowSession ): S Intercepts calls to StatefulWorkflow.onPropsChanged .","title":"onPropsChanged"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-simple-logging-workflow-interceptor/on-render/","text":"// workflow / com.squareup.workflow1 / SimpleLoggingWorkflowInterceptor / onRender onRender \u00b6 [jvm]\\ open override fun < P , S , O , R > onRender (renderProps: P , renderState: S , context: BaseRenderContext < P , S , O >, proceed: ( P , S , WorkflowInterceptor.RenderContextInterceptor < P , S , O >?) -> R , session: WorkflowInterceptor.WorkflowSession ): R Intercepts calls to StatefulWorkflow.render .","title":"On render"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-simple-logging-workflow-interceptor/on-render/#onrender","text":"[jvm]\\ open override fun < P , S , O , R > onRender (renderProps: P , renderState: S , context: BaseRenderContext < P , S , O >, proceed: ( P , S , WorkflowInterceptor.RenderContextInterceptor < P , S , O >?) -> R , session: WorkflowInterceptor.WorkflowSession ): R Intercepts calls to StatefulWorkflow.render .","title":"onRender"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-simple-logging-workflow-interceptor/on-session-started/","text":"// workflow / com.squareup.workflow1 / SimpleLoggingWorkflowInterceptor / onSessionStarted onSessionStarted \u00b6 [jvm]\\ open override fun onSessionStarted (workflowScope: CoroutineScope, session: WorkflowInterceptor.WorkflowSession ) Called when the session is starting, before onInitialState . Parameters \u00b6 jvm workflowScope The CoroutineScope that will be used for any side effects the workflow runs, as well as the parent for any workflows it renders.","title":"On session started"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-simple-logging-workflow-interceptor/on-session-started/#onsessionstarted","text":"[jvm]\\ open override fun onSessionStarted (workflowScope: CoroutineScope, session: WorkflowInterceptor.WorkflowSession ) Called when the session is starting, before onInitialState .","title":"onSessionStarted"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-simple-logging-workflow-interceptor/on-session-started/#parameters","text":"jvm workflowScope The CoroutineScope that will be used for any side effects the workflow runs, as well as the parent for any workflows it renders.","title":"Parameters"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-simple-logging-workflow-interceptor/on-snapshot-state/","text":"// workflow / com.squareup.workflow1 / SimpleLoggingWorkflowInterceptor / onSnapshotState onSnapshotState \u00b6 [jvm]\\ open override fun < S > onSnapshotState (state: S , proceed: ( S ) -> Snapshot ?, session: WorkflowInterceptor.WorkflowSession ): Snapshot ? Intercepts calls to StatefulWorkflow.snapshotState .","title":"On snapshot state"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-simple-logging-workflow-interceptor/on-snapshot-state/#onsnapshotstate","text":"[jvm]\\ open override fun < S > onSnapshotState (state: S , proceed: ( S ) -> Snapshot ?, session: WorkflowInterceptor.WorkflowSession ): Snapshot ? Intercepts calls to StatefulWorkflow.snapshotState .","title":"onSnapshotState"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-sink/","text":"// workflow / com.squareup.workflow1 / Sink Sink \u00b6 [jvm]\\ fun interface Sink <in T > An object that receives values (commonly events or WorkflowAction ). BaseRenderContext.actionSink implements this interface. Functions \u00b6 Name Summary send [jvm] abstract fun send (value: T ) Extensions \u00b6 Name Summary contraMap [jvm] fun < T1 , T2 > Sink < T1 >. contraMap (transform: ( T2 ) -> T1 ): Sink < T2 > Generates a new sink of type T2 .","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-sink/#sink","text":"[jvm]\\ fun interface Sink <in T > An object that receives values (commonly events or WorkflowAction ). BaseRenderContext.actionSink implements this interface.","title":"Sink"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-sink/#functions","text":"Name Summary send [jvm] abstract fun send (value: T )","title":"Functions"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-sink/#extensions","text":"Name Summary contraMap [jvm] fun < T1 , T2 > Sink < T1 >. contraMap (transform: ( T2 ) -> T1 ): Sink < T2 > Generates a new sink of type T2 .","title":"Extensions"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-sink/send/","text":"// workflow / com.squareup.workflow1 / Sink / send send \u00b6 [jvm]\\ abstract fun send (value: T )","title":"Send"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-sink/send/#send","text":"[jvm]\\ abstract fun send (value: T )","title":"send"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-snapshot/","text":"// workflow / com.squareup.workflow1 / Snapshot Snapshot \u00b6 [jvm]\\ class Snapshot A lazy wrapper of ByteString. Allows Workflow s to capture their state frequently, without worrying about performing unnecessary serialization work. Types \u00b6 Name Summary Companion [jvm] object Companion Functions \u00b6 Name Summary equals [jvm] open operator override fun equals (other: Any ?): Boolean Compares Snapshots by comparing their bytes . hashCode [jvm] open override fun hashCode (): Int Calculates hashcode using bytes . toString [jvm] open override fun toString (): String Returns a String describing the bytes of this Snapshot. Properties \u00b6 Name Summary bytes [jvm] @get: JvmName (name = \u201cbytes\u201d) val bytes : ByteString Extensions \u00b6 Name Summary toParcelable [androidJvm] inline fun < T : Parcelable > Snapshot . toParcelable (): T ?","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-snapshot/#snapshot","text":"[jvm]\\ class Snapshot A lazy wrapper of ByteString. Allows Workflow s to capture their state frequently, without worrying about performing unnecessary serialization work.","title":"Snapshot"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-snapshot/#types","text":"Name Summary Companion [jvm] object Companion","title":"Types"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-snapshot/#functions","text":"Name Summary equals [jvm] open operator override fun equals (other: Any ?): Boolean Compares Snapshots by comparing their bytes . hashCode [jvm] open override fun hashCode (): Int Calculates hashcode using bytes . toString [jvm] open override fun toString (): String Returns a String describing the bytes of this Snapshot.","title":"Functions"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-snapshot/#properties","text":"Name Summary bytes [jvm] @get: JvmName (name = \u201cbytes\u201d) val bytes : ByteString","title":"Properties"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-snapshot/#extensions","text":"Name Summary toParcelable [androidJvm] inline fun < T : Parcelable > Snapshot . toParcelable (): T ?","title":"Extensions"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-snapshot/bytes/","text":"// workflow / com.squareup.workflow1 / Snapshot / bytes bytes \u00b6 [jvm]\\ @get: JvmName (name = \u201cbytes\u201d) val bytes : ByteString","title":"Bytes"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-snapshot/bytes/#bytes","text":"[jvm]\\ @get: JvmName (name = \u201cbytes\u201d) val bytes : ByteString","title":"bytes"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-snapshot/equals/","text":"// workflow / com.squareup.workflow1 / Snapshot / equals equals \u00b6 [jvm]\\ open operator override fun equals (other: Any ?): Boolean Compares Snapshots by comparing their bytes . This method forces serialization, calling it may be expensive.","title":"Equals"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-snapshot/equals/#equals","text":"[jvm]\\ open operator override fun equals (other: Any ?): Boolean Compares Snapshots by comparing their bytes . This method forces serialization, calling it may be expensive.","title":"equals"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-snapshot/hash-code/","text":"// workflow / com.squareup.workflow1 / Snapshot / hashCode hashCode \u00b6 [jvm]\\ open override fun hashCode (): Int Calculates hashcode using bytes . This method forces serialization, calling it may be expensive.","title":"Hash code"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-snapshot/hash-code/#hashcode","text":"[jvm]\\ open override fun hashCode (): Int Calculates hashcode using bytes . This method forces serialization, calling it may be expensive.","title":"hashCode"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-snapshot/to-string/","text":"// workflow / com.squareup.workflow1 / Snapshot / toString toString \u00b6 [jvm]\\ open override fun toString (): String Returns a String describing the bytes of this Snapshot. This method forces serialization, calling it may be expensive.","title":"To string"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-snapshot/to-string/#tostring","text":"[jvm]\\ open override fun toString (): String Returns a String describing the bytes of this Snapshot. This method forces serialization, calling it may be expensive.","title":"toString"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-snapshot/-companion/","text":"// workflow / com.squareup.workflow1 / Snapshot / Companion Companion \u00b6 [jvm]\\ object Companion Functions \u00b6 Name Summary of [jvm] @ JvmStatic fun of (lazy: () -> ByteString): Snapshot @ JvmStatic fun of (integer: Int ): Snapshot @ JvmStatic fun of (string: String ): Snapshot @ JvmStatic fun of (byteString: ByteString): Snapshot write [jvm] @ JvmStatic fun write (lazy: (BufferedSink) -> Unit ): Snapshot Create a snapshot by writing to a nice ergonomic BufferedSink.","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-snapshot/-companion/#companion","text":"[jvm]\\ object Companion","title":"Companion"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-snapshot/-companion/#functions","text":"Name Summary of [jvm] @ JvmStatic fun of (lazy: () -> ByteString): Snapshot @ JvmStatic fun of (integer: Int ): Snapshot @ JvmStatic fun of (string: String ): Snapshot @ JvmStatic fun of (byteString: ByteString): Snapshot write [jvm] @ JvmStatic fun write (lazy: (BufferedSink) -> Unit ): Snapshot Create a snapshot by writing to a nice ergonomic BufferedSink.","title":"Functions"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-snapshot/-companion/of/","text":"// workflow / com.squareup.workflow1 / Snapshot / Companion / of of \u00b6 [jvm]\\ @ JvmStatic fun of (string: String ): Snapshot @ JvmStatic fun of (byteString: ByteString): Snapshot @ JvmStatic fun of (lazy: () -> ByteString): Snapshot @ JvmStatic fun of (integer: Int ): Snapshot","title":"Of"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-snapshot/-companion/of/#of","text":"[jvm]\\ @ JvmStatic fun of (string: String ): Snapshot @ JvmStatic fun of (byteString: ByteString): Snapshot @ JvmStatic fun of (lazy: () -> ByteString): Snapshot @ JvmStatic fun of (integer: Int ): Snapshot","title":"of"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-snapshot/-companion/write/","text":"// workflow / com.squareup.workflow1 / Snapshot / Companion / write write \u00b6 [jvm]\\ @ JvmStatic fun write (lazy: (BufferedSink) -> Unit ): Snapshot Create a snapshot by writing to a nice ergonomic BufferedSink.","title":"Write"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-snapshot/-companion/write/#write","text":"[jvm]\\ @ JvmStatic fun write (lazy: (BufferedSink) -> Unit ): Snapshot Create a snapshot by writing to a nice ergonomic BufferedSink.","title":"write"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-stateful-workflow/","text":"// workflow / com.squareup.workflow1 / StatefulWorkflow StatefulWorkflow \u00b6 [jvm]\\ abstract class StatefulWorkflow <in PropsT , StateT , out OutputT , out RenderingT > : Workflow < PropsT , OutputT , RenderingT > A composable, stateful object that can handle events, delegate to children, subscribe to arbitrary asynchronous events from the outside world, and be saved to a serialized form to be restored later. The basic purpose of a Workflow is to take some props and return a rendering that serves as a public representation of its current state, and which can be used to update that state. A rendering typically serves as a view model, though this is not assumed, and is not the only use case. To that end, a workflow may keep track of internal state , recursively ask other workflows to render themselves, subscribe to data streams from the outside world, and handle events both from its renderings and from workflows it\u2019s delegated to (its \u201cchildren\u201d). A Workflow may also emit output events up to its parent Workflow. Workflows form a tree, where each workflow can have zero or more child workflows. Child workflows are started as necessary whenever another workflow asks for them, and are cleaned up automatically when they\u2019re no longer needed. Props propagate down the tree, outputs and renderings propagate up the tree. Avoid capturing stale state \u00b6 Workflows may not perform side effects in their render methods, but may perform side effects by running Worker s and getting events from RenderingT s via WorkflowAction s. A WorkflowAction defines how to update the StateT and what OutputT s to emit. Actions get access to the current workflow\u2019s state, and they must use that view of the state. If an action is defined inline, it is incorrect to capture, or close over, the StateT passed to render in the action. Workflows are executed synchronously, but external events may not be, so captured state may be stale when the action is invoked. See also \u00b6 jvm com.squareup.workflow1.StatelessWorkflow Parameters \u00b6 jvm PropsT Typically a data class that is used to pass configuration information or bits of state that the workflow can always get from its parent and needn\u2019t duplicate in its own state. May be Unit if the workflow does not need any props data. StateT Typically a data class that contains all of the internal state for this workflow. The state is seeded via props in initialState . It can be serialized and later used to restore the workflow. Implementations of the Workflow interface should not generally contain their own state directly. They may inject objects like instances of their child workflows, or network clients, but should not contain directly mutable state. This is the only type parameter that a parent workflow needn\u2019t care about for its children, and may just use star (*) instead of specifying it. May be Unit if the workflow does not have any internal state (see StatelessWorkflow ). OutputT Typically a sealed class that represents \u201cevents\u201d that this workflow can send to its parent. May be Nothing if the workflow doesn\u2019t need to emit anything. RenderingT The value returned to this workflow\u2019s parent during composition . Typically represents a \u201cview\u201d of this workflow\u2019s props, current state, and children\u2019s renderings. A workflow that represents a UI component may use a view model as its rendering type. Constructors \u00b6 StatefulWorkflow [jvm] fun StatefulWorkflow () Types \u00b6 Name Summary RenderContext [jvm] inner class RenderContext : BaseRenderContext <@ UnsafeVariance PropsT , StateT , @ UnsafeVariance OutputT > Functions \u00b6 Name Summary asStatefulWorkflow [jvm] override fun asStatefulWorkflow (): StatefulWorkflow < PropsT , StateT , OutputT , RenderingT > Satisfies the Workflow interface by returning this. initialState [jvm] abstract fun initialState (props: PropsT , snapshot: Snapshot ?): StateT Called from RenderContext.renderChild when the state machine is first started, to get the initial state. onPropsChanged [jvm] open fun onPropsChanged (old: PropsT , new: PropsT , state: StateT ): StateT Called from RenderContext.renderChild instead of initialState when the workflow is already running. This allows the workflow to detect changes in props, and possibly change its state in response. This method is called only if the new props value is not == with the old. render [jvm] abstract fun render (renderProps: PropsT , renderState: StateT , context: StatefulWorkflow.RenderContext < PropsT , StateT , OutputT , RenderingT >): RenderingT Called at least once\u2020 any time one of the following things happens: snapshotState [jvm] abstract fun snapshotState (state: StateT ): Snapshot ? Called whenever the state changes to generate a new Snapshot of the state. Extensions \u00b6 Name Summary action [jvm] fun < PropsT , StateT , OutputT , RenderingT > StatefulWorkflow < PropsT , StateT , OutputT , RenderingT >. action (name: String = \u201c\u201d, update: WorkflowAction.Updater < PropsT , StateT , OutputT >.() -> Unit ): WorkflowAction < PropsT , StateT , OutputT > fun < PropsT , StateT , OutputT , RenderingT > StatefulWorkflow < PropsT , StateT , OutputT , RenderingT >. action (name: () -> String , update: WorkflowAction.Updater < PropsT , StateT , OutputT >.() -> Unit ): WorkflowAction < PropsT , StateT , OutputT > Convenience to create a WorkflowAction with parameter types matching those of the receiving StatefulWorkflow . The action will invoke the given lambda when it is applied . launchForTestingFromStateWith [jvm] @TestOnly fun < T , PropsT , StateT , OutputT , RenderingT > StatefulWorkflow < PropsT , StateT , OutputT , RenderingT >. launchForTestingFromStateWith (props: PropsT , initialState: StateT , context: CoroutineContext = EmptyCoroutineContext, block: WorkflowTestRuntime < PropsT , OutputT , RenderingT >.() -> T ): T @TestOnly fun < StateT , OutputT , RenderingT > StatefulWorkflow < Unit , StateT , OutputT , RenderingT >. launchForTestingFromStateWith (initialState: StateT , context: CoroutineContext = EmptyCoroutineContext, block: WorkflowTestRuntime < Unit , OutputT , RenderingT >.() -> Unit ) Creates a WorkflowTestRuntime to run this workflow for unit testing. If the workflow is stateful , initialState is not called. Instead, the workflow is started from the given initialState . launchForTestingWith [jvm] @TestOnly fun < T , PropsT , StateT , OutputT , RenderingT > StatefulWorkflow < PropsT , StateT , OutputT , RenderingT >. launchForTestingWith (props: PropsT , testParams: WorkflowTestParams < StateT > = WorkflowTestParams(), context: CoroutineContext = EmptyCoroutineContext, block: WorkflowTestRuntime < PropsT , OutputT , RenderingT >.() -> T ): T Creates a WorkflowTestRuntime to run this workflow for unit testing. testRender [jvm] fun < PropsT , StateT , OutputT , RenderingT > StatefulWorkflow < PropsT , StateT , OutputT , RenderingT >. testRender (props: PropsT , initialState: StateT ): RenderTester < PropsT , StateT , OutputT , RenderingT > Create a RenderTester to unit test an individual render pass of this workflow.","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-stateful-workflow/#statefulworkflow","text":"[jvm]\\ abstract class StatefulWorkflow <in PropsT , StateT , out OutputT , out RenderingT > : Workflow < PropsT , OutputT , RenderingT > A composable, stateful object that can handle events, delegate to children, subscribe to arbitrary asynchronous events from the outside world, and be saved to a serialized form to be restored later. The basic purpose of a Workflow is to take some props and return a rendering that serves as a public representation of its current state, and which can be used to update that state. A rendering typically serves as a view model, though this is not assumed, and is not the only use case. To that end, a workflow may keep track of internal state , recursively ask other workflows to render themselves, subscribe to data streams from the outside world, and handle events both from its renderings and from workflows it\u2019s delegated to (its \u201cchildren\u201d). A Workflow may also emit output events up to its parent Workflow. Workflows form a tree, where each workflow can have zero or more child workflows. Child workflows are started as necessary whenever another workflow asks for them, and are cleaned up automatically when they\u2019re no longer needed. Props propagate down the tree, outputs and renderings propagate up the tree.","title":"StatefulWorkflow"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-stateful-workflow/#avoid-capturing-stale-state","text":"Workflows may not perform side effects in their render methods, but may perform side effects by running Worker s and getting events from RenderingT s via WorkflowAction s. A WorkflowAction defines how to update the StateT and what OutputT s to emit. Actions get access to the current workflow\u2019s state, and they must use that view of the state. If an action is defined inline, it is incorrect to capture, or close over, the StateT passed to render in the action. Workflows are executed synchronously, but external events may not be, so captured state may be stale when the action is invoked.","title":"Avoid capturing stale state"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-stateful-workflow/#see-also","text":"jvm com.squareup.workflow1.StatelessWorkflow","title":"See also"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-stateful-workflow/#parameters","text":"jvm PropsT Typically a data class that is used to pass configuration information or bits of state that the workflow can always get from its parent and needn\u2019t duplicate in its own state. May be Unit if the workflow does not need any props data. StateT Typically a data class that contains all of the internal state for this workflow. The state is seeded via props in initialState . It can be serialized and later used to restore the workflow. Implementations of the Workflow interface should not generally contain their own state directly. They may inject objects like instances of their child workflows, or network clients, but should not contain directly mutable state. This is the only type parameter that a parent workflow needn\u2019t care about for its children, and may just use star (*) instead of specifying it. May be Unit if the workflow does not have any internal state (see StatelessWorkflow ). OutputT Typically a sealed class that represents \u201cevents\u201d that this workflow can send to its parent. May be Nothing if the workflow doesn\u2019t need to emit anything. RenderingT The value returned to this workflow\u2019s parent during composition . Typically represents a \u201cview\u201d of this workflow\u2019s props, current state, and children\u2019s renderings. A workflow that represents a UI component may use a view model as its rendering type.","title":"Parameters"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-stateful-workflow/#constructors","text":"StatefulWorkflow [jvm] fun StatefulWorkflow ()","title":"Constructors"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-stateful-workflow/#types","text":"Name Summary RenderContext [jvm] inner class RenderContext : BaseRenderContext <@ UnsafeVariance PropsT , StateT , @ UnsafeVariance OutputT >","title":"Types"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-stateful-workflow/#functions","text":"Name Summary asStatefulWorkflow [jvm] override fun asStatefulWorkflow (): StatefulWorkflow < PropsT , StateT , OutputT , RenderingT > Satisfies the Workflow interface by returning this. initialState [jvm] abstract fun initialState (props: PropsT , snapshot: Snapshot ?): StateT Called from RenderContext.renderChild when the state machine is first started, to get the initial state. onPropsChanged [jvm] open fun onPropsChanged (old: PropsT , new: PropsT , state: StateT ): StateT Called from RenderContext.renderChild instead of initialState when the workflow is already running. This allows the workflow to detect changes in props, and possibly change its state in response. This method is called only if the new props value is not == with the old. render [jvm] abstract fun render (renderProps: PropsT , renderState: StateT , context: StatefulWorkflow.RenderContext < PropsT , StateT , OutputT , RenderingT >): RenderingT Called at least once\u2020 any time one of the following things happens: snapshotState [jvm] abstract fun snapshotState (state: StateT ): Snapshot ? Called whenever the state changes to generate a new Snapshot of the state.","title":"Functions"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-stateful-workflow/#extensions","text":"Name Summary action [jvm] fun < PropsT , StateT , OutputT , RenderingT > StatefulWorkflow < PropsT , StateT , OutputT , RenderingT >. action (name: String = \u201c\u201d, update: WorkflowAction.Updater < PropsT , StateT , OutputT >.() -> Unit ): WorkflowAction < PropsT , StateT , OutputT > fun < PropsT , StateT , OutputT , RenderingT > StatefulWorkflow < PropsT , StateT , OutputT , RenderingT >. action (name: () -> String , update: WorkflowAction.Updater < PropsT , StateT , OutputT >.() -> Unit ): WorkflowAction < PropsT , StateT , OutputT > Convenience to create a WorkflowAction with parameter types matching those of the receiving StatefulWorkflow . The action will invoke the given lambda when it is applied . launchForTestingFromStateWith [jvm] @TestOnly fun < T , PropsT , StateT , OutputT , RenderingT > StatefulWorkflow < PropsT , StateT , OutputT , RenderingT >. launchForTestingFromStateWith (props: PropsT , initialState: StateT , context: CoroutineContext = EmptyCoroutineContext, block: WorkflowTestRuntime < PropsT , OutputT , RenderingT >.() -> T ): T @TestOnly fun < StateT , OutputT , RenderingT > StatefulWorkflow < Unit , StateT , OutputT , RenderingT >. launchForTestingFromStateWith (initialState: StateT , context: CoroutineContext = EmptyCoroutineContext, block: WorkflowTestRuntime < Unit , OutputT , RenderingT >.() -> Unit ) Creates a WorkflowTestRuntime to run this workflow for unit testing. If the workflow is stateful , initialState is not called. Instead, the workflow is started from the given initialState . launchForTestingWith [jvm] @TestOnly fun < T , PropsT , StateT , OutputT , RenderingT > StatefulWorkflow < PropsT , StateT , OutputT , RenderingT >. launchForTestingWith (props: PropsT , testParams: WorkflowTestParams < StateT > = WorkflowTestParams(), context: CoroutineContext = EmptyCoroutineContext, block: WorkflowTestRuntime < PropsT , OutputT , RenderingT >.() -> T ): T Creates a WorkflowTestRuntime to run this workflow for unit testing. testRender [jvm] fun < PropsT , StateT , OutputT , RenderingT > StatefulWorkflow < PropsT , StateT , OutputT , RenderingT >. testRender (props: PropsT , initialState: StateT ): RenderTester < PropsT , StateT , OutputT , RenderingT > Create a RenderTester to unit test an individual render pass of this workflow.","title":"Extensions"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-stateful-workflow/-stateful-workflow/","text":"// workflow / com.squareup.workflow1 / StatefulWorkflow / StatefulWorkflow StatefulWorkflow \u00b6 [jvm]\\ fun StatefulWorkflow () Parameters \u00b6 jvm PropsT Typically a data class that is used to pass configuration information or bits of state that the workflow can always get from its parent and needn\u2019t duplicate in its own state. May be Unit if the workflow does not need any props data. StateT Typically a data class that contains all of the internal state for this workflow. The state is seeded via props in initialState . It can be serialized and later used to restore the workflow. Implementations of the Workflow interface should not generally contain their own state directly. They may inject objects like instances of their child workflows, or network clients, but should not contain directly mutable state. This is the only type parameter that a parent workflow needn\u2019t care about for its children, and may just use star (*) instead of specifying it. May be Unit if the workflow does not have any internal state (see StatelessWorkflow ). OutputT Typically a sealed class that represents \u201cevents\u201d that this workflow can send to its parent. May be Nothing if the workflow doesn\u2019t need to emit anything. RenderingT The value returned to this workflow\u2019s parent during composition . Typically represents a \u201cview\u201d of this workflow\u2019s props, current state, and children\u2019s renderings. A workflow that represents a UI component may use a view model as its rendering type.","title":" stateful workflow"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-stateful-workflow/-stateful-workflow/#statefulworkflow","text":"[jvm]\\ fun StatefulWorkflow ()","title":"StatefulWorkflow"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-stateful-workflow/-stateful-workflow/#parameters","text":"jvm PropsT Typically a data class that is used to pass configuration information or bits of state that the workflow can always get from its parent and needn\u2019t duplicate in its own state. May be Unit if the workflow does not need any props data. StateT Typically a data class that contains all of the internal state for this workflow. The state is seeded via props in initialState . It can be serialized and later used to restore the workflow. Implementations of the Workflow interface should not generally contain their own state directly. They may inject objects like instances of their child workflows, or network clients, but should not contain directly mutable state. This is the only type parameter that a parent workflow needn\u2019t care about for its children, and may just use star (*) instead of specifying it. May be Unit if the workflow does not have any internal state (see StatelessWorkflow ). OutputT Typically a sealed class that represents \u201cevents\u201d that this workflow can send to its parent. May be Nothing if the workflow doesn\u2019t need to emit anything. RenderingT The value returned to this workflow\u2019s parent during composition . Typically represents a \u201cview\u201d of this workflow\u2019s props, current state, and children\u2019s renderings. A workflow that represents a UI component may use a view model as its rendering type.","title":"Parameters"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-stateful-workflow/as-stateful-workflow/","text":"// workflow / com.squareup.workflow1 / StatefulWorkflow / asStatefulWorkflow asStatefulWorkflow \u00b6 [jvm]\\ override fun asStatefulWorkflow (): StatefulWorkflow < PropsT , StateT , OutputT , RenderingT > Satisfies the Workflow interface by returning this.","title":"As stateful workflow"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-stateful-workflow/as-stateful-workflow/#asstatefulworkflow","text":"[jvm]\\ override fun asStatefulWorkflow (): StatefulWorkflow < PropsT , StateT , OutputT , RenderingT > Satisfies the Workflow interface by returning this.","title":"asStatefulWorkflow"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-stateful-workflow/initial-state/","text":"// workflow / com.squareup.workflow1 / StatefulWorkflow / initialState initialState \u00b6 [jvm]\\ abstract fun initialState (props: PropsT , snapshot: Snapshot ?): StateT Called from RenderContext.renderChild when the state machine is first started, to get the initial state. Parameters \u00b6 jvm snapshot If the workflow is being created fresh, OR the workflow is being restored from a null or empty Snapshot , snapshot will be null. A snapshot is considered \u201cempty\u201d if Snapshot.bytes returns an empty ByteString, probably because snapshotState returned null. If the workflow is being restored from a Snapshot , snapshot will be the last value returned from snapshotState , and implementations that return something other than null should create their initial state by parsing their snapshot.","title":"Initial state"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-stateful-workflow/initial-state/#initialstate","text":"[jvm]\\ abstract fun initialState (props: PropsT , snapshot: Snapshot ?): StateT Called from RenderContext.renderChild when the state machine is first started, to get the initial state.","title":"initialState"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-stateful-workflow/initial-state/#parameters","text":"jvm snapshot If the workflow is being created fresh, OR the workflow is being restored from a null or empty Snapshot , snapshot will be null. A snapshot is considered \u201cempty\u201d if Snapshot.bytes returns an empty ByteString, probably because snapshotState returned null. If the workflow is being restored from a Snapshot , snapshot will be the last value returned from snapshotState , and implementations that return something other than null should create their initial state by parsing their snapshot.","title":"Parameters"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-stateful-workflow/on-props-changed/","text":"// workflow / com.squareup.workflow1 / StatefulWorkflow / onPropsChanged onPropsChanged \u00b6 [jvm]\\ open fun onPropsChanged (old: PropsT , new: PropsT , state: StateT ): StateT Called from RenderContext.renderChild instead of initialState when the workflow is already running. This allows the workflow to detect changes in props, and possibly change its state in response. This method is called only if the new props value is not == with the old. Default implementation does nothing.","title":"On props changed"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-stateful-workflow/on-props-changed/#onpropschanged","text":"[jvm]\\ open fun onPropsChanged (old: PropsT , new: PropsT , state: StateT ): StateT Called from RenderContext.renderChild instead of initialState when the workflow is already running. This allows the workflow to detect changes in props, and possibly change its state in response. This method is called only if the new props value is not == with the old. Default implementation does nothing.","title":"onPropsChanged"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-stateful-workflow/render/","text":"// workflow / com.squareup.workflow1 / StatefulWorkflow / render render \u00b6 [jvm]\\ abstract fun render (renderProps: PropsT , renderState: StateT , context: StatefulWorkflow.RenderContext < PropsT , StateT , OutputT , RenderingT >): RenderingT Called at least once\u2020 any time one of the following things happens: This workflow's [renderProps](render.md) changes (via the parent passing a different one in). This workflow's [renderState](render.md) changes. A descendant (immediate or transitive child) workflow: Changes its internal state. Emits an output. Never call this method directly. To nest the rendering of a child workflow in your own, pass the child and any required props to RenderContext.renderChild. This method should not have any side effects, and in particular should not do anything that blocks the current thread. It may be called multiple times for the same state. It must do all its work by calling methods on context . \u2020 This method is guaranteed to be called at least once for every state, but may be called multiple times. Allowing this method to be invoked multiple times makes the internals simpler.","title":"Render"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-stateful-workflow/render/#render","text":"[jvm]\\ abstract fun render (renderProps: PropsT , renderState: StateT , context: StatefulWorkflow.RenderContext < PropsT , StateT , OutputT , RenderingT >): RenderingT Called at least once\u2020 any time one of the following things happens: This workflow's [renderProps](render.md) changes (via the parent passing a different one in). This workflow's [renderState](render.md) changes. A descendant (immediate or transitive child) workflow: Changes its internal state. Emits an output. Never call this method directly. To nest the rendering of a child workflow in your own, pass the child and any required props to RenderContext.renderChild. This method should not have any side effects, and in particular should not do anything that blocks the current thread. It may be called multiple times for the same state. It must do all its work by calling methods on context . \u2020 This method is guaranteed to be called at least once for every state, but may be called multiple times. Allowing this method to be invoked multiple times makes the internals simpler.","title":"render"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-stateful-workflow/snapshot-state/","text":"// workflow / com.squareup.workflow1 / StatefulWorkflow / snapshotState snapshotState \u00b6 [jvm]\\ abstract fun snapshotState (state: StateT ): Snapshot ? Called whenever the state changes to generate a new Snapshot of the state. Snapshots must be lazy. Serialization must not be done at the time this method is called, since the state will be snapshotted frequently but the serialized form may only be needed very rarely. If the workflow does not have any state, or should always be started from scratch, return null from this method. See also \u00b6 jvm com.squareup.workflow1.StatefulWorkflow","title":"Snapshot state"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-stateful-workflow/snapshot-state/#snapshotstate","text":"[jvm]\\ abstract fun snapshotState (state: StateT ): Snapshot ? Called whenever the state changes to generate a new Snapshot of the state. Snapshots must be lazy. Serialization must not be done at the time this method is called, since the state will be snapshotted frequently but the serialized form may only be needed very rarely. If the workflow does not have any state, or should always be started from scratch, return null from this method.","title":"snapshotState"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-stateful-workflow/snapshot-state/#see-also","text":"jvm com.squareup.workflow1.StatefulWorkflow","title":"See also"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-stateful-workflow/-render-context/","text":"// workflow / com.squareup.workflow1 / StatefulWorkflow / RenderContext RenderContext \u00b6 [jvm]\\ inner class RenderContext : BaseRenderContext <@ UnsafeVariance PropsT , StateT , @ UnsafeVariance OutputT > Functions \u00b6 Name Summary eventHandler [jvm] open override fun <E1, E2, E3, E4, E5, E6, E7, E8, E9> eventHandler (name: () -> String , update: WorkflowAction.Updater <@ UnsafeVariance PropsT , StateT , @ UnsafeVariance OutputT >.(E1, E2, E3, E4, E5, E6, E7, E8, E9) -> Unit ): (E1, E2, E3, E4, E5, E6, E7, E8, E9) -> Unit open override fun <E1, E2, E3, E4, E5, E6, E7, E8, E9, E10> eventHandler (name: () -> String , update: WorkflowAction.Updater <@ UnsafeVariance PropsT , StateT , @ UnsafeVariance OutputT >.(E1, E2, E3, E4, E5, E6, E7, E8, E9, E10) -> Unit ): (E1, E2, E3, E4, E5, E6, E7, E8, E9, E10) -> Unit open override fun <EventT> eventHandler (name: () -> String , update: WorkflowAction.Updater <@ UnsafeVariance PropsT , StateT , @ UnsafeVariance OutputT >.(EventT) -> Unit ): (EventT) -> Unit open override fun <E1, E2> eventHandler (name: () -> String , update: WorkflowAction.Updater <@ UnsafeVariance PropsT , StateT , @ UnsafeVariance OutputT >.(E1, E2) -> Unit ): (E1, E2) -> Unit open override fun <E1, E2, E3> eventHandler (name: () -> String , update: WorkflowAction.Updater <@ UnsafeVariance PropsT , StateT , @ UnsafeVariance OutputT >.(E1, E2, E3) -> Unit ): (E1, E2, E3) -> Unit open override fun <E1, E2, E3, E4> eventHandler (name: () -> String , update: WorkflowAction.Updater <@ UnsafeVariance PropsT , StateT , @ UnsafeVariance OutputT >.(E1, E2, E3, E4) -> Unit ): (E1, E2, E3, E4) -> Unit open override fun <E1, E2, E3, E4, E5> eventHandler (name: () -> String , update: WorkflowAction.Updater <@ UnsafeVariance PropsT , StateT , @ UnsafeVariance OutputT >.(E1, E2, E3, E4, E5) -> Unit ): (E1, E2, E3, E4, E5) -> Unit open override fun <E1, E2, E3, E4, E5, E6> eventHandler (name: () -> String , update: WorkflowAction.Updater <@ UnsafeVariance PropsT , StateT , @ UnsafeVariance OutputT >.(E1, E2, E3, E4, E5, E6) -> Unit ): (E1, E2, E3, E4, E5, E6) -> Unit open override fun <E1, E2, E3, E4, E5, E6, E7> eventHandler (name: () -> String , update: WorkflowAction.Updater <@ UnsafeVariance PropsT , StateT , @ UnsafeVariance OutputT >.(E1, E2, E3, E4, E5, E6, E7) -> Unit ): (E1, E2, E3, E4, E5, E6, E7) -> Unit open override fun <E1, E2, E3, E4, E5, E6, E7, E8> eventHandler (name: () -> String , update: WorkflowAction.Updater <@ UnsafeVariance PropsT , StateT , @ UnsafeVariance OutputT >.(E1, E2, E3, E4, E5, E6, E7, E8) -> Unit ): (E1, E2, E3, E4, E5, E6, E7, E8) -> Unit [jvm] open override fun eventHandler (name: () -> String , update: WorkflowAction.Updater <@ UnsafeVariance PropsT , StateT , @ UnsafeVariance OutputT >.() -> Unit ): () -> Unit Creates a function which builds a WorkflowAction from the given update function, and immediately passes it to actionSink. Handy for attaching event handlers to renderings. renderChild [jvm] open override fun <ChildPropsT, ChildOutputT, ChildRenderingT> renderChild (child: Workflow <ChildPropsT, ChildOutputT, ChildRenderingT>, props: ChildPropsT, key: String , handler: (ChildOutputT) -> WorkflowAction <@ UnsafeVariance PropsT , StateT , @ UnsafeVariance OutputT >): ChildRenderingT Ensures child is running as a child of this workflow, and returns the result of its render method. runningSideEffect [jvm] open override fun runningSideEffect (key: String , sideEffect: suspend CoroutineScope.() -> Unit ) Ensures sideEffect is running with the given key. Properties \u00b6 Name Summary actionSink [jvm] open override val actionSink : Sink < WorkflowAction <@ UnsafeVariance PropsT , StateT , @ UnsafeVariance OutputT >> Accepts a single WorkflowAction , invokes that action by calling WorkflowAction.apply to update the current state, and optionally emits the returned output value if it is non-null.","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-stateful-workflow/-render-context/#rendercontext","text":"[jvm]\\ inner class RenderContext : BaseRenderContext <@ UnsafeVariance PropsT , StateT , @ UnsafeVariance OutputT >","title":"RenderContext"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-stateful-workflow/-render-context/#functions","text":"Name Summary eventHandler [jvm] open override fun <E1, E2, E3, E4, E5, E6, E7, E8, E9> eventHandler (name: () -> String , update: WorkflowAction.Updater <@ UnsafeVariance PropsT , StateT , @ UnsafeVariance OutputT >.(E1, E2, E3, E4, E5, E6, E7, E8, E9) -> Unit ): (E1, E2, E3, E4, E5, E6, E7, E8, E9) -> Unit open override fun <E1, E2, E3, E4, E5, E6, E7, E8, E9, E10> eventHandler (name: () -> String , update: WorkflowAction.Updater <@ UnsafeVariance PropsT , StateT , @ UnsafeVariance OutputT >.(E1, E2, E3, E4, E5, E6, E7, E8, E9, E10) -> Unit ): (E1, E2, E3, E4, E5, E6, E7, E8, E9, E10) -> Unit open override fun <EventT> eventHandler (name: () -> String , update: WorkflowAction.Updater <@ UnsafeVariance PropsT , StateT , @ UnsafeVariance OutputT >.(EventT) -> Unit ): (EventT) -> Unit open override fun <E1, E2> eventHandler (name: () -> String , update: WorkflowAction.Updater <@ UnsafeVariance PropsT , StateT , @ UnsafeVariance OutputT >.(E1, E2) -> Unit ): (E1, E2) -> Unit open override fun <E1, E2, E3> eventHandler (name: () -> String , update: WorkflowAction.Updater <@ UnsafeVariance PropsT , StateT , @ UnsafeVariance OutputT >.(E1, E2, E3) -> Unit ): (E1, E2, E3) -> Unit open override fun <E1, E2, E3, E4> eventHandler (name: () -> String , update: WorkflowAction.Updater <@ UnsafeVariance PropsT , StateT , @ UnsafeVariance OutputT >.(E1, E2, E3, E4) -> Unit ): (E1, E2, E3, E4) -> Unit open override fun <E1, E2, E3, E4, E5> eventHandler (name: () -> String , update: WorkflowAction.Updater <@ UnsafeVariance PropsT , StateT , @ UnsafeVariance OutputT >.(E1, E2, E3, E4, E5) -> Unit ): (E1, E2, E3, E4, E5) -> Unit open override fun <E1, E2, E3, E4, E5, E6> eventHandler (name: () -> String , update: WorkflowAction.Updater <@ UnsafeVariance PropsT , StateT , @ UnsafeVariance OutputT >.(E1, E2, E3, E4, E5, E6) -> Unit ): (E1, E2, E3, E4, E5, E6) -> Unit open override fun <E1, E2, E3, E4, E5, E6, E7> eventHandler (name: () -> String , update: WorkflowAction.Updater <@ UnsafeVariance PropsT , StateT , @ UnsafeVariance OutputT >.(E1, E2, E3, E4, E5, E6, E7) -> Unit ): (E1, E2, E3, E4, E5, E6, E7) -> Unit open override fun <E1, E2, E3, E4, E5, E6, E7, E8> eventHandler (name: () -> String , update: WorkflowAction.Updater <@ UnsafeVariance PropsT , StateT , @ UnsafeVariance OutputT >.(E1, E2, E3, E4, E5, E6, E7, E8) -> Unit ): (E1, E2, E3, E4, E5, E6, E7, E8) -> Unit [jvm] open override fun eventHandler (name: () -> String , update: WorkflowAction.Updater <@ UnsafeVariance PropsT , StateT , @ UnsafeVariance OutputT >.() -> Unit ): () -> Unit Creates a function which builds a WorkflowAction from the given update function, and immediately passes it to actionSink. Handy for attaching event handlers to renderings. renderChild [jvm] open override fun <ChildPropsT, ChildOutputT, ChildRenderingT> renderChild (child: Workflow <ChildPropsT, ChildOutputT, ChildRenderingT>, props: ChildPropsT, key: String , handler: (ChildOutputT) -> WorkflowAction <@ UnsafeVariance PropsT , StateT , @ UnsafeVariance OutputT >): ChildRenderingT Ensures child is running as a child of this workflow, and returns the result of its render method. runningSideEffect [jvm] open override fun runningSideEffect (key: String , sideEffect: suspend CoroutineScope.() -> Unit ) Ensures sideEffect is running with the given key.","title":"Functions"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-stateful-workflow/-render-context/#properties","text":"Name Summary actionSink [jvm] open override val actionSink : Sink < WorkflowAction <@ UnsafeVariance PropsT , StateT , @ UnsafeVariance OutputT >> Accepts a single WorkflowAction , invokes that action by calling WorkflowAction.apply to update the current state, and optionally emits the returned output value if it is non-null.","title":"Properties"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-stateless-workflow/","text":"// workflow / com.squareup.workflow1 / StatelessWorkflow StatelessWorkflow \u00b6 [jvm]\\ abstract class StatelessWorkflow <in PropsT , out OutputT , out RenderingT > : Workflow < PropsT , OutputT , RenderingT > Minimal implementation of Workflow that maintains no state of its own. See also \u00b6 jvm com.squareup.workflow1.StatefulWorkflow Parameters \u00b6 jvm PropsT Typically a data class that is used to pass configuration information or bits of state that the workflow can always get from its parent and needn\u2019t duplicate in its own state. May be Unit if the workflow does not need any props data. OutputT Typically a sealed class that represents \u201cevents\u201d that this workflow can send to its parent. May be Nothing if the workflow doesn\u2019t need to emit anything. RenderingT The value returned to this workflow\u2019s parent during composition . Typically represents a \u201cview\u201d of this workflow\u2019s props, current state, and children\u2019s renderings. A workflow that represents a UI component may use a view model as its rendering type. Constructors \u00b6 StatelessWorkflow [jvm] fun StatelessWorkflow () Types \u00b6 Name Summary RenderContext [jvm] inner class RenderContext : BaseRenderContext <@ UnsafeVariance PropsT , Nothing , @ UnsafeVariance OutputT > Functions \u00b6 Name Summary asStatefulWorkflow [jvm] override fun asStatefulWorkflow (): StatefulWorkflow < PropsT , *, OutputT , RenderingT > Satisfies the Workflow interface by wrapping this in a StatefulWorkflow with Unit state. render [jvm] abstract fun render (renderProps: PropsT , context: StatelessWorkflow.RenderContext < PropsT , OutputT , RenderingT >): RenderingT Called at least once any time one of the following things happens: Extensions \u00b6 Name Summary action [jvm] fun < PropsT , OutputT , RenderingT > StatelessWorkflow < PropsT , OutputT , RenderingT >. action (name: String = \u201c\u201d, update: WorkflowAction.Updater < PropsT , *, OutputT >.() -> Unit ): WorkflowAction < PropsT , Nothing , OutputT > fun < PropsT , OutputT , RenderingT > StatelessWorkflow < PropsT , OutputT , RenderingT >. action (name: () -> String , update: WorkflowAction.Updater < PropsT , *, OutputT >.() -> Unit ): WorkflowAction < PropsT , Nothing , OutputT > Convenience to create a WorkflowAction with parameter types matching those of the receiving StatefulWorkflow . The action will invoke the given lambda when it is applied .","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-stateless-workflow/#statelessworkflow","text":"[jvm]\\ abstract class StatelessWorkflow <in PropsT , out OutputT , out RenderingT > : Workflow < PropsT , OutputT , RenderingT > Minimal implementation of Workflow that maintains no state of its own.","title":"StatelessWorkflow"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-stateless-workflow/#see-also","text":"jvm com.squareup.workflow1.StatefulWorkflow","title":"See also"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-stateless-workflow/#parameters","text":"jvm PropsT Typically a data class that is used to pass configuration information or bits of state that the workflow can always get from its parent and needn\u2019t duplicate in its own state. May be Unit if the workflow does not need any props data. OutputT Typically a sealed class that represents \u201cevents\u201d that this workflow can send to its parent. May be Nothing if the workflow doesn\u2019t need to emit anything. RenderingT The value returned to this workflow\u2019s parent during composition . Typically represents a \u201cview\u201d of this workflow\u2019s props, current state, and children\u2019s renderings. A workflow that represents a UI component may use a view model as its rendering type.","title":"Parameters"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-stateless-workflow/#constructors","text":"StatelessWorkflow [jvm] fun StatelessWorkflow ()","title":"Constructors"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-stateless-workflow/#types","text":"Name Summary RenderContext [jvm] inner class RenderContext : BaseRenderContext <@ UnsafeVariance PropsT , Nothing , @ UnsafeVariance OutputT >","title":"Types"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-stateless-workflow/#functions","text":"Name Summary asStatefulWorkflow [jvm] override fun asStatefulWorkflow (): StatefulWorkflow < PropsT , *, OutputT , RenderingT > Satisfies the Workflow interface by wrapping this in a StatefulWorkflow with Unit state. render [jvm] abstract fun render (renderProps: PropsT , context: StatelessWorkflow.RenderContext < PropsT , OutputT , RenderingT >): RenderingT Called at least once any time one of the following things happens:","title":"Functions"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-stateless-workflow/#extensions","text":"Name Summary action [jvm] fun < PropsT , OutputT , RenderingT > StatelessWorkflow < PropsT , OutputT , RenderingT >. action (name: String = \u201c\u201d, update: WorkflowAction.Updater < PropsT , *, OutputT >.() -> Unit ): WorkflowAction < PropsT , Nothing , OutputT > fun < PropsT , OutputT , RenderingT > StatelessWorkflow < PropsT , OutputT , RenderingT >. action (name: () -> String , update: WorkflowAction.Updater < PropsT , *, OutputT >.() -> Unit ): WorkflowAction < PropsT , Nothing , OutputT > Convenience to create a WorkflowAction with parameter types matching those of the receiving StatefulWorkflow . The action will invoke the given lambda when it is applied .","title":"Extensions"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-stateless-workflow/-stateless-workflow/","text":"// workflow / com.squareup.workflow1 / StatelessWorkflow / StatelessWorkflow StatelessWorkflow \u00b6 [jvm]\\ fun StatelessWorkflow () Parameters \u00b6 jvm PropsT Typically a data class that is used to pass configuration information or bits of state that the workflow can always get from its parent and needn\u2019t duplicate in its own state. May be Unit if the workflow does not need any props data. OutputT Typically a sealed class that represents \u201cevents\u201d that this workflow can send to its parent. May be Nothing if the workflow doesn\u2019t need to emit anything. RenderingT The value returned to this workflow\u2019s parent during composition . Typically represents a \u201cview\u201d of this workflow\u2019s props, current state, and children\u2019s renderings. A workflow that represents a UI component may use a view model as its rendering type.","title":" stateless workflow"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-stateless-workflow/-stateless-workflow/#statelessworkflow","text":"[jvm]\\ fun StatelessWorkflow ()","title":"StatelessWorkflow"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-stateless-workflow/-stateless-workflow/#parameters","text":"jvm PropsT Typically a data class that is used to pass configuration information or bits of state that the workflow can always get from its parent and needn\u2019t duplicate in its own state. May be Unit if the workflow does not need any props data. OutputT Typically a sealed class that represents \u201cevents\u201d that this workflow can send to its parent. May be Nothing if the workflow doesn\u2019t need to emit anything. RenderingT The value returned to this workflow\u2019s parent during composition . Typically represents a \u201cview\u201d of this workflow\u2019s props, current state, and children\u2019s renderings. A workflow that represents a UI component may use a view model as its rendering type.","title":"Parameters"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-stateless-workflow/as-stateful-workflow/","text":"// workflow / com.squareup.workflow1 / StatelessWorkflow / asStatefulWorkflow asStatefulWorkflow \u00b6 [jvm]\\ override fun asStatefulWorkflow (): StatefulWorkflow < PropsT , *, OutputT , RenderingT > Satisfies the Workflow interface by wrapping this in a StatefulWorkflow with Unit state. This method is called a few times per instance, but we don\u2019t need to allocate a new StatefulWorkflow every time, so we store it in a private property.","title":"As stateful workflow"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-stateless-workflow/as-stateful-workflow/#asstatefulworkflow","text":"[jvm]\\ override fun asStatefulWorkflow (): StatefulWorkflow < PropsT , *, OutputT , RenderingT > Satisfies the Workflow interface by wrapping this in a StatefulWorkflow with Unit state. This method is called a few times per instance, but we don\u2019t need to allocate a new StatefulWorkflow every time, so we store it in a private property.","title":"asStatefulWorkflow"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-stateless-workflow/render/","text":"// workflow / com.squareup.workflow1 / StatelessWorkflow / render render \u00b6 [jvm]\\ abstract fun render (renderProps: PropsT , context: StatelessWorkflow.RenderContext < PropsT , OutputT , RenderingT >): RenderingT Called at least once any time one of the following things happens: This workflow's [renderProps](render.md) change (via the parent passing a different one in). A descendant (immediate or transitive child) workflow: Changes its internal state. Emits an output. Never call this method directly. To get the rendering from a child workflow, pass the child and any required props to RenderContext.renderChild. This method should not have any side effects, and in particular should not do anything that blocks the current thread. It may be called multiple times for the same state. It must do all its work by calling methods on context .","title":"Render"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-stateless-workflow/render/#render","text":"[jvm]\\ abstract fun render (renderProps: PropsT , context: StatelessWorkflow.RenderContext < PropsT , OutputT , RenderingT >): RenderingT Called at least once any time one of the following things happens: This workflow's [renderProps](render.md) change (via the parent passing a different one in). A descendant (immediate or transitive child) workflow: Changes its internal state. Emits an output. Never call this method directly. To get the rendering from a child workflow, pass the child and any required props to RenderContext.renderChild. This method should not have any side effects, and in particular should not do anything that blocks the current thread. It may be called multiple times for the same state. It must do all its work by calling methods on context .","title":"render"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-stateless-workflow/-render-context/","text":"// workflow / com.squareup.workflow1 / StatelessWorkflow / RenderContext RenderContext \u00b6 [jvm]\\ inner class RenderContext : BaseRenderContext <@ UnsafeVariance PropsT , Nothing , @ UnsafeVariance OutputT > Functions \u00b6 Name Summary eventHandler [jvm] open override fun <E1, E2, E3, E4, E5, E6, E7, E8, E9> eventHandler (name: () -> String , update: WorkflowAction.Updater <@ UnsafeVariance PropsT , Nothing , @ UnsafeVariance OutputT >.(E1, E2, E3, E4, E5, E6, E7, E8, E9) -> Unit ): (E1, E2, E3, E4, E5, E6, E7, E8, E9) -> Unit open override fun <E1, E2, E3, E4, E5, E6, E7, E8, E9, E10> eventHandler (name: () -> String , update: WorkflowAction.Updater <@ UnsafeVariance PropsT , Nothing , @ UnsafeVariance OutputT >.(E1, E2, E3, E4, E5, E6, E7, E8, E9, E10) -> Unit ): (E1, E2, E3, E4, E5, E6, E7, E8, E9, E10) -> Unit open override fun <EventT> eventHandler (name: () -> String , update: WorkflowAction.Updater <@ UnsafeVariance PropsT , Nothing , @ UnsafeVariance OutputT >.(EventT) -> Unit ): (EventT) -> Unit open override fun <E1, E2> eventHandler (name: () -> String , update: WorkflowAction.Updater <@ UnsafeVariance PropsT , Nothing , @ UnsafeVariance OutputT >.(E1, E2) -> Unit ): (E1, E2) -> Unit open override fun <E1, E2, E3> eventHandler (name: () -> String , update: WorkflowAction.Updater <@ UnsafeVariance PropsT , Nothing , @ UnsafeVariance OutputT >.(E1, E2, E3) -> Unit ): (E1, E2, E3) -> Unit open override fun <E1, E2, E3, E4> eventHandler (name: () -> String , update: WorkflowAction.Updater <@ UnsafeVariance PropsT , Nothing , @ UnsafeVariance OutputT >.(E1, E2, E3, E4) -> Unit ): (E1, E2, E3, E4) -> Unit open override fun <E1, E2, E3, E4, E5> eventHandler (name: () -> String , update: WorkflowAction.Updater <@ UnsafeVariance PropsT , Nothing , @ UnsafeVariance OutputT >.(E1, E2, E3, E4, E5) -> Unit ): (E1, E2, E3, E4, E5) -> Unit open override fun <E1, E2, E3, E4, E5, E6> eventHandler (name: () -> String , update: WorkflowAction.Updater <@ UnsafeVariance PropsT , Nothing , @ UnsafeVariance OutputT >.(E1, E2, E3, E4, E5, E6) -> Unit ): (E1, E2, E3, E4, E5, E6) -> Unit open override fun <E1, E2, E3, E4, E5, E6, E7> eventHandler (name: () -> String , update: WorkflowAction.Updater <@ UnsafeVariance PropsT , Nothing , @ UnsafeVariance OutputT >.(E1, E2, E3, E4, E5, E6, E7) -> Unit ): (E1, E2, E3, E4, E5, E6, E7) -> Unit open override fun <E1, E2, E3, E4, E5, E6, E7, E8> eventHandler (name: () -> String , update: WorkflowAction.Updater <@ UnsafeVariance PropsT , Nothing , @ UnsafeVariance OutputT >.(E1, E2, E3, E4, E5, E6, E7, E8) -> Unit ): (E1, E2, E3, E4, E5, E6, E7, E8) -> Unit [jvm] open override fun eventHandler (name: () -> String , update: WorkflowAction.Updater <@ UnsafeVariance PropsT , Nothing , @ UnsafeVariance OutputT >.() -> Unit ): () -> Unit Creates a function which builds a WorkflowAction from the given update function, and immediately passes it to actionSink. Handy for attaching event handlers to renderings. renderChild [jvm] open override fun <ChildPropsT, ChildOutputT, ChildRenderingT> renderChild (child: Workflow <ChildPropsT, ChildOutputT, ChildRenderingT>, props: ChildPropsT, key: String , handler: (ChildOutputT) -> WorkflowAction <@ UnsafeVariance PropsT , Nothing , @ UnsafeVariance OutputT >): ChildRenderingT Ensures child is running as a child of this workflow, and returns the result of its render method. runningSideEffect [jvm] open override fun runningSideEffect (key: String , sideEffect: suspend CoroutineScope.() -> Unit ) Ensures sideEffect is running with the given key. Properties \u00b6 Name Summary actionSink [jvm] open override val actionSink : Sink < WorkflowAction <@ UnsafeVariance PropsT , Nothing , @ UnsafeVariance OutputT >> Accepts a single WorkflowAction , invokes that action by calling WorkflowAction.apply to update the current state, and optionally emits the returned output value if it is non-null.","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-stateless-workflow/-render-context/#rendercontext","text":"[jvm]\\ inner class RenderContext : BaseRenderContext <@ UnsafeVariance PropsT , Nothing , @ UnsafeVariance OutputT >","title":"RenderContext"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-stateless-workflow/-render-context/#functions","text":"Name Summary eventHandler [jvm] open override fun <E1, E2, E3, E4, E5, E6, E7, E8, E9> eventHandler (name: () -> String , update: WorkflowAction.Updater <@ UnsafeVariance PropsT , Nothing , @ UnsafeVariance OutputT >.(E1, E2, E3, E4, E5, E6, E7, E8, E9) -> Unit ): (E1, E2, E3, E4, E5, E6, E7, E8, E9) -> Unit open override fun <E1, E2, E3, E4, E5, E6, E7, E8, E9, E10> eventHandler (name: () -> String , update: WorkflowAction.Updater <@ UnsafeVariance PropsT , Nothing , @ UnsafeVariance OutputT >.(E1, E2, E3, E4, E5, E6, E7, E8, E9, E10) -> Unit ): (E1, E2, E3, E4, E5, E6, E7, E8, E9, E10) -> Unit open override fun <EventT> eventHandler (name: () -> String , update: WorkflowAction.Updater <@ UnsafeVariance PropsT , Nothing , @ UnsafeVariance OutputT >.(EventT) -> Unit ): (EventT) -> Unit open override fun <E1, E2> eventHandler (name: () -> String , update: WorkflowAction.Updater <@ UnsafeVariance PropsT , Nothing , @ UnsafeVariance OutputT >.(E1, E2) -> Unit ): (E1, E2) -> Unit open override fun <E1, E2, E3> eventHandler (name: () -> String , update: WorkflowAction.Updater <@ UnsafeVariance PropsT , Nothing , @ UnsafeVariance OutputT >.(E1, E2, E3) -> Unit ): (E1, E2, E3) -> Unit open override fun <E1, E2, E3, E4> eventHandler (name: () -> String , update: WorkflowAction.Updater <@ UnsafeVariance PropsT , Nothing , @ UnsafeVariance OutputT >.(E1, E2, E3, E4) -> Unit ): (E1, E2, E3, E4) -> Unit open override fun <E1, E2, E3, E4, E5> eventHandler (name: () -> String , update: WorkflowAction.Updater <@ UnsafeVariance PropsT , Nothing , @ UnsafeVariance OutputT >.(E1, E2, E3, E4, E5) -> Unit ): (E1, E2, E3, E4, E5) -> Unit open override fun <E1, E2, E3, E4, E5, E6> eventHandler (name: () -> String , update: WorkflowAction.Updater <@ UnsafeVariance PropsT , Nothing , @ UnsafeVariance OutputT >.(E1, E2, E3, E4, E5, E6) -> Unit ): (E1, E2, E3, E4, E5, E6) -> Unit open override fun <E1, E2, E3, E4, E5, E6, E7> eventHandler (name: () -> String , update: WorkflowAction.Updater <@ UnsafeVariance PropsT , Nothing , @ UnsafeVariance OutputT >.(E1, E2, E3, E4, E5, E6, E7) -> Unit ): (E1, E2, E3, E4, E5, E6, E7) -> Unit open override fun <E1, E2, E3, E4, E5, E6, E7, E8> eventHandler (name: () -> String , update: WorkflowAction.Updater <@ UnsafeVariance PropsT , Nothing , @ UnsafeVariance OutputT >.(E1, E2, E3, E4, E5, E6, E7, E8) -> Unit ): (E1, E2, E3, E4, E5, E6, E7, E8) -> Unit [jvm] open override fun eventHandler (name: () -> String , update: WorkflowAction.Updater <@ UnsafeVariance PropsT , Nothing , @ UnsafeVariance OutputT >.() -> Unit ): () -> Unit Creates a function which builds a WorkflowAction from the given update function, and immediately passes it to actionSink. Handy for attaching event handlers to renderings. renderChild [jvm] open override fun <ChildPropsT, ChildOutputT, ChildRenderingT> renderChild (child: Workflow <ChildPropsT, ChildOutputT, ChildRenderingT>, props: ChildPropsT, key: String , handler: (ChildOutputT) -> WorkflowAction <@ UnsafeVariance PropsT , Nothing , @ UnsafeVariance OutputT >): ChildRenderingT Ensures child is running as a child of this workflow, and returns the result of its render method. runningSideEffect [jvm] open override fun runningSideEffect (key: String , sideEffect: suspend CoroutineScope.() -> Unit ) Ensures sideEffect is running with the given key.","title":"Functions"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-stateless-workflow/-render-context/#properties","text":"Name Summary actionSink [jvm] open override val actionSink : Sink < WorkflowAction <@ UnsafeVariance PropsT , Nothing , @ UnsafeVariance OutputT >> Accepts a single WorkflowAction , invokes that action by calling WorkflowAction.apply to update the current state, and optionally emits the returned output value if it is non-null.","title":"Properties"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-tree-snapshot/","text":"// workflow / com.squareup.workflow1 / TreeSnapshot TreeSnapshot \u00b6 [jvm]\\ class TreeSnapshot Aggregate of all the snapshots of a tree of workflows. Can be serialized with toByteString and deserialized with parse . For tests, you can get a TreeSnapshot from a RenderingAndSnapshot or by creating one for your root workflow only by calling forRootOnly . Parameters \u00b6 jvm childTreeSnapshots A function that will lazily parse the child snapshots for this tree when invoked. It will be cached in the childTreeSnapshots property. Types \u00b6 Name Summary Companion [jvm] object Companion Functions \u00b6 Name Summary equals [jvm] open operator override fun equals (other: Any ?): Boolean hashCode [jvm] open override fun hashCode (): Int toByteString [jvm] fun toByteString (): ByteString Writes this Snapshot and all its children into a ByteString. The snapshot can be restored with parse .","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-tree-snapshot/#treesnapshot","text":"[jvm]\\ class TreeSnapshot Aggregate of all the snapshots of a tree of workflows. Can be serialized with toByteString and deserialized with parse . For tests, you can get a TreeSnapshot from a RenderingAndSnapshot or by creating one for your root workflow only by calling forRootOnly .","title":"TreeSnapshot"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-tree-snapshot/#parameters","text":"jvm childTreeSnapshots A function that will lazily parse the child snapshots for this tree when invoked. It will be cached in the childTreeSnapshots property.","title":"Parameters"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-tree-snapshot/#types","text":"Name Summary Companion [jvm] object Companion","title":"Types"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-tree-snapshot/#functions","text":"Name Summary equals [jvm] open operator override fun equals (other: Any ?): Boolean hashCode [jvm] open override fun hashCode (): Int toByteString [jvm] fun toByteString (): ByteString Writes this Snapshot and all its children into a ByteString. The snapshot can be restored with parse .","title":"Functions"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-tree-snapshot/equals/","text":"// workflow / com.squareup.workflow1 / TreeSnapshot / equals equals \u00b6 [jvm]\\ open operator override fun equals (other: Any ?): Boolean","title":"Equals"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-tree-snapshot/equals/#equals","text":"[jvm]\\ open operator override fun equals (other: Any ?): Boolean","title":"equals"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-tree-snapshot/hash-code/","text":"// workflow / com.squareup.workflow1 / TreeSnapshot / hashCode hashCode \u00b6 [jvm]\\ open override fun hashCode (): Int","title":"Hash code"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-tree-snapshot/hash-code/#hashcode","text":"[jvm]\\ open override fun hashCode (): Int","title":"hashCode"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-tree-snapshot/to-byte-string/","text":"// workflow / com.squareup.workflow1 / TreeSnapshot / toByteString toByteString \u00b6 [jvm]\\ fun toByteString (): ByteString Writes this Snapshot and all its children into a ByteString. The snapshot can be restored with parse . Any children snapshots for workflows whose WorkflowIdentifier s are unsnapshottable will not be serialized.","title":"To byte string"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-tree-snapshot/to-byte-string/#tobytestring","text":"[jvm]\\ fun toByteString (): ByteString Writes this Snapshot and all its children into a ByteString. The snapshot can be restored with parse . Any children snapshots for workflows whose WorkflowIdentifier s are unsnapshottable will not be serialized.","title":"toByteString"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-tree-snapshot/-companion/","text":"// workflow / com.squareup.workflow1 / TreeSnapshot / Companion Companion \u00b6 [jvm]\\ object Companion Functions \u00b6 Name Summary forRootOnly [jvm] fun forRootOnly (rootSnapshot: Snapshot ?): TreeSnapshot Returns a TreeSnapshot that only contains a Snapshot for the root workflow, and no child snapshots. parse [jvm] fun parse (bytes: ByteString): TreeSnapshot Parses a \u201croot\u201d snapshot and the list of child snapshots with associated WorkflowNodeIds from a ByteString returned by toByteString .","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-tree-snapshot/-companion/#companion","text":"[jvm]\\ object Companion","title":"Companion"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-tree-snapshot/-companion/#functions","text":"Name Summary forRootOnly [jvm] fun forRootOnly (rootSnapshot: Snapshot ?): TreeSnapshot Returns a TreeSnapshot that only contains a Snapshot for the root workflow, and no child snapshots. parse [jvm] fun parse (bytes: ByteString): TreeSnapshot Parses a \u201croot\u201d snapshot and the list of child snapshots with associated WorkflowNodeIds from a ByteString returned by toByteString .","title":"Functions"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-tree-snapshot/-companion/for-root-only/","text":"// workflow / com.squareup.workflow1 / TreeSnapshot / Companion / forRootOnly forRootOnly \u00b6 [jvm]\\ fun forRootOnly (rootSnapshot: Snapshot ?): TreeSnapshot Returns a TreeSnapshot that only contains a Snapshot for the root workflow, and no child snapshots.","title":"For root only"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-tree-snapshot/-companion/for-root-only/#forrootonly","text":"[jvm]\\ fun forRootOnly (rootSnapshot: Snapshot ?): TreeSnapshot Returns a TreeSnapshot that only contains a Snapshot for the root workflow, and no child snapshots.","title":"forRootOnly"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-tree-snapshot/-companion/parse/","text":"// workflow / com.squareup.workflow1 / TreeSnapshot / Companion / parse parse \u00b6 [jvm]\\ fun parse (bytes: ByteString): TreeSnapshot Parses a \u201croot\u201d snapshot and the list of child snapshots with associated WorkflowNodeIds from a ByteString returned by toByteString . Never returns an empty root snapshot: if the root snapshot is empty it will be null. Child snapshots, however, are always returned as-is. They must be recursively passed to this function to continue parsing the tree. Note that this method is mostly lazy. It will parse the list of child TreeSnapshot s, but will not recursively parse each of those.","title":"Parse"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-tree-snapshot/-companion/parse/#parse","text":"[jvm]\\ fun parse (bytes: ByteString): TreeSnapshot Parses a \u201croot\u201d snapshot and the list of child snapshots with associated WorkflowNodeIds from a ByteString returned by toByteString . Never returns an empty root snapshot: if the root snapshot is empty it will be null. Child snapshots, however, are always returned as-is. They must be recursively passed to this function to continue parsing the tree. Note that this method is mostly lazy. It will parse the list of child TreeSnapshot s, but will not recursively parse each of those.","title":"parse"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-worker/","text":"// workflow / com.squareup.workflow1 / Worker Worker \u00b6 [jvm]\\ interface Worker <out OutputT > Represents a unit of asynchronous work that can have zero, one, or multiple outputs. Workers allow you to execute arbitrary, possibly asynchronous tasks in a declarative manner. To perform their tasks, workers return a Flow. Workers are effectively Flows that can be compared to determine equivalence between render passes. A Workflow uses Workers to perform asynchronous work during the render pass by calling BaseRenderContext.runningWorker . See the documentation on run for more information on the returned Flow is consumed and how to implement asynchronous work. See the documentation on doesSameWorkAs for more details on how and when workers are compared and the worker lifecycle. Example: Network request \u00b6 Let\u2019s say you have a network service with an API that returns a number, and you want to call that service from a Workflow . interface TimeService {\\ suspend fun getTime(timezone: String): Long\\ } The first step is to define a Worker that can call this service, and maybe an extension function on your service class: fun TimeService.getTimeWorker(timezone: String): Worker<Long> = TimeWorker(timezone, this)\\ \\ private class TimeWorker(\\ val timezone: String,\\ val service: TimeService\\ ): Worker<Long> {\\ \\ override fun run(): Flow<Long> = flow {\\ val time = service.getTime(timezone)\\ emit(time)\\ }\\ } You also need to define how to determine if a previous Worker is already doing the same work. This will ensure that if the same request is made by the same Workflow in adjacent render passes, we\u2019ll keep the request alive from the first pass. override fun doesSameWorkAs(otherWorker: Worker<*>): Boolean =\\ otherWorker is TimeWorker &&\\ timezone == otherWorker.timezone Now you can request the time from your Workflow : class MyWorkflow(private val timeWorker: TimeWorker) {\\ override fun render(\u2026): Foo {\\ context.runningWorker(timeWorker) { time -> emitOutput(\u201cThe time is $time\u201d) }\\ } Alternatively, if the response is a unique type, unlikely to be shared by any other workers, you don\u2019t even need to create your own Worker class, you can use a builder, and the worker will automatically be distinguished by that response type: interface TimeService {\\ fun getTime(timezone: String): Deferred<TimeResponse>\\ }\\ \\ fun TimeService.getTimeWorker(timezone: String): Worker<TimeResponse> =\\ Worker.from { getTime(timezone).await()) } See also \u00b6 jvm com.squareup.workflow1.Worker.Companion Types \u00b6 Name Summary Companion [jvm] object Companion Functions \u00b6 Name Summary doesSameWorkAs [jvm] open fun doesSameWorkAs (otherWorker: Worker <*>): Boolean Override this method to define equivalence between Worker s. The default implementation returns true if this worker\u2019s class is the same as otherWorker \u2018s class. run [jvm] abstract fun run (): Flow< OutputT > Returns a Flow to execute the work represented by this worker. Inheritors \u00b6 Name LifecycleWorker PublisherWorker WorkerSink Extensions \u00b6 Name Summary test [jvm] fun < T > Worker < T >. test (timeoutMs: Long = DEFAULT_TIMEOUT_MS, block: suspend WorkerTester < T >.() -> Unit ) Test a Worker by defining assertions on its output within block . transform [jvm] fun < T , R > Worker < T >. transform (transform: (Flow< T >) -> Flow< R >): Worker < R > Returns a Worker that transforms this Worker \u2018s Flow by calling transform .","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-worker/#worker","text":"[jvm]\\ interface Worker <out OutputT > Represents a unit of asynchronous work that can have zero, one, or multiple outputs. Workers allow you to execute arbitrary, possibly asynchronous tasks in a declarative manner. To perform their tasks, workers return a Flow. Workers are effectively Flows that can be compared to determine equivalence between render passes. A Workflow uses Workers to perform asynchronous work during the render pass by calling BaseRenderContext.runningWorker . See the documentation on run for more information on the returned Flow is consumed and how to implement asynchronous work. See the documentation on doesSameWorkAs for more details on how and when workers are compared and the worker lifecycle.","title":"Worker"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-worker/#example-network-request","text":"Let\u2019s say you have a network service with an API that returns a number, and you want to call that service from a Workflow . interface TimeService {\\ suspend fun getTime(timezone: String): Long\\ } The first step is to define a Worker that can call this service, and maybe an extension function on your service class: fun TimeService.getTimeWorker(timezone: String): Worker<Long> = TimeWorker(timezone, this)\\ \\ private class TimeWorker(\\ val timezone: String,\\ val service: TimeService\\ ): Worker<Long> {\\ \\ override fun run(): Flow<Long> = flow {\\ val time = service.getTime(timezone)\\ emit(time)\\ }\\ } You also need to define how to determine if a previous Worker is already doing the same work. This will ensure that if the same request is made by the same Workflow in adjacent render passes, we\u2019ll keep the request alive from the first pass. override fun doesSameWorkAs(otherWorker: Worker<*>): Boolean =\\ otherWorker is TimeWorker &&\\ timezone == otherWorker.timezone Now you can request the time from your Workflow : class MyWorkflow(private val timeWorker: TimeWorker) {\\ override fun render(\u2026): Foo {\\ context.runningWorker(timeWorker) { time -> emitOutput(\u201cThe time is $time\u201d) }\\ } Alternatively, if the response is a unique type, unlikely to be shared by any other workers, you don\u2019t even need to create your own Worker class, you can use a builder, and the worker will automatically be distinguished by that response type: interface TimeService {\\ fun getTime(timezone: String): Deferred<TimeResponse>\\ }\\ \\ fun TimeService.getTimeWorker(timezone: String): Worker<TimeResponse> =\\ Worker.from { getTime(timezone).await()) }","title":"Example: Network request"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-worker/#see-also","text":"jvm com.squareup.workflow1.Worker.Companion","title":"See also"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-worker/#types","text":"Name Summary Companion [jvm] object Companion","title":"Types"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-worker/#functions","text":"Name Summary doesSameWorkAs [jvm] open fun doesSameWorkAs (otherWorker: Worker <*>): Boolean Override this method to define equivalence between Worker s. The default implementation returns true if this worker\u2019s class is the same as otherWorker \u2018s class. run [jvm] abstract fun run (): Flow< OutputT > Returns a Flow to execute the work represented by this worker.","title":"Functions"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-worker/#inheritors","text":"Name LifecycleWorker PublisherWorker WorkerSink","title":"Inheritors"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-worker/#extensions","text":"Name Summary test [jvm] fun < T > Worker < T >. test (timeoutMs: Long = DEFAULT_TIMEOUT_MS, block: suspend WorkerTester < T >.() -> Unit ) Test a Worker by defining assertions on its output within block . transform [jvm] fun < T , R > Worker < T >. transform (transform: (Flow< T >) -> Flow< R >): Worker < R > Returns a Worker that transforms this Worker \u2018s Flow by calling transform .","title":"Extensions"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-worker/does-same-work-as/","text":"// workflow / com.squareup.workflow1 / Worker / doesSameWorkAs doesSameWorkAs \u00b6 [jvm]\\ open fun doesSameWorkAs (otherWorker: Worker <*>): Boolean Override this method to define equivalence between Worker s. The default implementation returns true if this worker\u2019s class is the same as otherWorker \u2018s class. At the end of every render pass, the set of Worker s that were requested by the workflow are compared to the set from the last render pass using this method. Workers are compared by their declared KType - including generics. Equivalent workers are allowed to keep running. New workers are started ( run is called and the returned Flow is collected). Old workers are cancelled by cancelling their collecting coroutines. Workers for which doesSameWorkAs returns false will also be restarted. Implementations of this method should not be based on object identity. Nor do they need to be based on anything including in the KType - such as generics - as those will already be compared by the Workflow Runtime, see WorkerWorkflow. For example, a Worker that performs a network request might check that two workers are requests to the same endpoint and have the same request data. Most implementations of this method should compare constructor parameters. E.g: class SearchWorker(private val query: String): Worker<SearchResult> {\\ // run omitted for example.\\ \\ override fun doesSameWorkAs(otherWorker: Worker<*>): Boolean =\\ otherWorker is SearchWorker && otherWorker.query == query\\ }","title":"Does same work as"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-worker/does-same-work-as/#doessameworkas","text":"[jvm]\\ open fun doesSameWorkAs (otherWorker: Worker <*>): Boolean Override this method to define equivalence between Worker s. The default implementation returns true if this worker\u2019s class is the same as otherWorker \u2018s class. At the end of every render pass, the set of Worker s that were requested by the workflow are compared to the set from the last render pass using this method. Workers are compared by their declared KType - including generics. Equivalent workers are allowed to keep running. New workers are started ( run is called and the returned Flow is collected). Old workers are cancelled by cancelling their collecting coroutines. Workers for which doesSameWorkAs returns false will also be restarted. Implementations of this method should not be based on object identity. Nor do they need to be based on anything including in the KType - such as generics - as those will already be compared by the Workflow Runtime, see WorkerWorkflow. For example, a Worker that performs a network request might check that two workers are requests to the same endpoint and have the same request data. Most implementations of this method should compare constructor parameters. E.g: class SearchWorker(private val query: String): Worker<SearchResult> {\\ // run omitted for example.\\ \\ override fun doesSameWorkAs(otherWorker: Worker<*>): Boolean =\\ otherWorker is SearchWorker && otherWorker.query == query\\ }","title":"doesSameWorkAs"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-worker/run/","text":"// workflow / com.squareup.workflow1 / Worker / run run \u00b6 [jvm]\\ abstract fun run (): Flow< OutputT > Returns a Flow to execute the work represented by this worker. Flow is \u201ca cold asynchronous data stream that sequentially emits values and completes normally or with an exception\u201d, although it may not emit any values. It is common to use workers to perform some side effect that should only be executed when a state is entered \u2013 in this case, the worker never emits anything (and will have type Worker<Nothing>). Coroutine Context \u00b6 When a worker is started, a coroutine is launched to collect the flow. When the worker is torn down, the coroutine is cancelled. This coroutine is launched in the same scope as the workflow runtime, with a few changes: The dispatcher is always set to Unconfined to minimize overhead for workers that don't care which thread they're executed on (e.g. logging side effects, workers that wrap third-party reactive libraries, etc.). If your work cares which thread it runs on, use withContext or flowOn to specify a dispatcher. A CoroutineName that describes the Worker instance (via toString) and the key specified by the workflow running the worker. Exceptions \u00b6 If a worker needs to report an error to the workflow running it, it must not throw it as an exception \u2013 any exceptions thrown by a worker\u2019s Flow will cancel the entire workflow runtime. Instead, the worker\u2019s OutputT type should be capable of expressing errors itself, and the worker\u2019s logic should wrap any relevant exceptions into an output value (e.g. using the catch operator). While this might seem restrictive, this design decision keeps the BaseRenderContext.runningWorker API simpler, since it does not need to handle exceptions itself. It also discourages the code smell of relying on exceptions to handle control flow.","title":"Run"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-worker/run/#run","text":"[jvm]\\ abstract fun run (): Flow< OutputT > Returns a Flow to execute the work represented by this worker. Flow is \u201ca cold asynchronous data stream that sequentially emits values and completes normally or with an exception\u201d, although it may not emit any values. It is common to use workers to perform some side effect that should only be executed when a state is entered \u2013 in this case, the worker never emits anything (and will have type Worker<Nothing>).","title":"run"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-worker/run/#coroutine-context","text":"When a worker is started, a coroutine is launched to collect the flow. When the worker is torn down, the coroutine is cancelled. This coroutine is launched in the same scope as the workflow runtime, with a few changes: The dispatcher is always set to Unconfined to minimize overhead for workers that don't care which thread they're executed on (e.g. logging side effects, workers that wrap third-party reactive libraries, etc.). If your work cares which thread it runs on, use withContext or flowOn to specify a dispatcher. A CoroutineName that describes the Worker instance (via toString) and the key specified by the workflow running the worker.","title":"Coroutine Context"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-worker/run/#exceptions","text":"If a worker needs to report an error to the workflow running it, it must not throw it as an exception \u2013 any exceptions thrown by a worker\u2019s Flow will cancel the entire workflow runtime. Instead, the worker\u2019s OutputT type should be capable of expressing errors itself, and the worker\u2019s logic should wrap any relevant exceptions into an output value (e.g. using the catch operator). While this might seem restrictive, this design decision keeps the BaseRenderContext.runningWorker API simpler, since it does not need to handle exceptions itself. It also discourages the code smell of relying on exceptions to handle control flow.","title":"Exceptions"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-worker/-companion/","text":"// workflow / com.squareup.workflow1 / Worker / Companion Companion \u00b6 [jvm]\\ object Companion Functions \u00b6 Name Summary create [jvm] inline fun < OutputT > create (noinline block: suspend FlowCollector< OutputT >.() -> Unit ): Worker < OutputT > Shorthand for flow { block() }.asWorker(). finished [jvm] fun < T > finished (): Worker < T > Returns a Worker that finishes immediately without emitting anything. from [jvm] inline fun < OutputT > from (noinline block: suspend () -> OutputT ): Worker < OutputT > Creates a Worker from a function that returns a single value. fromNullable [jvm] inline fun < OutputT > fromNullable (noinline block: suspend () -> OutputT ?): Worker < OutputT > Creates a Worker from a function that returns a single value. The worker will emit the value if and only if the value is not null , then finish. timer [jvm] fun timer (delayMs: Long , key: String = \u201c\u201d): Worker < Unit > Creates a Worker that will emit Unit and then finish after delayMs milliseconds. Negative delays are clamped to zero.","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-worker/-companion/#companion","text":"[jvm]\\ object Companion","title":"Companion"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-worker/-companion/#functions","text":"Name Summary create [jvm] inline fun < OutputT > create (noinline block: suspend FlowCollector< OutputT >.() -> Unit ): Worker < OutputT > Shorthand for flow { block() }.asWorker(). finished [jvm] fun < T > finished (): Worker < T > Returns a Worker that finishes immediately without emitting anything. from [jvm] inline fun < OutputT > from (noinline block: suspend () -> OutputT ): Worker < OutputT > Creates a Worker from a function that returns a single value. fromNullable [jvm] inline fun < OutputT > fromNullable (noinline block: suspend () -> OutputT ?): Worker < OutputT > Creates a Worker from a function that returns a single value. The worker will emit the value if and only if the value is not null , then finish. timer [jvm] fun timer (delayMs: Long , key: String = \u201c\u201d): Worker < Unit > Creates a Worker that will emit Unit and then finish after delayMs milliseconds. Negative delays are clamped to zero.","title":"Functions"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-worker/-companion/create/","text":"// workflow / com.squareup.workflow1 / Worker / Companion / create create \u00b6 [jvm]\\ inline fun < OutputT > create (noinline block: suspend FlowCollector< OutputT >.() -> Unit ): Worker < OutputT > Shorthand for flow { block() }.asWorker(). Note: If your worker just needs to perform side effects and doesn\u2019t need to emit anything, do not use a Worker but instead call BaseRenderContext::runningSideEffect","title":"Create"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-worker/-companion/create/#create","text":"[jvm]\\ inline fun < OutputT > create (noinline block: suspend FlowCollector< OutputT >.() -> Unit ): Worker < OutputT > Shorthand for flow { block() }.asWorker(). Note: If your worker just needs to perform side effects and doesn\u2019t need to emit anything, do not use a Worker but instead call BaseRenderContext::runningSideEffect","title":"create"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-worker/-companion/finished/","text":"// workflow / com.squareup.workflow1 / Worker / Companion / finished finished \u00b6 [jvm]\\ fun < T > finished (): Worker < T > Returns a Worker that finishes immediately without emitting anything.","title":"Finished"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-worker/-companion/finished/#finished","text":"[jvm]\\ fun < T > finished (): Worker < T > Returns a Worker that finishes immediately without emitting anything.","title":"finished"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-worker/-companion/from-nullable/","text":"// workflow / com.squareup.workflow1 / Worker / Companion / fromNullable fromNullable \u00b6 [jvm]\\ inline fun < OutputT > fromNullable (noinline block: suspend () -> OutputT ?): Worker < OutputT > Creates a Worker from a function that returns a single value. The worker will emit the value if and only if the value is not null , then finish. The returned Worker will equate to any other workers created with any of the Worker builder functions that have the same output type.","title":"From nullable"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-worker/-companion/from-nullable/#fromnullable","text":"[jvm]\\ inline fun < OutputT > fromNullable (noinline block: suspend () -> OutputT ?): Worker < OutputT > Creates a Worker from a function that returns a single value. The worker will emit the value if and only if the value is not null , then finish. The returned Worker will equate to any other workers created with any of the Worker builder functions that have the same output type.","title":"fromNullable"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-worker/-companion/from/","text":"// workflow / com.squareup.workflow1 / Worker / Companion / from from \u00b6 [jvm]\\ inline fun < OutputT > from (noinline block: suspend () -> OutputT ): Worker < OutputT > Creates a Worker from a function that returns a single value. Shorthand for flow { emit(block()) }.asWorker(). The returned Worker will equate to any other workers created with any of the Worker builder functions that have the same output type.","title":"From"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-worker/-companion/from/#from","text":"[jvm]\\ inline fun < OutputT > from (noinline block: suspend () -> OutputT ): Worker < OutputT > Creates a Worker from a function that returns a single value. Shorthand for flow { emit(block()) }.asWorker(). The returned Worker will equate to any other workers created with any of the Worker builder functions that have the same output type.","title":"from"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-worker/-companion/timer/","text":"// workflow / com.squareup.workflow1 / Worker / Companion / timer timer \u00b6 [jvm]\\ fun timer (delayMs: Long , key: String = \u201c\u201d): Worker < Unit > Creates a Worker that will emit Unit and then finish after delayMs milliseconds. Negative delays are clamped to zero. Workers returned by this function will be compared by key .","title":"Timer"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-worker/-companion/timer/#timer","text":"[jvm]\\ fun timer (delayMs: Long , key: String = \u201c\u201d): Worker < Unit > Creates a Worker that will emit Unit and then finish after delayMs milliseconds. Negative delays are clamped to zero. Workers returned by this function will be compared by key .","title":"timer"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow/","text":"// workflow / com.squareup.workflow1 / Workflow Workflow \u00b6 [jvm]\\ interface Workflow <in PropsT , out OutputT , out RenderingT > A composable, optionally-stateful object that can handle events , delegate to children , subscribe to arbitrary asynchronous events from the outside world. The basic purpose of a Workflow is to take some input (in the form of PropsT ) and return a rendering . To that end, a workflow may keep track of internal state , recursively ask other workflows to render themselves, subscribe to data streams from the outside world, and handle events both from its renderings and from workflows it\u2019s delegated to (its \u201cchildren\u201d). A Workflow may also emit output events up to its parent Workflow. Workflows form a tree, where each workflow can have zero or more child workflows. Child workflows are started as necessary whenever another workflow asks for them, and are cleaned up automatically when they\u2019re no longer needed. Props propagates down the tree, outputs and renderings propagate up the tree. Implementing Workflow \u00b6 The Workflow interface is useful as a facade for your API. You can publish an interface that extends Workflow, and keep the implementation (e.g. is your workflow state*ful* or state*less* a private implementation detail. You should almost never implement Workflow directly, however. There are two abstract classes that you should subclass instead: StatefulWorkflow and StatelessWorkflow . The differences between them are described below, but both type have a render method that you implement to generate renderings from your props and interact with the runtime (e.g. by changing state or emitting outputs). Stateful Workflows \u00b6 If your workflow needs to keep track of internal state, subclass StatefulWorkflow . It has an additional type parameter, StateT, requires you to specify how to create the initial state and how to snapshot /restore your state, and passes the current state to the StatefulWorkflow.render method. Stateless Workflows \u00b6 If your workflow does not have any state of its own and simply needs to delegate to other workflows (e.g. transforming props, outputs, or renderings), subclass StatelessWorkflow and implement its sole StatelessWorkflow.render method, or just pass a lambda to the stateless function. Interacting with events and other workflows \u00b6 All workflows are passed a RenderContext in their render methods. This context allows the workflow to interact with the outside world by doing things like listening for events, subscribing to streams of data, rendering child workflows, and performing cleanup when the workflow is about to be torn down by its parent. See the documentation on BaseRenderContext for more information about what it can do. Things to avoid \u00b6 Mutable instance state \u00b6 Classes that implement Workflow should not contain mutable properties. Such properties are instance-specific state and can introduce buggy behavior. Instead, subclass StatefulWorkflow and move all your state to the workflow\u2019s StateT type. For example, setting a property will not cause your workflow to be re-rendered \u2013 the runtime has no way of knowing that some data it doesn\u2019t know about has changed. It can also break consumers of your workflows, who may be expecting to be able to re-use the same instance of your workflow type in different places in the workflow tree \u2013 this works if all the workflow\u2019s state is contained in its StateT, but not if the instance has its own properties. (Note that storing dependencies, which are effectively static relative to the workflow instance, in properties is fine.) Render side effects \u00b6 Workflows\u2019 render methods must not perform side effects or read mutable state. They can contain logic, but the logic must be based on the PropsT , the StateT if present, and the renderings from other workflows. They must declare what work to perform (via Worker s), and what data to render (via RenderingT s and child workflows). For this reason, programming with workflows can be considered declarative-style programming. See also \u00b6 jvm com.squareup.workflow1.StatefulWorkflow com.squareup.workflow1.StatelessWorkflow Parameters \u00b6 jvm PropsT Typically a data class that is used to pass configuration information or bits of state that the workflow can always get from its parent and needn\u2019t duplicate in its own state. May be Unit if the workflow does not need any props data. OutputT Typically a sealed class that represents \u201cevents\u201d that this workflow can send to its parent. May be Nothing if the workflow doesn\u2019t need to emit anything. RenderingT The value returned to this workflow\u2019s parent during composition . Typically represents a \u201cview\u201d of this workflow\u2019s props, current state, and children\u2019s renderings. A workflow that represents a UI component may use a view model as its rendering type. Types \u00b6 Name Summary Companion [jvm] object Companion Empty companion serves as a hook point to allow us to create Workflow.foo extension methods elsewhere. Functions \u00b6 Name Summary asStatefulWorkflow [jvm] abstract fun asStatefulWorkflow (): StatefulWorkflow < PropsT , *, OutputT , RenderingT > Provides a StatefulWorkflow view of this workflow. Necessary because StatefulWorkflow is the common API required for BaseRenderContext.renderChild to do its work. Inheritors \u00b6 Name StatefulWorkflow StatelessWorkflow Extensions \u00b6 Name Summary identifier [jvm] val Workflow <*, *, *>. identifier : WorkflowIdentifier The WorkflowIdentifier that identifies this Workflow . launchForTestingFromStartWith [jvm] @TestOnly fun < T , PropsT , OutputT , RenderingT > Workflow < PropsT , OutputT , RenderingT >. launchForTestingFromStartWith (props: PropsT , testParams: WorkflowTestParams < Nothing > = WorkflowTestParams(), context: CoroutineContext = EmptyCoroutineContext, block: WorkflowTestRuntime < PropsT , OutputT , RenderingT >.() -> T ): T @TestOnly fun < T , OutputT , RenderingT > Workflow < Unit , OutputT , RenderingT >. launchForTestingFromStartWith (testParams: WorkflowTestParams < Nothing > = WorkflowTestParams(), context: CoroutineContext = EmptyCoroutineContext, block: WorkflowTestRuntime < Unit , OutputT , RenderingT >.() -> T ): T Creates a WorkflowTestRuntime to run this workflow for unit testing. mapRendering [jvm] fun < PropsT , OutputT , FromRenderingT , ToRenderingT > Workflow < PropsT , OutputT , FromRenderingT >. mapRendering (transform: ( FromRenderingT ) -> ToRenderingT ): Workflow < PropsT , OutputT , ToRenderingT > Uses the given function to transform a Workflow that renders FromRenderingT to one renders ToRenderingT , renderAsState [androidJvm] @Composable fun < PropsT , OutputT : Any , RenderingT > Workflow < PropsT , OutputT , RenderingT >. renderAsState (props: PropsT , interceptors: List <WorkflowInterceptor> = emptyList(), scope: CoroutineScope = rememberCoroutineScope(), onOutput: suspend ( OutputT ) -> Unit ): State< RenderingT > Runs this Workflow as long as this composable is part of the composition, and returns a State object that will be updated whenever the runtime emits a new RenderingT . Note that here, and in the rest of the documentation for this class, the \u201cState\u201d type refers to Compose\u2019s snapshot State type, not the concept of the StateT type in a particular workflow. testRender [jvm] fun < PropsT , OutputT , RenderingT > Workflow < PropsT , OutputT , RenderingT >. testRender (props: PropsT ): RenderTester < PropsT , *, OutputT , RenderingT > Create a RenderTester to unit test an individual render pass of this workflow, using the workflow\u2019s initial state .","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow/#workflow","text":"[jvm]\\ interface Workflow <in PropsT , out OutputT , out RenderingT > A composable, optionally-stateful object that can handle events , delegate to children , subscribe to arbitrary asynchronous events from the outside world. The basic purpose of a Workflow is to take some input (in the form of PropsT ) and return a rendering . To that end, a workflow may keep track of internal state , recursively ask other workflows to render themselves, subscribe to data streams from the outside world, and handle events both from its renderings and from workflows it\u2019s delegated to (its \u201cchildren\u201d). A Workflow may also emit output events up to its parent Workflow. Workflows form a tree, where each workflow can have zero or more child workflows. Child workflows are started as necessary whenever another workflow asks for them, and are cleaned up automatically when they\u2019re no longer needed. Props propagates down the tree, outputs and renderings propagate up the tree.","title":"Workflow"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow/#implementing-workflow","text":"The Workflow interface is useful as a facade for your API. You can publish an interface that extends Workflow, and keep the implementation (e.g. is your workflow state*ful* or state*less* a private implementation detail. You should almost never implement Workflow directly, however. There are two abstract classes that you should subclass instead: StatefulWorkflow and StatelessWorkflow . The differences between them are described below, but both type have a render method that you implement to generate renderings from your props and interact with the runtime (e.g. by changing state or emitting outputs).","title":"Implementing Workflow"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow/#stateful-workflows","text":"If your workflow needs to keep track of internal state, subclass StatefulWorkflow . It has an additional type parameter, StateT, requires you to specify how to create the initial state and how to snapshot /restore your state, and passes the current state to the StatefulWorkflow.render method.","title":"Stateful Workflows"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow/#stateless-workflows","text":"If your workflow does not have any state of its own and simply needs to delegate to other workflows (e.g. transforming props, outputs, or renderings), subclass StatelessWorkflow and implement its sole StatelessWorkflow.render method, or just pass a lambda to the stateless function.","title":"Stateless Workflows"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow/#interacting-with-events-and-other-workflows","text":"All workflows are passed a RenderContext in their render methods. This context allows the workflow to interact with the outside world by doing things like listening for events, subscribing to streams of data, rendering child workflows, and performing cleanup when the workflow is about to be torn down by its parent. See the documentation on BaseRenderContext for more information about what it can do.","title":"Interacting with events and other workflows"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow/#things-to-avoid","text":"","title":"Things to avoid"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow/#mutable-instance-state","text":"Classes that implement Workflow should not contain mutable properties. Such properties are instance-specific state and can introduce buggy behavior. Instead, subclass StatefulWorkflow and move all your state to the workflow\u2019s StateT type. For example, setting a property will not cause your workflow to be re-rendered \u2013 the runtime has no way of knowing that some data it doesn\u2019t know about has changed. It can also break consumers of your workflows, who may be expecting to be able to re-use the same instance of your workflow type in different places in the workflow tree \u2013 this works if all the workflow\u2019s state is contained in its StateT, but not if the instance has its own properties. (Note that storing dependencies, which are effectively static relative to the workflow instance, in properties is fine.)","title":"Mutable instance state"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow/#render-side-effects","text":"Workflows\u2019 render methods must not perform side effects or read mutable state. They can contain logic, but the logic must be based on the PropsT , the StateT if present, and the renderings from other workflows. They must declare what work to perform (via Worker s), and what data to render (via RenderingT s and child workflows). For this reason, programming with workflows can be considered declarative-style programming.","title":"Render side effects"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow/#see-also","text":"jvm com.squareup.workflow1.StatefulWorkflow com.squareup.workflow1.StatelessWorkflow","title":"See also"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow/#parameters","text":"jvm PropsT Typically a data class that is used to pass configuration information or bits of state that the workflow can always get from its parent and needn\u2019t duplicate in its own state. May be Unit if the workflow does not need any props data. OutputT Typically a sealed class that represents \u201cevents\u201d that this workflow can send to its parent. May be Nothing if the workflow doesn\u2019t need to emit anything. RenderingT The value returned to this workflow\u2019s parent during composition . Typically represents a \u201cview\u201d of this workflow\u2019s props, current state, and children\u2019s renderings. A workflow that represents a UI component may use a view model as its rendering type.","title":"Parameters"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow/#types","text":"Name Summary Companion [jvm] object Companion Empty companion serves as a hook point to allow us to create Workflow.foo extension methods elsewhere.","title":"Types"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow/#functions","text":"Name Summary asStatefulWorkflow [jvm] abstract fun asStatefulWorkflow (): StatefulWorkflow < PropsT , *, OutputT , RenderingT > Provides a StatefulWorkflow view of this workflow. Necessary because StatefulWorkflow is the common API required for BaseRenderContext.renderChild to do its work.","title":"Functions"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow/#inheritors","text":"Name StatefulWorkflow StatelessWorkflow","title":"Inheritors"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow/#extensions","text":"Name Summary identifier [jvm] val Workflow <*, *, *>. identifier : WorkflowIdentifier The WorkflowIdentifier that identifies this Workflow . launchForTestingFromStartWith [jvm] @TestOnly fun < T , PropsT , OutputT , RenderingT > Workflow < PropsT , OutputT , RenderingT >. launchForTestingFromStartWith (props: PropsT , testParams: WorkflowTestParams < Nothing > = WorkflowTestParams(), context: CoroutineContext = EmptyCoroutineContext, block: WorkflowTestRuntime < PropsT , OutputT , RenderingT >.() -> T ): T @TestOnly fun < T , OutputT , RenderingT > Workflow < Unit , OutputT , RenderingT >. launchForTestingFromStartWith (testParams: WorkflowTestParams < Nothing > = WorkflowTestParams(), context: CoroutineContext = EmptyCoroutineContext, block: WorkflowTestRuntime < Unit , OutputT , RenderingT >.() -> T ): T Creates a WorkflowTestRuntime to run this workflow for unit testing. mapRendering [jvm] fun < PropsT , OutputT , FromRenderingT , ToRenderingT > Workflow < PropsT , OutputT , FromRenderingT >. mapRendering (transform: ( FromRenderingT ) -> ToRenderingT ): Workflow < PropsT , OutputT , ToRenderingT > Uses the given function to transform a Workflow that renders FromRenderingT to one renders ToRenderingT , renderAsState [androidJvm] @Composable fun < PropsT , OutputT : Any , RenderingT > Workflow < PropsT , OutputT , RenderingT >. renderAsState (props: PropsT , interceptors: List <WorkflowInterceptor> = emptyList(), scope: CoroutineScope = rememberCoroutineScope(), onOutput: suspend ( OutputT ) -> Unit ): State< RenderingT > Runs this Workflow as long as this composable is part of the composition, and returns a State object that will be updated whenever the runtime emits a new RenderingT . Note that here, and in the rest of the documentation for this class, the \u201cState\u201d type refers to Compose\u2019s snapshot State type, not the concept of the StateT type in a particular workflow. testRender [jvm] fun < PropsT , OutputT , RenderingT > Workflow < PropsT , OutputT , RenderingT >. testRender (props: PropsT ): RenderTester < PropsT , *, OutputT , RenderingT > Create a RenderTester to unit test an individual render pass of this workflow, using the workflow\u2019s initial state .","title":"Extensions"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow/as-stateful-workflow/","text":"// workflow / com.squareup.workflow1 / Workflow / asStatefulWorkflow asStatefulWorkflow \u00b6 [jvm]\\ abstract fun asStatefulWorkflow (): StatefulWorkflow < PropsT , *, OutputT , RenderingT > Provides a StatefulWorkflow view of this workflow. Necessary because StatefulWorkflow is the common API required for BaseRenderContext.renderChild to do its work.","title":"As stateful workflow"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow/as-stateful-workflow/#asstatefulworkflow","text":"[jvm]\\ abstract fun asStatefulWorkflow (): StatefulWorkflow < PropsT , *, OutputT , RenderingT > Provides a StatefulWorkflow view of this workflow. Necessary because StatefulWorkflow is the common API required for BaseRenderContext.renderChild to do its work.","title":"asStatefulWorkflow"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow/-companion/","text":"// workflow / com.squareup.workflow1 / Workflow / Companion Companion \u00b6 [jvm]\\ object Companion Empty companion serves as a hook point to allow us to create Workflow.foo extension methods elsewhere. Extensions \u00b6 Name Summary rendering [jvm] fun < RenderingT > Workflow.Companion . rendering (rendering: RenderingT ): Workflow < Unit , Nothing , RenderingT > Returns a workflow that does nothing but echo the given rendering . Handy for testing. stateful [jvm] inline fun < PropsT , StateT , OutputT , RenderingT > Workflow.Companion . stateful (crossinline initialState: ( PropsT , Snapshot ?) -> StateT , crossinline render: BaseRenderContext < PropsT , StateT , OutputT >.( PropsT , StateT ) -> RenderingT , crossinline snapshot: ( StateT ) -> Snapshot ?, crossinline onPropsChanged: ( PropsT , PropsT , StateT ) -> StateT = { _, _, state -> state }): StatefulWorkflow < PropsT , StateT , OutputT , RenderingT > inline fun < PropsT , StateT , OutputT , RenderingT > Workflow.Companion . stateful (crossinline initialState: ( PropsT ) -> StateT , crossinline render: BaseRenderContext < PropsT , StateT , OutputT >.( PropsT , StateT ) -> RenderingT , crossinline onPropsChanged: ( PropsT , PropsT , StateT ) -> StateT = { _, _, state -> state }): StatefulWorkflow < PropsT , StateT , OutputT , RenderingT > Returns a stateful Workflow implemented via the given functions. [jvm] inline fun < StateT , OutputT , RenderingT > Workflow.Companion . stateful (crossinline initialState: ( Snapshot ?) -> StateT , crossinline render: BaseRenderContext < Unit , StateT , OutputT >.( StateT ) -> RenderingT , crossinline snapshot: ( StateT ) -> Snapshot ?): StatefulWorkflow < Unit , StateT , OutputT , RenderingT > Returns a stateful Workflow , with no props, implemented via the given functions. [jvm] inline fun < StateT , OutputT , RenderingT > Workflow.Companion . stateful (initialState: StateT , crossinline render: BaseRenderContext < Unit , StateT , OutputT >.( StateT ) -> RenderingT ): StatefulWorkflow < Unit , StateT , OutputT , RenderingT > Returns a stateful Workflow , with no props, implemented via the given function. stateless [jvm] inline fun < PropsT , OutputT , RenderingT > Workflow.Companion . stateless (crossinline render: BaseRenderContext < PropsT , Nothing , OutputT >.( PropsT ) -> RenderingT ): Workflow < PropsT , OutputT , RenderingT > Returns a stateless Workflow via the given render function.","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow/-companion/#companion","text":"[jvm]\\ object Companion Empty companion serves as a hook point to allow us to create Workflow.foo extension methods elsewhere.","title":"Companion"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow/-companion/#extensions","text":"Name Summary rendering [jvm] fun < RenderingT > Workflow.Companion . rendering (rendering: RenderingT ): Workflow < Unit , Nothing , RenderingT > Returns a workflow that does nothing but echo the given rendering . Handy for testing. stateful [jvm] inline fun < PropsT , StateT , OutputT , RenderingT > Workflow.Companion . stateful (crossinline initialState: ( PropsT , Snapshot ?) -> StateT , crossinline render: BaseRenderContext < PropsT , StateT , OutputT >.( PropsT , StateT ) -> RenderingT , crossinline snapshot: ( StateT ) -> Snapshot ?, crossinline onPropsChanged: ( PropsT , PropsT , StateT ) -> StateT = { _, _, state -> state }): StatefulWorkflow < PropsT , StateT , OutputT , RenderingT > inline fun < PropsT , StateT , OutputT , RenderingT > Workflow.Companion . stateful (crossinline initialState: ( PropsT ) -> StateT , crossinline render: BaseRenderContext < PropsT , StateT , OutputT >.( PropsT , StateT ) -> RenderingT , crossinline onPropsChanged: ( PropsT , PropsT , StateT ) -> StateT = { _, _, state -> state }): StatefulWorkflow < PropsT , StateT , OutputT , RenderingT > Returns a stateful Workflow implemented via the given functions. [jvm] inline fun < StateT , OutputT , RenderingT > Workflow.Companion . stateful (crossinline initialState: ( Snapshot ?) -> StateT , crossinline render: BaseRenderContext < Unit , StateT , OutputT >.( StateT ) -> RenderingT , crossinline snapshot: ( StateT ) -> Snapshot ?): StatefulWorkflow < Unit , StateT , OutputT , RenderingT > Returns a stateful Workflow , with no props, implemented via the given functions. [jvm] inline fun < StateT , OutputT , RenderingT > Workflow.Companion . stateful (initialState: StateT , crossinline render: BaseRenderContext < Unit , StateT , OutputT >.( StateT ) -> RenderingT ): StatefulWorkflow < Unit , StateT , OutputT , RenderingT > Returns a stateful Workflow , with no props, implemented via the given function. stateless [jvm] inline fun < PropsT , OutputT , RenderingT > Workflow.Companion . stateless (crossinline render: BaseRenderContext < PropsT , Nothing , OutputT >.( PropsT ) -> RenderingT ): Workflow < PropsT , OutputT , RenderingT > Returns a stateless Workflow via the given render function.","title":"Extensions"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-action/","text":"// workflow / com.squareup.workflow1 / WorkflowAction WorkflowAction \u00b6 [jvm]\\ abstract class WorkflowAction <in PropsT , StateT , out OutputT > An atomic operation that updates the state of a Workflow , and also optionally emits an output. Constructors \u00b6 WorkflowAction [jvm] fun WorkflowAction () Types \u00b6 Name Summary Companion [jvm] object Companion Updater [jvm] inner class Updater (props: @ UnsafeVariance PropsT , state: StateT ) The context for calls to WorkflowAction.apply . Allows the action to set the state , and to emit the setOutput . Functions \u00b6 Name Summary apply [jvm] abstract fun WorkflowAction.Updater < PropsT , StateT , OutputT >. apply () Executes the logic for this action, including any side effects, updating state , and setting the OutputT to emit. Extensions \u00b6 Name Summary applyTo [jvm] fun < PropsT , StateT , OutputT > WorkflowAction < PropsT , StateT , OutputT >. applyTo (props: PropsT , state: StateT ): Pair < StateT , WorkflowOutput < OutputT >?> Applies this WorkflowAction to state .","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-action/#workflowaction","text":"[jvm]\\ abstract class WorkflowAction <in PropsT , StateT , out OutputT > An atomic operation that updates the state of a Workflow , and also optionally emits an output.","title":"WorkflowAction"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-action/#constructors","text":"WorkflowAction [jvm] fun WorkflowAction ()","title":"Constructors"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-action/#types","text":"Name Summary Companion [jvm] object Companion Updater [jvm] inner class Updater (props: @ UnsafeVariance PropsT , state: StateT ) The context for calls to WorkflowAction.apply . Allows the action to set the state , and to emit the setOutput .","title":"Types"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-action/#functions","text":"Name Summary apply [jvm] abstract fun WorkflowAction.Updater < PropsT , StateT , OutputT >. apply () Executes the logic for this action, including any side effects, updating state , and setting the OutputT to emit.","title":"Functions"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-action/#extensions","text":"Name Summary applyTo [jvm] fun < PropsT , StateT , OutputT > WorkflowAction < PropsT , StateT , OutputT >. applyTo (props: PropsT , state: StateT ): Pair < StateT , WorkflowOutput < OutputT >?> Applies this WorkflowAction to state .","title":"Extensions"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-action/-workflow-action/","text":"// workflow / com.squareup.workflow1 / WorkflowAction / WorkflowAction WorkflowAction \u00b6 [jvm]\\ fun WorkflowAction ()","title":" workflow action"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-action/-workflow-action/#workflowaction","text":"[jvm]\\ fun WorkflowAction ()","title":"WorkflowAction"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-action/apply/","text":"// workflow / com.squareup.workflow1 / WorkflowAction / apply apply \u00b6 [jvm]\\ abstract fun WorkflowAction.Updater < PropsT , StateT , OutputT >. apply () Executes the logic for this action, including any side effects, updating state , and setting the OutputT to emit.","title":"Apply"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-action/apply/#apply","text":"[jvm]\\ abstract fun WorkflowAction.Updater < PropsT , StateT , OutputT >. apply () Executes the logic for this action, including any side effects, updating state , and setting the OutputT to emit.","title":"apply"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-action/-companion/","text":"// workflow / com.squareup.workflow1 / WorkflowAction / Companion Companion \u00b6 [jvm]\\ object Companion Functions \u00b6 Name Summary noAction [jvm] fun < PropsT , StateT , OutputT > noAction (): WorkflowAction < PropsT , StateT , OutputT > Returns a WorkflowAction that does nothing: no output will be emitted, and the state will not change.","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-action/-companion/#companion","text":"[jvm]\\ object Companion","title":"Companion"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-action/-companion/#functions","text":"Name Summary noAction [jvm] fun < PropsT , StateT , OutputT > noAction (): WorkflowAction < PropsT , StateT , OutputT > Returns a WorkflowAction that does nothing: no output will be emitted, and the state will not change.","title":"Functions"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-action/-companion/no-action/","text":"// workflow / com.squareup.workflow1 / WorkflowAction / Companion / noAction noAction \u00b6 [jvm]\\ fun < PropsT , StateT , OutputT > noAction (): WorkflowAction < PropsT , StateT , OutputT > Returns a WorkflowAction that does nothing: no output will be emitted, and the state will not change. Use this to, for example, ignore the output of a child workflow or worker.","title":"No action"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-action/-companion/no-action/#noaction","text":"[jvm]\\ fun < PropsT , StateT , OutputT > noAction (): WorkflowAction < PropsT , StateT , OutputT > Returns a WorkflowAction that does nothing: no output will be emitted, and the state will not change. Use this to, for example, ignore the output of a child workflow or worker.","title":"noAction"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-action/-updater/","text":"// workflow / com.squareup.workflow1 / WorkflowAction / Updater Updater \u00b6 [jvm]\\ inner class Updater (props: @ UnsafeVariance PropsT , state: StateT ) The context for calls to WorkflowAction.apply . Allows the action to set the state , and to emit the setOutput . Parameters \u00b6 jvm state the state that the workflow should move to. Default is the current state. Constructors \u00b6 Updater [jvm] fun Updater (props: @ UnsafeVariance PropsT , state: StateT ) Functions \u00b6 Name Summary setOutput [jvm] fun setOutput (output: @ UnsafeVariance OutputT ) Sets the value the workflow will emit as output when this action is applied. If this method is not called, there will be no output. Properties \u00b6 Name Summary props [jvm] val props : @ UnsafeVariance PropsT state [jvm] var state : StateT","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-action/-updater/#updater","text":"[jvm]\\ inner class Updater (props: @ UnsafeVariance PropsT , state: StateT ) The context for calls to WorkflowAction.apply . Allows the action to set the state , and to emit the setOutput .","title":"Updater"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-action/-updater/#parameters","text":"jvm state the state that the workflow should move to. Default is the current state.","title":"Parameters"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-action/-updater/#constructors","text":"Updater [jvm] fun Updater (props: @ UnsafeVariance PropsT , state: StateT )","title":"Constructors"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-action/-updater/#functions","text":"Name Summary setOutput [jvm] fun setOutput (output: @ UnsafeVariance OutputT ) Sets the value the workflow will emit as output when this action is applied. If this method is not called, there will be no output.","title":"Functions"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-action/-updater/#properties","text":"Name Summary props [jvm] val props : @ UnsafeVariance PropsT state [jvm] var state : StateT","title":"Properties"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-action/-updater/-updater/","text":"// workflow / com.squareup.workflow1 / WorkflowAction / Updater / Updater Updater \u00b6 [jvm]\\ fun Updater (props: @ UnsafeVariance PropsT , state: StateT ) Parameters \u00b6 jvm state the state that the workflow should move to. Default is the current state.","title":" updater"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-action/-updater/-updater/#updater","text":"[jvm]\\ fun Updater (props: @ UnsafeVariance PropsT , state: StateT )","title":"Updater"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-action/-updater/-updater/#parameters","text":"jvm state the state that the workflow should move to. Default is the current state.","title":"Parameters"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-action/-updater/props/","text":"// workflow / com.squareup.workflow1 / WorkflowAction / Updater / props props \u00b6 [jvm]\\ val props : @ UnsafeVariance PropsT","title":"Props"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-action/-updater/props/#props","text":"[jvm]\\ val props : @ UnsafeVariance PropsT","title":"props"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-action/-updater/set-output/","text":"// workflow / com.squareup.workflow1 / WorkflowAction / Updater / setOutput setOutput \u00b6 [jvm]\\ fun setOutput (output: @ UnsafeVariance OutputT ) Sets the value the workflow will emit as output when this action is applied. If this method is not called, there will be no output.","title":"Set output"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-action/-updater/set-output/#setoutput","text":"[jvm]\\ fun setOutput (output: @ UnsafeVariance OutputT ) Sets the value the workflow will emit as output when this action is applied. If this method is not called, there will be no output.","title":"setOutput"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-action/-updater/state/","text":"// workflow / com.squareup.workflow1 / WorkflowAction / Updater / state state \u00b6 [jvm]\\ var state : StateT","title":"State"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-action/-updater/state/#state","text":"[jvm]\\ var state : StateT","title":"state"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-identifier/","text":"// workflow / com.squareup.workflow1 / WorkflowIdentifier WorkflowIdentifier \u00b6 [jvm]\\ class WorkflowIdentifier Represents a Workflow \u2018s \u201cidentity\u201d and is used by the runtime to determine whether a workflow is the same as one that was rendered in a previous render pass, in which case its state should be re-used; or if it\u2019s a new workflow and needs to be started. A workflow\u2019s identity consists primarily of its concrete type (i.e. the class that implements the Workflow interface). Two workflows of the same concrete type are considered identical. However, if a workflow class implements ImpostorWorkflow , the identifier will also include that workflow\u2019s ImpostorWorkflow.realIdentifier . Instances of this class are equatable and hashable . Identifiers and snapshots \u00b6 Since workflows can be serialized , workflows\u2019 identifiers must also be serializable in order to match workflows back up with their snapshots when restoring. However, some WorkflowIdentifier s may represent workflows that cannot be snapshotted. When an identifier is not snapshottable, toByteStringOrNull will return null, and any identifiers that reference ImpostorWorkflow s whose ImpostorWorkflow.realIdentifier is not snapshottable will also not be snapshottable. Such identifiers are created with unsnapshottableIdentifier , but should not be used to wrap arbitrary workflows since those workflows may expect to be snapshotted. Parameters \u00b6 jvm type The KClass of the Workflow this identifier identifies, or the KType of an unsnapshottableIdentifier . proxiedIdentifier An optional identifier from ImpostorWorkflow.realIdentifier that will be used to further narrow the scope of this identifier. description Implementation of ImpostorWorkflow.describeRealIdentifier . Types \u00b6 Name Summary Companion [jvm] object Companion Functions \u00b6 Name Summary equals [jvm] open operator override fun equals (other: Any ?): Boolean getRealIdentifierType [jvm] @TestOnly fun getRealIdentifierType (): KAnnotatedElement Returns either a KClass or KType representing the \u201creal\u201d type that this identifier identifies \u2013 i.e. which is not an ImpostorWorkflow . hashCode [jvm] open override fun hashCode (): Int toByteStringOrNull [jvm] fun toByteStringOrNull (): ByteString? If this identifier is snapshottable, returns the serialized form of the identifier. If it is not snapshottable, returns null. toString [jvm] open override fun toString (): String If this identifier identifies an ImpostorWorkflow , returns the result of that workflow\u2019s ImpostorWorkflow.describeRealIdentifier method, otherwise returns a description of this identifier including the name of its workflow type and any ImpostorWorkflow.realIdentifier s.","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-identifier/#workflowidentifier","text":"[jvm]\\ class WorkflowIdentifier Represents a Workflow \u2018s \u201cidentity\u201d and is used by the runtime to determine whether a workflow is the same as one that was rendered in a previous render pass, in which case its state should be re-used; or if it\u2019s a new workflow and needs to be started. A workflow\u2019s identity consists primarily of its concrete type (i.e. the class that implements the Workflow interface). Two workflows of the same concrete type are considered identical. However, if a workflow class implements ImpostorWorkflow , the identifier will also include that workflow\u2019s ImpostorWorkflow.realIdentifier . Instances of this class are equatable and hashable .","title":"WorkflowIdentifier"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-identifier/#identifiers-and-snapshots","text":"Since workflows can be serialized , workflows\u2019 identifiers must also be serializable in order to match workflows back up with their snapshots when restoring. However, some WorkflowIdentifier s may represent workflows that cannot be snapshotted. When an identifier is not snapshottable, toByteStringOrNull will return null, and any identifiers that reference ImpostorWorkflow s whose ImpostorWorkflow.realIdentifier is not snapshottable will also not be snapshottable. Such identifiers are created with unsnapshottableIdentifier , but should not be used to wrap arbitrary workflows since those workflows may expect to be snapshotted.","title":"Identifiers and snapshots"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-identifier/#parameters","text":"jvm type The KClass of the Workflow this identifier identifies, or the KType of an unsnapshottableIdentifier . proxiedIdentifier An optional identifier from ImpostorWorkflow.realIdentifier that will be used to further narrow the scope of this identifier. description Implementation of ImpostorWorkflow.describeRealIdentifier .","title":"Parameters"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-identifier/#types","text":"Name Summary Companion [jvm] object Companion","title":"Types"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-identifier/#functions","text":"Name Summary equals [jvm] open operator override fun equals (other: Any ?): Boolean getRealIdentifierType [jvm] @TestOnly fun getRealIdentifierType (): KAnnotatedElement Returns either a KClass or KType representing the \u201creal\u201d type that this identifier identifies \u2013 i.e. which is not an ImpostorWorkflow . hashCode [jvm] open override fun hashCode (): Int toByteStringOrNull [jvm] fun toByteStringOrNull (): ByteString? If this identifier is snapshottable, returns the serialized form of the identifier. If it is not snapshottable, returns null. toString [jvm] open override fun toString (): String If this identifier identifies an ImpostorWorkflow , returns the result of that workflow\u2019s ImpostorWorkflow.describeRealIdentifier method, otherwise returns a description of this identifier including the name of its workflow type and any ImpostorWorkflow.realIdentifier s.","title":"Functions"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-identifier/equals/","text":"// workflow / com.squareup.workflow1 / WorkflowIdentifier / equals equals \u00b6 [jvm]\\ open operator override fun equals (other: Any ?): Boolean","title":"Equals"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-identifier/equals/#equals","text":"[jvm]\\ open operator override fun equals (other: Any ?): Boolean","title":"equals"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-identifier/get-real-identifier-type/","text":"// workflow / com.squareup.workflow1 / WorkflowIdentifier / getRealIdentifierType getRealIdentifierType \u00b6 [jvm]\\ @TestOnly fun getRealIdentifierType (): KAnnotatedElement Returns either a KClass or KType representing the \u201creal\u201d type that this identifier identifies \u2013 i.e. which is not an ImpostorWorkflow .","title":"Get real identifier type"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-identifier/get-real-identifier-type/#getrealidentifiertype","text":"[jvm]\\ @TestOnly fun getRealIdentifierType (): KAnnotatedElement Returns either a KClass or KType representing the \u201creal\u201d type that this identifier identifies \u2013 i.e. which is not an ImpostorWorkflow .","title":"getRealIdentifierType"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-identifier/hash-code/","text":"// workflow / com.squareup.workflow1 / WorkflowIdentifier / hashCode hashCode \u00b6 [jvm]\\ open override fun hashCode (): Int","title":"Hash code"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-identifier/hash-code/#hashcode","text":"[jvm]\\ open override fun hashCode (): Int","title":"hashCode"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-identifier/to-byte-string-or-null/","text":"// workflow / com.squareup.workflow1 / WorkflowIdentifier / toByteStringOrNull toByteStringOrNull \u00b6 [jvm]\\ fun toByteStringOrNull (): ByteString? If this identifier is snapshottable, returns the serialized form of the identifier. If it is not snapshottable, returns null.","title":"To byte string or null"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-identifier/to-byte-string-or-null/#tobytestringornull","text":"[jvm]\\ fun toByteStringOrNull (): ByteString? If this identifier is snapshottable, returns the serialized form of the identifier. If it is not snapshottable, returns null.","title":"toByteStringOrNull"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-identifier/to-string/","text":"// workflow / com.squareup.workflow1 / WorkflowIdentifier / toString toString \u00b6 [jvm]\\ open override fun toString (): String If this identifier identifies an ImpostorWorkflow , returns the result of that workflow\u2019s ImpostorWorkflow.describeRealIdentifier method, otherwise returns a description of this identifier including the name of its workflow type and any ImpostorWorkflow.realIdentifier s.","title":"To string"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-identifier/to-string/#tostring","text":"[jvm]\\ open override fun toString (): String If this identifier identifies an ImpostorWorkflow , returns the result of that workflow\u2019s ImpostorWorkflow.describeRealIdentifier method, otherwise returns a description of this identifier including the name of its workflow type and any ImpostorWorkflow.realIdentifier s.","title":"toString"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-identifier/-companion/","text":"// workflow / com.squareup.workflow1 / WorkflowIdentifier / Companion Companion \u00b6 [jvm]\\ object Companion Functions \u00b6 Name Summary parse [jvm] fun parse (bytes: ByteString): WorkflowIdentifier Reads a WorkflowIdentifier from a ByteString as written by toByteStringOrNull .","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-identifier/-companion/#companion","text":"[jvm]\\ object Companion","title":"Companion"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-identifier/-companion/#functions","text":"Name Summary parse [jvm] fun parse (bytes: ByteString): WorkflowIdentifier Reads a WorkflowIdentifier from a ByteString as written by toByteStringOrNull .","title":"Functions"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-identifier/-companion/parse/","text":"// workflow / com.squareup.workflow1 / WorkflowIdentifier / Companion / parse parse \u00b6 [jvm]\\ fun parse (bytes: ByteString): WorkflowIdentifier Reads a WorkflowIdentifier from a ByteString as written by toByteStringOrNull . Throws \u00b6 kotlin.IllegalArgumentException if the source does not contain a valid WorkflowIdentifier java.lang.ClassNotFoundException if one of the workflow types can\u2019t be found in the class loader","title":"Parse"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-identifier/-companion/parse/#parse","text":"[jvm]\\ fun parse (bytes: ByteString): WorkflowIdentifier Reads a WorkflowIdentifier from a ByteString as written by toByteStringOrNull .","title":"parse"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-identifier/-companion/parse/#throws","text":"kotlin.IllegalArgumentException if the source does not contain a valid WorkflowIdentifier java.lang.ClassNotFoundException if one of the workflow types can\u2019t be found in the class loader","title":"Throws"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-interceptor/","text":"// workflow / com.squareup.workflow1 / WorkflowInterceptor WorkflowInterceptor \u00b6 [jvm]\\ interface WorkflowInterceptor Provides hooks into the workflow runtime that can be used to instrument or modify the behavior of workflows. This interface\u2019s methods mirror the methods of StatefulWorkflow . It also has one additional method, onSessionStarted , that is notified when a workflow is started. Each method returns the same thing as the corresponding method on StatefulWorkflow , and receives the same parameters as well as two extra parameters: **proceed** \u2013 A function that *exactly* mirrors the corresponding function on [StatefulWorkflow](../-stateful-workflow/index.md), accepting the same parameters and returning the same thing. An interceptor can call this function to run the actual workflow, but it may also decide to not call it at all, or call it multiple times. **session** \u2013 A [WorkflowSession](-workflow-session/index.md) object that can be queried for information about the workflow being intercepted. All methods have default no-op implementations. Workflow sessions \u00b6 A single workflow may be rendered by different parents at the same time, or the same parent at different, disjoint times. Each continuous sequence of renderings of a particular workflow type, with the same key passed to BaseRenderContext.renderChild , is called an \u201csession\u201d of that workflow. The workflow\u2019s StatefulWorkflow.initialState method will be called at the start of the session, and its state will be maintained by the runtime until the session is finished. Each session is identified by the WorkflowSession object passed into the corresponding method in a WorkflowInterceptor . In addition to the WorkflowIdentifier of the type of the workflow being rendered, this object also knows the key used to render the workflow and the WorkflowSession of the parent workflow that is rendering it. Each session is also assigned a numerical ID that uniquely identifies the session over the life of the entire runtime. This value will remain constant as long as the workflow\u2019s parent is rendering it, and then it will never be used again. If this workflow stops being rendered, and then starts again, the value will be different. Types \u00b6 Name Summary RenderContextInterceptor [jvm] interface RenderContextInterceptor < P , S , O > Provides hooks for intercepting calls to a BaseRenderContext , to be used from onRender . WorkflowSession [jvm] interface WorkflowSession Information about the session of a workflow in the runtime that a WorkflowInterceptor method is intercepting. Functions \u00b6 Name Summary onInitialState [jvm] open fun < P , S > onInitialState (props: P , snapshot: Snapshot ?, proceed: ( P , Snapshot ?) -> S , session: WorkflowInterceptor.WorkflowSession ): S Intercepts calls to StatefulWorkflow.initialState . onPropsChanged [jvm] open fun < P , S > onPropsChanged (old: P , new: P , state: S , proceed: ( P , P , S ) -> S , session: WorkflowInterceptor.WorkflowSession ): S Intercepts calls to StatefulWorkflow.onPropsChanged . onRender [jvm] open fun < P , S , O , R > onRender (renderProps: P , renderState: S , context: BaseRenderContext < P , S , O >, proceed: ( P , S , WorkflowInterceptor.RenderContextInterceptor < P , S , O >?) -> R , session: WorkflowInterceptor.WorkflowSession ): R Intercepts calls to StatefulWorkflow.render . onSessionStarted [jvm] open fun onSessionStarted (workflowScope: CoroutineScope, session: WorkflowInterceptor.WorkflowSession ) Called when the session is starting, before onInitialState . onSnapshotState [jvm] open fun < S > onSnapshotState (state: S , proceed: ( S ) -> Snapshot ?, session: WorkflowInterceptor.WorkflowSession ): Snapshot ? Intercepts calls to StatefulWorkflow.snapshotState . Inheritors \u00b6 Name SimpleLoggingWorkflowInterceptor NoopWorkflowInterceptor RenderIdempotencyChecker","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-interceptor/#workflowinterceptor","text":"[jvm]\\ interface WorkflowInterceptor Provides hooks into the workflow runtime that can be used to instrument or modify the behavior of workflows. This interface\u2019s methods mirror the methods of StatefulWorkflow . It also has one additional method, onSessionStarted , that is notified when a workflow is started. Each method returns the same thing as the corresponding method on StatefulWorkflow , and receives the same parameters as well as two extra parameters: **proceed** \u2013 A function that *exactly* mirrors the corresponding function on [StatefulWorkflow](../-stateful-workflow/index.md), accepting the same parameters and returning the same thing. An interceptor can call this function to run the actual workflow, but it may also decide to not call it at all, or call it multiple times. **session** \u2013 A [WorkflowSession](-workflow-session/index.md) object that can be queried for information about the workflow being intercepted. All methods have default no-op implementations.","title":"WorkflowInterceptor"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-interceptor/#workflow-sessions","text":"A single workflow may be rendered by different parents at the same time, or the same parent at different, disjoint times. Each continuous sequence of renderings of a particular workflow type, with the same key passed to BaseRenderContext.renderChild , is called an \u201csession\u201d of that workflow. The workflow\u2019s StatefulWorkflow.initialState method will be called at the start of the session, and its state will be maintained by the runtime until the session is finished. Each session is identified by the WorkflowSession object passed into the corresponding method in a WorkflowInterceptor . In addition to the WorkflowIdentifier of the type of the workflow being rendered, this object also knows the key used to render the workflow and the WorkflowSession of the parent workflow that is rendering it. Each session is also assigned a numerical ID that uniquely identifies the session over the life of the entire runtime. This value will remain constant as long as the workflow\u2019s parent is rendering it, and then it will never be used again. If this workflow stops being rendered, and then starts again, the value will be different.","title":"Workflow sessions"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-interceptor/#types","text":"Name Summary RenderContextInterceptor [jvm] interface RenderContextInterceptor < P , S , O > Provides hooks for intercepting calls to a BaseRenderContext , to be used from onRender . WorkflowSession [jvm] interface WorkflowSession Information about the session of a workflow in the runtime that a WorkflowInterceptor method is intercepting.","title":"Types"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-interceptor/#functions","text":"Name Summary onInitialState [jvm] open fun < P , S > onInitialState (props: P , snapshot: Snapshot ?, proceed: ( P , Snapshot ?) -> S , session: WorkflowInterceptor.WorkflowSession ): S Intercepts calls to StatefulWorkflow.initialState . onPropsChanged [jvm] open fun < P , S > onPropsChanged (old: P , new: P , state: S , proceed: ( P , P , S ) -> S , session: WorkflowInterceptor.WorkflowSession ): S Intercepts calls to StatefulWorkflow.onPropsChanged . onRender [jvm] open fun < P , S , O , R > onRender (renderProps: P , renderState: S , context: BaseRenderContext < P , S , O >, proceed: ( P , S , WorkflowInterceptor.RenderContextInterceptor < P , S , O >?) -> R , session: WorkflowInterceptor.WorkflowSession ): R Intercepts calls to StatefulWorkflow.render . onSessionStarted [jvm] open fun onSessionStarted (workflowScope: CoroutineScope, session: WorkflowInterceptor.WorkflowSession ) Called when the session is starting, before onInitialState . onSnapshotState [jvm] open fun < S > onSnapshotState (state: S , proceed: ( S ) -> Snapshot ?, session: WorkflowInterceptor.WorkflowSession ): Snapshot ? Intercepts calls to StatefulWorkflow.snapshotState .","title":"Functions"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-interceptor/#inheritors","text":"Name SimpleLoggingWorkflowInterceptor NoopWorkflowInterceptor RenderIdempotencyChecker","title":"Inheritors"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-interceptor/on-initial-state/","text":"// workflow / com.squareup.workflow1 / WorkflowInterceptor / onInitialState onInitialState \u00b6 [jvm]\\ open fun < P , S > onInitialState (props: P , snapshot: Snapshot ?, proceed: ( P , Snapshot ?) -> S , session: WorkflowInterceptor.WorkflowSession ): S Intercepts calls to StatefulWorkflow.initialState .","title":"On initial state"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-interceptor/on-initial-state/#oninitialstate","text":"[jvm]\\ open fun < P , S > onInitialState (props: P , snapshot: Snapshot ?, proceed: ( P , Snapshot ?) -> S , session: WorkflowInterceptor.WorkflowSession ): S Intercepts calls to StatefulWorkflow.initialState .","title":"onInitialState"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-interceptor/on-props-changed/","text":"// workflow / com.squareup.workflow1 / WorkflowInterceptor / onPropsChanged onPropsChanged \u00b6 [jvm]\\ open fun < P , S > onPropsChanged (old: P , new: P , state: S , proceed: ( P , P , S ) -> S , session: WorkflowInterceptor.WorkflowSession ): S Intercepts calls to StatefulWorkflow.onPropsChanged .","title":"On props changed"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-interceptor/on-props-changed/#onpropschanged","text":"[jvm]\\ open fun < P , S > onPropsChanged (old: P , new: P , state: S , proceed: ( P , P , S ) -> S , session: WorkflowInterceptor.WorkflowSession ): S Intercepts calls to StatefulWorkflow.onPropsChanged .","title":"onPropsChanged"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-interceptor/on-render/","text":"// workflow / com.squareup.workflow1 / WorkflowInterceptor / onRender onRender \u00b6 [jvm]\\ open fun < P , S , O , R > onRender (renderProps: P , renderState: S , context: BaseRenderContext < P , S , O >, proceed: ( P , S , WorkflowInterceptor.RenderContextInterceptor < P , S , O >?) -> R , session: WorkflowInterceptor.WorkflowSession ): R Intercepts calls to StatefulWorkflow.render .","title":"On render"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-interceptor/on-render/#onrender","text":"[jvm]\\ open fun < P , S , O , R > onRender (renderProps: P , renderState: S , context: BaseRenderContext < P , S , O >, proceed: ( P , S , WorkflowInterceptor.RenderContextInterceptor < P , S , O >?) -> R , session: WorkflowInterceptor.WorkflowSession ): R Intercepts calls to StatefulWorkflow.render .","title":"onRender"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-interceptor/on-session-started/","text":"// workflow / com.squareup.workflow1 / WorkflowInterceptor / onSessionStarted onSessionStarted \u00b6 [jvm]\\ open fun onSessionStarted (workflowScope: CoroutineScope, session: WorkflowInterceptor.WorkflowSession ) Called when the session is starting, before onInitialState . Parameters \u00b6 jvm workflowScope The CoroutineScope that will be used for any side effects the workflow runs, as well as the parent for any workflows it renders.","title":"On session started"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-interceptor/on-session-started/#onsessionstarted","text":"[jvm]\\ open fun onSessionStarted (workflowScope: CoroutineScope, session: WorkflowInterceptor.WorkflowSession ) Called when the session is starting, before onInitialState .","title":"onSessionStarted"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-interceptor/on-session-started/#parameters","text":"jvm workflowScope The CoroutineScope that will be used for any side effects the workflow runs, as well as the parent for any workflows it renders.","title":"Parameters"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-interceptor/on-snapshot-state/","text":"// workflow / com.squareup.workflow1 / WorkflowInterceptor / onSnapshotState onSnapshotState \u00b6 [jvm]\\ open fun < S > onSnapshotState (state: S , proceed: ( S ) -> Snapshot ?, session: WorkflowInterceptor.WorkflowSession ): Snapshot ? Intercepts calls to StatefulWorkflow.snapshotState .","title":"On snapshot state"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-interceptor/on-snapshot-state/#onsnapshotstate","text":"[jvm]\\ open fun < S > onSnapshotState (state: S , proceed: ( S ) -> Snapshot ?, session: WorkflowInterceptor.WorkflowSession ): Snapshot ? Intercepts calls to StatefulWorkflow.snapshotState .","title":"onSnapshotState"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-interceptor/-render-context-interceptor/","text":"// workflow / com.squareup.workflow1 / WorkflowInterceptor / RenderContextInterceptor RenderContextInterceptor \u00b6 [jvm]\\ interface RenderContextInterceptor < P , S , O > Provides hooks for intercepting calls to a BaseRenderContext , to be used from onRender . For use by onRender methods that want to hook into action and side effect events. See documentation on methods for more information about the individual hooks: [RenderContextInterceptor.onActionSent](on-action-sent.md) [RenderContextInterceptor.onRunningSideEffect](on-running-side-effect.md) E.g.: override fun <P, S, O, R> onRender(\\ renderProps: P,\\ renderState: S,\\ proceed: (P, S, RenderContextInterceptor<P, S, O>) -> R,\\ session: WorkflowSession\\ ): R = proceed(renderProps, renderState, object : RenderContextInterceptor<P, S, O> {\\ override fun onActionSent(\\ action: WorkflowAction<P, S, O>,\\ proceed: (WorkflowAction<P, S, O>) -> Unit\\ ) {\\ log(\u201cAction sent: $action\u201d)\\ proceed(action)\\ }\\ \\ override fun onRunningSideEffect(\\ key: String,\\ sideEffect: suspend () -> Unit,\\ proceed: (key: String, sideEffect: suspend () -> Unit) -> Unit\\ ) {\\ proceed(key) {\\ log(\u201cSide effect started: $key\u201d)\\ sideEffect()\\ log(\u201cSide effect ended: $key\u201d)\\ }\\ }\\ }) Functions \u00b6 Name Summary onActionSent [jvm] open fun onActionSent (action: WorkflowAction < P , S , O >, proceed: ( WorkflowAction < P , S , O >) -> Unit ) Intercepts calls to send on the BaseRenderContext.actionSink . onRenderChild [jvm] open fun < CP , CO , CR > onRenderChild (child: Workflow < CP , CO , CR >, childProps: CP , key: String , handler: ( CO ) -> WorkflowAction < P , S , O >, proceed: (child: Workflow < CP , CO , CR >, CP , key: String , handler: ( CO ) -> WorkflowAction < P , S , O >) -> CR ): CR Intercepts calls to BaseRenderContext.renderChild , allowing the interceptor to wrap or replace the child Workflow, its childProps , key , and the handler function to be applied to the child\u2019s output. onRunningSideEffect [jvm] open fun onRunningSideEffect (key: String , sideEffect: suspend () -> Unit , proceed: (key: String , sideEffect: suspend () -> Unit ) -> Unit ) Intercepts calls to BaseRenderContext.runningSideEffect , allowing the interceptor to wrap or replace the sideEffect and its key . This could be used to prevent a side effect from running, or to augment it with further effects.","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-interceptor/-render-context-interceptor/#rendercontextinterceptor","text":"[jvm]\\ interface RenderContextInterceptor < P , S , O > Provides hooks for intercepting calls to a BaseRenderContext , to be used from onRender . For use by onRender methods that want to hook into action and side effect events. See documentation on methods for more information about the individual hooks: [RenderContextInterceptor.onActionSent](on-action-sent.md) [RenderContextInterceptor.onRunningSideEffect](on-running-side-effect.md) E.g.: override fun <P, S, O, R> onRender(\\ renderProps: P,\\ renderState: S,\\ proceed: (P, S, RenderContextInterceptor<P, S, O>) -> R,\\ session: WorkflowSession\\ ): R = proceed(renderProps, renderState, object : RenderContextInterceptor<P, S, O> {\\ override fun onActionSent(\\ action: WorkflowAction<P, S, O>,\\ proceed: (WorkflowAction<P, S, O>) -> Unit\\ ) {\\ log(\u201cAction sent: $action\u201d)\\ proceed(action)\\ }\\ \\ override fun onRunningSideEffect(\\ key: String,\\ sideEffect: suspend () -> Unit,\\ proceed: (key: String, sideEffect: suspend () -> Unit) -> Unit\\ ) {\\ proceed(key) {\\ log(\u201cSide effect started: $key\u201d)\\ sideEffect()\\ log(\u201cSide effect ended: $key\u201d)\\ }\\ }\\ })","title":"RenderContextInterceptor"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-interceptor/-render-context-interceptor/#functions","text":"Name Summary onActionSent [jvm] open fun onActionSent (action: WorkflowAction < P , S , O >, proceed: ( WorkflowAction < P , S , O >) -> Unit ) Intercepts calls to send on the BaseRenderContext.actionSink . onRenderChild [jvm] open fun < CP , CO , CR > onRenderChild (child: Workflow < CP , CO , CR >, childProps: CP , key: String , handler: ( CO ) -> WorkflowAction < P , S , O >, proceed: (child: Workflow < CP , CO , CR >, CP , key: String , handler: ( CO ) -> WorkflowAction < P , S , O >) -> CR ): CR Intercepts calls to BaseRenderContext.renderChild , allowing the interceptor to wrap or replace the child Workflow, its childProps , key , and the handler function to be applied to the child\u2019s output. onRunningSideEffect [jvm] open fun onRunningSideEffect (key: String , sideEffect: suspend () -> Unit , proceed: (key: String , sideEffect: suspend () -> Unit ) -> Unit ) Intercepts calls to BaseRenderContext.runningSideEffect , allowing the interceptor to wrap or replace the sideEffect and its key . This could be used to prevent a side effect from running, or to augment it with further effects.","title":"Functions"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-interceptor/-render-context-interceptor/on-action-sent/","text":"// workflow / com.squareup.workflow1 / WorkflowInterceptor / RenderContextInterceptor / onActionSent onActionSent \u00b6 [jvm]\\ open fun onActionSent (action: WorkflowAction < P , S , O >, proceed: ( WorkflowAction < P , S , O >) -> Unit ) Intercepts calls to send on the BaseRenderContext.actionSink . This method will be called from inside the actual Sink.send stack frame, so any stack traces captured from it will include the code that is actually making the send call.","title":"On action sent"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-interceptor/-render-context-interceptor/on-action-sent/#onactionsent","text":"[jvm]\\ open fun onActionSent (action: WorkflowAction < P , S , O >, proceed: ( WorkflowAction < P , S , O >) -> Unit ) Intercepts calls to send on the BaseRenderContext.actionSink . This method will be called from inside the actual Sink.send stack frame, so any stack traces captured from it will include the code that is actually making the send call.","title":"onActionSent"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-interceptor/-render-context-interceptor/on-render-child/","text":"// workflow / com.squareup.workflow1 / WorkflowInterceptor / RenderContextInterceptor / onRenderChild onRenderChild \u00b6 [jvm]\\ open fun < CP , CO , CR > onRenderChild (child: Workflow < CP , CO , CR >, childProps: CP , key: String , handler: ( CO ) -> WorkflowAction < P , S , O >, proceed: (child: Workflow < CP , CO , CR >, CP , key: String , handler: ( CO ) -> WorkflowAction < P , S , O >) -> CR ): CR Intercepts calls to BaseRenderContext.renderChild , allowing the interceptor to wrap or replace the child Workflow, its childProps , key , and the handler function to be applied to the child\u2019s output.","title":"On render child"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-interceptor/-render-context-interceptor/on-render-child/#onrenderchild","text":"[jvm]\\ open fun < CP , CO , CR > onRenderChild (child: Workflow < CP , CO , CR >, childProps: CP , key: String , handler: ( CO ) -> WorkflowAction < P , S , O >, proceed: (child: Workflow < CP , CO , CR >, CP , key: String , handler: ( CO ) -> WorkflowAction < P , S , O >) -> CR ): CR Intercepts calls to BaseRenderContext.renderChild , allowing the interceptor to wrap or replace the child Workflow, its childProps , key , and the handler function to be applied to the child\u2019s output.","title":"onRenderChild"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-interceptor/-render-context-interceptor/on-running-side-effect/","text":"// workflow / com.squareup.workflow1 / WorkflowInterceptor / RenderContextInterceptor / onRunningSideEffect onRunningSideEffect \u00b6 [jvm]\\ open fun onRunningSideEffect (key: String , sideEffect: suspend () -> Unit , proceed: (key: String , sideEffect: suspend () -> Unit ) -> Unit ) Intercepts calls to BaseRenderContext.runningSideEffect , allowing the interceptor to wrap or replace the sideEffect and its key . This could be used to prevent a side effect from running, or to augment it with further effects. The sideEffect function will perform the actual suspending side effect, and only return when the side effect is complete \u2013 this may be far in the future. This means the interceptor can be notified when the side effect ends by simply running code after sideEffect returns or throws. The interceptor may run sideEffect in a different CoroutineContext , e.g to change its dispatcher or name, but should take care to use the original Job, or otherwise ensure that the structured concurrency contract is not broken.","title":"On running side effect"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-interceptor/-render-context-interceptor/on-running-side-effect/#onrunningsideeffect","text":"[jvm]\\ open fun onRunningSideEffect (key: String , sideEffect: suspend () -> Unit , proceed: (key: String , sideEffect: suspend () -> Unit ) -> Unit ) Intercepts calls to BaseRenderContext.runningSideEffect , allowing the interceptor to wrap or replace the sideEffect and its key . This could be used to prevent a side effect from running, or to augment it with further effects. The sideEffect function will perform the actual suspending side effect, and only return when the side effect is complete \u2013 this may be far in the future. This means the interceptor can be notified when the side effect ends by simply running code after sideEffect returns or throws. The interceptor may run sideEffect in a different CoroutineContext , e.g to change its dispatcher or name, but should take care to use the original Job, or otherwise ensure that the structured concurrency contract is not broken.","title":"onRunningSideEffect"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-interceptor/-workflow-session/","text":"// workflow / com.squareup.workflow1 / WorkflowInterceptor / WorkflowSession WorkflowSession \u00b6 [jvm]\\ interface WorkflowSession Information about the session of a workflow in the runtime that a WorkflowInterceptor method is intercepting. Properties \u00b6 Name Summary identifier [jvm] abstract val identifier : WorkflowIdentifier The WorkflowIdentifier that represents the type of this workflow. parent [jvm] abstract val parent : WorkflowInterceptor.WorkflowSession ? The parent WorkflowSession of this workflow, or null if this is the root workflow. renderKey [jvm] abstract val renderKey : String The string key argument that was passed to BaseRenderContext.renderChild to render this workflow. sessionId [jvm] abstract val sessionId : Long A unique value that identifies the currently-running session of this workflow in the runtime. See the documentation on WorkflowInterceptor for more information about what this value represents.","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-interceptor/-workflow-session/#workflowsession","text":"[jvm]\\ interface WorkflowSession Information about the session of a workflow in the runtime that a WorkflowInterceptor method is intercepting.","title":"WorkflowSession"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-interceptor/-workflow-session/#properties","text":"Name Summary identifier [jvm] abstract val identifier : WorkflowIdentifier The WorkflowIdentifier that represents the type of this workflow. parent [jvm] abstract val parent : WorkflowInterceptor.WorkflowSession ? The parent WorkflowSession of this workflow, or null if this is the root workflow. renderKey [jvm] abstract val renderKey : String The string key argument that was passed to BaseRenderContext.renderChild to render this workflow. sessionId [jvm] abstract val sessionId : Long A unique value that identifies the currently-running session of this workflow in the runtime. See the documentation on WorkflowInterceptor for more information about what this value represents.","title":"Properties"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-interceptor/-workflow-session/identifier/","text":"// workflow / com.squareup.workflow1 / WorkflowInterceptor / WorkflowSession / identifier identifier \u00b6 [jvm]\\ abstract val identifier : WorkflowIdentifier The WorkflowIdentifier that represents the type of this workflow.","title":"Identifier"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-interceptor/-workflow-session/identifier/#identifier","text":"[jvm]\\ abstract val identifier : WorkflowIdentifier The WorkflowIdentifier that represents the type of this workflow.","title":"identifier"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-interceptor/-workflow-session/parent/","text":"// workflow / com.squareup.workflow1 / WorkflowInterceptor / WorkflowSession / parent parent \u00b6 [jvm]\\ abstract val parent : WorkflowInterceptor.WorkflowSession ? The parent WorkflowSession of this workflow, or null if this is the root workflow.","title":"Parent"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-interceptor/-workflow-session/parent/#parent","text":"[jvm]\\ abstract val parent : WorkflowInterceptor.WorkflowSession ? The parent WorkflowSession of this workflow, or null if this is the root workflow.","title":"parent"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-interceptor/-workflow-session/render-key/","text":"// workflow / com.squareup.workflow1 / WorkflowInterceptor / WorkflowSession / renderKey renderKey \u00b6 [jvm]\\ abstract val renderKey : String The string key argument that was passed to BaseRenderContext.renderChild to render this workflow.","title":"Render key"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-interceptor/-workflow-session/render-key/#renderkey","text":"[jvm]\\ abstract val renderKey : String The string key argument that was passed to BaseRenderContext.renderChild to render this workflow.","title":"renderKey"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-interceptor/-workflow-session/session-id/","text":"// workflow / com.squareup.workflow1 / WorkflowInterceptor / WorkflowSession / sessionId sessionId \u00b6 [jvm]\\ abstract val sessionId : Long A unique value that identifies the currently-running session of this workflow in the runtime. See the documentation on WorkflowInterceptor for more information about what this value represents.","title":"Session id"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-interceptor/-workflow-session/session-id/#sessionid","text":"[jvm]\\ abstract val sessionId : Long A unique value that identifies the currently-running session of this workflow in the runtime. See the documentation on WorkflowInterceptor for more information about what this value represents.","title":"sessionId"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-output/","text":"// workflow / com.squareup.workflow1 / WorkflowOutput WorkflowOutput \u00b6 [jvm]\\ class WorkflowOutput <out OutputT >(value: OutputT ) Wrapper around a potentially-nullable OutputT value. Constructors \u00b6 WorkflowOutput [jvm] fun <out OutputT > WorkflowOutput (value: OutputT ) Functions \u00b6 Name Summary equals [jvm] open operator override fun equals (other: Any ?): Boolean hashCode [jvm] open override fun hashCode (): Int toString [jvm] open override fun toString (): String Properties \u00b6 Name Summary value [jvm] val value : OutputT","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-output/#workflowoutput","text":"[jvm]\\ class WorkflowOutput <out OutputT >(value: OutputT ) Wrapper around a potentially-nullable OutputT value.","title":"WorkflowOutput"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-output/#constructors","text":"WorkflowOutput [jvm] fun <out OutputT > WorkflowOutput (value: OutputT )","title":"Constructors"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-output/#functions","text":"Name Summary equals [jvm] open operator override fun equals (other: Any ?): Boolean hashCode [jvm] open override fun hashCode (): Int toString [jvm] open override fun toString (): String","title":"Functions"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-output/#properties","text":"Name Summary value [jvm] val value : OutputT","title":"Properties"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-output/-workflow-output/","text":"// workflow / com.squareup.workflow1 / WorkflowOutput / WorkflowOutput WorkflowOutput \u00b6 [jvm]\\ fun <out OutputT > WorkflowOutput (value: OutputT )","title":" workflow output"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-output/-workflow-output/#workflowoutput","text":"[jvm]\\ fun <out OutputT > WorkflowOutput (value: OutputT )","title":"WorkflowOutput"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-output/equals/","text":"// workflow / com.squareup.workflow1 / WorkflowOutput / equals equals \u00b6 [jvm]\\ open operator override fun equals (other: Any ?): Boolean","title":"Equals"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-output/equals/#equals","text":"[jvm]\\ open operator override fun equals (other: Any ?): Boolean","title":"equals"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-output/hash-code/","text":"// workflow / com.squareup.workflow1 / WorkflowOutput / hashCode hashCode \u00b6 [jvm]\\ open override fun hashCode (): Int","title":"Hash code"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-output/hash-code/#hashcode","text":"[jvm]\\ open override fun hashCode (): Int","title":"hashCode"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-output/to-string/","text":"// workflow / com.squareup.workflow1 / WorkflowOutput / toString toString \u00b6 [jvm]\\ open override fun toString (): String","title":"To string"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-output/to-string/#tostring","text":"[jvm]\\ open override fun toString (): String","title":"toString"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-output/value/","text":"// workflow / com.squareup.workflow1 / WorkflowOutput / value value \u00b6 [jvm]\\ val value : OutputT","title":"Value"},{"location":"kotlin/api/workflow/com.squareup.workflow1/-workflow-output/value/#value","text":"[jvm]\\ val value : OutputT","title":"value"},{"location":"kotlin/api/workflow/com.squareup.workflow1.rx2/","text":"// workflow / com.squareup.workflow1.rx2 Package com.squareup.workflow1.rx2 \u00b6 Types \u00b6 Name Summary PublisherWorker [jvm] abstract class PublisherWorker <out OutputT : Any > : Worker < OutputT > An convenience implementation of Worker that is expressed in terms of Reactive Streams\u2019 Publisher instead of Flow. Functions \u00b6 Name Summary asWorker [jvm] fun Completable. asWorker (): Worker < Nothing > Creates a Worker from this Completable. [jvm] inline fun < T : Any > Maybe<out T ?>. asWorker (): Worker < T > Creates a Worker from this Maybe. [jvm] inline fun < T : Any > Observable<out T ?>. asWorker (): Worker < T > Creates a Worker from this Observable. [jvm] inline fun < T : Any > Single<out T ?>. asWorker (): Worker < T > Creates a Worker from this Single. [jvm] inline fun < T : Any > Publisher<out T ?>. asWorker (): Worker < T > Creates a Worker from this Publisher (Flowable is a Publisher).","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1.rx2/#package-comsquareupworkflow1rx2","text":"","title":"Package com.squareup.workflow1.rx2"},{"location":"kotlin/api/workflow/com.squareup.workflow1.rx2/#types","text":"Name Summary PublisherWorker [jvm] abstract class PublisherWorker <out OutputT : Any > : Worker < OutputT > An convenience implementation of Worker that is expressed in terms of Reactive Streams\u2019 Publisher instead of Flow.","title":"Types"},{"location":"kotlin/api/workflow/com.squareup.workflow1.rx2/#functions","text":"Name Summary asWorker [jvm] fun Completable. asWorker (): Worker < Nothing > Creates a Worker from this Completable. [jvm] inline fun < T : Any > Maybe<out T ?>. asWorker (): Worker < T > Creates a Worker from this Maybe. [jvm] inline fun < T : Any > Observable<out T ?>. asWorker (): Worker < T > Creates a Worker from this Observable. [jvm] inline fun < T : Any > Single<out T ?>. asWorker (): Worker < T > Creates a Worker from this Single. [jvm] inline fun < T : Any > Publisher<out T ?>. asWorker (): Worker < T > Creates a Worker from this Publisher (Flowable is a Publisher).","title":"Functions"},{"location":"kotlin/api/workflow/com.squareup.workflow1.rx2/as-worker/","text":"// workflow / com.squareup.workflow1.rx2 / asWorker asWorker \u00b6 [jvm]\\ inline fun < T : Any > Observable<out T ?>. asWorker (): Worker < T > Creates a Worker from this Observable. The Observable will be subscribed to when the Worker is started, and disposed when it is cancelled. RxJava doesn\u2019t allow nulls, but it can\u2019t express that in its types. The receiver type parameter is nullable so that the resulting Worker is non-nullable instead of having platform nullability. [jvm]\\ inline fun < T : Any > Publisher<out T ?>. asWorker (): Worker < T > Creates a Worker from this Publisher (Flowable is a Publisher). The Publisher will be subscribed to when the Worker is started, and cancelled when it is cancelled. RxJava doesn\u2019t allow nulls, but it can\u2019t express that in its types. The receiver type parameter is nullable so that the resulting Worker is non-nullable instead of having platform nullability. [jvm]\\ inline fun < T : Any > Maybe<out T ?>. asWorker (): Worker < T > Creates a Worker from this Maybe. The Maybe will be subscribed to when the Worker is started, and disposed when it is cancelled. RxJava doesn\u2019t allow nulls, but it can\u2019t express that in its types. The receiver type parameter is nullable so that the resulting Worker is non-nullable instead of having platform nullability. [jvm]\\ inline fun < T : Any > Single<out T ?>. asWorker (): Worker < T > Creates a Worker from this Single. The Single will be subscribed to when the Worker is started, and disposed when it is cancelled. RxJava doesn\u2019t allow nulls, but it can\u2019t express that in its types. The receiver type parameter is nullable so that the resulting Worker is non-nullable instead of having platform nullability. [jvm]\\ fun Completable. asWorker (): Worker < Nothing > Creates a Worker from this Completable. The Completable will be subscribed to when the Worker is started, and disposed when it is cancelled. The key is required for this operator because there is no type information available to distinguish workers. TODO: https://github.com/square/workflow-kotlin/issues/526 once this is removed.","title":"As worker"},{"location":"kotlin/api/workflow/com.squareup.workflow1.rx2/as-worker/#asworker","text":"[jvm]\\ inline fun < T : Any > Observable<out T ?>. asWorker (): Worker < T > Creates a Worker from this Observable. The Observable will be subscribed to when the Worker is started, and disposed when it is cancelled. RxJava doesn\u2019t allow nulls, but it can\u2019t express that in its types. The receiver type parameter is nullable so that the resulting Worker is non-nullable instead of having platform nullability. [jvm]\\ inline fun < T : Any > Publisher<out T ?>. asWorker (): Worker < T > Creates a Worker from this Publisher (Flowable is a Publisher). The Publisher will be subscribed to when the Worker is started, and cancelled when it is cancelled. RxJava doesn\u2019t allow nulls, but it can\u2019t express that in its types. The receiver type parameter is nullable so that the resulting Worker is non-nullable instead of having platform nullability. [jvm]\\ inline fun < T : Any > Maybe<out T ?>. asWorker (): Worker < T > Creates a Worker from this Maybe. The Maybe will be subscribed to when the Worker is started, and disposed when it is cancelled. RxJava doesn\u2019t allow nulls, but it can\u2019t express that in its types. The receiver type parameter is nullable so that the resulting Worker is non-nullable instead of having platform nullability. [jvm]\\ inline fun < T : Any > Single<out T ?>. asWorker (): Worker < T > Creates a Worker from this Single. The Single will be subscribed to when the Worker is started, and disposed when it is cancelled. RxJava doesn\u2019t allow nulls, but it can\u2019t express that in its types. The receiver type parameter is nullable so that the resulting Worker is non-nullable instead of having platform nullability. [jvm]\\ fun Completable. asWorker (): Worker < Nothing > Creates a Worker from this Completable. The Completable will be subscribed to when the Worker is started, and disposed when it is cancelled. The key is required for this operator because there is no type information available to distinguish workers. TODO: https://github.com/square/workflow-kotlin/issues/526 once this is removed.","title":"asWorker"},{"location":"kotlin/api/workflow/com.squareup.workflow1.rx2/-publisher-worker/","text":"// workflow / com.squareup.workflow1.rx2 / PublisherWorker PublisherWorker \u00b6 [jvm]\\ abstract class PublisherWorker <out OutputT : Any > : Worker < OutputT > An convenience implementation of Worker that is expressed in terms of Reactive Streams\u2019 Publisher instead of Flow. If you\u2019re using RxJava, Flowable is a Publisher. Subclassing this is equivalent to just implementing Worker.run directly and calling asFlow on your Publisher. Constructors \u00b6 PublisherWorker [jvm] fun PublisherWorker () Functions \u00b6 Name Summary doesSameWorkAs [jvm] open fun doesSameWorkAs (otherWorker: Worker <*>): Boolean run [jvm] override fun run (): Flow< OutputT > runPublisher [jvm] abstract fun runPublisher (): Publisher<out OutputT > Returns a Flowable to execute the work represented by this worker.","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1.rx2/-publisher-worker/#publisherworker","text":"[jvm]\\ abstract class PublisherWorker <out OutputT : Any > : Worker < OutputT > An convenience implementation of Worker that is expressed in terms of Reactive Streams\u2019 Publisher instead of Flow. If you\u2019re using RxJava, Flowable is a Publisher. Subclassing this is equivalent to just implementing Worker.run directly and calling asFlow on your Publisher.","title":"PublisherWorker"},{"location":"kotlin/api/workflow/com.squareup.workflow1.rx2/-publisher-worker/#constructors","text":"PublisherWorker [jvm] fun PublisherWorker ()","title":"Constructors"},{"location":"kotlin/api/workflow/com.squareup.workflow1.rx2/-publisher-worker/#functions","text":"Name Summary doesSameWorkAs [jvm] open fun doesSameWorkAs (otherWorker: Worker <*>): Boolean run [jvm] override fun run (): Flow< OutputT > runPublisher [jvm] abstract fun runPublisher (): Publisher<out OutputT > Returns a Flowable to execute the work represented by this worker.","title":"Functions"},{"location":"kotlin/api/workflow/com.squareup.workflow1.rx2/-publisher-worker/-publisher-worker/","text":"// workflow / com.squareup.workflow1.rx2 / PublisherWorker / PublisherWorker PublisherWorker \u00b6 [jvm]\\ fun PublisherWorker ()","title":" publisher worker"},{"location":"kotlin/api/workflow/com.squareup.workflow1.rx2/-publisher-worker/-publisher-worker/#publisherworker","text":"[jvm]\\ fun PublisherWorker ()","title":"PublisherWorker"},{"location":"kotlin/api/workflow/com.squareup.workflow1.rx2/-publisher-worker/run-publisher/","text":"// workflow / com.squareup.workflow1.rx2 / PublisherWorker / runPublisher runPublisher \u00b6 [jvm]\\ abstract fun runPublisher (): Publisher<out OutputT > Returns a Flowable to execute the work represented by this worker. If you have an io.reactivex.Observable instead, just call toFlowable to convert it. The Flowable is subscribed to in the context of the workflow runtime. When this Worker , its parent Workflow , or any ancestor Workflow s are torn down, the subscription will be disposed.","title":"Run publisher"},{"location":"kotlin/api/workflow/com.squareup.workflow1.rx2/-publisher-worker/run-publisher/#runpublisher","text":"[jvm]\\ abstract fun runPublisher (): Publisher<out OutputT > Returns a Flowable to execute the work represented by this worker. If you have an io.reactivex.Observable instead, just call toFlowable to convert it. The Flowable is subscribed to in the context of the workflow runtime. When this Worker , its parent Workflow , or any ancestor Workflow s are torn down, the subscription will be disposed.","title":"runPublisher"},{"location":"kotlin/api/workflow/com.squareup.workflow1.rx2/-publisher-worker/run/","text":"// workflow / com.squareup.workflow1.rx2 / PublisherWorker / run run \u00b6 [jvm]\\ override fun run (): Flow< OutputT >","title":"Run"},{"location":"kotlin/api/workflow/com.squareup.workflow1.rx2/-publisher-worker/run/#run","text":"[jvm]\\ override fun run (): Flow< OutputT >","title":"run"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/","text":"// workflow / com.squareup.workflow1.testing Package com.squareup.workflow1.testing \u00b6 Types \u00b6 Name Summary RenderIdempotencyChecker [jvm] object RenderIdempotencyChecker : WorkflowInterceptor Intercepts the render pass of the root workflow and runs it twice to ensure that well-written unit tests catch side effects being incorrectly performed directly in the render method. RenderTester [jvm] abstract class RenderTester < PropsT , StateT , OutputT , RenderingT > The props must be specified, the initial state may be specified, and then all child workflows and workers that are expected to run, and any outputs from them, must be specified with expectWorkflow and (optionally) expectWorker calls. If one needs to verify all workers explicitly, perhaps to verify that a worker is not run, then use requireExplicitWorkerExpectations . Then call render and perform any assertions on the rendering. An event may also be sent to the rendering if no workflows or workers emitted an output. Lastly, the RenderTestResult returned by render may be used to assert on the WorkflowAction s processed to handle events or outputs by calling verifyAction or verifyActionResult . RenderTestResult [jvm] interface RenderTestResult < PropsT , StateT , OutputT , RenderingT > Result of a RenderTester.render call that can be used to verify that a WorkflowAction was processed and perform assertions on that action. WorkerSink [jvm] class WorkerSink < T >(name: String , type: KClass <*>) : Worker < T > Implementation of Worker for integration tests (using launchForTestingFromStartWith or launchForTestingFromStateWith ) that need to simply push values into the worker from the test. WorkerTester [jvm] interface WorkerTester < T > WorkflowTestParams [jvm] @TestOnly class WorkflowTestParams <out StateT >(startFrom: WorkflowTestParams.StartMode < StateT >, checkRenderIdempotence: Boolean ) Defines configuration for workflow testing infrastructure such as testRender, testFromStart. and test. WorkflowTestRuntime [jvm] class WorkflowTestRuntime < PropsT , OutputT , RenderingT > Runs a Workflow and provides access to its renderings , outputs , and snapshots . Functions \u00b6 Name Summary expectSideEffect [jvm] fun < PropsT , StateT , OutputT , RenderingT > RenderTester < PropsT , StateT , OutputT , RenderingT >. expectSideEffect (key: String ): RenderTester < PropsT , StateT , OutputT , RenderingT > Specifies that this render pass is expected to run a particular side effect. expectWorker [jvm] inline fun < PropsT , StateT , OutputT , RenderingT , WorkerOutputT , WorkerT : Worker < WorkerOutputT >> RenderTester < PropsT , StateT , OutputT , RenderingT >. expectWorker (expected: WorkerT , key: String = \u201c\u201d, output: WorkflowOutput < WorkerOutputT >? = null, description: String = \u201c\u201d): RenderTester < PropsT , StateT , OutputT , RenderingT > Specifies that this render pass is expected to run a Worker that has the same type of the given worker and for which the actual worker\u2019s doesSameWorkAs method returns true. If a worker is ran that matches the type of expected , but the actual worker\u2019s doesSameWorkAs returns false, then an AssertionError will be thrown. If you need to perform custom assertions, use the overload of this method that takes an assertWhen parameter. [jvm] inline fun < PropsT , StateT , OutputT , RenderingT , WorkerOutputT , WorkerT : Worker < WorkerOutputT >> RenderTester < PropsT , StateT , OutputT , RenderingT >. expectWorker (workerClass: KClass <out WorkerT >, key: String = \u201c\u201d, crossinline assertWorker: ( WorkerT ) -> Unit = {}, output: WorkflowOutput < WorkerOutputT >? = null, description: String = \u201c\u201d): RenderTester < PropsT , StateT , OutputT , RenderingT > Specifies that this render pass is expected to run a Worker with the given workerClass . The worker\u2019s output type is not taken into consideration. [jvm] fun < PropsT , StateT , OutputT , RenderingT > RenderTester < PropsT , StateT , OutputT , RenderingT >. expectWorker (workerType: KType , key: String = \u201c\u201d, assertWorker: ( Worker < >) -> Unit = {}, output: WorkflowOutput < >? = null, description: String = \u201c\u201d): RenderTester < PropsT , StateT , OutputT , RenderingT > Specifies that this render pass is expected to run a Worker whose KType matches workerType . expectWorkerOutputting [jvm] inline fun < PropsT , StateT , OutputT , RenderingT > RenderTester < PropsT , StateT , OutputT , RenderingT >. expectWorkerOutputting (outputType: KType , key: String = \u201c\u201d, crossinline assertWorker: ( Worker < >) -> Unit = {}, output: WorkflowOutput < >? = null, description: String = \u201c\u201d): RenderTester < PropsT , StateT , OutputT , RenderingT > Specifies that this render pass is expected to run a Worker with the given outputType . expectWorkflow [jvm] inline fun < ChildRenderingT , PropsT , StateT , OutputT , RenderingT > RenderTester < PropsT , StateT , OutputT , RenderingT >. expectWorkflow (identifier: WorkflowIdentifier , rendering: ChildRenderingT , key: String = \u201c\u201d, description: String = \u201c\u201d, noinline assertProps: (props: Any ?) -> Unit = {}): RenderTester < PropsT , StateT , OutputT , RenderingT > fun < ChildOutputT , ChildRenderingT , PropsT , StateT , OutputT , RenderingT > RenderTester < PropsT , StateT , OutputT , RenderingT >. expectWorkflow (identifier: WorkflowIdentifier , rendering: ChildRenderingT , output: WorkflowOutput < ChildOutputT >?, key: String = \u201c\u201d, description: String = \u201c\u201d, assertProps: (props: Any ?) -> Unit = {}): RenderTester < PropsT , StateT , OutputT , RenderingT > inline fun < ChildPropsT , ChildOutputT , ChildRenderingT , PropsT , StateT , OutputT , RenderingT > RenderTester < PropsT , StateT , OutputT , RenderingT >. expectWorkflow (workflowType: KClass <out Workflow < ChildPropsT , ChildOutputT , ChildRenderingT >>, rendering: ChildRenderingT , key: String = \u201c\u201d, crossinline assertProps: ( ChildPropsT ) -> Unit = {}, output: WorkflowOutput < ChildOutputT >? = null, description: String = \u201c\u201d): RenderTester < PropsT , StateT , OutputT , RenderingT > Specifies that this render pass is expected to render a particular child workflow. launchForTestingFromStartWith [jvm] @TestOnly fun < T , OutputT , RenderingT > Workflow < Unit , OutputT , RenderingT >. launchForTestingFromStartWith (testParams: WorkflowTestParams < Nothing > = WorkflowTestParams(), context: CoroutineContext = EmptyCoroutineContext, block: WorkflowTestRuntime < Unit , OutputT , RenderingT >.() -> T ): T @TestOnly fun < T , PropsT , OutputT , RenderingT > Workflow < PropsT , OutputT , RenderingT >. launchForTestingFromStartWith (props: PropsT , testParams: WorkflowTestParams < Nothing > = WorkflowTestParams(), context: CoroutineContext = EmptyCoroutineContext, block: WorkflowTestRuntime < PropsT , OutputT , RenderingT >.() -> T ): T Creates a WorkflowTestRuntime to run this workflow for unit testing. launchForTestingFromStateWith [jvm] @TestOnly fun < StateT , OutputT , RenderingT > StatefulWorkflow < Unit , StateT , OutputT , RenderingT >. launchForTestingFromStateWith (initialState: StateT , context: CoroutineContext = EmptyCoroutineContext, block: WorkflowTestRuntime < Unit , OutputT , RenderingT >.() -> Unit ) @TestOnly fun < T , PropsT , StateT , OutputT , RenderingT > StatefulWorkflow < PropsT , StateT , OutputT , RenderingT >. launchForTestingFromStateWith (props: PropsT , initialState: StateT , context: CoroutineContext = EmptyCoroutineContext, block: WorkflowTestRuntime < PropsT , OutputT , RenderingT >.() -> T ): T Creates a WorkflowTestRuntime to run this workflow for unit testing. If the workflow is stateful , initialState is not called. Instead, the workflow is started from the given initialState . launchForTestingWith [jvm] @TestOnly fun < T , PropsT , StateT , OutputT , RenderingT > StatefulWorkflow < PropsT , StateT , OutputT , RenderingT >. launchForTestingWith (props: PropsT , testParams: WorkflowTestParams < StateT > = WorkflowTestParams(), context: CoroutineContext = EmptyCoroutineContext, block: WorkflowTestRuntime < PropsT , OutputT , RenderingT >.() -> T ): T Creates a WorkflowTestRuntime to run this workflow for unit testing. test [jvm] fun < T > Worker < T >. test (timeoutMs: Long = DEFAULT_TIMEOUT_MS, block: suspend WorkerTester < T >.() -> Unit ) Test a Worker by defining assertions on its output within block . testRender [jvm] fun < PropsT , OutputT , RenderingT > Workflow < PropsT , OutputT , RenderingT >. testRender (props: PropsT ): RenderTester < PropsT , *, OutputT , RenderingT > Create a RenderTester to unit test an individual render pass of this workflow, using the workflow\u2019s initial state . [jvm] fun < PropsT , StateT , OutputT , RenderingT > StatefulWorkflow < PropsT , StateT , OutputT , RenderingT >. testRender (props: PropsT , initialState: StateT ): RenderTester < PropsT , StateT , OutputT , RenderingT > Create a RenderTester to unit test an individual render pass of this workflow. WorkerSink [jvm] inline fun < T > WorkerSink (name: String ): WorkerSink < T >","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/#package-comsquareupworkflow1testing","text":"","title":"Package com.squareup.workflow1.testing"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/#types","text":"Name Summary RenderIdempotencyChecker [jvm] object RenderIdempotencyChecker : WorkflowInterceptor Intercepts the render pass of the root workflow and runs it twice to ensure that well-written unit tests catch side effects being incorrectly performed directly in the render method. RenderTester [jvm] abstract class RenderTester < PropsT , StateT , OutputT , RenderingT > The props must be specified, the initial state may be specified, and then all child workflows and workers that are expected to run, and any outputs from them, must be specified with expectWorkflow and (optionally) expectWorker calls. If one needs to verify all workers explicitly, perhaps to verify that a worker is not run, then use requireExplicitWorkerExpectations . Then call render and perform any assertions on the rendering. An event may also be sent to the rendering if no workflows or workers emitted an output. Lastly, the RenderTestResult returned by render may be used to assert on the WorkflowAction s processed to handle events or outputs by calling verifyAction or verifyActionResult . RenderTestResult [jvm] interface RenderTestResult < PropsT , StateT , OutputT , RenderingT > Result of a RenderTester.render call that can be used to verify that a WorkflowAction was processed and perform assertions on that action. WorkerSink [jvm] class WorkerSink < T >(name: String , type: KClass <*>) : Worker < T > Implementation of Worker for integration tests (using launchForTestingFromStartWith or launchForTestingFromStateWith ) that need to simply push values into the worker from the test. WorkerTester [jvm] interface WorkerTester < T > WorkflowTestParams [jvm] @TestOnly class WorkflowTestParams <out StateT >(startFrom: WorkflowTestParams.StartMode < StateT >, checkRenderIdempotence: Boolean ) Defines configuration for workflow testing infrastructure such as testRender, testFromStart. and test. WorkflowTestRuntime [jvm] class WorkflowTestRuntime < PropsT , OutputT , RenderingT > Runs a Workflow and provides access to its renderings , outputs , and snapshots .","title":"Types"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/#functions","text":"Name Summary expectSideEffect [jvm] fun < PropsT , StateT , OutputT , RenderingT > RenderTester < PropsT , StateT , OutputT , RenderingT >. expectSideEffect (key: String ): RenderTester < PropsT , StateT , OutputT , RenderingT > Specifies that this render pass is expected to run a particular side effect. expectWorker [jvm] inline fun < PropsT , StateT , OutputT , RenderingT , WorkerOutputT , WorkerT : Worker < WorkerOutputT >> RenderTester < PropsT , StateT , OutputT , RenderingT >. expectWorker (expected: WorkerT , key: String = \u201c\u201d, output: WorkflowOutput < WorkerOutputT >? = null, description: String = \u201c\u201d): RenderTester < PropsT , StateT , OutputT , RenderingT > Specifies that this render pass is expected to run a Worker that has the same type of the given worker and for which the actual worker\u2019s doesSameWorkAs method returns true. If a worker is ran that matches the type of expected , but the actual worker\u2019s doesSameWorkAs returns false, then an AssertionError will be thrown. If you need to perform custom assertions, use the overload of this method that takes an assertWhen parameter. [jvm] inline fun < PropsT , StateT , OutputT , RenderingT , WorkerOutputT , WorkerT : Worker < WorkerOutputT >> RenderTester < PropsT , StateT , OutputT , RenderingT >. expectWorker (workerClass: KClass <out WorkerT >, key: String = \u201c\u201d, crossinline assertWorker: ( WorkerT ) -> Unit = {}, output: WorkflowOutput < WorkerOutputT >? = null, description: String = \u201c\u201d): RenderTester < PropsT , StateT , OutputT , RenderingT > Specifies that this render pass is expected to run a Worker with the given workerClass . The worker\u2019s output type is not taken into consideration. [jvm] fun < PropsT , StateT , OutputT , RenderingT > RenderTester < PropsT , StateT , OutputT , RenderingT >. expectWorker (workerType: KType , key: String = \u201c\u201d, assertWorker: ( Worker < >) -> Unit = {}, output: WorkflowOutput < >? = null, description: String = \u201c\u201d): RenderTester < PropsT , StateT , OutputT , RenderingT > Specifies that this render pass is expected to run a Worker whose KType matches workerType . expectWorkerOutputting [jvm] inline fun < PropsT , StateT , OutputT , RenderingT > RenderTester < PropsT , StateT , OutputT , RenderingT >. expectWorkerOutputting (outputType: KType , key: String = \u201c\u201d, crossinline assertWorker: ( Worker < >) -> Unit = {}, output: WorkflowOutput < >? = null, description: String = \u201c\u201d): RenderTester < PropsT , StateT , OutputT , RenderingT > Specifies that this render pass is expected to run a Worker with the given outputType . expectWorkflow [jvm] inline fun < ChildRenderingT , PropsT , StateT , OutputT , RenderingT > RenderTester < PropsT , StateT , OutputT , RenderingT >. expectWorkflow (identifier: WorkflowIdentifier , rendering: ChildRenderingT , key: String = \u201c\u201d, description: String = \u201c\u201d, noinline assertProps: (props: Any ?) -> Unit = {}): RenderTester < PropsT , StateT , OutputT , RenderingT > fun < ChildOutputT , ChildRenderingT , PropsT , StateT , OutputT , RenderingT > RenderTester < PropsT , StateT , OutputT , RenderingT >. expectWorkflow (identifier: WorkflowIdentifier , rendering: ChildRenderingT , output: WorkflowOutput < ChildOutputT >?, key: String = \u201c\u201d, description: String = \u201c\u201d, assertProps: (props: Any ?) -> Unit = {}): RenderTester < PropsT , StateT , OutputT , RenderingT > inline fun < ChildPropsT , ChildOutputT , ChildRenderingT , PropsT , StateT , OutputT , RenderingT > RenderTester < PropsT , StateT , OutputT , RenderingT >. expectWorkflow (workflowType: KClass <out Workflow < ChildPropsT , ChildOutputT , ChildRenderingT >>, rendering: ChildRenderingT , key: String = \u201c\u201d, crossinline assertProps: ( ChildPropsT ) -> Unit = {}, output: WorkflowOutput < ChildOutputT >? = null, description: String = \u201c\u201d): RenderTester < PropsT , StateT , OutputT , RenderingT > Specifies that this render pass is expected to render a particular child workflow. launchForTestingFromStartWith [jvm] @TestOnly fun < T , OutputT , RenderingT > Workflow < Unit , OutputT , RenderingT >. launchForTestingFromStartWith (testParams: WorkflowTestParams < Nothing > = WorkflowTestParams(), context: CoroutineContext = EmptyCoroutineContext, block: WorkflowTestRuntime < Unit , OutputT , RenderingT >.() -> T ): T @TestOnly fun < T , PropsT , OutputT , RenderingT > Workflow < PropsT , OutputT , RenderingT >. launchForTestingFromStartWith (props: PropsT , testParams: WorkflowTestParams < Nothing > = WorkflowTestParams(), context: CoroutineContext = EmptyCoroutineContext, block: WorkflowTestRuntime < PropsT , OutputT , RenderingT >.() -> T ): T Creates a WorkflowTestRuntime to run this workflow for unit testing. launchForTestingFromStateWith [jvm] @TestOnly fun < StateT , OutputT , RenderingT > StatefulWorkflow < Unit , StateT , OutputT , RenderingT >. launchForTestingFromStateWith (initialState: StateT , context: CoroutineContext = EmptyCoroutineContext, block: WorkflowTestRuntime < Unit , OutputT , RenderingT >.() -> Unit ) @TestOnly fun < T , PropsT , StateT , OutputT , RenderingT > StatefulWorkflow < PropsT , StateT , OutputT , RenderingT >. launchForTestingFromStateWith (props: PropsT , initialState: StateT , context: CoroutineContext = EmptyCoroutineContext, block: WorkflowTestRuntime < PropsT , OutputT , RenderingT >.() -> T ): T Creates a WorkflowTestRuntime to run this workflow for unit testing. If the workflow is stateful , initialState is not called. Instead, the workflow is started from the given initialState . launchForTestingWith [jvm] @TestOnly fun < T , PropsT , StateT , OutputT , RenderingT > StatefulWorkflow < PropsT , StateT , OutputT , RenderingT >. launchForTestingWith (props: PropsT , testParams: WorkflowTestParams < StateT > = WorkflowTestParams(), context: CoroutineContext = EmptyCoroutineContext, block: WorkflowTestRuntime < PropsT , OutputT , RenderingT >.() -> T ): T Creates a WorkflowTestRuntime to run this workflow for unit testing. test [jvm] fun < T > Worker < T >. test (timeoutMs: Long = DEFAULT_TIMEOUT_MS, block: suspend WorkerTester < T >.() -> Unit ) Test a Worker by defining assertions on its output within block . testRender [jvm] fun < PropsT , OutputT , RenderingT > Workflow < PropsT , OutputT , RenderingT >. testRender (props: PropsT ): RenderTester < PropsT , *, OutputT , RenderingT > Create a RenderTester to unit test an individual render pass of this workflow, using the workflow\u2019s initial state . [jvm] fun < PropsT , StateT , OutputT , RenderingT > StatefulWorkflow < PropsT , StateT , OutputT , RenderingT >. testRender (props: PropsT , initialState: StateT ): RenderTester < PropsT , StateT , OutputT , RenderingT > Create a RenderTester to unit test an individual render pass of this workflow. WorkerSink [jvm] inline fun < T > WorkerSink (name: String ): WorkerSink < T >","title":"Functions"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-worker-sink/","text":"// workflow / com.squareup.workflow1.testing / WorkerSink WorkerSink \u00b6 [jvm]\\ inline fun < T > WorkerSink (name: String ): WorkerSink < T >","title":" worker sink"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-worker-sink/#workersink","text":"[jvm]\\ inline fun < T > WorkerSink (name: String ): WorkerSink < T >","title":"WorkerSink"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/expect-side-effect/","text":"// workflow / com.squareup.workflow1.testing / expectSideEffect expectSideEffect \u00b6 [jvm]\\ fun < PropsT , StateT , OutputT , RenderingT > RenderTester < PropsT , StateT , OutputT , RenderingT >. expectSideEffect (key: String ): RenderTester < PropsT , StateT , OutputT , RenderingT > Specifies that this render pass is expected to run a particular side effect. Parameters \u00b6 jvm key The key passed to runningSideEffect when rendering this workflow.","title":"Expect side effect"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/expect-side-effect/#expectsideeffect","text":"[jvm]\\ fun < PropsT , StateT , OutputT , RenderingT > RenderTester < PropsT , StateT , OutputT , RenderingT >. expectSideEffect (key: String ): RenderTester < PropsT , StateT , OutputT , RenderingT > Specifies that this render pass is expected to run a particular side effect.","title":"expectSideEffect"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/expect-side-effect/#parameters","text":"jvm key The key passed to runningSideEffect when rendering this workflow.","title":"Parameters"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/expect-worker-outputting/","text":"// workflow / com.squareup.workflow1.testing / expectWorkerOutputting expectWorkerOutputting \u00b6 [jvm]\\ inline fun < PropsT , StateT , OutputT , RenderingT > RenderTester < PropsT , StateT , OutputT , RenderingT >. expectWorkerOutputting (outputType: KType , key: String = \u201c\u201d, crossinline assertWorker: ( Worker < >) -> Unit = {}, output: WorkflowOutput < >? = null, description: String = \u201c\u201d): RenderTester < PropsT , StateT , OutputT , RenderingT > Specifies that this render pass is expected to run a Worker with the given outputType . Parameters \u00b6 jvm outputType the KType of the Worker \u2018s OutputT type parameter. key The key passed to runningWorker when rendering this workflow. output If non-null, WorkflowOutput.value will be emitted when this worker is ran. The WorkflowAction used to handle this output can be verified using methods on RenderTestResult . description Optional string that will be used to describe this expectation in error messages.","title":"Expect worker outputting"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/expect-worker-outputting/#expectworkeroutputting","text":"[jvm]\\ inline fun < PropsT , StateT , OutputT , RenderingT > RenderTester < PropsT , StateT , OutputT , RenderingT >. expectWorkerOutputting (outputType: KType , key: String = \u201c\u201d, crossinline assertWorker: ( Worker < >) -> Unit = {}, output: WorkflowOutput < >? = null, description: String = \u201c\u201d): RenderTester < PropsT , StateT , OutputT , RenderingT > Specifies that this render pass is expected to run a Worker with the given outputType .","title":"expectWorkerOutputting"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/expect-worker-outputting/#parameters","text":"jvm outputType the KType of the Worker \u2018s OutputT type parameter. key The key passed to runningWorker when rendering this workflow. output If non-null, WorkflowOutput.value will be emitted when this worker is ran. The WorkflowAction used to handle this output can be verified using methods on RenderTestResult . description Optional string that will be used to describe this expectation in error messages.","title":"Parameters"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/expect-worker/","text":"// workflow / com.squareup.workflow1.testing / expectWorker expectWorker \u00b6 [jvm]\\ inline fun < PropsT , StateT , OutputT , RenderingT , WorkerOutputT , WorkerT : Worker < WorkerOutputT >> RenderTester < PropsT , StateT , OutputT , RenderingT >. expectWorker (expected: WorkerT , key: String = \u201c\u201d, output: WorkflowOutput < WorkerOutputT >? = null, description: String = \u201c\u201d): RenderTester < PropsT , StateT , OutputT , RenderingT > Specifies that this render pass is expected to run a Worker that has the same type of the given worker and for which the actual worker\u2019s doesSameWorkAs method returns true. If a worker is ran that matches the type of expected , but the actual worker\u2019s doesSameWorkAs returns false, then an AssertionError will be thrown. If you need to perform custom assertions, use the overload of this method that takes an assertWhen parameter. Parameters \u00b6 jvm expected Worker passed to the actual worker\u2019s doesSameWorkAs method to assert the worker matches. key The key passed to runningWorker when rendering this workflow. output If non-null, WorkflowOutput.value will be emitted when this worker is ran. The WorkflowAction used to handle this output can be verified using methods on RenderTestResult . description Optional string that will be used to describe this expectation in error messages. [jvm]\\ inline fun < PropsT , StateT , OutputT , RenderingT , WorkerOutputT , WorkerT : Worker < WorkerOutputT >> RenderTester < PropsT , StateT , OutputT , RenderingT >. expectWorker (workerClass: KClass <out WorkerT >, key: String = \u201c\u201d, crossinline assertWorker: ( WorkerT ) -> Unit = {}, output: WorkflowOutput < WorkerOutputT >? = null, description: String = \u201c\u201d): RenderTester < PropsT , StateT , OutputT , RenderingT > Specifies that this render pass is expected to run a Worker with the given workerClass . The worker\u2019s output type is not taken into consideration. Parameters \u00b6 jvm workerClass The KClass of the worker that is expected to be run. key The key passed to runningWorker when rendering this workflow. assertWorker A function that will be passed the actual worker that matches this expectation and can perform custom assertions on the worker instance. output If non-null, WorkflowOutput.value will be emitted when this worker is ran. The WorkflowAction used to handle this output can be verified using methods on RenderTestResult . description Optional string that will be used to describe this expectation in error messages. [jvm]\\ fun < PropsT , StateT , OutputT , RenderingT > RenderTester < PropsT , StateT , OutputT , RenderingT >. expectWorker (workerType: KType , key: String = \u201c\u201d, assertWorker: ( Worker < >) -> Unit = {}, output: WorkflowOutput < >? = null, description: String = \u201c\u201d): RenderTester < PropsT , StateT , OutputT , RenderingT > Specifies that this render pass is expected to run a Worker whose KType matches workerType . Parameters \u00b6 jvm workerType The KType of the Worker that is expected to be run. This will be compared against the concrete type of the worker that is passed to com.squareup.workflow.runningWorker, but may be a supertype of that type. E.g. an expected worker type of typeOf<Worker<Collection<CharSequence>>>() will match a worker that has the type SomeConcreteWorker<List<String>>. key The key passed to runningWorker when rendering this workflow. assertWorker A function that will be passed the actual worker that matches this expectation and can perform custom assertions on the worker instance. output If non-null, WorkflowOutput.value will be emitted when this worker is ran. The WorkflowAction used to handle this output can be verified using methods on RenderTestResult . description Optional string that will be used to describe this expectation in error messages.","title":"Expect worker"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/expect-worker/#expectworker","text":"[jvm]\\ inline fun < PropsT , StateT , OutputT , RenderingT , WorkerOutputT , WorkerT : Worker < WorkerOutputT >> RenderTester < PropsT , StateT , OutputT , RenderingT >. expectWorker (expected: WorkerT , key: String = \u201c\u201d, output: WorkflowOutput < WorkerOutputT >? = null, description: String = \u201c\u201d): RenderTester < PropsT , StateT , OutputT , RenderingT > Specifies that this render pass is expected to run a Worker that has the same type of the given worker and for which the actual worker\u2019s doesSameWorkAs method returns true. If a worker is ran that matches the type of expected , but the actual worker\u2019s doesSameWorkAs returns false, then an AssertionError will be thrown. If you need to perform custom assertions, use the overload of this method that takes an assertWhen parameter.","title":"expectWorker"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/expect-worker/#parameters","text":"jvm expected Worker passed to the actual worker\u2019s doesSameWorkAs method to assert the worker matches. key The key passed to runningWorker when rendering this workflow. output If non-null, WorkflowOutput.value will be emitted when this worker is ran. The WorkflowAction used to handle this output can be verified using methods on RenderTestResult . description Optional string that will be used to describe this expectation in error messages. [jvm]\\ inline fun < PropsT , StateT , OutputT , RenderingT , WorkerOutputT , WorkerT : Worker < WorkerOutputT >> RenderTester < PropsT , StateT , OutputT , RenderingT >. expectWorker (workerClass: KClass <out WorkerT >, key: String = \u201c\u201d, crossinline assertWorker: ( WorkerT ) -> Unit = {}, output: WorkflowOutput < WorkerOutputT >? = null, description: String = \u201c\u201d): RenderTester < PropsT , StateT , OutputT , RenderingT > Specifies that this render pass is expected to run a Worker with the given workerClass . The worker\u2019s output type is not taken into consideration.","title":"Parameters"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/expect-worker/#parameters_1","text":"jvm workerClass The KClass of the worker that is expected to be run. key The key passed to runningWorker when rendering this workflow. assertWorker A function that will be passed the actual worker that matches this expectation and can perform custom assertions on the worker instance. output If non-null, WorkflowOutput.value will be emitted when this worker is ran. The WorkflowAction used to handle this output can be verified using methods on RenderTestResult . description Optional string that will be used to describe this expectation in error messages. [jvm]\\ fun < PropsT , StateT , OutputT , RenderingT > RenderTester < PropsT , StateT , OutputT , RenderingT >. expectWorker (workerType: KType , key: String = \u201c\u201d, assertWorker: ( Worker < >) -> Unit = {}, output: WorkflowOutput < >? = null, description: String = \u201c\u201d): RenderTester < PropsT , StateT , OutputT , RenderingT > Specifies that this render pass is expected to run a Worker whose KType matches workerType .","title":"Parameters"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/expect-worker/#parameters_2","text":"jvm workerType The KType of the Worker that is expected to be run. This will be compared against the concrete type of the worker that is passed to com.squareup.workflow.runningWorker, but may be a supertype of that type. E.g. an expected worker type of typeOf<Worker<Collection<CharSequence>>>() will match a worker that has the type SomeConcreteWorker<List<String>>. key The key passed to runningWorker when rendering this workflow. assertWorker A function that will be passed the actual worker that matches this expectation and can perform custom assertions on the worker instance. output If non-null, WorkflowOutput.value will be emitted when this worker is ran. The WorkflowAction used to handle this output can be verified using methods on RenderTestResult . description Optional string that will be used to describe this expectation in error messages.","title":"Parameters"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/expect-workflow/","text":"// workflow / com.squareup.workflow1.testing / expectWorkflow expectWorkflow \u00b6 [jvm]\\ inline fun < ChildRenderingT , PropsT , StateT , OutputT , RenderingT > RenderTester < PropsT , StateT , OutputT , RenderingT >. expectWorkflow (identifier: WorkflowIdentifier , rendering: ChildRenderingT , key: String = \u201c\u201d, description: String = \u201c\u201d, noinline assertProps: (props: Any ?) -> Unit = {}): RenderTester < PropsT , StateT , OutputT , RenderingT > Specifies that this render pass is expected to render a particular child workflow. Workflow identifiers are compared taking the type hierarchy into account. When a workflow is rendered, it will match any expectation that specifies the type of that workflow, or any of its supertypes. This means that if you have a workflow that is split into an interface and a concrete class, your render tests can pass the class of the interface to this method instead of the actual class that implements it. Expecting impostor workflows \u00b6 If the workflow-under-test renders an ImpostorWorkflow , the match will not be performed using the impostor type, but rather the real identifier of the impostor\u2019s WorkflowIdentifier . This will be the last identifier in the chain of impostor workflows\u2019 realIdentifier s. A workflow that is wrapped multiple times by various operators will be matched on the upstream workflow, so for example the following expectation would succeed: val workflow = Workflow.stateless<\u2026> {\\ renderChild(\\ childWorkflow.mapRendering { \u2026 }\\ .mapOutput { \u2026 }\\ )\\ }\\ \\ workflow.testRender(\u2026)\\ .expectWorkflow(childWorkflow::class, \u2026) Parameters \u00b6 jvm identifier The WorkflowIdentifier of the expected workflow. May identify any supertype of the actual rendered workflow, e.g. if the workflow type is an interface and the workflow-under-test injects a fake. rendering The rendering to return from renderChild when this workflow is rendered. key The key passed to renderChild when rendering this workflow. assertProps A function that performs assertions on the props passed to renderChild . description Optional string that will be used to describe this expectation in error messages. [jvm]\\ fun < ChildOutputT , ChildRenderingT , PropsT , StateT , OutputT , RenderingT > RenderTester < PropsT , StateT , OutputT , RenderingT >. expectWorkflow (identifier: WorkflowIdentifier , rendering: ChildRenderingT , output: WorkflowOutput < ChildOutputT >?, key: String = \u201c\u201d, description: String = \u201c\u201d, assertProps: (props: Any ?) -> Unit = {}): RenderTester < PropsT , StateT , OutputT , RenderingT > Specifies that this render pass is expected to render a particular child workflow. Workflow identifiers are compared taking the type hierarchy into account. When a workflow is rendered, it will match any expectation that specifies the type of that workflow, or any of its supertypes. This means that if you have a workflow that is split into an interface and a concrete class, your render tests can pass the class of the interface to this method instead of the actual class that implements it. Expecting impostor workflows \u00b6 If the workflow-under-test renders an ImpostorWorkflow , the match will not be performed using the impostor type, but rather the real identifier of the impostor\u2019s WorkflowIdentifier . This will be the last identifier in the chain of impostor workflows\u2019 realIdentifier s. A workflow that is wrapped multiple times by various operators will be matched on the upstream workflow, so for example the following expectation would succeed: val workflow = Workflow.stateless<\u2026> {\\ renderChild(\\ childWorkflow.mapRendering { \u2026 }\\ .mapOutput { \u2026 }\\ )\\ }\\ \\ workflow.testRender(\u2026)\\ .expectWorkflow(childWorkflow::class, \u2026) Parameters \u00b6 jvm identifier The WorkflowIdentifier of the expected workflow. May identify any supertype of the actual rendered workflow, e.g. if the workflow type is an interface and the workflow-under-test injects a fake. rendering The rendering to return from renderChild when this workflow is rendered. key The key passed to renderChild when rendering this workflow. assertProps A function that performs assertions on the props passed to renderChild . output If non-null, WorkflowOutput.value will be \u201cemitted\u201d when this workflow is rendered. The WorkflowAction used to handle this output can be verified using methods on RenderTestResult . description Optional string that will be used to describe this expectation in error messages. [jvm]\\ inline fun < ChildPropsT , ChildOutputT , ChildRenderingT , PropsT , StateT , OutputT , RenderingT > RenderTester < PropsT , StateT , OutputT , RenderingT >. expectWorkflow (workflowType: KClass <out Workflow < ChildPropsT , ChildOutputT , ChildRenderingT >>, rendering: ChildRenderingT , key: String = \u201c\u201d, crossinline assertProps: ( ChildPropsT ) -> Unit = {}, output: WorkflowOutput < ChildOutputT >? = null, description: String = \u201c\u201d): RenderTester < PropsT , StateT , OutputT , RenderingT > Specifies that this render pass is expected to render a particular child workflow. Workflow identifiers are compared taking the type hierarchy into account. When a workflow is rendered, it will match any expectation that specifies the type of that workflow, or any of its supertypes. This means that if you have a workflow that is split into an interface and a concrete class, your render tests can pass the class of the interface to this method instead of the actual class that implements it. Expecting impostor workflows \u00b6 If the workflow-under-test renders an ImpostorWorkflow , the match will not be performed using the impostor type, but rather the real identifier of the impostor\u2019s WorkflowIdentifier . This will be the last identifier in the chain of impostor workflows\u2019 realIdentifier s. A workflow that is wrapped multiple times by various operators will be matched on the upstream workflow, so for example the following expectation would succeed: val workflow = Workflow.stateless<\u2026> {\\ renderChild(childWorkflow.mapRendering { \u2026 })\\ }\\ \\ workflow.testRender(\u2026)\\ .expectWorkflow(childWorkflow::class, \u2026) Parameters \u00b6 jvm workflowType The KClass of the expected workflow. May also be any of the supertypes of the expected workflow, e.g. if the workflow type is an interface and the workflow-under-test injects a fake. rendering The rendering to return from renderChild when this workflow is rendered. key The key passed to renderChild when rendering this workflow. assertProps A function that performs assertions on the props passed to renderChild . output If non-null, WorkflowOutput.value will be \u201cemitted\u201d when this workflow is rendered. The WorkflowAction used to handle this output can be verified using methods on RenderTestResult . description Optional string that will be used to describe this expectation in error messages.","title":"Expect workflow"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/expect-workflow/#expectworkflow","text":"[jvm]\\ inline fun < ChildRenderingT , PropsT , StateT , OutputT , RenderingT > RenderTester < PropsT , StateT , OutputT , RenderingT >. expectWorkflow (identifier: WorkflowIdentifier , rendering: ChildRenderingT , key: String = \u201c\u201d, description: String = \u201c\u201d, noinline assertProps: (props: Any ?) -> Unit = {}): RenderTester < PropsT , StateT , OutputT , RenderingT > Specifies that this render pass is expected to render a particular child workflow. Workflow identifiers are compared taking the type hierarchy into account. When a workflow is rendered, it will match any expectation that specifies the type of that workflow, or any of its supertypes. This means that if you have a workflow that is split into an interface and a concrete class, your render tests can pass the class of the interface to this method instead of the actual class that implements it.","title":"expectWorkflow"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/expect-workflow/#expecting-impostor-workflows","text":"If the workflow-under-test renders an ImpostorWorkflow , the match will not be performed using the impostor type, but rather the real identifier of the impostor\u2019s WorkflowIdentifier . This will be the last identifier in the chain of impostor workflows\u2019 realIdentifier s. A workflow that is wrapped multiple times by various operators will be matched on the upstream workflow, so for example the following expectation would succeed: val workflow = Workflow.stateless<\u2026> {\\ renderChild(\\ childWorkflow.mapRendering { \u2026 }\\ .mapOutput { \u2026 }\\ )\\ }\\ \\ workflow.testRender(\u2026)\\ .expectWorkflow(childWorkflow::class, \u2026)","title":"Expecting impostor workflows"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/expect-workflow/#parameters","text":"jvm identifier The WorkflowIdentifier of the expected workflow. May identify any supertype of the actual rendered workflow, e.g. if the workflow type is an interface and the workflow-under-test injects a fake. rendering The rendering to return from renderChild when this workflow is rendered. key The key passed to renderChild when rendering this workflow. assertProps A function that performs assertions on the props passed to renderChild . description Optional string that will be used to describe this expectation in error messages. [jvm]\\ fun < ChildOutputT , ChildRenderingT , PropsT , StateT , OutputT , RenderingT > RenderTester < PropsT , StateT , OutputT , RenderingT >. expectWorkflow (identifier: WorkflowIdentifier , rendering: ChildRenderingT , output: WorkflowOutput < ChildOutputT >?, key: String = \u201c\u201d, description: String = \u201c\u201d, assertProps: (props: Any ?) -> Unit = {}): RenderTester < PropsT , StateT , OutputT , RenderingT > Specifies that this render pass is expected to render a particular child workflow. Workflow identifiers are compared taking the type hierarchy into account. When a workflow is rendered, it will match any expectation that specifies the type of that workflow, or any of its supertypes. This means that if you have a workflow that is split into an interface and a concrete class, your render tests can pass the class of the interface to this method instead of the actual class that implements it.","title":"Parameters"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/expect-workflow/#expecting-impostor-workflows_1","text":"If the workflow-under-test renders an ImpostorWorkflow , the match will not be performed using the impostor type, but rather the real identifier of the impostor\u2019s WorkflowIdentifier . This will be the last identifier in the chain of impostor workflows\u2019 realIdentifier s. A workflow that is wrapped multiple times by various operators will be matched on the upstream workflow, so for example the following expectation would succeed: val workflow = Workflow.stateless<\u2026> {\\ renderChild(\\ childWorkflow.mapRendering { \u2026 }\\ .mapOutput { \u2026 }\\ )\\ }\\ \\ workflow.testRender(\u2026)\\ .expectWorkflow(childWorkflow::class, \u2026)","title":"Expecting impostor workflows"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/expect-workflow/#parameters_1","text":"jvm identifier The WorkflowIdentifier of the expected workflow. May identify any supertype of the actual rendered workflow, e.g. if the workflow type is an interface and the workflow-under-test injects a fake. rendering The rendering to return from renderChild when this workflow is rendered. key The key passed to renderChild when rendering this workflow. assertProps A function that performs assertions on the props passed to renderChild . output If non-null, WorkflowOutput.value will be \u201cemitted\u201d when this workflow is rendered. The WorkflowAction used to handle this output can be verified using methods on RenderTestResult . description Optional string that will be used to describe this expectation in error messages. [jvm]\\ inline fun < ChildPropsT , ChildOutputT , ChildRenderingT , PropsT , StateT , OutputT , RenderingT > RenderTester < PropsT , StateT , OutputT , RenderingT >. expectWorkflow (workflowType: KClass <out Workflow < ChildPropsT , ChildOutputT , ChildRenderingT >>, rendering: ChildRenderingT , key: String = \u201c\u201d, crossinline assertProps: ( ChildPropsT ) -> Unit = {}, output: WorkflowOutput < ChildOutputT >? = null, description: String = \u201c\u201d): RenderTester < PropsT , StateT , OutputT , RenderingT > Specifies that this render pass is expected to render a particular child workflow. Workflow identifiers are compared taking the type hierarchy into account. When a workflow is rendered, it will match any expectation that specifies the type of that workflow, or any of its supertypes. This means that if you have a workflow that is split into an interface and a concrete class, your render tests can pass the class of the interface to this method instead of the actual class that implements it.","title":"Parameters"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/expect-workflow/#expecting-impostor-workflows_2","text":"If the workflow-under-test renders an ImpostorWorkflow , the match will not be performed using the impostor type, but rather the real identifier of the impostor\u2019s WorkflowIdentifier . This will be the last identifier in the chain of impostor workflows\u2019 realIdentifier s. A workflow that is wrapped multiple times by various operators will be matched on the upstream workflow, so for example the following expectation would succeed: val workflow = Workflow.stateless<\u2026> {\\ renderChild(childWorkflow.mapRendering { \u2026 })\\ }\\ \\ workflow.testRender(\u2026)\\ .expectWorkflow(childWorkflow::class, \u2026)","title":"Expecting impostor workflows"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/expect-workflow/#parameters_2","text":"jvm workflowType The KClass of the expected workflow. May also be any of the supertypes of the expected workflow, e.g. if the workflow type is an interface and the workflow-under-test injects a fake. rendering The rendering to return from renderChild when this workflow is rendered. key The key passed to renderChild when rendering this workflow. assertProps A function that performs assertions on the props passed to renderChild . output If non-null, WorkflowOutput.value will be \u201cemitted\u201d when this workflow is rendered. The WorkflowAction used to handle this output can be verified using methods on RenderTestResult . description Optional string that will be used to describe this expectation in error messages.","title":"Parameters"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/launch-for-testing-from-start-with/","text":"// workflow / com.squareup.workflow1.testing / launchForTestingFromStartWith launchForTestingFromStartWith \u00b6 [jvm]\\ @TestOnly fun < T , PropsT , OutputT , RenderingT > Workflow < PropsT , OutputT , RenderingT >. launchForTestingFromStartWith (props: PropsT , testParams: WorkflowTestParams < Nothing > = WorkflowTestParams(), context: CoroutineContext = EmptyCoroutineContext, block: WorkflowTestRuntime < PropsT , OutputT , RenderingT >.() -> T ): T @TestOnly fun < T , OutputT , RenderingT > Workflow < Unit , OutputT , RenderingT >. launchForTestingFromStartWith (testParams: WorkflowTestParams < Nothing > = WorkflowTestParams(), context: CoroutineContext = EmptyCoroutineContext, block: WorkflowTestRuntime < Unit , OutputT , RenderingT >.() -> T ): T Creates a WorkflowTestRuntime to run this workflow for unit testing. All workflow-related coroutines are cancelled when the block exits.","title":"Launch for testing from start with"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/launch-for-testing-from-start-with/#launchfortestingfromstartwith","text":"[jvm]\\ @TestOnly fun < T , PropsT , OutputT , RenderingT > Workflow < PropsT , OutputT , RenderingT >. launchForTestingFromStartWith (props: PropsT , testParams: WorkflowTestParams < Nothing > = WorkflowTestParams(), context: CoroutineContext = EmptyCoroutineContext, block: WorkflowTestRuntime < PropsT , OutputT , RenderingT >.() -> T ): T @TestOnly fun < T , OutputT , RenderingT > Workflow < Unit , OutputT , RenderingT >. launchForTestingFromStartWith (testParams: WorkflowTestParams < Nothing > = WorkflowTestParams(), context: CoroutineContext = EmptyCoroutineContext, block: WorkflowTestRuntime < Unit , OutputT , RenderingT >.() -> T ): T Creates a WorkflowTestRuntime to run this workflow for unit testing. All workflow-related coroutines are cancelled when the block exits.","title":"launchForTestingFromStartWith"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/launch-for-testing-from-state-with/","text":"// workflow / com.squareup.workflow1.testing / launchForTestingFromStateWith launchForTestingFromStateWith \u00b6 [jvm]\\ @TestOnly fun < T , PropsT , StateT , OutputT , RenderingT > StatefulWorkflow < PropsT , StateT , OutputT , RenderingT >. launchForTestingFromStateWith (props: PropsT , initialState: StateT , context: CoroutineContext = EmptyCoroutineContext, block: WorkflowTestRuntime < PropsT , OutputT , RenderingT >.() -> T ): T @TestOnly fun < StateT , OutputT , RenderingT > StatefulWorkflow < Unit , StateT , OutputT , RenderingT >. launchForTestingFromStateWith (initialState: StateT , context: CoroutineContext = EmptyCoroutineContext, block: WorkflowTestRuntime < Unit , OutputT , RenderingT >.() -> Unit ) Creates a WorkflowTestRuntime to run this workflow for unit testing. If the workflow is stateful , initialState is not called. Instead, the workflow is started from the given initialState . All workflow-related coroutines are cancelled when the block exits.","title":"Launch for testing from state with"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/launch-for-testing-from-state-with/#launchfortestingfromstatewith","text":"[jvm]\\ @TestOnly fun < T , PropsT , StateT , OutputT , RenderingT > StatefulWorkflow < PropsT , StateT , OutputT , RenderingT >. launchForTestingFromStateWith (props: PropsT , initialState: StateT , context: CoroutineContext = EmptyCoroutineContext, block: WorkflowTestRuntime < PropsT , OutputT , RenderingT >.() -> T ): T @TestOnly fun < StateT , OutputT , RenderingT > StatefulWorkflow < Unit , StateT , OutputT , RenderingT >. launchForTestingFromStateWith (initialState: StateT , context: CoroutineContext = EmptyCoroutineContext, block: WorkflowTestRuntime < Unit , OutputT , RenderingT >.() -> Unit ) Creates a WorkflowTestRuntime to run this workflow for unit testing. If the workflow is stateful , initialState is not called. Instead, the workflow is started from the given initialState . All workflow-related coroutines are cancelled when the block exits.","title":"launchForTestingFromStateWith"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/launch-for-testing-with/","text":"// workflow / com.squareup.workflow1.testing / launchForTestingWith launchForTestingWith \u00b6 [jvm]\\ @TestOnly fun < T , PropsT , StateT , OutputT , RenderingT > StatefulWorkflow < PropsT , StateT , OutputT , RenderingT >. launchForTestingWith (props: PropsT , testParams: WorkflowTestParams < StateT > = WorkflowTestParams(), context: CoroutineContext = EmptyCoroutineContext, block: WorkflowTestRuntime < PropsT , OutputT , RenderingT >.() -> T ): T Creates a WorkflowTestRuntime to run this workflow for unit testing. All workflow-related coroutines are cancelled when the block exits.","title":"Launch for testing with"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/launch-for-testing-with/#launchfortestingwith","text":"[jvm]\\ @TestOnly fun < T , PropsT , StateT , OutputT , RenderingT > StatefulWorkflow < PropsT , StateT , OutputT , RenderingT >. launchForTestingWith (props: PropsT , testParams: WorkflowTestParams < StateT > = WorkflowTestParams(), context: CoroutineContext = EmptyCoroutineContext, block: WorkflowTestRuntime < PropsT , OutputT , RenderingT >.() -> T ): T Creates a WorkflowTestRuntime to run this workflow for unit testing. All workflow-related coroutines are cancelled when the block exits.","title":"launchForTestingWith"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/test-render/","text":"// workflow / com.squareup.workflow1.testing / testRender testRender \u00b6 [jvm]\\ fun < PropsT , OutputT , RenderingT > Workflow < PropsT , OutputT , RenderingT >. testRender (props: PropsT ): RenderTester < PropsT , *, OutputT , RenderingT > Create a RenderTester to unit test an individual render pass of this workflow, using the workflow\u2019s initial state . See RenderTester for usage documentation. [jvm]\\ fun < PropsT , StateT , OutputT , RenderingT > StatefulWorkflow < PropsT , StateT , OutputT , RenderingT >. testRender (props: PropsT , initialState: StateT ): RenderTester < PropsT , StateT , OutputT , RenderingT > Create a RenderTester to unit test an individual render pass of this workflow. See RenderTester for usage documentation.","title":"Test render"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/test-render/#testrender","text":"[jvm]\\ fun < PropsT , OutputT , RenderingT > Workflow < PropsT , OutputT , RenderingT >. testRender (props: PropsT ): RenderTester < PropsT , *, OutputT , RenderingT > Create a RenderTester to unit test an individual render pass of this workflow, using the workflow\u2019s initial state . See RenderTester for usage documentation. [jvm]\\ fun < PropsT , StateT , OutputT , RenderingT > StatefulWorkflow < PropsT , StateT , OutputT , RenderingT >. testRender (props: PropsT , initialState: StateT ): RenderTester < PropsT , StateT , OutputT , RenderingT > Create a RenderTester to unit test an individual render pass of this workflow. See RenderTester for usage documentation.","title":"testRender"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/test/","text":"// workflow / com.squareup.workflow1.testing / test test \u00b6 [jvm]\\ fun < T > Worker < T >. test (timeoutMs: Long = DEFAULT_TIMEOUT_MS, block: suspend WorkerTester < T >.() -> Unit ) Test a Worker by defining assertions on its output within block .","title":"Test"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/test/#test","text":"[jvm]\\ fun < T > Worker < T >. test (timeoutMs: Long = DEFAULT_TIMEOUT_MS, block: suspend WorkerTester < T >.() -> Unit ) Test a Worker by defining assertions on its output within block .","title":"test"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-render-idempotency-checker/","text":"// workflow / com.squareup.workflow1.testing / RenderIdempotencyChecker RenderIdempotencyChecker \u00b6 [jvm]\\ object RenderIdempotencyChecker : WorkflowInterceptor Intercepts the render pass of the root workflow and runs it twice to ensure that well-written unit tests catch side effects being incorrectly performed directly in the render method. The first render pass is the real one, the second one is a no-op and child workflow renderings will be played back, in order, to their renderChild calls. Functions \u00b6 Name Summary onInitialState [jvm] open fun < P , S > onInitialState (props: P , snapshot: Snapshot ?, proceed: ( P , Snapshot ?) -> S , session: WorkflowInterceptor.WorkflowSession ): S onPropsChanged [jvm] open fun < P , S > onPropsChanged (old: P , new: P , state: S , proceed: ( P , P , S ) -> S , session: WorkflowInterceptor.WorkflowSession ): S onRender [jvm] open override fun < P , S , O , R > onRender (renderProps: P , renderState: S , context: BaseRenderContext < P , S , O >, proceed: ( P , S , WorkflowInterceptor.RenderContextInterceptor < P , S , O >?) -> R , session: WorkflowInterceptor.WorkflowSession ): R onSessionStarted [jvm] open fun onSessionStarted (workflowScope: CoroutineScope, session: WorkflowInterceptor.WorkflowSession ) onSnapshotState [jvm] open fun < S > onSnapshotState (state: S , proceed: ( S ) -> Snapshot ?, session: WorkflowInterceptor.WorkflowSession ): Snapshot ?","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-render-idempotency-checker/#renderidempotencychecker","text":"[jvm]\\ object RenderIdempotencyChecker : WorkflowInterceptor Intercepts the render pass of the root workflow and runs it twice to ensure that well-written unit tests catch side effects being incorrectly performed directly in the render method. The first render pass is the real one, the second one is a no-op and child workflow renderings will be played back, in order, to their renderChild calls.","title":"RenderIdempotencyChecker"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-render-idempotency-checker/#functions","text":"Name Summary onInitialState [jvm] open fun < P , S > onInitialState (props: P , snapshot: Snapshot ?, proceed: ( P , Snapshot ?) -> S , session: WorkflowInterceptor.WorkflowSession ): S onPropsChanged [jvm] open fun < P , S > onPropsChanged (old: P , new: P , state: S , proceed: ( P , P , S ) -> S , session: WorkflowInterceptor.WorkflowSession ): S onRender [jvm] open override fun < P , S , O , R > onRender (renderProps: P , renderState: S , context: BaseRenderContext < P , S , O >, proceed: ( P , S , WorkflowInterceptor.RenderContextInterceptor < P , S , O >?) -> R , session: WorkflowInterceptor.WorkflowSession ): R onSessionStarted [jvm] open fun onSessionStarted (workflowScope: CoroutineScope, session: WorkflowInterceptor.WorkflowSession ) onSnapshotState [jvm] open fun < S > onSnapshotState (state: S , proceed: ( S ) -> Snapshot ?, session: WorkflowInterceptor.WorkflowSession ): Snapshot ?","title":"Functions"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-render-idempotency-checker/on-render/","text":"// workflow / com.squareup.workflow1.testing / RenderIdempotencyChecker / onRender onRender \u00b6 [jvm]\\ open override fun < P , S , O , R > onRender (renderProps: P , renderState: S , context: BaseRenderContext < P , S , O >, proceed: ( P , S , WorkflowInterceptor.RenderContextInterceptor < P , S , O >?) -> R , session: WorkflowInterceptor.WorkflowSession ): R","title":"On render"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-render-idempotency-checker/on-render/#onrender","text":"[jvm]\\ open override fun < P , S , O , R > onRender (renderProps: P , renderState: S , context: BaseRenderContext < P , S , O >, proceed: ( P , S , WorkflowInterceptor.RenderContextInterceptor < P , S , O >?) -> R , session: WorkflowInterceptor.WorkflowSession ): R","title":"onRender"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-render-test-result/","text":"// workflow / com.squareup.workflow1.testing / RenderTestResult RenderTestResult \u00b6 [jvm]\\ interface RenderTestResult < PropsT , StateT , OutputT , RenderingT > Result of a RenderTester.render call that can be used to verify that a WorkflowAction was processed and perform assertions on that action. See also \u00b6 jvm com.squareup.workflow1.testing.RenderTestResult Functions \u00b6 Name Summary testNextRender [jvm] abstract fun testNextRender (): RenderTester < PropsT , StateT , OutputT , RenderingT > Starts a new RenderTester session using the same props as the previous session started by testRender or testNextRenderWithProps , and the state that is a result of the latest render pass (the same one you could run assertions on in verifyActionResult ). testNextRenderWithProps [jvm] abstract fun testNextRenderWithProps (newProps: PropsT ): RenderTester < PropsT , StateT , OutputT , RenderingT > Starts a new RenderTester session using newProps props, and the state that is a result of the latest render pass (the same one you could run assertions on in verifyActionResult ). verifyAction [jvm] abstract fun verifyAction (block: ( WorkflowAction < PropsT , StateT , OutputT >) -> Unit ): RenderTestResult < PropsT , StateT , OutputT , RenderingT > Asserts that the render pass handled either a workflow/worker output or a rendering event, and passes the resulting WorkflowAction to block for asserting. verifyActionResult [jvm] abstract fun verifyActionResult (block: ( StateT , output: WorkflowOutput < OutputT >?) -> Unit ): RenderTestResult < PropsT , StateT , OutputT , RenderingT > Asserts that the render pass handled either a workflow/worker output or a rendering event, \u201cexecutes\u201d the action with the state passed to testRender , then invokes block with the resulting state and output values.","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-render-test-result/#rendertestresult","text":"[jvm]\\ interface RenderTestResult < PropsT , StateT , OutputT , RenderingT > Result of a RenderTester.render call that can be used to verify that a WorkflowAction was processed and perform assertions on that action.","title":"RenderTestResult"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-render-test-result/#see-also","text":"jvm com.squareup.workflow1.testing.RenderTestResult","title":"See also"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-render-test-result/#functions","text":"Name Summary testNextRender [jvm] abstract fun testNextRender (): RenderTester < PropsT , StateT , OutputT , RenderingT > Starts a new RenderTester session using the same props as the previous session started by testRender or testNextRenderWithProps , and the state that is a result of the latest render pass (the same one you could run assertions on in verifyActionResult ). testNextRenderWithProps [jvm] abstract fun testNextRenderWithProps (newProps: PropsT ): RenderTester < PropsT , StateT , OutputT , RenderingT > Starts a new RenderTester session using newProps props, and the state that is a result of the latest render pass (the same one you could run assertions on in verifyActionResult ). verifyAction [jvm] abstract fun verifyAction (block: ( WorkflowAction < PropsT , StateT , OutputT >) -> Unit ): RenderTestResult < PropsT , StateT , OutputT , RenderingT > Asserts that the render pass handled either a workflow/worker output or a rendering event, and passes the resulting WorkflowAction to block for asserting. verifyActionResult [jvm] abstract fun verifyActionResult (block: ( StateT , output: WorkflowOutput < OutputT >?) -> Unit ): RenderTestResult < PropsT , StateT , OutputT , RenderingT > Asserts that the render pass handled either a workflow/worker output or a rendering event, \u201cexecutes\u201d the action with the state passed to testRender , then invokes block with the resulting state and output values.","title":"Functions"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-render-test-result/test-next-render-with-props/","text":"// workflow / com.squareup.workflow1.testing / RenderTestResult / testNextRenderWithProps testNextRenderWithProps \u00b6 [jvm]\\ abstract fun testNextRenderWithProps (newProps: PropsT ): RenderTester < PropsT , StateT , OutputT , RenderingT > Starts a new RenderTester session using newProps props, and the state that is a result of the latest render pass (the same one you could run assertions on in verifyActionResult ). This method is useful for daisy-chaining of RenderTester sessions, when you want to assert different state transitions without WorkflowTestRuntime overhead. Note that if you\u2019re overriding StatefulWorkflow.onPropsChanged method, it\u2019ll be ran before the next RenderTester.render pass, and RenderTester returned by this method will use the updated state value.","title":"Test next render with props"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-render-test-result/test-next-render-with-props/#testnextrenderwithprops","text":"[jvm]\\ abstract fun testNextRenderWithProps (newProps: PropsT ): RenderTester < PropsT , StateT , OutputT , RenderingT > Starts a new RenderTester session using newProps props, and the state that is a result of the latest render pass (the same one you could run assertions on in verifyActionResult ). This method is useful for daisy-chaining of RenderTester sessions, when you want to assert different state transitions without WorkflowTestRuntime overhead. Note that if you\u2019re overriding StatefulWorkflow.onPropsChanged method, it\u2019ll be ran before the next RenderTester.render pass, and RenderTester returned by this method will use the updated state value.","title":"testNextRenderWithProps"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-render-test-result/test-next-render/","text":"// workflow / com.squareup.workflow1.testing / RenderTestResult / testNextRender testNextRender \u00b6 [jvm]\\ abstract fun testNextRender (): RenderTester < PropsT , StateT , OutputT , RenderingT > Starts a new RenderTester session using the same props as the previous session started by testRender or testNextRenderWithProps , and the state that is a result of the latest render pass (the same one you could run assertions on in verifyActionResult ). This method is useful for daisy-chaining of RenderTester sessions, when you want to assert different state transitions without WorkflowTestRuntime overhead.","title":"Test next render"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-render-test-result/test-next-render/#testnextrender","text":"[jvm]\\ abstract fun testNextRender (): RenderTester < PropsT , StateT , OutputT , RenderingT > Starts a new RenderTester session using the same props as the previous session started by testRender or testNextRenderWithProps , and the state that is a result of the latest render pass (the same one you could run assertions on in verifyActionResult ). This method is useful for daisy-chaining of RenderTester sessions, when you want to assert different state transitions without WorkflowTestRuntime overhead.","title":"testNextRender"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-render-test-result/verify-action-result/","text":"// workflow / com.squareup.workflow1.testing / RenderTestResult / verifyActionResult verifyActionResult \u00b6 [jvm]\\ abstract fun verifyActionResult (block: ( StateT , output: WorkflowOutput < OutputT >?) -> Unit ): RenderTestResult < PropsT , StateT , OutputT , RenderingT > Asserts that the render pass handled either a workflow/worker output or a rendering event, \u201cexecutes\u201d the action with the state passed to testRender , then invokes block with the resulting state and output values. If the workflow didn\u2019t process any actions, newState will be the initial state and output will be null. Note that by using this method, you\u2019re also testing the implementation of your action. This can be useful if your actions are anonymous. If they are a sealed class or enum, use verifyAction instead and write separate unit tests for your action implementations.","title":"Verify action result"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-render-test-result/verify-action-result/#verifyactionresult","text":"[jvm]\\ abstract fun verifyActionResult (block: ( StateT , output: WorkflowOutput < OutputT >?) -> Unit ): RenderTestResult < PropsT , StateT , OutputT , RenderingT > Asserts that the render pass handled either a workflow/worker output or a rendering event, \u201cexecutes\u201d the action with the state passed to testRender , then invokes block with the resulting state and output values. If the workflow didn\u2019t process any actions, newState will be the initial state and output will be null. Note that by using this method, you\u2019re also testing the implementation of your action. This can be useful if your actions are anonymous. If they are a sealed class or enum, use verifyAction instead and write separate unit tests for your action implementations.","title":"verifyActionResult"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-render-test-result/verify-action/","text":"// workflow / com.squareup.workflow1.testing / RenderTestResult / verifyAction verifyAction \u00b6 [jvm]\\ abstract fun verifyAction (block: ( WorkflowAction < PropsT , StateT , OutputT >) -> Unit ): RenderTestResult < PropsT , StateT , OutputT , RenderingT > Asserts that the render pass handled either a workflow/worker output or a rendering event, and passes the resulting WorkflowAction to block for asserting. If the workflow didn\u2019t process any actions, block will be passed WorkflowAction.noAction . This is useful if your actions are a sealed class or enum. If you need to test an anonymous action, use verifyActionResult .","title":"Verify action"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-render-test-result/verify-action/#verifyaction","text":"[jvm]\\ abstract fun verifyAction (block: ( WorkflowAction < PropsT , StateT , OutputT >) -> Unit ): RenderTestResult < PropsT , StateT , OutputT , RenderingT > Asserts that the render pass handled either a workflow/worker output or a rendering event, and passes the resulting WorkflowAction to block for asserting. If the workflow didn\u2019t process any actions, block will be passed WorkflowAction.noAction . This is useful if your actions are a sealed class or enum. If you need to test an anonymous action, use verifyActionResult .","title":"verifyAction"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-render-tester/","text":"// workflow / com.squareup.workflow1.testing / RenderTester RenderTester \u00b6 [jvm]\\ abstract class RenderTester < PropsT , StateT , OutputT , RenderingT > The props must be specified, the initial state may be specified, and then all child workflows and workers that are expected to run, and any outputs from them, must be specified with expectWorkflow and (optionally) expectWorker calls. If one needs to verify all workers explicitly, perhaps to verify that a worker is not run, then use requireExplicitWorkerExpectations . Then call render and perform any assertions on the rendering. An event may also be sent to the rendering if no workflows or workers emitted an output. Lastly, the RenderTestResult returned by render may be used to assert on the WorkflowAction s processed to handle events or outputs by calling verifyAction or verifyActionResult . All workflows that are rendered/ran by this workflow must be specified. Workers are optionally specified. Specified workers must run. Unexpected workers on a render pass do not cause a test failure. It is an error if more than one workflow or worker specifies an output. It is a test failure if any workflows or workers that were expected were not ran. It is a test failure if the workflow tried to run any workflows that were not expected. It is a test failure if no workflow or workflow emitted an output, no rendering event was invoked, and any of the action verification methods on [RenderTestResult](../-render-test-result/index.md) is called. Examples \u00b6 Worker output \u00b6 The following example tests a render pass that runs one worker, SubmitLoginWorker, which is configured to have \u201cemitted\u201d an output, and one workflow, ChildWorkflow, which expects a props containing \u201c test@foo.com \u201d and returning a ChildRendering as its rendering. It checks that the rendering properties are expected and that the output handler for the SubmitLoginWorker returned the CompleteLogin action. workflow\\ .testRender(\\ props = MyProps(\u2026),\\ initialState = MyState(\u2026)\\ )\\ .expectWorker(\\ workerClass = SubmitLoginWorker::class\\ key = \u201csignin\u201d,\\ output = WorkflowOutput(LoginResponse(success = true))\\ )\\ .expectWorkflow(\\ workflowType = ChildWorkflow::class,\\ key = \u201cchild\u201d,\\ assertProps = { assertThat(it.email).isEqualTo(\u201c test@foo.com \u201d) },\\ rendering = ChildRendering(\u201cmessage\u201d)\\ )\\ .render { rendering ->\\ assertThat(rendering.text).isEqualTo(\u201cfoo\u201d)\\ }\\ .verifyAction { action ->\\ assertThat(action).isEqualTo(Action.CompleteLogin(success = true))\\ } Rendering event \u00b6 This is similar to the example above, but will test an event sent to the rendering instead. workflow\\ .testRender(\\ props = MyProps(\u2026),\\ initialState = MyState(\u2026)\\ )\\ .expectWorker(\\ matchesWhen = { it is SubmitLoginWorker },\\ key = \u201csignin\u201d\\ )\\ .expectWorkflow(\\ workflowType = ChildWorkflow::class,\\ key = \u201cchild\u201d,\\ assertProps = { assertThat(it.email).isEqualTo(\u201c test@foo.com \u201d) },\\ rendering = ChildRendering(\u201cmessage\u201d)\\ )\\ .render { rendering ->\\ rendering.onCancelClicked()\\ assertThat(rendering.text).isEqualTo(\u201cfoo\u201d)\\ }\\ .verifyAction { action ->\\ assertThat(action).isEqualTo(Action.CancelLogin)\\ } Verify action result \u00b6 This test verifies the action result instead of the action itself. This technique is useful if the WorkflowAction is anonymous or inline. val currentState = \u2026\\ val previousState = \u2026\\ \\ workflow\\ .testRender(\\ props = MyProps(\u2026),\\ initialState = currentState\\ )\\ .render { rendering ->\\ rendering.onCancelClicked()\\ }\\ .verifyActionResult { newState, output ->\\ // Check that the workflow navigated back correctly.\\ assertThat(newState).isEqualTo(previousState)\\ \\ // Check that the workflow didn\u2019t emit any output from the button click.\\ assertThat(output).isNull()\\ } Too many outputs \u00b6 This is an example of what not to do \u2013 this test will error out because a worker is emitting and output and a rendering event is sent. workflow\\ .testRender(\\ props = MyProps(\u2026),\\ initialState = MyState(\u2026)\\ )\\ .expectWorker(\\ matchesWhen = { it is SubmitLoginWorker },\\ key = \u201csignin\u201d,\\ output = WorkflowOutput(LoginResponse(success = true))\\ )\\ .expectWorkflow(\\ workflowType = ChildWorkflow::class,\\ key = \u201cchild\u201d,\\ assertProps = { assertThat(it.email).isEqualTo(\u201c test@foo.com \u201d) },\\ rendering = ChildRendering(\u201cmessage\u201d)\\ )\\ .render { rendering ->\\ // This will throw and fail the test because the SubmitLoginWorker is also configured to emit\\ // an output.\\ rendering.onCancelClicked() Constructors \u00b6 RenderTester [jvm] fun RenderTester () Types \u00b6 Name Summary ChildWorkflowMatch [jvm] sealed class ChildWorkflowMatch RenderChildInvocation [jvm] class RenderChildInvocation (workflow: Workflow <*, *, *>, props: Any ?, outputType: KTypeProjection , renderingType: KTypeProjection , renderKey: String ) Describes a call to RenderContext.renderChild . Functions \u00b6 Name Summary expectSideEffect [jvm] abstract fun expectSideEffect (description: String , exactMatch: Boolean = true, matcher: (key: String ) -> Boolean ): RenderTester < PropsT , StateT , OutputT , RenderingT > Specifies that this render pass is expected to run a side effect with a key that satisfies matcher . This expectation is strict, and will fail if multiple side effects match. render [jvm] abstract fun render (block: ( RenderingT ) -> Unit = {}): RenderTestResult < PropsT , StateT , OutputT , RenderingT > Execute the workflow\u2019s render method and run block to perform assertions on and send events to the resulting rendering. requireExplicitSideEffectExpectations [jvm] abstract fun requireExplicitSideEffectExpectations (): RenderTester < PropsT , StateT , OutputT , RenderingT > requireExplicitWorkerExpectations [jvm] abstract fun requireExplicitWorkerExpectations (): RenderTester < PropsT , StateT , OutputT , RenderingT > Extensions \u00b6 Name Summary expectSideEffect [jvm] fun < PropsT , StateT , OutputT , RenderingT > RenderTester < PropsT , StateT , OutputT , RenderingT >. expectSideEffect (key: String ): RenderTester < PropsT , StateT , OutputT , RenderingT > Specifies that this render pass is expected to run a particular side effect. expectWorker [jvm] inline fun < PropsT , StateT , OutputT , RenderingT , WorkerOutputT , WorkerT : Worker < WorkerOutputT >> RenderTester < PropsT , StateT , OutputT , RenderingT >. expectWorker (expected: WorkerT , key: String = \u201c\u201d, output: WorkflowOutput < WorkerOutputT >? = null, description: String = \u201c\u201d): RenderTester < PropsT , StateT , OutputT , RenderingT > Specifies that this render pass is expected to run a Worker that has the same type of the given worker and for which the actual worker\u2019s doesSameWorkAs method returns true. If a worker is ran that matches the type of expected , but the actual worker\u2019s doesSameWorkAs returns false, then an AssertionError will be thrown. If you need to perform custom assertions, use the overload of this method that takes an assertWhen parameter. [jvm] inline fun < PropsT , StateT , OutputT , RenderingT , WorkerOutputT , WorkerT : Worker < WorkerOutputT >> RenderTester < PropsT , StateT , OutputT , RenderingT >. expectWorker (workerClass: KClass <out WorkerT >, key: String = \u201c\u201d, crossinline assertWorker: ( WorkerT ) -> Unit = {}, output: WorkflowOutput < WorkerOutputT >? = null, description: String = \u201c\u201d): RenderTester < PropsT , StateT , OutputT , RenderingT > Specifies that this render pass is expected to run a Worker with the given workerClass . The worker\u2019s output type is not taken into consideration. [jvm] fun < PropsT , StateT , OutputT , RenderingT > RenderTester < PropsT , StateT , OutputT , RenderingT >. expectWorker (workerType: KType , key: String = \u201c\u201d, assertWorker: ( Worker < >) -> Unit = {}, output: WorkflowOutput < >? = null, description: String = \u201c\u201d): RenderTester < PropsT , StateT , OutputT , RenderingT > Specifies that this render pass is expected to run a Worker whose KType matches workerType . expectWorkerOutputting [jvm] inline fun < PropsT , StateT , OutputT , RenderingT > RenderTester < PropsT , StateT , OutputT , RenderingT >. expectWorkerOutputting (outputType: KType , key: String = \u201c\u201d, crossinline assertWorker: ( Worker < >) -> Unit = {}, output: WorkflowOutput < >? = null, description: String = \u201c\u201d): RenderTester < PropsT , StateT , OutputT , RenderingT > Specifies that this render pass is expected to run a Worker with the given outputType . expectWorkflow [jvm] inline fun < ChildRenderingT , PropsT , StateT , OutputT , RenderingT > RenderTester < PropsT , StateT , OutputT , RenderingT >. expectWorkflow (identifier: WorkflowIdentifier , rendering: ChildRenderingT , key: String = \u201c\u201d, description: String = \u201c\u201d, noinline assertProps: (props: Any ?) -> Unit = {}): RenderTester < PropsT , StateT , OutputT , RenderingT > fun < ChildOutputT , ChildRenderingT , PropsT , StateT , OutputT , RenderingT > RenderTester < PropsT , StateT , OutputT , RenderingT >. expectWorkflow (identifier: WorkflowIdentifier , rendering: ChildRenderingT , output: WorkflowOutput < ChildOutputT >?, key: String = \u201c\u201d, description: String = \u201c\u201d, assertProps: (props: Any ?) -> Unit = {}): RenderTester < PropsT , StateT , OutputT , RenderingT > inline fun < ChildPropsT , ChildOutputT , ChildRenderingT , PropsT , StateT , OutputT , RenderingT > RenderTester < PropsT , StateT , OutputT , RenderingT >. expectWorkflow (workflowType: KClass <out Workflow < ChildPropsT , ChildOutputT , ChildRenderingT >>, rendering: ChildRenderingT , key: String = \u201c\u201d, crossinline assertProps: ( ChildPropsT ) -> Unit = {}, output: WorkflowOutput < ChildOutputT >? = null, description: String = \u201c\u201d): RenderTester < PropsT , StateT , OutputT , RenderingT > Specifies that this render pass is expected to render a particular child workflow.","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-render-tester/#rendertester","text":"[jvm]\\ abstract class RenderTester < PropsT , StateT , OutputT , RenderingT > The props must be specified, the initial state may be specified, and then all child workflows and workers that are expected to run, and any outputs from them, must be specified with expectWorkflow and (optionally) expectWorker calls. If one needs to verify all workers explicitly, perhaps to verify that a worker is not run, then use requireExplicitWorkerExpectations . Then call render and perform any assertions on the rendering. An event may also be sent to the rendering if no workflows or workers emitted an output. Lastly, the RenderTestResult returned by render may be used to assert on the WorkflowAction s processed to handle events or outputs by calling verifyAction or verifyActionResult . All workflows that are rendered/ran by this workflow must be specified. Workers are optionally specified. Specified workers must run. Unexpected workers on a render pass do not cause a test failure. It is an error if more than one workflow or worker specifies an output. It is a test failure if any workflows or workers that were expected were not ran. It is a test failure if the workflow tried to run any workflows that were not expected. It is a test failure if no workflow or workflow emitted an output, no rendering event was invoked, and any of the action verification methods on [RenderTestResult](../-render-test-result/index.md) is called.","title":"RenderTester"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-render-tester/#examples","text":"","title":"Examples"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-render-tester/#worker-output","text":"The following example tests a render pass that runs one worker, SubmitLoginWorker, which is configured to have \u201cemitted\u201d an output, and one workflow, ChildWorkflow, which expects a props containing \u201c test@foo.com \u201d and returning a ChildRendering as its rendering. It checks that the rendering properties are expected and that the output handler for the SubmitLoginWorker returned the CompleteLogin action. workflow\\ .testRender(\\ props = MyProps(\u2026),\\ initialState = MyState(\u2026)\\ )\\ .expectWorker(\\ workerClass = SubmitLoginWorker::class\\ key = \u201csignin\u201d,\\ output = WorkflowOutput(LoginResponse(success = true))\\ )\\ .expectWorkflow(\\ workflowType = ChildWorkflow::class,\\ key = \u201cchild\u201d,\\ assertProps = { assertThat(it.email).isEqualTo(\u201c test@foo.com \u201d) },\\ rendering = ChildRendering(\u201cmessage\u201d)\\ )\\ .render { rendering ->\\ assertThat(rendering.text).isEqualTo(\u201cfoo\u201d)\\ }\\ .verifyAction { action ->\\ assertThat(action).isEqualTo(Action.CompleteLogin(success = true))\\ }","title":"Worker output"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-render-tester/#rendering-event","text":"This is similar to the example above, but will test an event sent to the rendering instead. workflow\\ .testRender(\\ props = MyProps(\u2026),\\ initialState = MyState(\u2026)\\ )\\ .expectWorker(\\ matchesWhen = { it is SubmitLoginWorker },\\ key = \u201csignin\u201d\\ )\\ .expectWorkflow(\\ workflowType = ChildWorkflow::class,\\ key = \u201cchild\u201d,\\ assertProps = { assertThat(it.email).isEqualTo(\u201c test@foo.com \u201d) },\\ rendering = ChildRendering(\u201cmessage\u201d)\\ )\\ .render { rendering ->\\ rendering.onCancelClicked()\\ assertThat(rendering.text).isEqualTo(\u201cfoo\u201d)\\ }\\ .verifyAction { action ->\\ assertThat(action).isEqualTo(Action.CancelLogin)\\ }","title":"Rendering event"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-render-tester/#verify-action-result","text":"This test verifies the action result instead of the action itself. This technique is useful if the WorkflowAction is anonymous or inline. val currentState = \u2026\\ val previousState = \u2026\\ \\ workflow\\ .testRender(\\ props = MyProps(\u2026),\\ initialState = currentState\\ )\\ .render { rendering ->\\ rendering.onCancelClicked()\\ }\\ .verifyActionResult { newState, output ->\\ // Check that the workflow navigated back correctly.\\ assertThat(newState).isEqualTo(previousState)\\ \\ // Check that the workflow didn\u2019t emit any output from the button click.\\ assertThat(output).isNull()\\ }","title":"Verify action result"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-render-tester/#too-many-outputs","text":"This is an example of what not to do \u2013 this test will error out because a worker is emitting and output and a rendering event is sent. workflow\\ .testRender(\\ props = MyProps(\u2026),\\ initialState = MyState(\u2026)\\ )\\ .expectWorker(\\ matchesWhen = { it is SubmitLoginWorker },\\ key = \u201csignin\u201d,\\ output = WorkflowOutput(LoginResponse(success = true))\\ )\\ .expectWorkflow(\\ workflowType = ChildWorkflow::class,\\ key = \u201cchild\u201d,\\ assertProps = { assertThat(it.email).isEqualTo(\u201c test@foo.com \u201d) },\\ rendering = ChildRendering(\u201cmessage\u201d)\\ )\\ .render { rendering ->\\ // This will throw and fail the test because the SubmitLoginWorker is also configured to emit\\ // an output.\\ rendering.onCancelClicked()","title":"Too many outputs"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-render-tester/#constructors","text":"RenderTester [jvm] fun RenderTester ()","title":"Constructors"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-render-tester/#types","text":"Name Summary ChildWorkflowMatch [jvm] sealed class ChildWorkflowMatch RenderChildInvocation [jvm] class RenderChildInvocation (workflow: Workflow <*, *, *>, props: Any ?, outputType: KTypeProjection , renderingType: KTypeProjection , renderKey: String ) Describes a call to RenderContext.renderChild .","title":"Types"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-render-tester/#functions","text":"Name Summary expectSideEffect [jvm] abstract fun expectSideEffect (description: String , exactMatch: Boolean = true, matcher: (key: String ) -> Boolean ): RenderTester < PropsT , StateT , OutputT , RenderingT > Specifies that this render pass is expected to run a side effect with a key that satisfies matcher . This expectation is strict, and will fail if multiple side effects match. render [jvm] abstract fun render (block: ( RenderingT ) -> Unit = {}): RenderTestResult < PropsT , StateT , OutputT , RenderingT > Execute the workflow\u2019s render method and run block to perform assertions on and send events to the resulting rendering. requireExplicitSideEffectExpectations [jvm] abstract fun requireExplicitSideEffectExpectations (): RenderTester < PropsT , StateT , OutputT , RenderingT > requireExplicitWorkerExpectations [jvm] abstract fun requireExplicitWorkerExpectations (): RenderTester < PropsT , StateT , OutputT , RenderingT >","title":"Functions"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-render-tester/#extensions","text":"Name Summary expectSideEffect [jvm] fun < PropsT , StateT , OutputT , RenderingT > RenderTester < PropsT , StateT , OutputT , RenderingT >. expectSideEffect (key: String ): RenderTester < PropsT , StateT , OutputT , RenderingT > Specifies that this render pass is expected to run a particular side effect. expectWorker [jvm] inline fun < PropsT , StateT , OutputT , RenderingT , WorkerOutputT , WorkerT : Worker < WorkerOutputT >> RenderTester < PropsT , StateT , OutputT , RenderingT >. expectWorker (expected: WorkerT , key: String = \u201c\u201d, output: WorkflowOutput < WorkerOutputT >? = null, description: String = \u201c\u201d): RenderTester < PropsT , StateT , OutputT , RenderingT > Specifies that this render pass is expected to run a Worker that has the same type of the given worker and for which the actual worker\u2019s doesSameWorkAs method returns true. If a worker is ran that matches the type of expected , but the actual worker\u2019s doesSameWorkAs returns false, then an AssertionError will be thrown. If you need to perform custom assertions, use the overload of this method that takes an assertWhen parameter. [jvm] inline fun < PropsT , StateT , OutputT , RenderingT , WorkerOutputT , WorkerT : Worker < WorkerOutputT >> RenderTester < PropsT , StateT , OutputT , RenderingT >. expectWorker (workerClass: KClass <out WorkerT >, key: String = \u201c\u201d, crossinline assertWorker: ( WorkerT ) -> Unit = {}, output: WorkflowOutput < WorkerOutputT >? = null, description: String = \u201c\u201d): RenderTester < PropsT , StateT , OutputT , RenderingT > Specifies that this render pass is expected to run a Worker with the given workerClass . The worker\u2019s output type is not taken into consideration. [jvm] fun < PropsT , StateT , OutputT , RenderingT > RenderTester < PropsT , StateT , OutputT , RenderingT >. expectWorker (workerType: KType , key: String = \u201c\u201d, assertWorker: ( Worker < >) -> Unit = {}, output: WorkflowOutput < >? = null, description: String = \u201c\u201d): RenderTester < PropsT , StateT , OutputT , RenderingT > Specifies that this render pass is expected to run a Worker whose KType matches workerType . expectWorkerOutputting [jvm] inline fun < PropsT , StateT , OutputT , RenderingT > RenderTester < PropsT , StateT , OutputT , RenderingT >. expectWorkerOutputting (outputType: KType , key: String = \u201c\u201d, crossinline assertWorker: ( Worker < >) -> Unit = {}, output: WorkflowOutput < >? = null, description: String = \u201c\u201d): RenderTester < PropsT , StateT , OutputT , RenderingT > Specifies that this render pass is expected to run a Worker with the given outputType . expectWorkflow [jvm] inline fun < ChildRenderingT , PropsT , StateT , OutputT , RenderingT > RenderTester < PropsT , StateT , OutputT , RenderingT >. expectWorkflow (identifier: WorkflowIdentifier , rendering: ChildRenderingT , key: String = \u201c\u201d, description: String = \u201c\u201d, noinline assertProps: (props: Any ?) -> Unit = {}): RenderTester < PropsT , StateT , OutputT , RenderingT > fun < ChildOutputT , ChildRenderingT , PropsT , StateT , OutputT , RenderingT > RenderTester < PropsT , StateT , OutputT , RenderingT >. expectWorkflow (identifier: WorkflowIdentifier , rendering: ChildRenderingT , output: WorkflowOutput < ChildOutputT >?, key: String = \u201c\u201d, description: String = \u201c\u201d, assertProps: (props: Any ?) -> Unit = {}): RenderTester < PropsT , StateT , OutputT , RenderingT > inline fun < ChildPropsT , ChildOutputT , ChildRenderingT , PropsT , StateT , OutputT , RenderingT > RenderTester < PropsT , StateT , OutputT , RenderingT >. expectWorkflow (workflowType: KClass <out Workflow < ChildPropsT , ChildOutputT , ChildRenderingT >>, rendering: ChildRenderingT , key: String = \u201c\u201d, crossinline assertProps: ( ChildPropsT ) -> Unit = {}, output: WorkflowOutput < ChildOutputT >? = null, description: String = \u201c\u201d): RenderTester < PropsT , StateT , OutputT , RenderingT > Specifies that this render pass is expected to render a particular child workflow.","title":"Extensions"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-render-tester/-render-tester/","text":"// workflow / com.squareup.workflow1.testing / RenderTester / RenderTester RenderTester \u00b6 [jvm]\\ fun RenderTester ()","title":" render tester"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-render-tester/-render-tester/#rendertester","text":"[jvm]\\ fun RenderTester ()","title":"RenderTester"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-render-tester/expect-side-effect/","text":"// workflow / com.squareup.workflow1.testing / RenderTester / expectSideEffect expectSideEffect \u00b6 [jvm]\\ abstract fun expectSideEffect (description: String , exactMatch: Boolean = true, matcher: (key: String ) -> Boolean ): RenderTester < PropsT , StateT , OutputT , RenderingT > Specifies that this render pass is expected to run a side effect with a key that satisfies matcher . This expectation is strict, and will fail if multiple side effects match. Parameters \u00b6 jvm description String that will be used to describe this expectation in error messages. The description is required since no human-readable description can be derived from the predicate alone. exactMatch If true, then the test will fail if any other matching expectations are also exact matches, and the expectation will only be allowed to match a single side effect. If false, the match will only be used if no other expectations return exclusive matches (in which case the first match will be used), and the expectation may match multiple side effects. matcher A function that is passed the key value from runningSideEffect and return true if this key is expected.","title":"Expect side effect"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-render-tester/expect-side-effect/#expectsideeffect","text":"[jvm]\\ abstract fun expectSideEffect (description: String , exactMatch: Boolean = true, matcher: (key: String ) -> Boolean ): RenderTester < PropsT , StateT , OutputT , RenderingT > Specifies that this render pass is expected to run a side effect with a key that satisfies matcher . This expectation is strict, and will fail if multiple side effects match.","title":"expectSideEffect"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-render-tester/expect-side-effect/#parameters","text":"jvm description String that will be used to describe this expectation in error messages. The description is required since no human-readable description can be derived from the predicate alone. exactMatch If true, then the test will fail if any other matching expectations are also exact matches, and the expectation will only be allowed to match a single side effect. If false, the match will only be used if no other expectations return exclusive matches (in which case the first match will be used), and the expectation may match multiple side effects. matcher A function that is passed the key value from runningSideEffect and return true if this key is expected.","title":"Parameters"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-render-tester/render/","text":"// workflow / com.squareup.workflow1.testing / RenderTester / render render \u00b6 [jvm]\\ abstract fun render (block: ( RenderingT ) -> Unit = {}): RenderTestResult < PropsT , StateT , OutputT , RenderingT > Execute the workflow\u2019s render method and run block to perform assertions on and send events to the resulting rendering. All workflows rendered/ran by the workflow must be specified before calling this method. Workers are optionally specified. Return \u00b6 A RenderTestResult that can be used to verify the WorkflowAction that was used to handle a workflow or worker output or a rendering event. Parameters \u00b6 jvm block Passed the result of the render pass to perform assertions on. If no child workflow or worker was configured to emit an output, may also invoke one of the rendering\u2019s event handlers. It is an error to invoke an event handler if a child emitted an output.","title":"Render"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-render-tester/render/#render","text":"[jvm]\\ abstract fun render (block: ( RenderingT ) -> Unit = {}): RenderTestResult < PropsT , StateT , OutputT , RenderingT > Execute the workflow\u2019s render method and run block to perform assertions on and send events to the resulting rendering. All workflows rendered/ran by the workflow must be specified before calling this method. Workers are optionally specified.","title":"render"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-render-tester/render/#return","text":"A RenderTestResult that can be used to verify the WorkflowAction that was used to handle a workflow or worker output or a rendering event.","title":"Return"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-render-tester/render/#parameters","text":"jvm block Passed the result of the render pass to perform assertions on. If no child workflow or worker was configured to emit an output, may also invoke one of the rendering\u2019s event handlers. It is an error to invoke an event handler if a child emitted an output.","title":"Parameters"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-render-tester/require-explicit-side-effect-expectations/","text":"// workflow / com.squareup.workflow1.testing / RenderTester / requireExplicitSideEffectExpectations requireExplicitSideEffectExpectations \u00b6 [jvm]\\ abstract fun requireExplicitSideEffectExpectations (): RenderTester < PropsT , StateT , OutputT , RenderingT >","title":"Require explicit side effect expectations"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-render-tester/require-explicit-side-effect-expectations/#requireexplicitsideeffectexpectations","text":"[jvm]\\ abstract fun requireExplicitSideEffectExpectations (): RenderTester < PropsT , StateT , OutputT , RenderingT >","title":"requireExplicitSideEffectExpectations"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-render-tester/require-explicit-worker-expectations/","text":"// workflow / com.squareup.workflow1.testing / RenderTester / requireExplicitWorkerExpectations requireExplicitWorkerExpectations \u00b6 [jvm]\\ abstract fun requireExplicitWorkerExpectations (): RenderTester < PropsT , StateT , OutputT , RenderingT >","title":"Require explicit worker expectations"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-render-tester/require-explicit-worker-expectations/#requireexplicitworkerexpectations","text":"[jvm]\\ abstract fun requireExplicitWorkerExpectations (): RenderTester < PropsT , StateT , OutputT , RenderingT >","title":"requireExplicitWorkerExpectations"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-render-tester/-child-workflow-match/","text":"// workflow / com.squareup.workflow1.testing / RenderTester / ChildWorkflowMatch ChildWorkflowMatch \u00b6 [jvm]\\ sealed class ChildWorkflowMatch Types \u00b6 Name Summary Matched [jvm] class Matched (childRendering: Any ?, output: WorkflowOutput < Any ?>?) : RenderTester.ChildWorkflowMatch Indicates that the workflow matches the predicate. NotMatched [jvm] object NotMatched : RenderTester.ChildWorkflowMatch Indicates that the child workflow did not match the predicate and must match a different expectation. The test will fail if all expectations return this value. Inheritors \u00b6 Name RenderTester.ChildWorkflowMatch RenderTester.ChildWorkflowMatch","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-render-tester/-child-workflow-match/#childworkflowmatch","text":"[jvm]\\ sealed class ChildWorkflowMatch","title":"ChildWorkflowMatch"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-render-tester/-child-workflow-match/#types","text":"Name Summary Matched [jvm] class Matched (childRendering: Any ?, output: WorkflowOutput < Any ?>?) : RenderTester.ChildWorkflowMatch Indicates that the workflow matches the predicate. NotMatched [jvm] object NotMatched : RenderTester.ChildWorkflowMatch Indicates that the child workflow did not match the predicate and must match a different expectation. The test will fail if all expectations return this value.","title":"Types"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-render-tester/-child-workflow-match/#inheritors","text":"Name RenderTester.ChildWorkflowMatch RenderTester.ChildWorkflowMatch","title":"Inheritors"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-render-tester/-child-workflow-match/-matched/","text":"// workflow / com.squareup.workflow1.testing / RenderTester / ChildWorkflowMatch / Matched Matched \u00b6 [jvm]\\ class Matched (childRendering: Any ?, output: WorkflowOutput < Any ?>?) : RenderTester.ChildWorkflowMatch Indicates that the workflow matches the predicate. Parameters \u00b6 jvm childRendering The value to return as the child\u2019s rendering. output If non-null, WorkflowOutput.value will be \u201cemitted\u201d when this workflow is rendered. The WorkflowAction used to handle this output can be verified using methods on RenderTestResult . Constructors \u00b6 Matched [jvm] fun Matched (childRendering: Any ?, output: WorkflowOutput < Any ?>? = null) Properties \u00b6 Name Summary childRendering [jvm] val childRendering : Any ? output [jvm] val output : WorkflowOutput < Any ?>? = null","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-render-tester/-child-workflow-match/-matched/#matched","text":"[jvm]\\ class Matched (childRendering: Any ?, output: WorkflowOutput < Any ?>?) : RenderTester.ChildWorkflowMatch Indicates that the workflow matches the predicate.","title":"Matched"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-render-tester/-child-workflow-match/-matched/#parameters","text":"jvm childRendering The value to return as the child\u2019s rendering. output If non-null, WorkflowOutput.value will be \u201cemitted\u201d when this workflow is rendered. The WorkflowAction used to handle this output can be verified using methods on RenderTestResult .","title":"Parameters"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-render-tester/-child-workflow-match/-matched/#constructors","text":"Matched [jvm] fun Matched (childRendering: Any ?, output: WorkflowOutput < Any ?>? = null)","title":"Constructors"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-render-tester/-child-workflow-match/-matched/#properties","text":"Name Summary childRendering [jvm] val childRendering : Any ? output [jvm] val output : WorkflowOutput < Any ?>? = null","title":"Properties"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-render-tester/-child-workflow-match/-matched/-matched/","text":"// workflow / com.squareup.workflow1.testing / RenderTester / ChildWorkflowMatch / Matched / Matched Matched \u00b6 [jvm]\\ fun Matched (childRendering: Any ?, output: WorkflowOutput < Any ?>? = null) Parameters \u00b6 jvm childRendering The value to return as the child\u2019s rendering. output If non-null, WorkflowOutput.value will be \u201cemitted\u201d when this workflow is rendered. The WorkflowAction used to handle this output can be verified using methods on RenderTestResult .","title":" matched"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-render-tester/-child-workflow-match/-matched/-matched/#matched","text":"[jvm]\\ fun Matched (childRendering: Any ?, output: WorkflowOutput < Any ?>? = null)","title":"Matched"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-render-tester/-child-workflow-match/-matched/-matched/#parameters","text":"jvm childRendering The value to return as the child\u2019s rendering. output If non-null, WorkflowOutput.value will be \u201cemitted\u201d when this workflow is rendered. The WorkflowAction used to handle this output can be verified using methods on RenderTestResult .","title":"Parameters"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-render-tester/-child-workflow-match/-matched/child-rendering/","text":"// workflow / com.squareup.workflow1.testing / RenderTester / ChildWorkflowMatch / Matched / childRendering childRendering \u00b6 [jvm]\\ val childRendering : Any ?","title":"Child rendering"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-render-tester/-child-workflow-match/-matched/child-rendering/#childrendering","text":"[jvm]\\ val childRendering : Any ?","title":"childRendering"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-render-tester/-child-workflow-match/-matched/output/","text":"// workflow / com.squareup.workflow1.testing / RenderTester / ChildWorkflowMatch / Matched / output output \u00b6 [jvm]\\ val output : WorkflowOutput < Any ?>? = null","title":"Output"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-render-tester/-child-workflow-match/-matched/output/#output","text":"[jvm]\\ val output : WorkflowOutput < Any ?>? = null","title":"output"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-render-tester/-child-workflow-match/-not-matched/","text":"// workflow / com.squareup.workflow1.testing / RenderTester / ChildWorkflowMatch / NotMatched NotMatched \u00b6 [jvm]\\ object NotMatched : RenderTester.ChildWorkflowMatch Indicates that the child workflow did not match the predicate and must match a different expectation. The test will fail if all expectations return this value.","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-render-tester/-child-workflow-match/-not-matched/#notmatched","text":"[jvm]\\ object NotMatched : RenderTester.ChildWorkflowMatch Indicates that the child workflow did not match the predicate and must match a different expectation. The test will fail if all expectations return this value.","title":"NotMatched"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-render-tester/-render-child-invocation/","text":"// workflow / com.squareup.workflow1.testing / RenderTester / RenderChildInvocation RenderChildInvocation \u00b6 [jvm]\\ class RenderChildInvocation (workflow: Workflow <*, *, *>, props: Any ?, outputType: KTypeProjection , renderingType: KTypeProjection , renderKey: String ) Describes a call to RenderContext.renderChild . Output and rendering types \u00b6 The testing library will attempt to determine the output and rendering types by using reflection to determine the type arguments that the concrete workflow class passes to the Workflow interface. This is subject to the limitations of Kotlin\u2019s reflection. Notably, there is a compiler bug ( KT-17103 ) that prevents reflecting on these types when the workflow is an anonymous class that was created by an inline function with reified types, such as Workflow.stateful and Workflow.stateless. Parameters \u00b6 jvm workflow The child workflow that is being rendered. props The props value passed to renderChild. outputType The KType of the workflow\u2019s OutputT. renderingType The KType of the workflow\u2019s RenderingT. renderKey The string key passed to renderChild. Constructors \u00b6 RenderChildInvocation [jvm] fun RenderChildInvocation (workflow: Workflow <*, *, *>, props: Any ?, outputType: KTypeProjection , renderingType: KTypeProjection , renderKey: String ) Properties \u00b6 Name Summary outputType [jvm] val outputType : KTypeProjection props [jvm] val props : Any ? renderingType [jvm] val renderingType : KTypeProjection renderKey [jvm] val renderKey : String workflow [jvm] val workflow : Workflow <*, *, *>","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-render-tester/-render-child-invocation/#renderchildinvocation","text":"[jvm]\\ class RenderChildInvocation (workflow: Workflow <*, *, *>, props: Any ?, outputType: KTypeProjection , renderingType: KTypeProjection , renderKey: String ) Describes a call to RenderContext.renderChild .","title":"RenderChildInvocation"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-render-tester/-render-child-invocation/#output-and-rendering-types","text":"The testing library will attempt to determine the output and rendering types by using reflection to determine the type arguments that the concrete workflow class passes to the Workflow interface. This is subject to the limitations of Kotlin\u2019s reflection. Notably, there is a compiler bug ( KT-17103 ) that prevents reflecting on these types when the workflow is an anonymous class that was created by an inline function with reified types, such as Workflow.stateful and Workflow.stateless.","title":"Output and rendering types"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-render-tester/-render-child-invocation/#parameters","text":"jvm workflow The child workflow that is being rendered. props The props value passed to renderChild. outputType The KType of the workflow\u2019s OutputT. renderingType The KType of the workflow\u2019s RenderingT. renderKey The string key passed to renderChild.","title":"Parameters"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-render-tester/-render-child-invocation/#constructors","text":"RenderChildInvocation [jvm] fun RenderChildInvocation (workflow: Workflow <*, *, *>, props: Any ?, outputType: KTypeProjection , renderingType: KTypeProjection , renderKey: String )","title":"Constructors"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-render-tester/-render-child-invocation/#properties","text":"Name Summary outputType [jvm] val outputType : KTypeProjection props [jvm] val props : Any ? renderingType [jvm] val renderingType : KTypeProjection renderKey [jvm] val renderKey : String workflow [jvm] val workflow : Workflow <*, *, *>","title":"Properties"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-render-tester/-render-child-invocation/-render-child-invocation/","text":"// workflow / com.squareup.workflow1.testing / RenderTester / RenderChildInvocation / RenderChildInvocation RenderChildInvocation \u00b6 [jvm]\\ fun RenderChildInvocation (workflow: Workflow <*, *, *>, props: Any ?, outputType: KTypeProjection , renderingType: KTypeProjection , renderKey: String ) Parameters \u00b6 jvm workflow The child workflow that is being rendered. props The props value passed to renderChild. outputType The KType of the workflow\u2019s OutputT. renderingType The KType of the workflow\u2019s RenderingT. renderKey The string key passed to renderChild.","title":" render child invocation"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-render-tester/-render-child-invocation/-render-child-invocation/#renderchildinvocation","text":"[jvm]\\ fun RenderChildInvocation (workflow: Workflow <*, *, *>, props: Any ?, outputType: KTypeProjection , renderingType: KTypeProjection , renderKey: String )","title":"RenderChildInvocation"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-render-tester/-render-child-invocation/-render-child-invocation/#parameters","text":"jvm workflow The child workflow that is being rendered. props The props value passed to renderChild. outputType The KType of the workflow\u2019s OutputT. renderingType The KType of the workflow\u2019s RenderingT. renderKey The string key passed to renderChild.","title":"Parameters"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-render-tester/-render-child-invocation/output-type/","text":"// workflow / com.squareup.workflow1.testing / RenderTester / RenderChildInvocation / outputType outputType \u00b6 [jvm]\\ val outputType : KTypeProjection","title":"Output type"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-render-tester/-render-child-invocation/output-type/#outputtype","text":"[jvm]\\ val outputType : KTypeProjection","title":"outputType"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-render-tester/-render-child-invocation/props/","text":"// workflow / com.squareup.workflow1.testing / RenderTester / RenderChildInvocation / props props \u00b6 [jvm]\\ val props : Any ?","title":"Props"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-render-tester/-render-child-invocation/props/#props","text":"[jvm]\\ val props : Any ?","title":"props"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-render-tester/-render-child-invocation/render-key/","text":"// workflow / com.squareup.workflow1.testing / RenderTester / RenderChildInvocation / renderKey renderKey \u00b6 [jvm]\\ val renderKey : String","title":"Render key"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-render-tester/-render-child-invocation/render-key/#renderkey","text":"[jvm]\\ val renderKey : String","title":"renderKey"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-render-tester/-render-child-invocation/rendering-type/","text":"// workflow / com.squareup.workflow1.testing / RenderTester / RenderChildInvocation / renderingType renderingType \u00b6 [jvm]\\ val renderingType : KTypeProjection","title":"Rendering type"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-render-tester/-render-child-invocation/rendering-type/#renderingtype","text":"[jvm]\\ val renderingType : KTypeProjection","title":"renderingType"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-render-tester/-render-child-invocation/workflow/","text":"// workflow / com.squareup.workflow1.testing / RenderTester / RenderChildInvocation / workflow workflow \u00b6 [jvm]\\ val workflow : Workflow <*, *, *>","title":"Workflow"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-render-tester/-render-child-invocation/workflow/#workflow","text":"[jvm]\\ val workflow : Workflow <*, *, *>","title":"workflow"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-worker-sink/","text":"// workflow / com.squareup.workflow1.testing / WorkerSink WorkerSink \u00b6 [jvm]\\ class WorkerSink < T >(name: String , type: KClass <*>) : Worker < T > Implementation of Worker for integration tests (using launchForTestingFromStartWith or launchForTestingFromStateWith ) that need to simply push values into the worker from the test. Instances of this class are considered equivalent if they have matching type and name. These workers can not be run concurrently \u2013 they may only be run by a single workflow at a time, although they may be run multiple times sequentially. The Flow returned by run will throw an exception if it is collected more than once concurrently. Parameters \u00b6 jvm name String used to distinguish this worker from other WorkerSink s being ran by the same workflow. Used to implement doesSameWorkAs , see the kdoc on that method for more information. Constructors \u00b6 WorkerSink [jvm] fun WorkerSink (name: String , type: KClass <*>) Functions \u00b6 Name Summary doesSameWorkAs [jvm] open override fun doesSameWorkAs (otherWorker: Worker <*>): Boolean run [jvm] open override fun run (): Flow< T > send [jvm] fun send (value: T ) toString [jvm] open override fun toString (): String","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-worker-sink/#workersink","text":"[jvm]\\ class WorkerSink < T >(name: String , type: KClass <*>) : Worker < T > Implementation of Worker for integration tests (using launchForTestingFromStartWith or launchForTestingFromStateWith ) that need to simply push values into the worker from the test. Instances of this class are considered equivalent if they have matching type and name. These workers can not be run concurrently \u2013 they may only be run by a single workflow at a time, although they may be run multiple times sequentially. The Flow returned by run will throw an exception if it is collected more than once concurrently.","title":"WorkerSink"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-worker-sink/#parameters","text":"jvm name String used to distinguish this worker from other WorkerSink s being ran by the same workflow. Used to implement doesSameWorkAs , see the kdoc on that method for more information.","title":"Parameters"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-worker-sink/#constructors","text":"WorkerSink [jvm] fun WorkerSink (name: String , type: KClass <*>)","title":"Constructors"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-worker-sink/#functions","text":"Name Summary doesSameWorkAs [jvm] open override fun doesSameWorkAs (otherWorker: Worker <*>): Boolean run [jvm] open override fun run (): Flow< T > send [jvm] fun send (value: T ) toString [jvm] open override fun toString (): String","title":"Functions"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-worker-sink/-worker-sink/","text":"// workflow / com.squareup.workflow1.testing / WorkerSink / WorkerSink WorkerSink \u00b6 [jvm]\\ fun WorkerSink (name: String , type: KClass <*>) Parameters \u00b6 jvm name String used to distinguish this worker from other WorkerSink s being ran by the same workflow. Used to implement doesSameWorkAs , see the kdoc on that method for more information.","title":" worker sink"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-worker-sink/-worker-sink/#workersink","text":"[jvm]\\ fun WorkerSink (name: String , type: KClass <*>)","title":"WorkerSink"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-worker-sink/-worker-sink/#parameters","text":"jvm name String used to distinguish this worker from other WorkerSink s being ran by the same workflow. Used to implement doesSameWorkAs , see the kdoc on that method for more information.","title":"Parameters"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-worker-sink/does-same-work-as/","text":"// workflow / com.squareup.workflow1.testing / WorkerSink / doesSameWorkAs doesSameWorkAs \u00b6 [jvm]\\ open override fun doesSameWorkAs (otherWorker: Worker <*>): Boolean","title":"Does same work as"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-worker-sink/does-same-work-as/#doessameworkas","text":"[jvm]\\ open override fun doesSameWorkAs (otherWorker: Worker <*>): Boolean","title":"doesSameWorkAs"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-worker-sink/run/","text":"// workflow / com.squareup.workflow1.testing / WorkerSink / run run \u00b6 [jvm]\\ open override fun run (): Flow< T >","title":"Run"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-worker-sink/run/#run","text":"[jvm]\\ open override fun run (): Flow< T >","title":"run"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-worker-sink/send/","text":"// workflow / com.squareup.workflow1.testing / WorkerSink / send send \u00b6 [jvm]\\ fun send (value: T )","title":"Send"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-worker-sink/send/#send","text":"[jvm]\\ fun send (value: T )","title":"send"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-worker-sink/to-string/","text":"// workflow / com.squareup.workflow1.testing / WorkerSink / toString toString \u00b6 [jvm]\\ open override fun toString (): String","title":"To string"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-worker-sink/to-string/#tostring","text":"[jvm]\\ open override fun toString (): String","title":"toString"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-worker-tester/","text":"// workflow / com.squareup.workflow1.testing / WorkerTester WorkerTester \u00b6 [jvm]\\ interface WorkerTester < T > Functions \u00b6 Name Summary assertFinished [jvm] abstract suspend fun assertFinished () Suspends until the worker emits an output or finishes. assertNoOutput [jvm] abstract fun assertNoOutput () Throws an AssertionError if an output has been emitted since the last call to nextOutput . assertNotFinished [jvm] abstract fun assertNotFinished () Throws an AssertionError immediately if the worker is finished. cancelWorker [jvm] abstract suspend fun cancelWorker () Cancels the worker and suspends until it\u2019s finished cancelling (joined). getException [jvm] abstract suspend fun getException (): Throwable Suspends until the worker throws an exception, then returns it. nextOutput [jvm] abstract suspend fun nextOutput (): T Suspends until the worker emits its next value, then returns it.","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-worker-tester/#workertester","text":"[jvm]\\ interface WorkerTester < T >","title":"WorkerTester"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-worker-tester/#functions","text":"Name Summary assertFinished [jvm] abstract suspend fun assertFinished () Suspends until the worker emits an output or finishes. assertNoOutput [jvm] abstract fun assertNoOutput () Throws an AssertionError if an output has been emitted since the last call to nextOutput . assertNotFinished [jvm] abstract fun assertNotFinished () Throws an AssertionError immediately if the worker is finished. cancelWorker [jvm] abstract suspend fun cancelWorker () Cancels the worker and suspends until it\u2019s finished cancelling (joined). getException [jvm] abstract suspend fun getException (): Throwable Suspends until the worker throws an exception, then returns it. nextOutput [jvm] abstract suspend fun nextOutput (): T Suspends until the worker emits its next value, then returns it.","title":"Functions"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-worker-tester/assert-finished/","text":"// workflow / com.squareup.workflow1.testing / WorkerTester / assertFinished assertFinished \u00b6 [jvm]\\ abstract suspend fun assertFinished () Suspends until the worker emits an output or finishes. Throws an AssertionError if an output was emitted.","title":"Assert finished"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-worker-tester/assert-finished/#assertfinished","text":"[jvm]\\ abstract suspend fun assertFinished () Suspends until the worker emits an output or finishes. Throws an AssertionError if an output was emitted.","title":"assertFinished"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-worker-tester/assert-no-output/","text":"// workflow / com.squareup.workflow1.testing / WorkerTester / assertNoOutput assertNoOutput \u00b6 [jvm]\\ abstract fun assertNoOutput () Throws an AssertionError if an output has been emitted since the last call to nextOutput .","title":"Assert no output"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-worker-tester/assert-no-output/#assertnooutput","text":"[jvm]\\ abstract fun assertNoOutput () Throws an AssertionError if an output has been emitted since the last call to nextOutput .","title":"assertNoOutput"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-worker-tester/assert-not-finished/","text":"// workflow / com.squareup.workflow1.testing / WorkerTester / assertNotFinished assertNotFinished \u00b6 [jvm]\\ abstract fun assertNotFinished () Throws an AssertionError immediately if the worker is finished.","title":"Assert not finished"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-worker-tester/assert-not-finished/#assertnotfinished","text":"[jvm]\\ abstract fun assertNotFinished () Throws an AssertionError immediately if the worker is finished.","title":"assertNotFinished"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-worker-tester/cancel-worker/","text":"// workflow / com.squareup.workflow1.testing / WorkerTester / cancelWorker cancelWorker \u00b6 [jvm]\\ abstract suspend fun cancelWorker () Cancels the worker and suspends until it\u2019s finished cancelling (joined).","title":"Cancel worker"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-worker-tester/cancel-worker/#cancelworker","text":"[jvm]\\ abstract suspend fun cancelWorker () Cancels the worker and suspends until it\u2019s finished cancelling (joined).","title":"cancelWorker"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-worker-tester/get-exception/","text":"// workflow / com.squareup.workflow1.testing / WorkerTester / getException getException \u00b6 [jvm]\\ abstract suspend fun getException (): Throwable Suspends until the worker throws an exception, then returns it.","title":"Get exception"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-worker-tester/get-exception/#getexception","text":"[jvm]\\ abstract suspend fun getException (): Throwable Suspends until the worker throws an exception, then returns it.","title":"getException"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-worker-tester/next-output/","text":"// workflow / com.squareup.workflow1.testing / WorkerTester / nextOutput nextOutput \u00b6 [jvm]\\ abstract suspend fun nextOutput (): T Suspends until the worker emits its next value, then returns it.","title":"Next output"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-worker-tester/next-output/#nextoutput","text":"[jvm]\\ abstract suspend fun nextOutput (): T Suspends until the worker emits its next value, then returns it.","title":"nextOutput"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-workflow-test-params/","text":"// workflow / com.squareup.workflow1.testing / WorkflowTestParams WorkflowTestParams \u00b6 [jvm]\\ @TestOnly class WorkflowTestParams <out StateT >(startFrom: WorkflowTestParams.StartMode < StateT >, checkRenderIdempotence: Boolean ) Defines configuration for workflow testing infrastructure such as testRender, testFromStart. and test. Parameters \u00b6 jvm startFrom How to start the workflow \u2013 see StartMode . checkRenderIdempotence If true, every render method will be called multiple times, to help suss out any side effects that a render method is trying to perform. This parameter defaults to true since the workflow contract is that render will be called an arbitrary number of times for any given state, so performing side effects in render will almost always result in bugs. It is recommended to leave this on, but if you need to debug a test and don\u2019t want to have to deal with the extra passes, you can temporarily set it to false. Constructors \u00b6 WorkflowTestParams [jvm] fun <out StateT > WorkflowTestParams (startFrom: WorkflowTestParams.StartMode < StateT > = StartFresh, checkRenderIdempotence: Boolean = true) Types \u00b6 Name Summary StartMode [jvm] sealed class StartMode <out StateT > Defines how to start the workflow for tests. Properties \u00b6 Name Summary checkRenderIdempotence [jvm] val checkRenderIdempotence : Boolean = true startFrom [jvm] val startFrom : WorkflowTestParams.StartMode < StateT >","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-workflow-test-params/#workflowtestparams","text":"[jvm]\\ @TestOnly class WorkflowTestParams <out StateT >(startFrom: WorkflowTestParams.StartMode < StateT >, checkRenderIdempotence: Boolean ) Defines configuration for workflow testing infrastructure such as testRender, testFromStart. and test.","title":"WorkflowTestParams"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-workflow-test-params/#parameters","text":"jvm startFrom How to start the workflow \u2013 see StartMode . checkRenderIdempotence If true, every render method will be called multiple times, to help suss out any side effects that a render method is trying to perform. This parameter defaults to true since the workflow contract is that render will be called an arbitrary number of times for any given state, so performing side effects in render will almost always result in bugs. It is recommended to leave this on, but if you need to debug a test and don\u2019t want to have to deal with the extra passes, you can temporarily set it to false.","title":"Parameters"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-workflow-test-params/#constructors","text":"WorkflowTestParams [jvm] fun <out StateT > WorkflowTestParams (startFrom: WorkflowTestParams.StartMode < StateT > = StartFresh, checkRenderIdempotence: Boolean = true)","title":"Constructors"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-workflow-test-params/#types","text":"Name Summary StartMode [jvm] sealed class StartMode <out StateT > Defines how to start the workflow for tests.","title":"Types"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-workflow-test-params/#properties","text":"Name Summary checkRenderIdempotence [jvm] val checkRenderIdempotence : Boolean = true startFrom [jvm] val startFrom : WorkflowTestParams.StartMode < StateT >","title":"Properties"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-workflow-test-params/-workflow-test-params/","text":"// workflow / com.squareup.workflow1.testing / WorkflowTestParams / WorkflowTestParams WorkflowTestParams \u00b6 [jvm]\\ fun <out StateT > WorkflowTestParams (startFrom: WorkflowTestParams.StartMode < StateT > = StartFresh, checkRenderIdempotence: Boolean = true) Parameters \u00b6 jvm startFrom How to start the workflow \u2013 see StartMode . checkRenderIdempotence If true, every render method will be called multiple times, to help suss out any side effects that a render method is trying to perform. This parameter defaults to true since the workflow contract is that render will be called an arbitrary number of times for any given state, so performing side effects in render will almost always result in bugs. It is recommended to leave this on, but if you need to debug a test and don\u2019t want to have to deal with the extra passes, you can temporarily set it to false.","title":" workflow test params"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-workflow-test-params/-workflow-test-params/#workflowtestparams","text":"[jvm]\\ fun <out StateT > WorkflowTestParams (startFrom: WorkflowTestParams.StartMode < StateT > = StartFresh, checkRenderIdempotence: Boolean = true)","title":"WorkflowTestParams"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-workflow-test-params/-workflow-test-params/#parameters","text":"jvm startFrom How to start the workflow \u2013 see StartMode . checkRenderIdempotence If true, every render method will be called multiple times, to help suss out any side effects that a render method is trying to perform. This parameter defaults to true since the workflow contract is that render will be called an arbitrary number of times for any given state, so performing side effects in render will almost always result in bugs. It is recommended to leave this on, but if you need to debug a test and don\u2019t want to have to deal with the extra passes, you can temporarily set it to false.","title":"Parameters"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-workflow-test-params/check-render-idempotence/","text":"// workflow / com.squareup.workflow1.testing / WorkflowTestParams / checkRenderIdempotence checkRenderIdempotence \u00b6 [jvm]\\ val checkRenderIdempotence : Boolean = true","title":"Check render idempotence"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-workflow-test-params/check-render-idempotence/#checkrenderidempotence","text":"[jvm]\\ val checkRenderIdempotence : Boolean = true","title":"checkRenderIdempotence"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-workflow-test-params/start-from/","text":"// workflow / com.squareup.workflow1.testing / WorkflowTestParams / startFrom startFrom \u00b6 [jvm]\\ val startFrom : WorkflowTestParams.StartMode < StateT >","title":"Start from"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-workflow-test-params/start-from/#startfrom","text":"[jvm]\\ val startFrom : WorkflowTestParams.StartMode < StateT >","title":"startFrom"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-workflow-test-params/-start-mode/","text":"// workflow / com.squareup.workflow1.testing / WorkflowTestParams / StartMode StartMode \u00b6 [jvm]\\ sealed class StartMode <out StateT > Defines how to start the workflow for tests. See the documentation on individual cases for more information: [StartFresh](-start-fresh/index.md) [StartFromWorkflowSnapshot](-start-from-workflow-snapshot/index.md) [StartFromCompleteSnapshot](-start-from-complete-snapshot/index.md) [StartFromState](-start-from-state/index.md) Types \u00b6 Name Summary StartFresh [jvm] object StartFresh : WorkflowTestParams.StartMode < Nothing > Starts the workflow from its initial state (as specified by initial state ), with a null snapshot. StartFromCompleteSnapshot [jvm] class StartFromCompleteSnapshot (snapshot: TreeSnapshot ) : WorkflowTestParams.StartMode < Nothing > Starts the workflow from its initial state (as specified by initial state ), with a non-null snapshot. Only applies to StatefulWorkflow s. StartFromState [jvm] class StartFromState < StateT >(state: StateT ) : WorkflowTestParams.StartMode < StateT > Starts the workflow from an exact state. Only applies to StatefulWorkflow s. StartFromWorkflowSnapshot [jvm] class StartFromWorkflowSnapshot (snapshot: Snapshot ) : WorkflowTestParams.StartMode < Nothing > Starts the workflow from its initial state (as specified by initial state ), with a non-null snapshot. Only applies to StatefulWorkflow s. Inheritors \u00b6 Name WorkflowTestParams.StartMode WorkflowTestParams.StartMode WorkflowTestParams.StartMode WorkflowTestParams.StartMode","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-workflow-test-params/-start-mode/#startmode","text":"[jvm]\\ sealed class StartMode <out StateT > Defines how to start the workflow for tests. See the documentation on individual cases for more information: [StartFresh](-start-fresh/index.md) [StartFromWorkflowSnapshot](-start-from-workflow-snapshot/index.md) [StartFromCompleteSnapshot](-start-from-complete-snapshot/index.md) [StartFromState](-start-from-state/index.md)","title":"StartMode"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-workflow-test-params/-start-mode/#types","text":"Name Summary StartFresh [jvm] object StartFresh : WorkflowTestParams.StartMode < Nothing > Starts the workflow from its initial state (as specified by initial state ), with a null snapshot. StartFromCompleteSnapshot [jvm] class StartFromCompleteSnapshot (snapshot: TreeSnapshot ) : WorkflowTestParams.StartMode < Nothing > Starts the workflow from its initial state (as specified by initial state ), with a non-null snapshot. Only applies to StatefulWorkflow s. StartFromState [jvm] class StartFromState < StateT >(state: StateT ) : WorkflowTestParams.StartMode < StateT > Starts the workflow from an exact state. Only applies to StatefulWorkflow s. StartFromWorkflowSnapshot [jvm] class StartFromWorkflowSnapshot (snapshot: Snapshot ) : WorkflowTestParams.StartMode < Nothing > Starts the workflow from its initial state (as specified by initial state ), with a non-null snapshot. Only applies to StatefulWorkflow s.","title":"Types"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-workflow-test-params/-start-mode/#inheritors","text":"Name WorkflowTestParams.StartMode WorkflowTestParams.StartMode WorkflowTestParams.StartMode WorkflowTestParams.StartMode","title":"Inheritors"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-workflow-test-params/-start-mode/-start-fresh/","text":"// workflow / com.squareup.workflow1.testing / WorkflowTestParams / StartMode / StartFresh StartFresh \u00b6 [jvm]\\ object StartFresh : WorkflowTestParams.StartMode < Nothing > Starts the workflow from its initial state (as specified by initial state ), with a null snapshot.","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-workflow-test-params/-start-mode/-start-fresh/#startfresh","text":"[jvm]\\ object StartFresh : WorkflowTestParams.StartMode < Nothing > Starts the workflow from its initial state (as specified by initial state ), with a null snapshot.","title":"StartFresh"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-workflow-test-params/-start-mode/-start-from-complete-snapshot/","text":"// workflow / com.squareup.workflow1.testing / WorkflowTestParams / StartMode / StartFromCompleteSnapshot StartFromCompleteSnapshot \u00b6 [jvm]\\ class StartFromCompleteSnapshot (snapshot: TreeSnapshot ) : WorkflowTestParams.StartMode < Nothing > Starts the workflow from its initial state (as specified by initial state ), with a non-null snapshot. Only applies to StatefulWorkflow s. This differs from StartFromWorkflowSnapshot because it represents a complete snapshot of the entire tree, not just the individual snapshot for the root workflow. Parameters \u00b6 jvm snapshot A Snapshot that is the entire snapshot from the workflow tree, as returned by WorkflowTester.awaitNextSnapshot. To test with only the snapshot returned by snapshotState , use StartFromWorkflowSnapshot . Constructors \u00b6 StartFromCompleteSnapshot [jvm] fun StartFromCompleteSnapshot (snapshot: TreeSnapshot ) Properties \u00b6 Name Summary snapshot [jvm] val snapshot : TreeSnapshot","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-workflow-test-params/-start-mode/-start-from-complete-snapshot/#startfromcompletesnapshot","text":"[jvm]\\ class StartFromCompleteSnapshot (snapshot: TreeSnapshot ) : WorkflowTestParams.StartMode < Nothing > Starts the workflow from its initial state (as specified by initial state ), with a non-null snapshot. Only applies to StatefulWorkflow s. This differs from StartFromWorkflowSnapshot because it represents a complete snapshot of the entire tree, not just the individual snapshot for the root workflow.","title":"StartFromCompleteSnapshot"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-workflow-test-params/-start-mode/-start-from-complete-snapshot/#parameters","text":"jvm snapshot A Snapshot that is the entire snapshot from the workflow tree, as returned by WorkflowTester.awaitNextSnapshot. To test with only the snapshot returned by snapshotState , use StartFromWorkflowSnapshot .","title":"Parameters"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-workflow-test-params/-start-mode/-start-from-complete-snapshot/#constructors","text":"StartFromCompleteSnapshot [jvm] fun StartFromCompleteSnapshot (snapshot: TreeSnapshot )","title":"Constructors"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-workflow-test-params/-start-mode/-start-from-complete-snapshot/#properties","text":"Name Summary snapshot [jvm] val snapshot : TreeSnapshot","title":"Properties"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-workflow-test-params/-start-mode/-start-from-complete-snapshot/-start-from-complete-snapshot/","text":"// workflow / com.squareup.workflow1.testing / WorkflowTestParams / StartMode / StartFromCompleteSnapshot / StartFromCompleteSnapshot StartFromCompleteSnapshot \u00b6 [jvm]\\ fun StartFromCompleteSnapshot (snapshot: TreeSnapshot ) Parameters \u00b6 jvm snapshot A Snapshot that is the entire snapshot from the workflow tree, as returned by WorkflowTester.awaitNextSnapshot. To test with only the snapshot returned by snapshotState , use StartFromWorkflowSnapshot .","title":" start from complete snapshot"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-workflow-test-params/-start-mode/-start-from-complete-snapshot/-start-from-complete-snapshot/#startfromcompletesnapshot","text":"[jvm]\\ fun StartFromCompleteSnapshot (snapshot: TreeSnapshot )","title":"StartFromCompleteSnapshot"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-workflow-test-params/-start-mode/-start-from-complete-snapshot/-start-from-complete-snapshot/#parameters","text":"jvm snapshot A Snapshot that is the entire snapshot from the workflow tree, as returned by WorkflowTester.awaitNextSnapshot. To test with only the snapshot returned by snapshotState , use StartFromWorkflowSnapshot .","title":"Parameters"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-workflow-test-params/-start-mode/-start-from-complete-snapshot/snapshot/","text":"// workflow / com.squareup.workflow1.testing / WorkflowTestParams / StartMode / StartFromCompleteSnapshot / snapshot snapshot \u00b6 [jvm]\\ val snapshot : TreeSnapshot","title":"Snapshot"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-workflow-test-params/-start-mode/-start-from-complete-snapshot/snapshot/#snapshot","text":"[jvm]\\ val snapshot : TreeSnapshot","title":"snapshot"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-workflow-test-params/-start-mode/-start-from-state/","text":"// workflow / com.squareup.workflow1.testing / WorkflowTestParams / StartMode / StartFromState StartFromState \u00b6 [jvm]\\ class StartFromState < StateT >(state: StateT ) : WorkflowTestParams.StartMode < StateT > Starts the workflow from an exact state. Only applies to StatefulWorkflow s. Constructors \u00b6 StartFromState [jvm] fun < StateT > StartFromState (state: StateT ) Properties \u00b6 Name Summary state [jvm] val state : StateT","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-workflow-test-params/-start-mode/-start-from-state/#startfromstate","text":"[jvm]\\ class StartFromState < StateT >(state: StateT ) : WorkflowTestParams.StartMode < StateT > Starts the workflow from an exact state. Only applies to StatefulWorkflow s.","title":"StartFromState"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-workflow-test-params/-start-mode/-start-from-state/#constructors","text":"StartFromState [jvm] fun < StateT > StartFromState (state: StateT )","title":"Constructors"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-workflow-test-params/-start-mode/-start-from-state/#properties","text":"Name Summary state [jvm] val state : StateT","title":"Properties"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-workflow-test-params/-start-mode/-start-from-state/-start-from-state/","text":"// workflow / com.squareup.workflow1.testing / WorkflowTestParams / StartMode / StartFromState / StartFromState StartFromState \u00b6 [jvm]\\ fun < StateT > StartFromState (state: StateT )","title":" start from state"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-workflow-test-params/-start-mode/-start-from-state/-start-from-state/#startfromstate","text":"[jvm]\\ fun < StateT > StartFromState (state: StateT )","title":"StartFromState"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-workflow-test-params/-start-mode/-start-from-state/state/","text":"// workflow / com.squareup.workflow1.testing / WorkflowTestParams / StartMode / StartFromState / state state \u00b6 [jvm]\\ val state : StateT","title":"State"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-workflow-test-params/-start-mode/-start-from-state/state/#state","text":"[jvm]\\ val state : StateT","title":"state"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-workflow-test-params/-start-mode/-start-from-workflow-snapshot/","text":"// workflow / com.squareup.workflow1.testing / WorkflowTestParams / StartMode / StartFromWorkflowSnapshot StartFromWorkflowSnapshot \u00b6 [jvm]\\ class StartFromWorkflowSnapshot (snapshot: Snapshot ) : WorkflowTestParams.StartMode < Nothing > Starts the workflow from its initial state (as specified by initial state ), with a non-null snapshot. Only applies to StatefulWorkflow s. This differs from StartFromCompleteSnapshot because it represents only the snapshot for the root workflow, without any of the snapshots of its children or other bookkeeping data added by the workflow runtime. Parameters \u00b6 jvm snapshot A Snapshot that can be directly parsed by a workflow\u2019s initialState method. For workflow trees, this is only the snapshot of the root workflow, as returned by snapshotState . To test with a complete snapshot of the entire workflow tree, use StartFromCompleteSnapshot . Constructors \u00b6 StartFromWorkflowSnapshot [jvm] fun StartFromWorkflowSnapshot (snapshot: Snapshot ) Properties \u00b6 Name Summary snapshot [jvm] val snapshot : Snapshot","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-workflow-test-params/-start-mode/-start-from-workflow-snapshot/#startfromworkflowsnapshot","text":"[jvm]\\ class StartFromWorkflowSnapshot (snapshot: Snapshot ) : WorkflowTestParams.StartMode < Nothing > Starts the workflow from its initial state (as specified by initial state ), with a non-null snapshot. Only applies to StatefulWorkflow s. This differs from StartFromCompleteSnapshot because it represents only the snapshot for the root workflow, without any of the snapshots of its children or other bookkeeping data added by the workflow runtime.","title":"StartFromWorkflowSnapshot"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-workflow-test-params/-start-mode/-start-from-workflow-snapshot/#parameters","text":"jvm snapshot A Snapshot that can be directly parsed by a workflow\u2019s initialState method. For workflow trees, this is only the snapshot of the root workflow, as returned by snapshotState . To test with a complete snapshot of the entire workflow tree, use StartFromCompleteSnapshot .","title":"Parameters"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-workflow-test-params/-start-mode/-start-from-workflow-snapshot/#constructors","text":"StartFromWorkflowSnapshot [jvm] fun StartFromWorkflowSnapshot (snapshot: Snapshot )","title":"Constructors"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-workflow-test-params/-start-mode/-start-from-workflow-snapshot/#properties","text":"Name Summary snapshot [jvm] val snapshot : Snapshot","title":"Properties"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-workflow-test-params/-start-mode/-start-from-workflow-snapshot/-start-from-workflow-snapshot/","text":"// workflow / com.squareup.workflow1.testing / WorkflowTestParams / StartMode / StartFromWorkflowSnapshot / StartFromWorkflowSnapshot StartFromWorkflowSnapshot \u00b6 [jvm]\\ fun StartFromWorkflowSnapshot (snapshot: Snapshot ) Parameters \u00b6 jvm snapshot A Snapshot that can be directly parsed by a workflow\u2019s initialState method. For workflow trees, this is only the snapshot of the root workflow, as returned by snapshotState . To test with a complete snapshot of the entire workflow tree, use StartFromCompleteSnapshot .","title":" start from workflow snapshot"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-workflow-test-params/-start-mode/-start-from-workflow-snapshot/-start-from-workflow-snapshot/#startfromworkflowsnapshot","text":"[jvm]\\ fun StartFromWorkflowSnapshot (snapshot: Snapshot )","title":"StartFromWorkflowSnapshot"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-workflow-test-params/-start-mode/-start-from-workflow-snapshot/-start-from-workflow-snapshot/#parameters","text":"jvm snapshot A Snapshot that can be directly parsed by a workflow\u2019s initialState method. For workflow trees, this is only the snapshot of the root workflow, as returned by snapshotState . To test with a complete snapshot of the entire workflow tree, use StartFromCompleteSnapshot .","title":"Parameters"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-workflow-test-params/-start-mode/-start-from-workflow-snapshot/snapshot/","text":"// workflow / com.squareup.workflow1.testing / WorkflowTestParams / StartMode / StartFromWorkflowSnapshot / snapshot snapshot \u00b6 [jvm]\\ val snapshot : Snapshot","title":"Snapshot"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-workflow-test-params/-start-mode/-start-from-workflow-snapshot/snapshot/#snapshot","text":"[jvm]\\ val snapshot : Snapshot","title":"snapshot"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-workflow-test-runtime/","text":"// workflow / com.squareup.workflow1.testing / WorkflowTestRuntime WorkflowTestRuntime \u00b6 [jvm]\\ class WorkflowTestRuntime < PropsT , OutputT , RenderingT > Runs a Workflow and provides access to its renderings , outputs , and snapshots . For each of renderings, outputs, and snapshots, this class gives you a few ways to access information about them: [awaitNextRendering](await-next-rendering.md), [awaitNextOutput](await-next-output.md), [awaitNextSnapshot](await-next-snapshot.md) Block until something becomes available, and then return it. [hasRendering](has-rendering.md), [hasOutput](has-output.md), [hasSnapshot](has-snapshot.md) Return true if the previous methods won't block. [sendProps](send-props.md) Send a new [PropsT](index.md) to the root workflow. Types \u00b6 Name Summary Companion [jvm] object Companion Functions \u00b6 Name Summary awaitNextOutput [jvm] fun awaitNextOutput (timeoutMs: Long ? = null): OutputT Blocks until the workflow emits an output, then returns it. awaitNextRendering [jvm] fun awaitNextRendering (timeoutMs: Long ? = null, skipIntermediate: Boolean = true): RenderingT Blocks until the workflow emits a rendering, then returns it. awaitNextSnapshot [jvm] fun awaitNextSnapshot (timeoutMs: Long ? = null, skipIntermediate: Boolean = true): TreeSnapshot Blocks until the workflow emits a snapshot, then returns it. sendProps [jvm] fun sendProps (input: PropsT ) Sends input to the workflow. Properties \u00b6 Name Summary hasOutput [jvm] val hasOutput : Boolean True if the workflow has emitted a new output that is ready to be consumed. hasRendering [jvm] val hasRendering : Boolean True if the workflow has emitted a new rendering that is ready to be consumed. hasSnapshot [jvm] val hasSnapshot : Boolean True if the workflow has emitted a new snapshot that is ready to be consumed.","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-workflow-test-runtime/#workflowtestruntime","text":"[jvm]\\ class WorkflowTestRuntime < PropsT , OutputT , RenderingT > Runs a Workflow and provides access to its renderings , outputs , and snapshots . For each of renderings, outputs, and snapshots, this class gives you a few ways to access information about them: [awaitNextRendering](await-next-rendering.md), [awaitNextOutput](await-next-output.md), [awaitNextSnapshot](await-next-snapshot.md) Block until something becomes available, and then return it. [hasRendering](has-rendering.md), [hasOutput](has-output.md), [hasSnapshot](has-snapshot.md) Return true if the previous methods won't block. [sendProps](send-props.md) Send a new [PropsT](index.md) to the root workflow.","title":"WorkflowTestRuntime"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-workflow-test-runtime/#types","text":"Name Summary Companion [jvm] object Companion","title":"Types"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-workflow-test-runtime/#functions","text":"Name Summary awaitNextOutput [jvm] fun awaitNextOutput (timeoutMs: Long ? = null): OutputT Blocks until the workflow emits an output, then returns it. awaitNextRendering [jvm] fun awaitNextRendering (timeoutMs: Long ? = null, skipIntermediate: Boolean = true): RenderingT Blocks until the workflow emits a rendering, then returns it. awaitNextSnapshot [jvm] fun awaitNextSnapshot (timeoutMs: Long ? = null, skipIntermediate: Boolean = true): TreeSnapshot Blocks until the workflow emits a snapshot, then returns it. sendProps [jvm] fun sendProps (input: PropsT ) Sends input to the workflow.","title":"Functions"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-workflow-test-runtime/#properties","text":"Name Summary hasOutput [jvm] val hasOutput : Boolean True if the workflow has emitted a new output that is ready to be consumed. hasRendering [jvm] val hasRendering : Boolean True if the workflow has emitted a new rendering that is ready to be consumed. hasSnapshot [jvm] val hasSnapshot : Boolean True if the workflow has emitted a new snapshot that is ready to be consumed.","title":"Properties"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-workflow-test-runtime/await-next-output/","text":"// workflow / com.squareup.workflow1.testing / WorkflowTestRuntime / awaitNextOutput awaitNextOutput \u00b6 [jvm]\\ fun awaitNextOutput (timeoutMs: Long ? = null): OutputT Blocks until the workflow emits an output, then returns it. Parameters \u00b6 jvm timeoutMs The maximum amount of time to wait for an output to be emitted. If null, DEFAULT_TIMEOUT_MS will be used instead.","title":"Await next output"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-workflow-test-runtime/await-next-output/#awaitnextoutput","text":"[jvm]\\ fun awaitNextOutput (timeoutMs: Long ? = null): OutputT Blocks until the workflow emits an output, then returns it.","title":"awaitNextOutput"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-workflow-test-runtime/await-next-output/#parameters","text":"jvm timeoutMs The maximum amount of time to wait for an output to be emitted. If null, DEFAULT_TIMEOUT_MS will be used instead.","title":"Parameters"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-workflow-test-runtime/await-next-rendering/","text":"// workflow / com.squareup.workflow1.testing / WorkflowTestRuntime / awaitNextRendering awaitNextRendering \u00b6 [jvm]\\ fun awaitNextRendering (timeoutMs: Long ? = null, skipIntermediate: Boolean = true): RenderingT Blocks until the workflow emits a rendering, then returns it. Parameters \u00b6 jvm timeoutMs The maximum amount of time to wait for a rendering to be emitted. If null, WorkflowTestRuntime.DEFAULT_TIMEOUT_MS will be used instead. skipIntermediate If true, and the workflow has emitted multiple renderings, all but the most recent one will be dropped.","title":"Await next rendering"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-workflow-test-runtime/await-next-rendering/#awaitnextrendering","text":"[jvm]\\ fun awaitNextRendering (timeoutMs: Long ? = null, skipIntermediate: Boolean = true): RenderingT Blocks until the workflow emits a rendering, then returns it.","title":"awaitNextRendering"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-workflow-test-runtime/await-next-rendering/#parameters","text":"jvm timeoutMs The maximum amount of time to wait for a rendering to be emitted. If null, WorkflowTestRuntime.DEFAULT_TIMEOUT_MS will be used instead. skipIntermediate If true, and the workflow has emitted multiple renderings, all but the most recent one will be dropped.","title":"Parameters"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-workflow-test-runtime/await-next-snapshot/","text":"// workflow / com.squareup.workflow1.testing / WorkflowTestRuntime / awaitNextSnapshot awaitNextSnapshot \u00b6 [jvm]\\ fun awaitNextSnapshot (timeoutMs: Long ? = null, skipIntermediate: Boolean = true): TreeSnapshot Blocks until the workflow emits a snapshot, then returns it. The returned snapshot will be the snapshot only of the root workflow. It will be null if snapshotState returned an empty Snapshot . Parameters \u00b6 jvm timeoutMs The maximum amount of time to wait for a snapshot to be emitted. If null, DEFAULT_TIMEOUT_MS will be used instead. skipIntermediate If true, and the workflow has emitted multiple snapshots, all but the most recent one will be dropped.","title":"Await next snapshot"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-workflow-test-runtime/await-next-snapshot/#awaitnextsnapshot","text":"[jvm]\\ fun awaitNextSnapshot (timeoutMs: Long ? = null, skipIntermediate: Boolean = true): TreeSnapshot Blocks until the workflow emits a snapshot, then returns it. The returned snapshot will be the snapshot only of the root workflow. It will be null if snapshotState returned an empty Snapshot .","title":"awaitNextSnapshot"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-workflow-test-runtime/await-next-snapshot/#parameters","text":"jvm timeoutMs The maximum amount of time to wait for a snapshot to be emitted. If null, DEFAULT_TIMEOUT_MS will be used instead. skipIntermediate If true, and the workflow has emitted multiple snapshots, all but the most recent one will be dropped.","title":"Parameters"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-workflow-test-runtime/has-output/","text":"// workflow / com.squareup.workflow1.testing / WorkflowTestRuntime / hasOutput hasOutput \u00b6 [jvm]\\ val hasOutput : Boolean True if the workflow has emitted a new output that is ready to be consumed.","title":"Has output"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-workflow-test-runtime/has-output/#hasoutput","text":"[jvm]\\ val hasOutput : Boolean True if the workflow has emitted a new output that is ready to be consumed.","title":"hasOutput"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-workflow-test-runtime/has-rendering/","text":"// workflow / com.squareup.workflow1.testing / WorkflowTestRuntime / hasRendering hasRendering \u00b6 [jvm]\\ val hasRendering : Boolean True if the workflow has emitted a new rendering that is ready to be consumed.","title":"Has rendering"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-workflow-test-runtime/has-rendering/#hasrendering","text":"[jvm]\\ val hasRendering : Boolean True if the workflow has emitted a new rendering that is ready to be consumed.","title":"hasRendering"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-workflow-test-runtime/has-snapshot/","text":"// workflow / com.squareup.workflow1.testing / WorkflowTestRuntime / hasSnapshot hasSnapshot \u00b6 [jvm]\\ val hasSnapshot : Boolean True if the workflow has emitted a new snapshot that is ready to be consumed.","title":"Has snapshot"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-workflow-test-runtime/has-snapshot/#hassnapshot","text":"[jvm]\\ val hasSnapshot : Boolean True if the workflow has emitted a new snapshot that is ready to be consumed.","title":"hasSnapshot"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-workflow-test-runtime/send-props/","text":"// workflow / com.squareup.workflow1.testing / WorkflowTestRuntime / sendProps sendProps \u00b6 [jvm]\\ fun sendProps (input: PropsT ) Sends input to the workflow.","title":"Send props"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-workflow-test-runtime/send-props/#sendprops","text":"[jvm]\\ fun sendProps (input: PropsT ) Sends input to the workflow.","title":"sendProps"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-workflow-test-runtime/-companion/","text":"// workflow / com.squareup.workflow1.testing / WorkflowTestRuntime / Companion Companion \u00b6 [jvm]\\ object Companion Properties \u00b6 Name Summary DEFAULT_TIMEOUT_MS [jvm] const val DEFAULT_TIMEOUT_MS : Long = 500","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-workflow-test-runtime/-companion/#companion","text":"[jvm]\\ object Companion","title":"Companion"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-workflow-test-runtime/-companion/#properties","text":"Name Summary DEFAULT_TIMEOUT_MS [jvm] const val DEFAULT_TIMEOUT_MS : Long = 500","title":"Properties"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-workflow-test-runtime/-companion/-d-e-f-a-u-l-t_-t-i-m-e-o-u-t_-m-s/","text":"// workflow / com.squareup.workflow1.testing / WorkflowTestRuntime / Companion / DEFAULT_TIMEOUT_MS DEFAULT_TIMEOUT_MS \u00b6 [jvm]\\ const val DEFAULT_TIMEOUT_MS : Long = 500","title":" d e f a u l t  t i m e o u t  m s"},{"location":"kotlin/api/workflow/com.squareup.workflow1.testing/-workflow-test-runtime/-companion/-d-e-f-a-u-l-t_-t-i-m-e-o-u-t_-m-s/#default_timeout_ms","text":"[jvm]\\ const val DEFAULT_TIMEOUT_MS : Long = 500","title":"DEFAULT_TIMEOUT_MS"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/","text":"// workflow / com.squareup.workflow1.ui Package com.squareup.workflow1.ui \u00b6 Types \u00b6 Name Summary AndroidViewRendering [androidJvm] @WorkflowUiExperimentalApi interface AndroidViewRendering < V : AndroidViewRendering < V >> Interface implemented by a rendering class to allow it to drive an Android UI via an appropriate ViewFactory implementation. BackPressHandler [androidJvm] @WorkflowUiExperimentalApi typealias BackPressHandler = () -> Unit A function passed to View.backPressedHandler , to be called if the back button is pressed while that view is attached to a window. BuilderViewFactory [androidJvm] @WorkflowUiExperimentalApi class BuilderViewFactory < RenderingT : Any >(type: KClass < RenderingT >, viewConstructor: ( RenderingT , initialViewEnvironment: ViewEnvironment , contextForNewView: Context , container: ViewGroup ?) -> View ) : ViewFactory < RenderingT > A ViewFactory that creates View s that need to be generated from code. (Use LayoutRunner to work with XML layout resources.) Compatible [jvm] @ WorkflowUiExperimentalApi interface Compatible Implemented by objects whose compatibility requires more nuance than just being of the same type. DecorativeViewFactory [androidJvm] @WorkflowUiExperimentalApi class DecorativeViewFactory < OuterT : Any , InnerT : Any >(type: KClass < OuterT >, map: ( OuterT , ViewEnvironment ) -> Pair < InnerT , ViewEnvironment >, viewStarter: ViewStarter ?, doShowRendering: (view: View , ViewShowRendering < InnerT >, OuterT , env: ViewEnvironment ) -> Unit ) : ViewFactory < OuterT > A ViewFactory for OuterT that delegates view construction responsibilities to the factory registered for InnerT . Makes it convenient for OuterT to wrap instances of InnerT to add information or behavior, without requiring wasteful wrapping in the view system. LayoutRunner [androidJvm] @WorkflowUiExperimentalApi fun interface LayoutRunner < RenderingT : Any > A delegate that implements a showRendering method to be called when a workflow rendering of type RenderingT is ready to be displayed in a view inflated from a layout resource by a ViewRegistry . (Use BuilderViewFactory if you want to build views from code rather than layouts.) Named [jvm] @ WorkflowUiExperimentalApi data class Named < W : Any >(wrapped: W , name: String ) : Compatible Allows renderings that do not implement Compatible themselves to be distinguished by more than just their type. Instances are compatible if they have the same name and have compatible fields. TextController [jvm] @ WorkflowUiExperimentalApi class TextController (initialValue: String ) Helper class for keeping a workflow in sync with editable text in a UI, without interfering with the user\u2019s typing. ViewBindingInflater [androidJvm] @WorkflowUiExperimentalApi typealias ViewBindingInflater < BindingT > = ( LayoutInflater , ViewGroup ?, Boolean ) -> BindingT ViewEnvironment [androidJvm] @WorkflowUiExperimentalApi class ViewEnvironment (map: Map < ViewEnvironmentKey <*>, Any >) Immutable, append-only map of values that a parent view can pass down to its children via View.showRendering et al. Allows container views to give descendants information about the context in which they\u2019re drawing. ViewEnvironmentKey [androidJvm] @WorkflowUiExperimentalApi abstract class ViewEnvironmentKey < T : Any >(type: KClass < T >) Defines a value that can be provided by a ViewEnvironment map, specifying its type and default value. ViewFactory [androidJvm] @WorkflowUiExperimentalApi interface ViewFactory <in RenderingT : Any > Factory for View instances that can show renderings of type RenderingT . ViewRegistry [androidJvm] @WorkflowUiExperimentalApi interface ViewRegistry The ViewEnvironment service that can be used to display the stream of renderings from a workflow tree as View instances. This is the engine behind AndroidViewRendering , WorkflowViewStub and ViewFactory . Most apps can ignore ViewRegistry as an implementation detail, by using AndroidViewRendering to tie their rendering classes to view code. ViewShowRendering [androidJvm] @WorkflowUiExperimentalApi typealias ViewShowRendering < RenderingT > = (@ UnsafeVariance RenderingT , ViewEnvironment ) -> Unit Function attached to a view created by ViewFactory , to allow it to respond to View.showRendering . ViewStarter [androidJvm] @WorkflowUiExperimentalApi fun interface ViewStarter A wrapper for the function invoked when View.start is called, allowing for last second initialization of a newly built View . Provided via ViewRegistry.buildView or DecorativeViewFactory.viewStarter. WorkflowLayout [androidJvm] @WorkflowUiExperimentalApi class WorkflowLayout (context: Context , attributeSet: AttributeSet ?) : FrameLayout A view that can be driven by a stream of renderings (and an optional ViewRegistry ) passed to its start method. WorkflowUiExperimentalApi [jvm] @ Target (allowedTargets = [ AnnotationTarget.CLASS , AnnotationTarget.PROPERTY , AnnotationTarget.FUNCTION , AnnotationTarget.TYPEALIAS ]) annotation class WorkflowUiExperimentalApi Marks Workflow user interface APIs which are still in flux. Annotated code SHOULD NOT be used in library code or app code that you are not prepared to update when changing even minor workflow versions. Proceed with caution, and be ready to have the rug pulled out from under you. WorkflowViewStub [androidJvm] @WorkflowUiExperimentalApi class WorkflowViewStub @ JvmOverloads constructor(context: Context , attributeSet: AttributeSet ?, defStyle: Int , defStyleRes: Int ) : View A placeholder View that can replace itself with ones driven by workflow renderings, similar to android.view.ViewStub . Functions \u00b6 Name Summary bindShowRendering [androidJvm] @WorkflowUiExperimentalApi fun < RenderingT : Any > View . bindShowRendering (initialRendering: RenderingT , initialViewEnvironment: ViewEnvironment , showRendering: ViewShowRendering < RenderingT >) For use by implementations of ViewFactory.buildView . Establishes showRendering as the implementation of View.showRendering for the receiver, possibly replacing the existing one. buildView [androidJvm] @WorkflowUiExperimentalApi fun < RenderingT : Any > ViewRegistry . buildView (initialRendering: RenderingT , initialViewEnvironment: ViewEnvironment , contextForNewView: Context , container: ViewGroup ? = null, viewStarter: ViewStarter ? = null): View It is usually more convenient to use WorkflowViewStub or DecorativeViewFactory than to call this method directly. canShowRendering [androidJvm] @WorkflowUiExperimentalApi fun View . canShowRendering (rendering: Any ): Boolean Note that WorkflowViewStub.showRendering makes this check for you. compatible [jvm] @ WorkflowUiExperimentalApi fun compatible (me: Any , you: Any ): Boolean Normally returns true if me and you are instances of the same class. If that common class implements Compatible , both instances must also have the same Compatible.compatibilityKey . control [androidJvm] @WorkflowUiExperimentalApi fun TextController . control (view: EditText ) Call this from your view code\u2019s showRendering method. This method is idempotent: if it has already been called with a particular EditText , and the view has not been detached since the last call, it will do nothing. If a different TextController \u2018s control is called on the same EditText , the old one will be disconnected and the new one will replace it. getFactoryForRendering [androidJvm] @WorkflowUiExperimentalApi fun < RenderingT : Any > ViewRegistry . getFactoryForRendering (rendering: RenderingT ): ViewFactory < RenderingT > It is usually more convenient to use WorkflowViewStub or DecorativeViewFactory than to call this method directly. getRendering [androidJvm] @WorkflowUiExperimentalApi inline fun < RenderingT : Any > View . getRendering (): RenderingT ? Returns the most recent rendering shown by this view cast to RenderingT , or null if bindShowRendering has never been called. getShowRendering [androidJvm] @WorkflowUiExperimentalApi fun < RenderingT : Any > View . getShowRendering (): ViewShowRendering < RenderingT >? Returns the function set by the most recent call to bindShowRendering , or null if that method has never been called. onBackPressedDispatcherOwnerOrNull [androidJvm] @WorkflowUiExperimentalApi tailrec fun Context . onBackPressedDispatcherOwnerOrNull (): OnBackPressedDispatcherOwner ? plus [androidJvm] @WorkflowUiExperimentalApi operator fun ViewRegistry . plus (binding: ViewFactory <*>): ViewRegistry @WorkflowUiExperimentalApi operator fun ViewRegistry . plus (other: ViewRegistry ): ViewRegistry renderWorkflowIn [androidJvm] @WorkflowUiExperimentalApi fun < OutputT , RenderingT > renderWorkflowIn (workflow: Workflow < Unit , OutputT , RenderingT >, scope: CoroutineScope, savedStateHandle: SavedStateHandle ? = null, interceptors: List <WorkflowInterceptor> = emptyList(), onOutput: suspend ( OutputT ) -> Unit = {}): StateFlow< RenderingT > An Android ViewModel-friendly wrapper for com.squareup.workflow1.renderWorkflowIn, for use with a workflow that takes no input (that is, has PropsT set to Unit ). [androidJvm] @WorkflowUiExperimentalApi fun < PropsT , OutputT , RenderingT > renderWorkflowIn (workflow: Workflow < PropsT , OutputT , RenderingT >, scope: CoroutineScope, prop: PropsT , savedStateHandle: SavedStateHandle ? = null, interceptors: List <WorkflowInterceptor> = emptyList(), onOutput: suspend ( OutputT ) -> Unit = {}): StateFlow< RenderingT > An Android ViewModel-friendly wrapper for com.squareup.workflow1.renderWorkflowIn, for use with a workflow that requires one input value ( prop ) to run. [androidJvm] @WorkflowUiExperimentalApi fun < PropsT , OutputT , RenderingT > renderWorkflowIn (workflow: Workflow < PropsT , OutputT , RenderingT >, scope: CoroutineScope, props: StateFlow< PropsT >, savedStateHandle: SavedStateHandle ? = null, interceptors: List <WorkflowInterceptor> = emptyList(), onOutput: suspend ( OutputT ) -> Unit = {}): StateFlow< RenderingT > An Android ViewModel-friendly wrapper for com.squareup.workflow1.renderWorkflowIn, for use with a workflow that requires input ( props ) to run. showRendering [androidJvm] @WorkflowUiExperimentalApi fun < RenderingT : Any > View . showRendering (rendering: RenderingT , viewEnvironment: ViewEnvironment ) It is usually more convenient to call WorkflowViewStub.showRendering than to call this method directly. start [androidJvm] @WorkflowUiExperimentalApi fun View . start () Note that WorkflowViewStub calls this method for you. toParcelable [androidJvm] inline fun < T : Parcelable > Snapshot . toParcelable (): T ? inline fun < T : Parcelable > ByteString. toParcelable (): T toSnapshot [androidJvm] fun Parcelable . toSnapshot (): Snapshot Wraps receiver in a Snapshot suitable for use with com.squareup.workflow1.StatefulWorkflow. Intended to allow use of @Parcelize. ViewRegistry [androidJvm] @WorkflowUiExperimentalApi fun ViewRegistry (): ViewRegistry Returns a ViewRegistry that contains no bindings. [androidJvm] @WorkflowUiExperimentalApi fun ViewRegistry (vararg bindings: ViewFactory <*>): ViewRegistry Properties \u00b6 Name Summary backPressedHandler [androidJvm] @WorkflowUiExperimentalApi var View . backPressedHandler : BackPressHandler ? A function to be called if the device back button is pressed while this view is attached to a window. environment [androidJvm] @WorkflowUiExperimentalApi val View . environment : ViewEnvironment ? Returns the most recent ViewEnvironment applied to this view, or null if bindShowRendering has never been called.","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/#package-comsquareupworkflow1ui","text":"","title":"Package com.squareup.workflow1.ui"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/#types","text":"Name Summary AndroidViewRendering [androidJvm] @WorkflowUiExperimentalApi interface AndroidViewRendering < V : AndroidViewRendering < V >> Interface implemented by a rendering class to allow it to drive an Android UI via an appropriate ViewFactory implementation. BackPressHandler [androidJvm] @WorkflowUiExperimentalApi typealias BackPressHandler = () -> Unit A function passed to View.backPressedHandler , to be called if the back button is pressed while that view is attached to a window. BuilderViewFactory [androidJvm] @WorkflowUiExperimentalApi class BuilderViewFactory < RenderingT : Any >(type: KClass < RenderingT >, viewConstructor: ( RenderingT , initialViewEnvironment: ViewEnvironment , contextForNewView: Context , container: ViewGroup ?) -> View ) : ViewFactory < RenderingT > A ViewFactory that creates View s that need to be generated from code. (Use LayoutRunner to work with XML layout resources.) Compatible [jvm] @ WorkflowUiExperimentalApi interface Compatible Implemented by objects whose compatibility requires more nuance than just being of the same type. DecorativeViewFactory [androidJvm] @WorkflowUiExperimentalApi class DecorativeViewFactory < OuterT : Any , InnerT : Any >(type: KClass < OuterT >, map: ( OuterT , ViewEnvironment ) -> Pair < InnerT , ViewEnvironment >, viewStarter: ViewStarter ?, doShowRendering: (view: View , ViewShowRendering < InnerT >, OuterT , env: ViewEnvironment ) -> Unit ) : ViewFactory < OuterT > A ViewFactory for OuterT that delegates view construction responsibilities to the factory registered for InnerT . Makes it convenient for OuterT to wrap instances of InnerT to add information or behavior, without requiring wasteful wrapping in the view system. LayoutRunner [androidJvm] @WorkflowUiExperimentalApi fun interface LayoutRunner < RenderingT : Any > A delegate that implements a showRendering method to be called when a workflow rendering of type RenderingT is ready to be displayed in a view inflated from a layout resource by a ViewRegistry . (Use BuilderViewFactory if you want to build views from code rather than layouts.) Named [jvm] @ WorkflowUiExperimentalApi data class Named < W : Any >(wrapped: W , name: String ) : Compatible Allows renderings that do not implement Compatible themselves to be distinguished by more than just their type. Instances are compatible if they have the same name and have compatible fields. TextController [jvm] @ WorkflowUiExperimentalApi class TextController (initialValue: String ) Helper class for keeping a workflow in sync with editable text in a UI, without interfering with the user\u2019s typing. ViewBindingInflater [androidJvm] @WorkflowUiExperimentalApi typealias ViewBindingInflater < BindingT > = ( LayoutInflater , ViewGroup ?, Boolean ) -> BindingT ViewEnvironment [androidJvm] @WorkflowUiExperimentalApi class ViewEnvironment (map: Map < ViewEnvironmentKey <*>, Any >) Immutable, append-only map of values that a parent view can pass down to its children via View.showRendering et al. Allows container views to give descendants information about the context in which they\u2019re drawing. ViewEnvironmentKey [androidJvm] @WorkflowUiExperimentalApi abstract class ViewEnvironmentKey < T : Any >(type: KClass < T >) Defines a value that can be provided by a ViewEnvironment map, specifying its type and default value. ViewFactory [androidJvm] @WorkflowUiExperimentalApi interface ViewFactory <in RenderingT : Any > Factory for View instances that can show renderings of type RenderingT . ViewRegistry [androidJvm] @WorkflowUiExperimentalApi interface ViewRegistry The ViewEnvironment service that can be used to display the stream of renderings from a workflow tree as View instances. This is the engine behind AndroidViewRendering , WorkflowViewStub and ViewFactory . Most apps can ignore ViewRegistry as an implementation detail, by using AndroidViewRendering to tie their rendering classes to view code. ViewShowRendering [androidJvm] @WorkflowUiExperimentalApi typealias ViewShowRendering < RenderingT > = (@ UnsafeVariance RenderingT , ViewEnvironment ) -> Unit Function attached to a view created by ViewFactory , to allow it to respond to View.showRendering . ViewStarter [androidJvm] @WorkflowUiExperimentalApi fun interface ViewStarter A wrapper for the function invoked when View.start is called, allowing for last second initialization of a newly built View . Provided via ViewRegistry.buildView or DecorativeViewFactory.viewStarter. WorkflowLayout [androidJvm] @WorkflowUiExperimentalApi class WorkflowLayout (context: Context , attributeSet: AttributeSet ?) : FrameLayout A view that can be driven by a stream of renderings (and an optional ViewRegistry ) passed to its start method. WorkflowUiExperimentalApi [jvm] @ Target (allowedTargets = [ AnnotationTarget.CLASS , AnnotationTarget.PROPERTY , AnnotationTarget.FUNCTION , AnnotationTarget.TYPEALIAS ]) annotation class WorkflowUiExperimentalApi Marks Workflow user interface APIs which are still in flux. Annotated code SHOULD NOT be used in library code or app code that you are not prepared to update when changing even minor workflow versions. Proceed with caution, and be ready to have the rug pulled out from under you. WorkflowViewStub [androidJvm] @WorkflowUiExperimentalApi class WorkflowViewStub @ JvmOverloads constructor(context: Context , attributeSet: AttributeSet ?, defStyle: Int , defStyleRes: Int ) : View A placeholder View that can replace itself with ones driven by workflow renderings, similar to android.view.ViewStub .","title":"Types"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/#functions","text":"Name Summary bindShowRendering [androidJvm] @WorkflowUiExperimentalApi fun < RenderingT : Any > View . bindShowRendering (initialRendering: RenderingT , initialViewEnvironment: ViewEnvironment , showRendering: ViewShowRendering < RenderingT >) For use by implementations of ViewFactory.buildView . Establishes showRendering as the implementation of View.showRendering for the receiver, possibly replacing the existing one. buildView [androidJvm] @WorkflowUiExperimentalApi fun < RenderingT : Any > ViewRegistry . buildView (initialRendering: RenderingT , initialViewEnvironment: ViewEnvironment , contextForNewView: Context , container: ViewGroup ? = null, viewStarter: ViewStarter ? = null): View It is usually more convenient to use WorkflowViewStub or DecorativeViewFactory than to call this method directly. canShowRendering [androidJvm] @WorkflowUiExperimentalApi fun View . canShowRendering (rendering: Any ): Boolean Note that WorkflowViewStub.showRendering makes this check for you. compatible [jvm] @ WorkflowUiExperimentalApi fun compatible (me: Any , you: Any ): Boolean Normally returns true if me and you are instances of the same class. If that common class implements Compatible , both instances must also have the same Compatible.compatibilityKey . control [androidJvm] @WorkflowUiExperimentalApi fun TextController . control (view: EditText ) Call this from your view code\u2019s showRendering method. This method is idempotent: if it has already been called with a particular EditText , and the view has not been detached since the last call, it will do nothing. If a different TextController \u2018s control is called on the same EditText , the old one will be disconnected and the new one will replace it. getFactoryForRendering [androidJvm] @WorkflowUiExperimentalApi fun < RenderingT : Any > ViewRegistry . getFactoryForRendering (rendering: RenderingT ): ViewFactory < RenderingT > It is usually more convenient to use WorkflowViewStub or DecorativeViewFactory than to call this method directly. getRendering [androidJvm] @WorkflowUiExperimentalApi inline fun < RenderingT : Any > View . getRendering (): RenderingT ? Returns the most recent rendering shown by this view cast to RenderingT , or null if bindShowRendering has never been called. getShowRendering [androidJvm] @WorkflowUiExperimentalApi fun < RenderingT : Any > View . getShowRendering (): ViewShowRendering < RenderingT >? Returns the function set by the most recent call to bindShowRendering , or null if that method has never been called. onBackPressedDispatcherOwnerOrNull [androidJvm] @WorkflowUiExperimentalApi tailrec fun Context . onBackPressedDispatcherOwnerOrNull (): OnBackPressedDispatcherOwner ? plus [androidJvm] @WorkflowUiExperimentalApi operator fun ViewRegistry . plus (binding: ViewFactory <*>): ViewRegistry @WorkflowUiExperimentalApi operator fun ViewRegistry . plus (other: ViewRegistry ): ViewRegistry renderWorkflowIn [androidJvm] @WorkflowUiExperimentalApi fun < OutputT , RenderingT > renderWorkflowIn (workflow: Workflow < Unit , OutputT , RenderingT >, scope: CoroutineScope, savedStateHandle: SavedStateHandle ? = null, interceptors: List <WorkflowInterceptor> = emptyList(), onOutput: suspend ( OutputT ) -> Unit = {}): StateFlow< RenderingT > An Android ViewModel-friendly wrapper for com.squareup.workflow1.renderWorkflowIn, for use with a workflow that takes no input (that is, has PropsT set to Unit ). [androidJvm] @WorkflowUiExperimentalApi fun < PropsT , OutputT , RenderingT > renderWorkflowIn (workflow: Workflow < PropsT , OutputT , RenderingT >, scope: CoroutineScope, prop: PropsT , savedStateHandle: SavedStateHandle ? = null, interceptors: List <WorkflowInterceptor> = emptyList(), onOutput: suspend ( OutputT ) -> Unit = {}): StateFlow< RenderingT > An Android ViewModel-friendly wrapper for com.squareup.workflow1.renderWorkflowIn, for use with a workflow that requires one input value ( prop ) to run. [androidJvm] @WorkflowUiExperimentalApi fun < PropsT , OutputT , RenderingT > renderWorkflowIn (workflow: Workflow < PropsT , OutputT , RenderingT >, scope: CoroutineScope, props: StateFlow< PropsT >, savedStateHandle: SavedStateHandle ? = null, interceptors: List <WorkflowInterceptor> = emptyList(), onOutput: suspend ( OutputT ) -> Unit = {}): StateFlow< RenderingT > An Android ViewModel-friendly wrapper for com.squareup.workflow1.renderWorkflowIn, for use with a workflow that requires input ( props ) to run. showRendering [androidJvm] @WorkflowUiExperimentalApi fun < RenderingT : Any > View . showRendering (rendering: RenderingT , viewEnvironment: ViewEnvironment ) It is usually more convenient to call WorkflowViewStub.showRendering than to call this method directly. start [androidJvm] @WorkflowUiExperimentalApi fun View . start () Note that WorkflowViewStub calls this method for you. toParcelable [androidJvm] inline fun < T : Parcelable > Snapshot . toParcelable (): T ? inline fun < T : Parcelable > ByteString. toParcelable (): T toSnapshot [androidJvm] fun Parcelable . toSnapshot (): Snapshot Wraps receiver in a Snapshot suitable for use with com.squareup.workflow1.StatefulWorkflow. Intended to allow use of @Parcelize. ViewRegistry [androidJvm] @WorkflowUiExperimentalApi fun ViewRegistry (): ViewRegistry Returns a ViewRegistry that contains no bindings. [androidJvm] @WorkflowUiExperimentalApi fun ViewRegistry (vararg bindings: ViewFactory <*>): ViewRegistry","title":"Functions"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/#properties","text":"Name Summary backPressedHandler [androidJvm] @WorkflowUiExperimentalApi var View . backPressedHandler : BackPressHandler ? A function to be called if the device back button is pressed while this view is attached to a window. environment [androidJvm] @WorkflowUiExperimentalApi val View . environment : ViewEnvironment ? Returns the most recent ViewEnvironment applied to this view, or null if bindShowRendering has never been called.","title":"Properties"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-view-registry/","text":"// workflow / com.squareup.workflow1.ui / ViewRegistry ViewRegistry \u00b6 [androidJvm]\\ @WorkflowUiExperimentalApi fun ViewRegistry (vararg bindings: ViewFactory <*>): ViewRegistry [androidJvm]\\ @WorkflowUiExperimentalApi fun ViewRegistry (): ViewRegistry Returns a ViewRegistry that contains no bindings. Exists as a separate overload from the other two functions to disambiguate between them.","title":" view registry"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-view-registry/#viewregistry","text":"[androidJvm]\\ @WorkflowUiExperimentalApi fun ViewRegistry (vararg bindings: ViewFactory <*>): ViewRegistry [androidJvm]\\ @WorkflowUiExperimentalApi fun ViewRegistry (): ViewRegistry Returns a ViewRegistry that contains no bindings. Exists as a separate overload from the other two functions to disambiguate between them.","title":"ViewRegistry"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/back-pressed-handler/","text":"// workflow / com.squareup.workflow1.ui / backPressedHandler backPressedHandler \u00b6 [androidJvm]\\ @WorkflowUiExperimentalApi var View . backPressedHandler : BackPressHandler ? A function to be called if the device back button is pressed while this view is attached to a window. Implemented via a OnBackPressedCallback , making this a last-registered-first-served mechanism.","title":"Back pressed handler"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/back-pressed-handler/#backpressedhandler","text":"[androidJvm]\\ @WorkflowUiExperimentalApi var View . backPressedHandler : BackPressHandler ? A function to be called if the device back button is pressed while this view is attached to a window. Implemented via a OnBackPressedCallback , making this a last-registered-first-served mechanism.","title":"backPressedHandler"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/bind-show-rendering/","text":"// workflow / com.squareup.workflow1.ui / bindShowRendering bindShowRendering \u00b6 [androidJvm]\\ @WorkflowUiExperimentalApi fun < RenderingT : Any > View . bindShowRendering (initialRendering: RenderingT , initialViewEnvironment: ViewEnvironment , showRendering: ViewShowRendering < RenderingT >) For use by implementations of ViewFactory.buildView . Establishes showRendering as the implementation of View.showRendering for the receiver, possibly replacing the existing one. After this method is called, [View.start](start.md) must be called exactly once before [View.showRendering](show-rendering.md) can be called. If this method is called again *after*[View.start](start.md) (e.g. if a [View](https://developer.android.com/reference/kotlin/android/view/View.html) is reused), the receiver is reset to its initialized state, and [View.start](start.md) must be called again. See also \u00b6 androidJvm com.squareup.workflow1.ui.ViewFactory com.squareup.workflow1.ui.DecorativeViewFactory","title":"Bind show rendering"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/bind-show-rendering/#bindshowrendering","text":"[androidJvm]\\ @WorkflowUiExperimentalApi fun < RenderingT : Any > View . bindShowRendering (initialRendering: RenderingT , initialViewEnvironment: ViewEnvironment , showRendering: ViewShowRendering < RenderingT >) For use by implementations of ViewFactory.buildView . Establishes showRendering as the implementation of View.showRendering for the receiver, possibly replacing the existing one. After this method is called, [View.start](start.md) must be called exactly once before [View.showRendering](show-rendering.md) can be called. If this method is called again *after*[View.start](start.md) (e.g. if a [View](https://developer.android.com/reference/kotlin/android/view/View.html) is reused), the receiver is reset to its initialized state, and [View.start](start.md) must be called again.","title":"bindShowRendering"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/bind-show-rendering/#see-also","text":"androidJvm com.squareup.workflow1.ui.ViewFactory com.squareup.workflow1.ui.DecorativeViewFactory","title":"See also"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/build-view/","text":"// workflow / com.squareup.workflow1.ui / buildView buildView \u00b6 [androidJvm]\\ @WorkflowUiExperimentalApi fun < RenderingT : Any > ViewRegistry . buildView (initialRendering: RenderingT , initialViewEnvironment: ViewEnvironment , contextForNewView: Context , container: ViewGroup ? = null, viewStarter: ViewStarter ? = null): View It is usually more convenient to use WorkflowViewStub or DecorativeViewFactory than to call this method directly. Finds a ViewFactory to create a View ready to display initialRendering . The caller is responsible for calling View.start on the new View . After that, View.showRendering can be used to update it with new renderings that are compatible with initialRendering . Parameters \u00b6 androidJvm viewStarter An optional wrapper for the function invoked when View.start is called, allowing for last second initialization of a newly built View . See ViewStarter for details. Throws \u00b6 kotlin.IllegalArgumentException if no factory can be found for type RenderingT kotlin.IllegalStateException if the matching ViewFactory fails to call View.bindShowRendering when constructing the view","title":"Build view"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/build-view/#buildview","text":"[androidJvm]\\ @WorkflowUiExperimentalApi fun < RenderingT : Any > ViewRegistry . buildView (initialRendering: RenderingT , initialViewEnvironment: ViewEnvironment , contextForNewView: Context , container: ViewGroup ? = null, viewStarter: ViewStarter ? = null): View It is usually more convenient to use WorkflowViewStub or DecorativeViewFactory than to call this method directly. Finds a ViewFactory to create a View ready to display initialRendering . The caller is responsible for calling View.start on the new View . After that, View.showRendering can be used to update it with new renderings that are compatible with initialRendering .","title":"buildView"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/build-view/#parameters","text":"androidJvm viewStarter An optional wrapper for the function invoked when View.start is called, allowing for last second initialization of a newly built View . See ViewStarter for details.","title":"Parameters"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/build-view/#throws","text":"kotlin.IllegalArgumentException if no factory can be found for type RenderingT kotlin.IllegalStateException if the matching ViewFactory fails to call View.bindShowRendering when constructing the view","title":"Throws"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/can-show-rendering/","text":"// workflow / com.squareup.workflow1.ui / canShowRendering canShowRendering \u00b6 [androidJvm]\\ @WorkflowUiExperimentalApi fun View . canShowRendering (rendering: Any ): Boolean Note that WorkflowViewStub.showRendering makes this check for you. True if this view is able to show rendering . Returns false if View.bindShowRendering has not been called, so it is always safe to call this method. Otherwise returns the compatibility of the current View.getRendering and the new one.","title":"Can show rendering"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/can-show-rendering/#canshowrendering","text":"[androidJvm]\\ @WorkflowUiExperimentalApi fun View . canShowRendering (rendering: Any ): Boolean Note that WorkflowViewStub.showRendering makes this check for you. True if this view is able to show rendering . Returns false if View.bindShowRendering has not been called, so it is always safe to call this method. Otherwise returns the compatibility of the current View.getRendering and the new one.","title":"canShowRendering"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/compatible/","text":"// workflow / com.squareup.workflow1.ui / compatible compatible \u00b6 [jvm]\\ @ WorkflowUiExperimentalApi fun compatible (me: Any , you: Any ): Boolean Normally returns true if me and you are instances of the same class. If that common class implements Compatible , both instances must also have the same Compatible.compatibilityKey . A convenient way to take control over the matching behavior of objects that don\u2019t implement Compatible is to wrap them with Named .","title":"Compatible"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/compatible/#compatible","text":"[jvm]\\ @ WorkflowUiExperimentalApi fun compatible (me: Any , you: Any ): Boolean Normally returns true if me and you are instances of the same class. If that common class implements Compatible , both instances must also have the same Compatible.compatibilityKey . A convenient way to take control over the matching behavior of objects that don\u2019t implement Compatible is to wrap them with Named .","title":"compatible"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/control/","text":"// workflow / com.squareup.workflow1.ui / control control \u00b6 [androidJvm]\\ @WorkflowUiExperimentalApi fun TextController . control (view: EditText ) Call this from your view code\u2019s showRendering method. This method is idempotent: if it has already been called with a particular EditText , and the view has not been detached since the last call, it will do nothing. If a different TextController \u2018s control is called on the same EditText , the old one will be disconnected and the new one will replace it. See TextController for more documentation.","title":"Control"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/control/#control","text":"[androidJvm]\\ @WorkflowUiExperimentalApi fun TextController . control (view: EditText ) Call this from your view code\u2019s showRendering method. This method is idempotent: if it has already been called with a particular EditText , and the view has not been detached since the last call, it will do nothing. If a different TextController \u2018s control is called on the same EditText , the old one will be disconnected and the new one will replace it. See TextController for more documentation.","title":"control"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/environment/","text":"// workflow / com.squareup.workflow1.ui / environment environment \u00b6 [androidJvm]\\ @WorkflowUiExperimentalApi val View . environment : ViewEnvironment ? Returns the most recent ViewEnvironment applied to this view, or null if bindShowRendering has never been called.","title":"Environment"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/environment/#environment","text":"[androidJvm]\\ @WorkflowUiExperimentalApi val View . environment : ViewEnvironment ? Returns the most recent ViewEnvironment applied to this view, or null if bindShowRendering has never been called.","title":"environment"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/get-factory-for-rendering/","text":"// workflow / com.squareup.workflow1.ui / getFactoryForRendering getFactoryForRendering \u00b6 [androidJvm]\\ @WorkflowUiExperimentalApi fun < RenderingT : Any > ViewRegistry . getFactoryForRendering (rendering: RenderingT ): ViewFactory < RenderingT > It is usually more convenient to use WorkflowViewStub or DecorativeViewFactory than to call this method directly. Returns the ViewFactory that builds View instances suitable to display the given rendering , via subsequent calls to View.showRendering . Prefers factories found via ViewRegistry.getFactoryFor . If that returns null, falls back to the factory provided by the rendering\u2019s implementation of AndroidViewRendering.viewFactory , if there is one. Note that this means that a compile time AndroidViewRendering.viewFactory binding can be overridden at runtime. Throws \u00b6 kotlin.IllegalArgumentException if no factory can be find for type RenderingT","title":"Get factory for rendering"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/get-factory-for-rendering/#getfactoryforrendering","text":"[androidJvm]\\ @WorkflowUiExperimentalApi fun < RenderingT : Any > ViewRegistry . getFactoryForRendering (rendering: RenderingT ): ViewFactory < RenderingT > It is usually more convenient to use WorkflowViewStub or DecorativeViewFactory than to call this method directly. Returns the ViewFactory that builds View instances suitable to display the given rendering , via subsequent calls to View.showRendering . Prefers factories found via ViewRegistry.getFactoryFor . If that returns null, falls back to the factory provided by the rendering\u2019s implementation of AndroidViewRendering.viewFactory , if there is one. Note that this means that a compile time AndroidViewRendering.viewFactory binding can be overridden at runtime.","title":"getFactoryForRendering"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/get-factory-for-rendering/#throws","text":"kotlin.IllegalArgumentException if no factory can be find for type RenderingT","title":"Throws"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/get-rendering/","text":"// workflow / com.squareup.workflow1.ui / getRendering getRendering \u00b6 [androidJvm]\\ @WorkflowUiExperimentalApi inline fun < RenderingT : Any > View . getRendering (): RenderingT ? Returns the most recent rendering shown by this view cast to RenderingT , or null if bindShowRendering has never been called. Throws \u00b6 kotlin.ClassCastException if the current rendering is not of type RenderingT","title":"Get rendering"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/get-rendering/#getrendering","text":"[androidJvm]\\ @WorkflowUiExperimentalApi inline fun < RenderingT : Any > View . getRendering (): RenderingT ? Returns the most recent rendering shown by this view cast to RenderingT , or null if bindShowRendering has never been called.","title":"getRendering"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/get-rendering/#throws","text":"kotlin.ClassCastException if the current rendering is not of type RenderingT","title":"Throws"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/get-show-rendering/","text":"// workflow / com.squareup.workflow1.ui / getShowRendering getShowRendering \u00b6 [androidJvm]\\ @WorkflowUiExperimentalApi fun < RenderingT : Any > View . getShowRendering (): ViewShowRendering < RenderingT >? Returns the function set by the most recent call to bindShowRendering , or null if that method has never been called.","title":"Get show rendering"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/get-show-rendering/#getshowrendering","text":"[androidJvm]\\ @WorkflowUiExperimentalApi fun < RenderingT : Any > View . getShowRendering (): ViewShowRendering < RenderingT >? Returns the function set by the most recent call to bindShowRendering , or null if that method has never been called.","title":"getShowRendering"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/on-back-pressed-dispatcher-owner-or-null/","text":"// workflow / com.squareup.workflow1.ui / onBackPressedDispatcherOwnerOrNull onBackPressedDispatcherOwnerOrNull \u00b6 [androidJvm]\\ @WorkflowUiExperimentalApi tailrec fun Context . onBackPressedDispatcherOwnerOrNull (): OnBackPressedDispatcherOwner ?","title":"On back pressed dispatcher owner or null"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/on-back-pressed-dispatcher-owner-or-null/#onbackpresseddispatcherownerornull","text":"[androidJvm]\\ @WorkflowUiExperimentalApi tailrec fun Context . onBackPressedDispatcherOwnerOrNull (): OnBackPressedDispatcherOwner ?","title":"onBackPressedDispatcherOwnerOrNull"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/plus/","text":"// workflow / com.squareup.workflow1.ui / plus plus \u00b6 [androidJvm]\\ @WorkflowUiExperimentalApi operator fun ViewRegistry . plus (binding: ViewFactory <*>): ViewRegistry @WorkflowUiExperimentalApi operator fun ViewRegistry . plus (other: ViewRegistry ): ViewRegistry","title":"Plus"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/plus/#plus","text":"[androidJvm]\\ @WorkflowUiExperimentalApi operator fun ViewRegistry . plus (binding: ViewFactory <*>): ViewRegistry @WorkflowUiExperimentalApi operator fun ViewRegistry . plus (other: ViewRegistry ): ViewRegistry","title":"plus"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/render-workflow-in/","text":"// workflow / com.squareup.workflow1.ui / renderWorkflowIn renderWorkflowIn \u00b6 [androidJvm]\\ @WorkflowUiExperimentalApi fun < OutputT , RenderingT > renderWorkflowIn (workflow: Workflow < Unit , OutputT , RenderingT >, scope: CoroutineScope, savedStateHandle: SavedStateHandle ? = null, interceptors: List <WorkflowInterceptor> = emptyList(), onOutput: suspend ( OutputT ) -> Unit = {}): StateFlow< RenderingT > An Android ViewModel-friendly wrapper for com.squareup.workflow1.renderWorkflowIn, for use with a workflow that takes no input (that is, has PropsT set to Unit ). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @OptIn(WorkflowUiExperimentalApi::class) class HelloWorkflowActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val model: HelloViewModel by viewModels() setContentView( WorkflowLayout(this).apply { start(model.renderings) } ) } } class HelloViewModel(savedState: SavedStateHandle) : ViewModel() { @OptIn(WorkflowUiExperimentalApi::class) val renderings: StateFlow = renderWorkflowIn( workflow = HelloWorkflow, scope = this.viewModelScope, savedStateHandle = savedState ) } Return \u00b6 A StateFlow of RenderingT s that will emit any time the root workflow creates a new rendering. Parameters \u00b6 androidJvm workflow The root workflow to render. scope The CoroutineScope in which to launch the workflow runtime, typically from the androidx ViewModel.viewModelScope extension. Any exceptions thrown in any workflows, after the initial render pass, will be handled by this scope, and cancelling this scope will cancel the workflow runtime and any running workers. Note that any dispatcher in this scope will not be used to execute the very first render pass. savedStateHandle Used to restore workflow state in a new process. Typically this is the savedState: SavedStateHandle constructor parameter of an androidx ViewModel . interceptors An optional list of WorkflowInterceptors that will wrap every workflow rendered by the runtime. Interceptors will be invoked in 0-to-length order: the interceptor at index 0 will process the workflow first, then the interceptor at index 1, etc. onOutput A function that will be called whenever the root workflow emits an OutputT . This is a suspend function, and is invoked synchronously within the runtime: if it suspends, the workflow runtime will effectively be paused until it returns. This means that it will propagate backpressure if used to forward outputs to a Flow or Channel, for example. [androidJvm]\\ @WorkflowUiExperimentalApi fun < PropsT , OutputT , RenderingT > renderWorkflowIn (workflow: Workflow < PropsT , OutputT , RenderingT >, scope: CoroutineScope, prop: PropsT , savedStateHandle: SavedStateHandle ? = null, interceptors: List <WorkflowInterceptor> = emptyList(), onOutput: suspend ( OutputT ) -> Unit = {}): StateFlow< RenderingT > An Android ViewModel-friendly wrapper for com.squareup.workflow1.renderWorkflowIn, for use with a workflow that requires one input value ( prop ) to run. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @OptIn(WorkflowUiExperimentalApi::class) class HelloNameWorkflowActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val model: HelloNameViewModel by viewModels() setContentView( WorkflowLayout(this).apply { start(model.renderings) } ) } } class HelloNameViewModel(savedState: SavedStateHandle) : ViewModel() { @OptIn(WorkflowUiExperimentalApi::class) val renderings: StateFlow = renderWorkflowIn( workflow = HelloNameWorkflow, scope = this.viewModelScope, savedStateHandle = savedState, prop = \"Your name here!\" ) } Return \u00b6 A StateFlow of RenderingT s that will emit any time the root workflow creates a new rendering. Parameters \u00b6 androidJvm workflow The root workflow to render. scope The CoroutineScope in which to launch the workflow runtime, typically from the androidx ViewModel.viewModelScope extension. Any exceptions thrown in any workflows, after the initial render pass, will be handled by this scope, and cancelling this scope will cancel the workflow runtime and any running workers. Note that any dispatcher in this scope will not be used to execute the very first render pass. prop Specifies the sole PropsT value to use to render the root workflow. To allow updates, use the renderWorkflowIn overload with a props: StateFlow<PropsT> argument instead of this one. savedStateHandle Used to restore workflow state in a new process. Typically this is the savedState: SavedStateHandle constructor parameter of an androidx ViewModel . interceptors An optional list of WorkflowInterceptors that will wrap every workflow rendered by the runtime. Interceptors will be invoked in 0-to-length order: the interceptor at index 0 will process the workflow first, then the interceptor at index 1, etc. onOutput A function that will be called whenever the root workflow emits an OutputT . This is a suspend function, and is invoked synchronously within the runtime: if it suspends, the workflow runtime will effectively be paused until it returns. This means that it will propagate backpressure if used to forward outputs to a Flow or Channel, for example. [androidJvm]\\ @WorkflowUiExperimentalApi fun < PropsT , OutputT , RenderingT > renderWorkflowIn (workflow: Workflow < PropsT , OutputT , RenderingT >, scope: CoroutineScope, props: StateFlow< PropsT >, savedStateHandle: SavedStateHandle ? = null, interceptors: List <WorkflowInterceptor> = emptyList(), onOutput: suspend ( OutputT ) -> Unit = {}): StateFlow< RenderingT > An Android ViewModel-friendly wrapper for com.squareup.workflow1.renderWorkflowIn, for use with a workflow that requires input ( props ) to run. For example, for a workflow that uses android.content.Intent as its PropsT type, you could do something like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 @OptIn(WorkflowUiExperimentalApi::class) class HelloIntentsWorkflowActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val model: HelloIntentsViewModel by viewModels() model.intents.value = intent setContentView( WorkflowLayout(this).apply { start(model.renderings) } ) } override fun onNewIntent(intent: Intent) { super.onNewIntent(intent) val model: HelloIntentsViewModel by viewModels() model.intents.value = intent } } class HelloIntentsViewModel(savedState: SavedStateHandle) : ViewModel() { val intents = MutableStateFlow(Intent()) @OptIn(WorkflowUiExperimentalApi::class) val renderings: StateFlow = renderWorkflowIn( workflow = HelloWorkflow, scope = this.viewModelScope, savedStateHandle = savedState, props = intents ) } Return \u00b6 A StateFlow of RenderingT s that will emit any time the root workflow creates a new rendering. Parameters \u00b6 androidJvm workflow The root workflow to render. scope The CoroutineScope in which to launch the workflow runtime, typically from the androidx ViewModel.viewModelScope extension. Any exceptions thrown in any workflows, after the initial render pass, will be handled by this scope, and cancelling this scope will cancel the workflow runtime and any running workers. Note that any dispatcher in this scope will not be used to execute the very first render pass. props Specifies the initial PropsT to use to render the root workflow, and will cause a re-render when new props are emitted. If this flow completes after emitting at least one value, the runtime will not fail or stop, it will continue running with the last-emitted input. To only pass a single props value, simply create a MutableStateFlow with the value. savedStateHandle Used to restore workflow state in a new process. Typically this is the savedState: SavedStateHandle constructor parameter of an androidx ViewModel . interceptors An optional list of WorkflowInterceptors that will wrap every workflow rendered by the runtime. Interceptors will be invoked in 0-to-length order: the interceptor at index 0 will process the workflow first, then the interceptor at index 1, etc. onOutput A function that will be called whenever the root workflow emits an OutputT . This is a suspend function, and is invoked synchronously within the runtime: if it suspends, the workflow runtime will effectively be paused until it returns. This means that it will propagate backpressure if used to forward outputs to a Flow or Channel, for example.","title":"Render workflow in"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/render-workflow-in/#renderworkflowin","text":"[androidJvm]\\ @WorkflowUiExperimentalApi fun < OutputT , RenderingT > renderWorkflowIn (workflow: Workflow < Unit , OutputT , RenderingT >, scope: CoroutineScope, savedStateHandle: SavedStateHandle ? = null, interceptors: List <WorkflowInterceptor> = emptyList(), onOutput: suspend ( OutputT ) -> Unit = {}): StateFlow< RenderingT > An Android ViewModel-friendly wrapper for com.squareup.workflow1.renderWorkflowIn, for use with a workflow that takes no input (that is, has PropsT set to Unit ). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @OptIn(WorkflowUiExperimentalApi::class) class HelloWorkflowActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val model: HelloViewModel by viewModels() setContentView( WorkflowLayout(this).apply { start(model.renderings) } ) } } class HelloViewModel(savedState: SavedStateHandle) : ViewModel() { @OptIn(WorkflowUiExperimentalApi::class) val renderings: StateFlow = renderWorkflowIn( workflow = HelloWorkflow, scope = this.viewModelScope, savedStateHandle = savedState ) }","title":"renderWorkflowIn"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/render-workflow-in/#return","text":"A StateFlow of RenderingT s that will emit any time the root workflow creates a new rendering.","title":"Return"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/render-workflow-in/#parameters","text":"androidJvm workflow The root workflow to render. scope The CoroutineScope in which to launch the workflow runtime, typically from the androidx ViewModel.viewModelScope extension. Any exceptions thrown in any workflows, after the initial render pass, will be handled by this scope, and cancelling this scope will cancel the workflow runtime and any running workers. Note that any dispatcher in this scope will not be used to execute the very first render pass. savedStateHandle Used to restore workflow state in a new process. Typically this is the savedState: SavedStateHandle constructor parameter of an androidx ViewModel . interceptors An optional list of WorkflowInterceptors that will wrap every workflow rendered by the runtime. Interceptors will be invoked in 0-to-length order: the interceptor at index 0 will process the workflow first, then the interceptor at index 1, etc. onOutput A function that will be called whenever the root workflow emits an OutputT . This is a suspend function, and is invoked synchronously within the runtime: if it suspends, the workflow runtime will effectively be paused until it returns. This means that it will propagate backpressure if used to forward outputs to a Flow or Channel, for example. [androidJvm]\\ @WorkflowUiExperimentalApi fun < PropsT , OutputT , RenderingT > renderWorkflowIn (workflow: Workflow < PropsT , OutputT , RenderingT >, scope: CoroutineScope, prop: PropsT , savedStateHandle: SavedStateHandle ? = null, interceptors: List <WorkflowInterceptor> = emptyList(), onOutput: suspend ( OutputT ) -> Unit = {}): StateFlow< RenderingT > An Android ViewModel-friendly wrapper for com.squareup.workflow1.renderWorkflowIn, for use with a workflow that requires one input value ( prop ) to run. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @OptIn(WorkflowUiExperimentalApi::class) class HelloNameWorkflowActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val model: HelloNameViewModel by viewModels() setContentView( WorkflowLayout(this).apply { start(model.renderings) } ) } } class HelloNameViewModel(savedState: SavedStateHandle) : ViewModel() { @OptIn(WorkflowUiExperimentalApi::class) val renderings: StateFlow = renderWorkflowIn( workflow = HelloNameWorkflow, scope = this.viewModelScope, savedStateHandle = savedState, prop = \"Your name here!\" ) }","title":"Parameters"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/render-workflow-in/#return_1","text":"A StateFlow of RenderingT s that will emit any time the root workflow creates a new rendering.","title":"Return"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/render-workflow-in/#parameters_1","text":"androidJvm workflow The root workflow to render. scope The CoroutineScope in which to launch the workflow runtime, typically from the androidx ViewModel.viewModelScope extension. Any exceptions thrown in any workflows, after the initial render pass, will be handled by this scope, and cancelling this scope will cancel the workflow runtime and any running workers. Note that any dispatcher in this scope will not be used to execute the very first render pass. prop Specifies the sole PropsT value to use to render the root workflow. To allow updates, use the renderWorkflowIn overload with a props: StateFlow<PropsT> argument instead of this one. savedStateHandle Used to restore workflow state in a new process. Typically this is the savedState: SavedStateHandle constructor parameter of an androidx ViewModel . interceptors An optional list of WorkflowInterceptors that will wrap every workflow rendered by the runtime. Interceptors will be invoked in 0-to-length order: the interceptor at index 0 will process the workflow first, then the interceptor at index 1, etc. onOutput A function that will be called whenever the root workflow emits an OutputT . This is a suspend function, and is invoked synchronously within the runtime: if it suspends, the workflow runtime will effectively be paused until it returns. This means that it will propagate backpressure if used to forward outputs to a Flow or Channel, for example. [androidJvm]\\ @WorkflowUiExperimentalApi fun < PropsT , OutputT , RenderingT > renderWorkflowIn (workflow: Workflow < PropsT , OutputT , RenderingT >, scope: CoroutineScope, props: StateFlow< PropsT >, savedStateHandle: SavedStateHandle ? = null, interceptors: List <WorkflowInterceptor> = emptyList(), onOutput: suspend ( OutputT ) -> Unit = {}): StateFlow< RenderingT > An Android ViewModel-friendly wrapper for com.squareup.workflow1.renderWorkflowIn, for use with a workflow that requires input ( props ) to run. For example, for a workflow that uses android.content.Intent as its PropsT type, you could do something like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 @OptIn(WorkflowUiExperimentalApi::class) class HelloIntentsWorkflowActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val model: HelloIntentsViewModel by viewModels() model.intents.value = intent setContentView( WorkflowLayout(this).apply { start(model.renderings) } ) } override fun onNewIntent(intent: Intent) { super.onNewIntent(intent) val model: HelloIntentsViewModel by viewModels() model.intents.value = intent } } class HelloIntentsViewModel(savedState: SavedStateHandle) : ViewModel() { val intents = MutableStateFlow(Intent()) @OptIn(WorkflowUiExperimentalApi::class) val renderings: StateFlow = renderWorkflowIn( workflow = HelloWorkflow, scope = this.viewModelScope, savedStateHandle = savedState, props = intents ) }","title":"Parameters"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/render-workflow-in/#return_2","text":"A StateFlow of RenderingT s that will emit any time the root workflow creates a new rendering.","title":"Return"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/render-workflow-in/#parameters_2","text":"androidJvm workflow The root workflow to render. scope The CoroutineScope in which to launch the workflow runtime, typically from the androidx ViewModel.viewModelScope extension. Any exceptions thrown in any workflows, after the initial render pass, will be handled by this scope, and cancelling this scope will cancel the workflow runtime and any running workers. Note that any dispatcher in this scope will not be used to execute the very first render pass. props Specifies the initial PropsT to use to render the root workflow, and will cause a re-render when new props are emitted. If this flow completes after emitting at least one value, the runtime will not fail or stop, it will continue running with the last-emitted input. To only pass a single props value, simply create a MutableStateFlow with the value. savedStateHandle Used to restore workflow state in a new process. Typically this is the savedState: SavedStateHandle constructor parameter of an androidx ViewModel . interceptors An optional list of WorkflowInterceptors that will wrap every workflow rendered by the runtime. Interceptors will be invoked in 0-to-length order: the interceptor at index 0 will process the workflow first, then the interceptor at index 1, etc. onOutput A function that will be called whenever the root workflow emits an OutputT . This is a suspend function, and is invoked synchronously within the runtime: if it suspends, the workflow runtime will effectively be paused until it returns. This means that it will propagate backpressure if used to forward outputs to a Flow or Channel, for example.","title":"Parameters"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/show-rendering/","text":"// workflow / com.squareup.workflow1.ui / showRendering showRendering \u00b6 [androidJvm]\\ @WorkflowUiExperimentalApi fun < RenderingT : Any > View . showRendering (rendering: RenderingT , viewEnvironment: ViewEnvironment ) It is usually more convenient to call WorkflowViewStub.showRendering than to call this method directly. Shows rendering in this View by invoking the ViewShowRendering function previously set by bindShowRendering . Throws \u00b6 kotlin.IllegalStateException if bindShowRendering has not been called.","title":"Show rendering"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/show-rendering/#showrendering","text":"[androidJvm]\\ @WorkflowUiExperimentalApi fun < RenderingT : Any > View . showRendering (rendering: RenderingT , viewEnvironment: ViewEnvironment ) It is usually more convenient to call WorkflowViewStub.showRendering than to call this method directly. Shows rendering in this View by invoking the ViewShowRendering function previously set by bindShowRendering .","title":"showRendering"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/show-rendering/#throws","text":"kotlin.IllegalStateException if bindShowRendering has not been called.","title":"Throws"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/start/","text":"// workflow / com.squareup.workflow1.ui / start start \u00b6 [androidJvm]\\ @WorkflowUiExperimentalApi fun View . start () Note that WorkflowViewStub calls this method for you. Makes the initial call to View.showRendering , along with any wrappers that have been added via ViewRegistry.buildView , or DecorativeViewFactory.viewStarter. It is an error to call this method more than once. It is an error to call [View.showRendering](show-rendering.md) without having called this method first.","title":"Start"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/start/#start","text":"[androidJvm]\\ @WorkflowUiExperimentalApi fun View . start () Note that WorkflowViewStub calls this method for you. Makes the initial call to View.showRendering , along with any wrappers that have been added via ViewRegistry.buildView , or DecorativeViewFactory.viewStarter. It is an error to call this method more than once. It is an error to call [View.showRendering](show-rendering.md) without having called this method first.","title":"start"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/to-parcelable/","text":"// workflow / com.squareup.workflow1.ui / toParcelable toParcelable \u00b6 [androidJvm]\\ inline fun < T : Parcelable > Snapshot . toParcelable (): T ? Return \u00b6 a Parcelable previously wrapped with toSnapshot , or null if the receiver is empty. [androidJvm]\\ inline fun < T : Parcelable > ByteString. toParcelable (): T","title":"To parcelable"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/to-parcelable/#toparcelable","text":"[androidJvm]\\ inline fun < T : Parcelable > Snapshot . toParcelable (): T ?","title":"toParcelable"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/to-parcelable/#return","text":"a Parcelable previously wrapped with toSnapshot , or null if the receiver is empty. [androidJvm]\\ inline fun < T : Parcelable > ByteString. toParcelable (): T","title":"Return"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/to-snapshot/","text":"// workflow / com.squareup.workflow1.ui / toSnapshot toSnapshot \u00b6 [androidJvm]\\ fun Parcelable . toSnapshot (): Snapshot Wraps receiver in a Snapshot suitable for use with com.squareup.workflow1.StatefulWorkflow. Intended to allow use of @Parcelize. Read the Parcelable back with toParcelable .","title":"To snapshot"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/to-snapshot/#tosnapshot","text":"[androidJvm]\\ fun Parcelable . toSnapshot (): Snapshot Wraps receiver in a Snapshot suitable for use with com.squareup.workflow1.StatefulWorkflow. Intended to allow use of @Parcelize. Read the Parcelable back with toParcelable .","title":"toSnapshot"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-android-view-rendering/","text":"// workflow / com.squareup.workflow1.ui / AndroidViewRendering AndroidViewRendering \u00b6 [androidJvm]\\ @WorkflowUiExperimentalApi interface AndroidViewRendering < V : AndroidViewRendering < V >> Interface implemented by a rendering class to allow it to drive an Android UI via an appropriate ViewFactory implementation. You will rarely, if ever, write a ViewFactory yourself. Instead use LayoutRunner.bind to work with XML layout resources, or BuilderViewFactory to create views from code. See LayoutRunner for more details. 1 2 3 4 5 6 7 8 9 10 @OptIn(WorkflowUiExperimentalApi::class) data class HelloView( val message: String, val onClick: () -> Unit ) : AndroidViewRendering { override val viewFactory: ViewFactory = LayoutRunner.bind(HelloGoodbyeLayoutBinding::inflate) { r, _ ->helloMessage.text = r.message helloMessage.setOnClickListener { r.onClick() } } } This is the simplest way to bridge the gap between your workflows and the UI, but using it requires your workflows code to reside in Android modules, instead of pure Kotlin. If this is a problem, or you need more flexibility for any other reason, you can use ViewRegistry to bind your renderings to ViewFactory implementations at runtime. Properties \u00b6 Name Summary viewFactory [androidJvm] abstract val viewFactory : ViewFactory < V > Used to build instances of android.view.View as needed to display renderings of this type. Inheritors \u00b6 Name ComposeRendering","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-android-view-rendering/#androidviewrendering","text":"[androidJvm]\\ @WorkflowUiExperimentalApi interface AndroidViewRendering < V : AndroidViewRendering < V >> Interface implemented by a rendering class to allow it to drive an Android UI via an appropriate ViewFactory implementation. You will rarely, if ever, write a ViewFactory yourself. Instead use LayoutRunner.bind to work with XML layout resources, or BuilderViewFactory to create views from code. See LayoutRunner for more details. 1 2 3 4 5 6 7 8 9 10 @OptIn(WorkflowUiExperimentalApi::class) data class HelloView( val message: String, val onClick: () -> Unit ) : AndroidViewRendering { override val viewFactory: ViewFactory = LayoutRunner.bind(HelloGoodbyeLayoutBinding::inflate) { r, _ ->helloMessage.text = r.message helloMessage.setOnClickListener { r.onClick() } } } This is the simplest way to bridge the gap between your workflows and the UI, but using it requires your workflows code to reside in Android modules, instead of pure Kotlin. If this is a problem, or you need more flexibility for any other reason, you can use ViewRegistry to bind your renderings to ViewFactory implementations at runtime.","title":"AndroidViewRendering"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-android-view-rendering/#properties","text":"Name Summary viewFactory [androidJvm] abstract val viewFactory : ViewFactory < V > Used to build instances of android.view.View as needed to display renderings of this type.","title":"Properties"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-android-view-rendering/#inheritors","text":"Name ComposeRendering","title":"Inheritors"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-android-view-rendering/view-factory/","text":"// workflow / com.squareup.workflow1.ui / AndroidViewRendering / viewFactory viewFactory \u00b6 [androidJvm]\\ abstract val viewFactory : ViewFactory < V > Used to build instances of android.view.View as needed to display renderings of this type.","title":"View factory"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-android-view-rendering/view-factory/#viewfactory","text":"[androidJvm]\\ abstract val viewFactory : ViewFactory < V > Used to build instances of android.view.View as needed to display renderings of this type.","title":"viewFactory"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-builder-view-factory/","text":"// workflow / com.squareup.workflow1.ui / BuilderViewFactory BuilderViewFactory \u00b6 [androidJvm]\\ @WorkflowUiExperimentalApi class BuilderViewFactory < RenderingT : Any >(type: KClass < RenderingT >, viewConstructor: ( RenderingT , initialViewEnvironment: ViewEnvironment , contextForNewView: Context , container: ViewGroup ?) -> View ) : ViewFactory < RenderingT > A ViewFactory that creates View s that need to be generated from code. (Use LayoutRunner to work with XML layout resources.) 1 2 3 4 5 6 7 8 9 10 11 12 13 data class MyView(): AndroidViewRendering { val viewFactory = BuilderViewFactory( type = MyScreen::class, viewConstructor = { initialRendering, _, context, _ ->MyFrame(context).apply { layoutParams = ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT) bindShowRendering(initialRendering, ::update) } ) } private class MyFrame(context: Context) : FrameLayout(context, attributeSet) { private fun update(rendering: MyView) { ... } } Constructors \u00b6 BuilderViewFactory [androidJvm] fun < RenderingT : Any > BuilderViewFactory (type: KClass < RenderingT >, viewConstructor: ( RenderingT , initialViewEnvironment: ViewEnvironment , contextForNewView: Context , container: ViewGroup ?) -> View ) Functions \u00b6 Name Summary buildView [androidJvm] open override fun buildView (initialRendering: RenderingT , initialViewEnvironment: ViewEnvironment , contextForNewView: Context , container: ViewGroup ?): View Returns a View ready to display initialRendering (and any succeeding values) via View.showRendering . Properties \u00b6 Name Summary type [androidJvm] open override val type : KClass < RenderingT >","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-builder-view-factory/#builderviewfactory","text":"[androidJvm]\\ @WorkflowUiExperimentalApi class BuilderViewFactory < RenderingT : Any >(type: KClass < RenderingT >, viewConstructor: ( RenderingT , initialViewEnvironment: ViewEnvironment , contextForNewView: Context , container: ViewGroup ?) -> View ) : ViewFactory < RenderingT > A ViewFactory that creates View s that need to be generated from code. (Use LayoutRunner to work with XML layout resources.) 1 2 3 4 5 6 7 8 9 10 11 12 13 data class MyView(): AndroidViewRendering { val viewFactory = BuilderViewFactory( type = MyScreen::class, viewConstructor = { initialRendering, _, context, _ ->MyFrame(context).apply { layoutParams = ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT) bindShowRendering(initialRendering, ::update) } ) } private class MyFrame(context: Context) : FrameLayout(context, attributeSet) { private fun update(rendering: MyView) { ... } }","title":"BuilderViewFactory"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-builder-view-factory/#constructors","text":"BuilderViewFactory [androidJvm] fun < RenderingT : Any > BuilderViewFactory (type: KClass < RenderingT >, viewConstructor: ( RenderingT , initialViewEnvironment: ViewEnvironment , contextForNewView: Context , container: ViewGroup ?) -> View )","title":"Constructors"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-builder-view-factory/#functions","text":"Name Summary buildView [androidJvm] open override fun buildView (initialRendering: RenderingT , initialViewEnvironment: ViewEnvironment , contextForNewView: Context , container: ViewGroup ?): View Returns a View ready to display initialRendering (and any succeeding values) via View.showRendering .","title":"Functions"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-builder-view-factory/#properties","text":"Name Summary type [androidJvm] open override val type : KClass < RenderingT >","title":"Properties"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-builder-view-factory/-builder-view-factory/","text":"// workflow / com.squareup.workflow1.ui / BuilderViewFactory / BuilderViewFactory BuilderViewFactory \u00b6 [androidJvm]\\ fun < RenderingT : Any > BuilderViewFactory (type: KClass < RenderingT >, viewConstructor: ( RenderingT , initialViewEnvironment: ViewEnvironment , contextForNewView: Context , container: ViewGroup ?) -> View )","title":" builder view factory"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-builder-view-factory/-builder-view-factory/#builderviewfactory","text":"[androidJvm]\\ fun < RenderingT : Any > BuilderViewFactory (type: KClass < RenderingT >, viewConstructor: ( RenderingT , initialViewEnvironment: ViewEnvironment , contextForNewView: Context , container: ViewGroup ?) -> View )","title":"BuilderViewFactory"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-builder-view-factory/build-view/","text":"// workflow / com.squareup.workflow1.ui / BuilderViewFactory / buildView buildView \u00b6 [androidJvm]\\ open override fun buildView (initialRendering: RenderingT , initialViewEnvironment: ViewEnvironment , contextForNewView: Context , container: ViewGroup ?): View Returns a View ready to display initialRendering (and any succeeding values) via View.showRendering .","title":"Build view"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-builder-view-factory/build-view/#buildview","text":"[androidJvm]\\ open override fun buildView (initialRendering: RenderingT , initialViewEnvironment: ViewEnvironment , contextForNewView: Context , container: ViewGroup ?): View Returns a View ready to display initialRendering (and any succeeding values) via View.showRendering .","title":"buildView"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-builder-view-factory/type/","text":"// workflow / com.squareup.workflow1.ui / BuilderViewFactory / type type \u00b6 [androidJvm]\\ open override val type : KClass < RenderingT >","title":"Type"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-builder-view-factory/type/#type","text":"[androidJvm]\\ open override val type : KClass < RenderingT >","title":"type"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-compatible/","text":"// workflow / com.squareup.workflow1.ui / Compatible Compatible \u00b6 [jvm]\\ @ WorkflowUiExperimentalApi interface Compatible Implemented by objects whose compatibility requires more nuance than just being of the same type. Renderings that don\u2019t implement this interface directly can be distinguished by wrapping them with Named . Types \u00b6 Name Summary Companion [jvm] object Companion Properties \u00b6 Name Summary compatibilityKey [jvm] abstract val compatibilityKey : String Instances of the same type are compatible iff they have the same compatibilityKey . Inheritors \u00b6 Name Named","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-compatible/#compatible","text":"[jvm]\\ @ WorkflowUiExperimentalApi interface Compatible Implemented by objects whose compatibility requires more nuance than just being of the same type. Renderings that don\u2019t implement this interface directly can be distinguished by wrapping them with Named .","title":"Compatible"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-compatible/#types","text":"Name Summary Companion [jvm] object Companion","title":"Types"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-compatible/#properties","text":"Name Summary compatibilityKey [jvm] abstract val compatibilityKey : String Instances of the same type are compatible iff they have the same compatibilityKey .","title":"Properties"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-compatible/#inheritors","text":"Name Named","title":"Inheritors"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-compatible/compatibility-key/","text":"// workflow / com.squareup.workflow1.ui / Compatible / compatibilityKey compatibilityKey \u00b6 [jvm]\\ abstract val compatibilityKey : String Instances of the same type are compatible iff they have the same compatibilityKey .","title":"Compatibility key"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-compatible/compatibility-key/#compatibilitykey","text":"[jvm]\\ abstract val compatibilityKey : String Instances of the same type are compatible iff they have the same compatibilityKey .","title":"compatibilityKey"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-compatible/-companion/","text":"// workflow / com.squareup.workflow1.ui / Compatible / Companion Companion \u00b6 [jvm]\\ object Companion Functions \u00b6 Name Summary keyFor [jvm] fun keyFor (value: Any , name: String = \u201c\u201d): String Calculates a suitable Compatible.compatibilityKey for a given value and name .","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-compatible/-companion/#companion","text":"[jvm]\\ object Companion","title":"Companion"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-compatible/-companion/#functions","text":"Name Summary keyFor [jvm] fun keyFor (value: Any , name: String = \u201c\u201d): String Calculates a suitable Compatible.compatibilityKey for a given value and name .","title":"Functions"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-compatible/-companion/key-for/","text":"// workflow / com.squareup.workflow1.ui / Compatible / Companion / keyFor keyFor \u00b6 [jvm]\\ fun keyFor (value: Any , name: String = \u201c\u201d): String Calculates a suitable Compatible.compatibilityKey for a given value and name .","title":"Key for"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-compatible/-companion/key-for/#keyfor","text":"[jvm]\\ fun keyFor (value: Any , name: String = \u201c\u201d): String Calculates a suitable Compatible.compatibilityKey for a given value and name .","title":"keyFor"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-decorative-view-factory/","text":"// workflow / com.squareup.workflow1.ui / DecorativeViewFactory DecorativeViewFactory \u00b6 [androidJvm]\\ @WorkflowUiExperimentalApi class DecorativeViewFactory < OuterT : Any , InnerT : Any >(type: KClass < OuterT >, map: ( OuterT , ViewEnvironment ) -> Pair < InnerT , ViewEnvironment >, viewStarter: ViewStarter ?, doShowRendering: (view: View , ViewShowRendering < InnerT >, OuterT , env: ViewEnvironment ) -> Unit ) : ViewFactory < OuterT > A ViewFactory for OuterT that delegates view construction responsibilities to the factory registered for InnerT . Makes it convenient for OuterT to wrap instances of InnerT to add information or behavior, without requiring wasteful wrapping in the view system. One general note: when creating a wrapper rendering, you\u2019re very likely to want it to implement Compatible, to ensure that checks made to update or replace a view are based on the wrapped item. Each example below illustrates this. Examples \u00b6 To make one rendering type an \u201calias\u201d for another \u2013 that is, to use the same ViewFactory to display it \u2013 provide nothing but a single-arg mapping function: 1 2 3 4 5 6 7 class OriginalRendering(val data: String) : AndroidViewRendering {...} class AliasRendering(val similarData: String) object DecorativeViewFactory : ViewFactory by DecorativeViewFactory( type = AliasRendering::class, map = { alias -> OriginalRendering(alias.similarData) } ) To make a decorator type that adds information to the ViewEnvironment : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class NeutronFlowPolarity(val reversed: Boolean) { companion object : ViewEnvironmentKey(NeutronFlowPolarity::class) { override val default: NeutronFlowPolarity = NeutronFlowPolarity(reversed = false) } } class NeutronFlowPolarityOverride( val wrapped: W, val polarity: NeutronFlowPolarity ) : Compatible { override val compatibilityKey: String = Compatible.keyFor(wrapped) } object NeutronFlowPolarityViewFactory : ViewFactory<*>>by DecorativeViewFactory( type = NeutronFlowPolarityOverride::class, map = { override, env ->Pair(override.wrapped, env + (NeutronFlowPolarity to override.polarity)) } ) To make a decorator type that customizes View initialization: 1 2 3 4 5 6 7 8 9 10 11 class WithTutorialTips(val wrapped: W) : Compatible { override val compatibilityKey: String = Compatible.keyFor(wrapped) } object WithTutorialTipsViewFactory : ViewFactory<*>>by DecorativeViewFactory( type = WithTutorialTips::class, map = { withTips -> withTips.wrapped }, viewStarter = { view, doStart ->TutorialTipRunner.run(view) doStart() } ) To make a decorator type that adds pre- or post-processing to View updates: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class BackButtonScreen( val wrapped: W, val override: Boolean = false, val onBackPressed: (() -> Unit)? = null ) : Compatible { override val compatibilityKey: String = Compatible.keyFor(wrapped) } object BackButtonViewFactory : ViewFactory<*>>by DecorativeViewFactory( type = BackButtonScreen::class, map = { outer -> outer.wrapped }, doShowRendering = { view, innerShowRendering, outerRendering, viewEnvironment ->if (!outerRendering.override) { // Place our handler before invoking innerShowRendering, so that // its later calls to view.backPressedHandler will take precedence // over ours. view.backPressedHandler = outerRendering.onBackPressed } innerShowRendering.invoke(outerRendering.wrapped, viewEnvironment) if (outerRendering.override) { // Place our handler after invoking innerShowRendering, so that ours wins. view.backPressedHandler = outerRendering.onBackPressed } }) Parameters \u00b6 androidJvm map called to convert instances of OuterT to InnerT , and to allow ViewEnvironment to be transformed. viewStarter An optional wrapper for the function invoked when View.start is called, allowing for last second initialization of a newly built View . See ViewStarter for details. doShowRendering called to apply the ViewShowRendering function for InnerT , allowing pre- and post-processing. Default implementation simply uses map to extract the InnerT instance from OuterT and makes the function call. Constructors \u00b6 DecorativeViewFactory [androidJvm] fun < OuterT : Any , InnerT : Any > DecorativeViewFactory (type: KClass < OuterT >, map: ( OuterT ) -> InnerT , viewStarter: ViewStarter ? = null, doShowRendering: (view: View , ViewShowRendering < InnerT >, OuterT , env: ViewEnvironment ) -> Unit = { _, innerShowRendering, outerRendering, viewEnvironment -> innerShowRendering(map(outerRendering), viewEnvironment) }) Convenience constructor for cases requiring no changes to the ViewEnvironment . DecorativeViewFactory [androidJvm] fun < OuterT : Any , InnerT : Any > DecorativeViewFactory (type: KClass < OuterT >, map: ( OuterT , ViewEnvironment ) -> Pair < InnerT , ViewEnvironment >, viewStarter: ViewStarter ? = null, doShowRendering: (view: View , ViewShowRendering < InnerT >, OuterT , env: ViewEnvironment ) -> Unit = { _, innerShowRendering, outerRendering, viewEnvironment -> val (innerRendering, processedEnv) = map(outerRendering, viewEnvironment) innerShowRendering(innerRendering, processedEnv) }) Functions \u00b6 Name Summary buildView [androidJvm] open override fun buildView (initialRendering: OuterT , initialViewEnvironment: ViewEnvironment , contextForNewView: Context , container: ViewGroup ?): View Returns a View ready to display initialRendering (and any succeeding values) via View.showRendering . Properties \u00b6 Name Summary type [androidJvm] open override val type : KClass < OuterT >","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-decorative-view-factory/#decorativeviewfactory","text":"[androidJvm]\\ @WorkflowUiExperimentalApi class DecorativeViewFactory < OuterT : Any , InnerT : Any >(type: KClass < OuterT >, map: ( OuterT , ViewEnvironment ) -> Pair < InnerT , ViewEnvironment >, viewStarter: ViewStarter ?, doShowRendering: (view: View , ViewShowRendering < InnerT >, OuterT , env: ViewEnvironment ) -> Unit ) : ViewFactory < OuterT > A ViewFactory for OuterT that delegates view construction responsibilities to the factory registered for InnerT . Makes it convenient for OuterT to wrap instances of InnerT to add information or behavior, without requiring wasteful wrapping in the view system. One general note: when creating a wrapper rendering, you\u2019re very likely to want it to implement Compatible, to ensure that checks made to update or replace a view are based on the wrapped item. Each example below illustrates this.","title":"DecorativeViewFactory"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-decorative-view-factory/#examples","text":"To make one rendering type an \u201calias\u201d for another \u2013 that is, to use the same ViewFactory to display it \u2013 provide nothing but a single-arg mapping function: 1 2 3 4 5 6 7 class OriginalRendering(val data: String) : AndroidViewRendering {...} class AliasRendering(val similarData: String) object DecorativeViewFactory : ViewFactory by DecorativeViewFactory( type = AliasRendering::class, map = { alias -> OriginalRendering(alias.similarData) } ) To make a decorator type that adds information to the ViewEnvironment : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class NeutronFlowPolarity(val reversed: Boolean) { companion object : ViewEnvironmentKey(NeutronFlowPolarity::class) { override val default: NeutronFlowPolarity = NeutronFlowPolarity(reversed = false) } } class NeutronFlowPolarityOverride( val wrapped: W, val polarity: NeutronFlowPolarity ) : Compatible { override val compatibilityKey: String = Compatible.keyFor(wrapped) } object NeutronFlowPolarityViewFactory : ViewFactory<*>>by DecorativeViewFactory( type = NeutronFlowPolarityOverride::class, map = { override, env ->Pair(override.wrapped, env + (NeutronFlowPolarity to override.polarity)) } ) To make a decorator type that customizes View initialization: 1 2 3 4 5 6 7 8 9 10 11 class WithTutorialTips(val wrapped: W) : Compatible { override val compatibilityKey: String = Compatible.keyFor(wrapped) } object WithTutorialTipsViewFactory : ViewFactory<*>>by DecorativeViewFactory( type = WithTutorialTips::class, map = { withTips -> withTips.wrapped }, viewStarter = { view, doStart ->TutorialTipRunner.run(view) doStart() } ) To make a decorator type that adds pre- or post-processing to View updates: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class BackButtonScreen( val wrapped: W, val override: Boolean = false, val onBackPressed: (() -> Unit)? = null ) : Compatible { override val compatibilityKey: String = Compatible.keyFor(wrapped) } object BackButtonViewFactory : ViewFactory<*>>by DecorativeViewFactory( type = BackButtonScreen::class, map = { outer -> outer.wrapped }, doShowRendering = { view, innerShowRendering, outerRendering, viewEnvironment ->if (!outerRendering.override) { // Place our handler before invoking innerShowRendering, so that // its later calls to view.backPressedHandler will take precedence // over ours. view.backPressedHandler = outerRendering.onBackPressed } innerShowRendering.invoke(outerRendering.wrapped, viewEnvironment) if (outerRendering.override) { // Place our handler after invoking innerShowRendering, so that ours wins. view.backPressedHandler = outerRendering.onBackPressed } })","title":"Examples"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-decorative-view-factory/#parameters","text":"androidJvm map called to convert instances of OuterT to InnerT , and to allow ViewEnvironment to be transformed. viewStarter An optional wrapper for the function invoked when View.start is called, allowing for last second initialization of a newly built View . See ViewStarter for details. doShowRendering called to apply the ViewShowRendering function for InnerT , allowing pre- and post-processing. Default implementation simply uses map to extract the InnerT instance from OuterT and makes the function call.","title":"Parameters"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-decorative-view-factory/#constructors","text":"DecorativeViewFactory [androidJvm] fun < OuterT : Any , InnerT : Any > DecorativeViewFactory (type: KClass < OuterT >, map: ( OuterT ) -> InnerT , viewStarter: ViewStarter ? = null, doShowRendering: (view: View , ViewShowRendering < InnerT >, OuterT , env: ViewEnvironment ) -> Unit = { _, innerShowRendering, outerRendering, viewEnvironment -> innerShowRendering(map(outerRendering), viewEnvironment) }) Convenience constructor for cases requiring no changes to the ViewEnvironment . DecorativeViewFactory [androidJvm] fun < OuterT : Any , InnerT : Any > DecorativeViewFactory (type: KClass < OuterT >, map: ( OuterT , ViewEnvironment ) -> Pair < InnerT , ViewEnvironment >, viewStarter: ViewStarter ? = null, doShowRendering: (view: View , ViewShowRendering < InnerT >, OuterT , env: ViewEnvironment ) -> Unit = { _, innerShowRendering, outerRendering, viewEnvironment -> val (innerRendering, processedEnv) = map(outerRendering, viewEnvironment) innerShowRendering(innerRendering, processedEnv) })","title":"Constructors"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-decorative-view-factory/#functions","text":"Name Summary buildView [androidJvm] open override fun buildView (initialRendering: OuterT , initialViewEnvironment: ViewEnvironment , contextForNewView: Context , container: ViewGroup ?): View Returns a View ready to display initialRendering (and any succeeding values) via View.showRendering .","title":"Functions"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-decorative-view-factory/#properties","text":"Name Summary type [androidJvm] open override val type : KClass < OuterT >","title":"Properties"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-decorative-view-factory/-decorative-view-factory/","text":"// workflow / com.squareup.workflow1.ui / DecorativeViewFactory / DecorativeViewFactory DecorativeViewFactory \u00b6 [androidJvm]\\ fun < OuterT : Any , InnerT : Any > DecorativeViewFactory (type: KClass < OuterT >, map: ( OuterT ) -> InnerT , viewStarter: ViewStarter ? = null, doShowRendering: (view: View , ViewShowRendering < InnerT >, OuterT , env: ViewEnvironment ) -> Unit = { _, innerShowRendering, outerRendering, viewEnvironment -> innerShowRendering(map(outerRendering), viewEnvironment) }) Convenience constructor for cases requiring no changes to the ViewEnvironment . [androidJvm]\\ fun < OuterT : Any , InnerT : Any > DecorativeViewFactory (type: KClass < OuterT >, map: ( OuterT , ViewEnvironment ) -> Pair < InnerT , ViewEnvironment >, viewStarter: ViewStarter ? = null, doShowRendering: (view: View , ViewShowRendering < InnerT >, OuterT , env: ViewEnvironment ) -> Unit = { _, innerShowRendering, outerRendering, viewEnvironment -> val (innerRendering, processedEnv) = map(outerRendering, viewEnvironment) innerShowRendering(innerRendering, processedEnv) }) Parameters \u00b6 androidJvm map called to convert instances of OuterT to InnerT , and to allow ViewEnvironment to be transformed. viewStarter An optional wrapper for the function invoked when View.start is called, allowing for last second initialization of a newly built View . See ViewStarter for details. doShowRendering called to apply the ViewShowRendering function for InnerT , allowing pre- and post-processing. Default implementation simply uses map to extract the InnerT instance from OuterT and makes the function call.","title":" decorative view factory"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-decorative-view-factory/-decorative-view-factory/#decorativeviewfactory","text":"[androidJvm]\\ fun < OuterT : Any , InnerT : Any > DecorativeViewFactory (type: KClass < OuterT >, map: ( OuterT ) -> InnerT , viewStarter: ViewStarter ? = null, doShowRendering: (view: View , ViewShowRendering < InnerT >, OuterT , env: ViewEnvironment ) -> Unit = { _, innerShowRendering, outerRendering, viewEnvironment -> innerShowRendering(map(outerRendering), viewEnvironment) }) Convenience constructor for cases requiring no changes to the ViewEnvironment . [androidJvm]\\ fun < OuterT : Any , InnerT : Any > DecorativeViewFactory (type: KClass < OuterT >, map: ( OuterT , ViewEnvironment ) -> Pair < InnerT , ViewEnvironment >, viewStarter: ViewStarter ? = null, doShowRendering: (view: View , ViewShowRendering < InnerT >, OuterT , env: ViewEnvironment ) -> Unit = { _, innerShowRendering, outerRendering, viewEnvironment -> val (innerRendering, processedEnv) = map(outerRendering, viewEnvironment) innerShowRendering(innerRendering, processedEnv) })","title":"DecorativeViewFactory"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-decorative-view-factory/-decorative-view-factory/#parameters","text":"androidJvm map called to convert instances of OuterT to InnerT , and to allow ViewEnvironment to be transformed. viewStarter An optional wrapper for the function invoked when View.start is called, allowing for last second initialization of a newly built View . See ViewStarter for details. doShowRendering called to apply the ViewShowRendering function for InnerT , allowing pre- and post-processing. Default implementation simply uses map to extract the InnerT instance from OuterT and makes the function call.","title":"Parameters"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-decorative-view-factory/build-view/","text":"// workflow / com.squareup.workflow1.ui / DecorativeViewFactory / buildView buildView \u00b6 [androidJvm]\\ open override fun buildView (initialRendering: OuterT , initialViewEnvironment: ViewEnvironment , contextForNewView: Context , container: ViewGroup ?): View Returns a View ready to display initialRendering (and any succeeding values) via View.showRendering .","title":"Build view"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-decorative-view-factory/build-view/#buildview","text":"[androidJvm]\\ open override fun buildView (initialRendering: OuterT , initialViewEnvironment: ViewEnvironment , contextForNewView: Context , container: ViewGroup ?): View Returns a View ready to display initialRendering (and any succeeding values) via View.showRendering .","title":"buildView"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-decorative-view-factory/type/","text":"// workflow / com.squareup.workflow1.ui / DecorativeViewFactory / type type \u00b6 [androidJvm]\\ open override val type : KClass < OuterT >","title":"Type"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-decorative-view-factory/type/#type","text":"[androidJvm]\\ open override val type : KClass < OuterT >","title":"type"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-layout-runner/","text":"// workflow / com.squareup.workflow1.ui / LayoutRunner LayoutRunner \u00b6 [androidJvm]\\ @WorkflowUiExperimentalApi fun interface LayoutRunner < RenderingT : Any > A delegate that implements a showRendering method to be called when a workflow rendering of type RenderingT is ready to be displayed in a view inflated from a layout resource by a ViewRegistry . (Use BuilderViewFactory if you want to build views from code rather than layouts.) If you\u2019re using AndroidX ViewBinding you likely won\u2019t need to implement this interface at all. For details, see the three overloads of LayoutRunner.bind . Types \u00b6 Name Summary Companion [androidJvm] object Companion Functions \u00b6 Name Summary showRendering [androidJvm] abstract fun showRendering (rendering: RenderingT , viewEnvironment: ViewEnvironment )","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-layout-runner/#layoutrunner","text":"[androidJvm]\\ @WorkflowUiExperimentalApi fun interface LayoutRunner < RenderingT : Any > A delegate that implements a showRendering method to be called when a workflow rendering of type RenderingT is ready to be displayed in a view inflated from a layout resource by a ViewRegistry . (Use BuilderViewFactory if you want to build views from code rather than layouts.) If you\u2019re using AndroidX ViewBinding you likely won\u2019t need to implement this interface at all. For details, see the three overloads of LayoutRunner.bind .","title":"LayoutRunner"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-layout-runner/#types","text":"Name Summary Companion [androidJvm] object Companion","title":"Types"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-layout-runner/#functions","text":"Name Summary showRendering [androidJvm] abstract fun showRendering (rendering: RenderingT , viewEnvironment: ViewEnvironment )","title":"Functions"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-layout-runner/show-rendering/","text":"// workflow / com.squareup.workflow1.ui / LayoutRunner / showRendering showRendering \u00b6 [androidJvm]\\ abstract fun showRendering (rendering: RenderingT , viewEnvironment: ViewEnvironment )","title":"Show rendering"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-layout-runner/show-rendering/#showrendering","text":"[androidJvm]\\ abstract fun showRendering (rendering: RenderingT , viewEnvironment: ViewEnvironment )","title":"showRendering"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-layout-runner/-companion/","text":"// workflow / com.squareup.workflow1.ui / LayoutRunner / Companion Companion \u00b6 [androidJvm]\\ object Companion Functions \u00b6 Name Summary bind [androidJvm] inline fun < BindingT : ViewBinding, RenderingT : Any > bind (noinline bindingInflater: ViewBindingInflater < BindingT >, noinline constructor: ( BindingT ) -> LayoutRunner < RenderingT >): ViewFactory < RenderingT > Creates a ViewFactory that inflates a ViewBinding ( BindingT ) to show renderings of type RenderingT , using a LayoutRunner created by constructor . Handy if you need to perform some set up before showRendering is called. [androidJvm] inline fun < BindingT : ViewBinding, RenderingT : Any > bind (noinline bindingInflater: ViewBindingInflater < BindingT >, crossinline showRendering: BindingT .( RenderingT , ViewEnvironment ) -> Unit ): ViewFactory < RenderingT > Creates a ViewFactory that inflates a ViewBinding ( BindingT ) to show renderings of type RenderingT , using a lambda . [androidJvm] inline fun < RenderingT : Any > bind (@ LayoutRes layoutId: Int , noinline constructor: ( View ) -> LayoutRunner < RenderingT >): ViewFactory < RenderingT > Creates a ViewFactory that inflates layoutId to show renderings of type RenderingT , using a LayoutRunner created by constructor . Avoids any use of AndroidX ViewBinding. bindNoRunner [androidJvm] inline fun < RenderingT : Any > bindNoRunner (@ LayoutRes layoutId: Int ): ViewFactory < RenderingT > Creates a ViewFactory that inflates layoutId to \u201cshow\u201d renderings of type RenderingT , with a no-op LayoutRunner . Handy for showing static views, e.g. when prototyping.","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-layout-runner/-companion/#companion","text":"[androidJvm]\\ object Companion","title":"Companion"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-layout-runner/-companion/#functions","text":"Name Summary bind [androidJvm] inline fun < BindingT : ViewBinding, RenderingT : Any > bind (noinline bindingInflater: ViewBindingInflater < BindingT >, noinline constructor: ( BindingT ) -> LayoutRunner < RenderingT >): ViewFactory < RenderingT > Creates a ViewFactory that inflates a ViewBinding ( BindingT ) to show renderings of type RenderingT , using a LayoutRunner created by constructor . Handy if you need to perform some set up before showRendering is called. [androidJvm] inline fun < BindingT : ViewBinding, RenderingT : Any > bind (noinline bindingInflater: ViewBindingInflater < BindingT >, crossinline showRendering: BindingT .( RenderingT , ViewEnvironment ) -> Unit ): ViewFactory < RenderingT > Creates a ViewFactory that inflates a ViewBinding ( BindingT ) to show renderings of type RenderingT , using a lambda . [androidJvm] inline fun < RenderingT : Any > bind (@ LayoutRes layoutId: Int , noinline constructor: ( View ) -> LayoutRunner < RenderingT >): ViewFactory < RenderingT > Creates a ViewFactory that inflates layoutId to show renderings of type RenderingT , using a LayoutRunner created by constructor . Avoids any use of AndroidX ViewBinding. bindNoRunner [androidJvm] inline fun < RenderingT : Any > bindNoRunner (@ LayoutRes layoutId: Int ): ViewFactory < RenderingT > Creates a ViewFactory that inflates layoutId to \u201cshow\u201d renderings of type RenderingT , with a no-op LayoutRunner . Handy for showing static views, e.g. when prototyping.","title":"Functions"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-layout-runner/-companion/bind-no-runner/","text":"// workflow / com.squareup.workflow1.ui / LayoutRunner / Companion / bindNoRunner bindNoRunner \u00b6 [androidJvm]\\ inline fun < RenderingT : Any > bindNoRunner (@ LayoutRes layoutId: Int ): ViewFactory < RenderingT > Creates a ViewFactory that inflates layoutId to \u201cshow\u201d renderings of type RenderingT , with a no-op LayoutRunner . Handy for showing static views, e.g. when prototyping.","title":"Bind no runner"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-layout-runner/-companion/bind-no-runner/#bindnorunner","text":"[androidJvm]\\ inline fun < RenderingT : Any > bindNoRunner (@ LayoutRes layoutId: Int ): ViewFactory < RenderingT > Creates a ViewFactory that inflates layoutId to \u201cshow\u201d renderings of type RenderingT , with a no-op LayoutRunner . Handy for showing static views, e.g. when prototyping.","title":"bindNoRunner"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-layout-runner/-companion/bind/","text":"// workflow / com.squareup.workflow1.ui / LayoutRunner / Companion / bind bind \u00b6 [androidJvm]\\ inline fun < BindingT : ViewBinding, RenderingT : Any > bind (noinline bindingInflater: ViewBindingInflater < BindingT >, crossinline showRendering: BindingT .( RenderingT , ViewEnvironment ) -> Unit ): ViewFactory < RenderingT > Creates a ViewFactory that inflates a ViewBinding ( BindingT ) to show renderings of type RenderingT , using a lambda . 1 2 3 4 val HelloBinding: ViewFactory = LayoutRunner.bind(HelloGoodbyeLayoutBinding::inflate) { rendering, viewEnvironment ->helloMessage.text = rendering.message helloMessage.setOnClickListener { rendering.onClick(Unit) } } If you need to initialize your view before showRendering is called, implement LayoutRunner and create a binding using the bind variant that accepts a (ViewBinding) -> LayoutRunner function, below. [androidJvm]\\ inline fun < BindingT : ViewBinding, RenderingT : Any > bind (noinline bindingInflater: ViewBindingInflater < BindingT >, noinline constructor: ( BindingT ) -> LayoutRunner < RenderingT >): ViewFactory < RenderingT > Creates a ViewFactory that inflates a ViewBinding ( BindingT ) to show renderings of type RenderingT , using a LayoutRunner created by constructor . Handy if you need to perform some set up before showRendering is called. class HelloLayoutRunner( private val binding: HelloGoodbyeLayoutBinding ) : LayoutRunner { 1 2 3 4 5 6 7 8 override fun showRendering(rendering: Rendering) { binding.messageView.text = rendering.message binding.messageView.setOnClickListener { rendering.onClick(Unit) } } companion object : ViewFactory by bind( HelloGoodbyeLayoutBinding::inflate, ::HelloLayoutRunner ) } If the view doesn\u2019t need to be initialized before showRendering is called, use the variant above which just takes a lambda. [androidJvm]\\ inline fun < RenderingT : Any > bind (@ LayoutRes layoutId: Int , noinline constructor: ( View ) -> LayoutRunner < RenderingT >): ViewFactory < RenderingT > Creates a ViewFactory that inflates layoutId to show renderings of type RenderingT , using a LayoutRunner created by constructor . Avoids any use of AndroidX ViewBinding.","title":"Bind"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-layout-runner/-companion/bind/#bind","text":"[androidJvm]\\ inline fun < BindingT : ViewBinding, RenderingT : Any > bind (noinline bindingInflater: ViewBindingInflater < BindingT >, crossinline showRendering: BindingT .( RenderingT , ViewEnvironment ) -> Unit ): ViewFactory < RenderingT > Creates a ViewFactory that inflates a ViewBinding ( BindingT ) to show renderings of type RenderingT , using a lambda . 1 2 3 4 val HelloBinding: ViewFactory = LayoutRunner.bind(HelloGoodbyeLayoutBinding::inflate) { rendering, viewEnvironment ->helloMessage.text = rendering.message helloMessage.setOnClickListener { rendering.onClick(Unit) } } If you need to initialize your view before showRendering is called, implement LayoutRunner and create a binding using the bind variant that accepts a (ViewBinding) -> LayoutRunner function, below. [androidJvm]\\ inline fun < BindingT : ViewBinding, RenderingT : Any > bind (noinline bindingInflater: ViewBindingInflater < BindingT >, noinline constructor: ( BindingT ) -> LayoutRunner < RenderingT >): ViewFactory < RenderingT > Creates a ViewFactory that inflates a ViewBinding ( BindingT ) to show renderings of type RenderingT , using a LayoutRunner created by constructor . Handy if you need to perform some set up before showRendering is called. class HelloLayoutRunner( private val binding: HelloGoodbyeLayoutBinding ) : LayoutRunner { 1 2 3 4 5 6 7 8 override fun showRendering(rendering: Rendering) { binding.messageView.text = rendering.message binding.messageView.setOnClickListener { rendering.onClick(Unit) } } companion object : ViewFactory by bind( HelloGoodbyeLayoutBinding::inflate, ::HelloLayoutRunner ) } If the view doesn\u2019t need to be initialized before showRendering is called, use the variant above which just takes a lambda. [androidJvm]\\ inline fun < RenderingT : Any > bind (@ LayoutRes layoutId: Int , noinline constructor: ( View ) -> LayoutRunner < RenderingT >): ViewFactory < RenderingT > Creates a ViewFactory that inflates layoutId to show renderings of type RenderingT , using a LayoutRunner created by constructor . Avoids any use of AndroidX ViewBinding.","title":"bind"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-named/","text":"// workflow / com.squareup.workflow1.ui / Named Named \u00b6 [jvm]\\ @ WorkflowUiExperimentalApi data class Named < W : Any >(wrapped: W , name: String ) : Compatible Allows renderings that do not implement Compatible themselves to be distinguished by more than just their type. Instances are compatible if they have the same name and have compatible fields. Constructors \u00b6 Named [jvm] fun < W : Any > Named (wrapped: W , name: String ) Functions \u00b6 Name Summary toString [jvm] open override fun toString (): String Properties \u00b6 Name Summary compatibilityKey [jvm] open override val compatibilityKey : String Instances of the same type are compatible iff they have the same compatibilityKey . name [jvm] val name : String wrapped [jvm] val wrapped : W","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-named/#named","text":"[jvm]\\ @ WorkflowUiExperimentalApi data class Named < W : Any >(wrapped: W , name: String ) : Compatible Allows renderings that do not implement Compatible themselves to be distinguished by more than just their type. Instances are compatible if they have the same name and have compatible fields.","title":"Named"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-named/#constructors","text":"Named [jvm] fun < W : Any > Named (wrapped: W , name: String )","title":"Constructors"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-named/#functions","text":"Name Summary toString [jvm] open override fun toString (): String","title":"Functions"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-named/#properties","text":"Name Summary compatibilityKey [jvm] open override val compatibilityKey : String Instances of the same type are compatible iff they have the same compatibilityKey . name [jvm] val name : String wrapped [jvm] val wrapped : W","title":"Properties"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-named/-named/","text":"// workflow / com.squareup.workflow1.ui / Named / Named Named \u00b6 [jvm]\\ fun < W : Any > Named (wrapped: W , name: String )","title":" named"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-named/-named/#named","text":"[jvm]\\ fun < W : Any > Named (wrapped: W , name: String )","title":"Named"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-named/compatibility-key/","text":"// workflow / com.squareup.workflow1.ui / Named / compatibilityKey compatibilityKey \u00b6 [jvm]\\ open override val compatibilityKey : String Instances of the same type are compatible iff they have the same compatibilityKey .","title":"Compatibility key"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-named/compatibility-key/#compatibilitykey","text":"[jvm]\\ open override val compatibilityKey : String Instances of the same type are compatible iff they have the same compatibilityKey .","title":"compatibilityKey"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-named/name/","text":"// workflow / com.squareup.workflow1.ui / Named / name name \u00b6 [jvm]\\ val name : String","title":"Name"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-named/name/#name","text":"[jvm]\\ val name : String","title":"name"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-named/to-string/","text":"// workflow / com.squareup.workflow1.ui / Named / toString toString \u00b6 [jvm]\\ open override fun toString (): String","title":"To string"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-named/to-string/#tostring","text":"[jvm]\\ open override fun toString (): String","title":"toString"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-named/wrapped/","text":"// workflow / com.squareup.workflow1.ui / Named / wrapped wrapped \u00b6 [jvm]\\ val wrapped : W","title":"Wrapped"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-named/wrapped/#wrapped","text":"[jvm]\\ val wrapped : W","title":"wrapped"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-text-controller/","text":"// workflow / com.squareup.workflow1.ui / TextController TextController \u00b6 [jvm]\\ @ WorkflowUiExperimentalApi class TextController (initialValue: String ) Helper class for keeping a workflow in sync with editable text in a UI, without interfering with the user\u2019s typing. Usage \u00b6 For every editable string in your state, create a property of type [TextController](index.md). data class State(val text: TextController = TextController()) Create a matching property in your rendering type. data class Rendering(val text: TextController) In your render method, copy each [TextController](index.md) from your state to your rendering: return Rendering(state.text) In your view code's showRendering method, call the appropriate extension function for your UI platform, e.g.: control() for an Android EditText viiew asMutableState() from an Android @Composable function If your workflow needs to access or change the current text value, get the value from textValue . If your workflow needs to react to changes, it can observe onTextChanged by converting it to a worker. Constructors \u00b6 TextController [jvm] fun TextController (initialValue: String = \u201c\u201d) Properties \u00b6 Name Summary onTextChanged [jvm] val onTextChanged : Flow< String > A Flow that emits the text value whenever it changes \u2013 and only when it changes, the current value is not provided at subscription time. Workflows can safely observe changes by converting this value to a worker. (When using multiple instances, remember to provide unique key values to each asWorker call.) textValue [jvm] var textValue : String The current text value. Extensions \u00b6 Name Summary asMutableState [androidJvm] @Composable fun TextController . asMutableState (): MutableState< String > Exposes the textValue of a TextController as a remembered MutableState, suitable for use from @Composable functions. control [androidJvm] @WorkflowUiExperimentalApi fun TextController . control (view: EditText ) Call this from your view code\u2019s showRendering method. This method is idempotent: if it has already been called with a particular EditText , and the view has not been detached since the last call, it will do nothing. If a different TextController \u2018s control is called on the same EditText , the old one will be disconnected and the new one will replace it.","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-text-controller/#textcontroller","text":"[jvm]\\ @ WorkflowUiExperimentalApi class TextController (initialValue: String ) Helper class for keeping a workflow in sync with editable text in a UI, without interfering with the user\u2019s typing.","title":"TextController"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-text-controller/#usage","text":"For every editable string in your state, create a property of type [TextController](index.md). data class State(val text: TextController = TextController()) Create a matching property in your rendering type. data class Rendering(val text: TextController) In your render method, copy each [TextController](index.md) from your state to your rendering: return Rendering(state.text) In your view code's showRendering method, call the appropriate extension function for your UI platform, e.g.: control() for an Android EditText viiew asMutableState() from an Android @Composable function If your workflow needs to access or change the current text value, get the value from textValue . If your workflow needs to react to changes, it can observe onTextChanged by converting it to a worker.","title":"Usage"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-text-controller/#constructors","text":"TextController [jvm] fun TextController (initialValue: String = \u201c\u201d)","title":"Constructors"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-text-controller/#properties","text":"Name Summary onTextChanged [jvm] val onTextChanged : Flow< String > A Flow that emits the text value whenever it changes \u2013 and only when it changes, the current value is not provided at subscription time. Workflows can safely observe changes by converting this value to a worker. (When using multiple instances, remember to provide unique key values to each asWorker call.) textValue [jvm] var textValue : String The current text value.","title":"Properties"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-text-controller/#extensions","text":"Name Summary asMutableState [androidJvm] @Composable fun TextController . asMutableState (): MutableState< String > Exposes the textValue of a TextController as a remembered MutableState, suitable for use from @Composable functions. control [androidJvm] @WorkflowUiExperimentalApi fun TextController . control (view: EditText ) Call this from your view code\u2019s showRendering method. This method is idempotent: if it has already been called with a particular EditText , and the view has not been detached since the last call, it will do nothing. If a different TextController \u2018s control is called on the same EditText , the old one will be disconnected and the new one will replace it.","title":"Extensions"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-text-controller/-text-controller/","text":"// workflow / com.squareup.workflow1.ui / TextController / TextController TextController \u00b6 [jvm]\\ fun TextController (initialValue: String = \u201c\u201d)","title":" text controller"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-text-controller/-text-controller/#textcontroller","text":"[jvm]\\ fun TextController (initialValue: String = \u201c\u201d)","title":"TextController"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-text-controller/on-text-changed/","text":"// workflow / com.squareup.workflow1.ui / TextController / onTextChanged onTextChanged \u00b6 [jvm]\\ val onTextChanged : Flow< String > A Flow that emits the text value whenever it changes \u2013 and only when it changes, the current value is not provided at subscription time. Workflows can safely observe changes by converting this value to a worker. (When using multiple instances, remember to provide unique key values to each asWorker call.) If you can do processing that doesn\u2019t require running a WorkflowAction or triggering a render pass, it can be done in regular Flow operators before converting to a worker.","title":"On text changed"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-text-controller/on-text-changed/#ontextchanged","text":"[jvm]\\ val onTextChanged : Flow< String > A Flow that emits the text value whenever it changes \u2013 and only when it changes, the current value is not provided at subscription time. Workflows can safely observe changes by converting this value to a worker. (When using multiple instances, remember to provide unique key values to each asWorker call.) If you can do processing that doesn\u2019t require running a WorkflowAction or triggering a render pass, it can be done in regular Flow operators before converting to a worker.","title":"onTextChanged"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-text-controller/text-value/","text":"// workflow / com.squareup.workflow1.ui / TextController / textValue textValue \u00b6 [jvm]\\ var textValue : String The current text value.","title":"Text value"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-text-controller/text-value/#textvalue","text":"[jvm]\\ var textValue : String The current text value.","title":"textValue"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-view-environment/","text":"// workflow / com.squareup.workflow1.ui / ViewEnvironment ViewEnvironment \u00b6 [androidJvm]\\ @WorkflowUiExperimentalApi class ViewEnvironment (map: Map < ViewEnvironmentKey <*>, Any >) Immutable, append-only map of values that a parent view can pass down to its children via View.showRendering et al. Allows container views to give descendants information about the context in which they\u2019re drawing. Constructors \u00b6 ViewEnvironment [androidJvm] fun ViewEnvironment (map: Map < ViewEnvironmentKey <*>, Any > = emptyMap()) Functions \u00b6 Name Summary equals [androidJvm] open operator override fun equals (other: Any ?): Boolean get [androidJvm] operator fun < T : Any > get (key: ViewEnvironmentKey < T >): T hashCode [androidJvm] open override fun hashCode (): Int plus [androidJvm] operator fun plus (other: ViewEnvironment ): ViewEnvironment operator fun < T : Any > plus (pair: Pair < ViewEnvironmentKey < T >, T >): ViewEnvironment toString [androidJvm] open override fun toString (): String Properties \u00b6 Name Summary map [androidJvm] val map : Map < ViewEnvironmentKey <*>, Any > Extensions \u00b6 Name Summary withBackStackStateKeyPrefix [androidJvm] fun ViewEnvironment . withBackStackStateKeyPrefix (prefix: String ): ViewEnvironment Sets a disambiguation prefix used by BackStackContainer when managing androidx.savedstate.SavedStateRegistryOwner . Allows parent containers to use multiple BackStackContainer instances at once. withCompositionRoot [androidJvm] @WorkflowUiExperimentalApi fun ViewEnvironment . withCompositionRoot (root: CompositionRoot ): ViewEnvironment Convenience function for applying a CompositionRoot to this ViewEnvironment \u2018s ViewRegistry . See ViewRegistry.withCompositionRoot .","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-view-environment/#viewenvironment","text":"[androidJvm]\\ @WorkflowUiExperimentalApi class ViewEnvironment (map: Map < ViewEnvironmentKey <*>, Any >) Immutable, append-only map of values that a parent view can pass down to its children via View.showRendering et al. Allows container views to give descendants information about the context in which they\u2019re drawing.","title":"ViewEnvironment"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-view-environment/#constructors","text":"ViewEnvironment [androidJvm] fun ViewEnvironment (map: Map < ViewEnvironmentKey <*>, Any > = emptyMap())","title":"Constructors"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-view-environment/#functions","text":"Name Summary equals [androidJvm] open operator override fun equals (other: Any ?): Boolean get [androidJvm] operator fun < T : Any > get (key: ViewEnvironmentKey < T >): T hashCode [androidJvm] open override fun hashCode (): Int plus [androidJvm] operator fun plus (other: ViewEnvironment ): ViewEnvironment operator fun < T : Any > plus (pair: Pair < ViewEnvironmentKey < T >, T >): ViewEnvironment toString [androidJvm] open override fun toString (): String","title":"Functions"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-view-environment/#properties","text":"Name Summary map [androidJvm] val map : Map < ViewEnvironmentKey <*>, Any >","title":"Properties"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-view-environment/#extensions","text":"Name Summary withBackStackStateKeyPrefix [androidJvm] fun ViewEnvironment . withBackStackStateKeyPrefix (prefix: String ): ViewEnvironment Sets a disambiguation prefix used by BackStackContainer when managing androidx.savedstate.SavedStateRegistryOwner . Allows parent containers to use multiple BackStackContainer instances at once. withCompositionRoot [androidJvm] @WorkflowUiExperimentalApi fun ViewEnvironment . withCompositionRoot (root: CompositionRoot ): ViewEnvironment Convenience function for applying a CompositionRoot to this ViewEnvironment \u2018s ViewRegistry . See ViewRegistry.withCompositionRoot .","title":"Extensions"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-view-environment/-view-environment/","text":"// workflow / com.squareup.workflow1.ui / ViewEnvironment / ViewEnvironment ViewEnvironment \u00b6 [androidJvm]\\ fun ViewEnvironment (map: Map < ViewEnvironmentKey <*>, Any > = emptyMap())","title":" view environment"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-view-environment/-view-environment/#viewenvironment","text":"[androidJvm]\\ fun ViewEnvironment (map: Map < ViewEnvironmentKey <*>, Any > = emptyMap())","title":"ViewEnvironment"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-view-environment/equals/","text":"// workflow / com.squareup.workflow1.ui / ViewEnvironment / equals equals \u00b6 [androidJvm]\\ open operator override fun equals (other: Any ?): Boolean","title":"Equals"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-view-environment/equals/#equals","text":"[androidJvm]\\ open operator override fun equals (other: Any ?): Boolean","title":"equals"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-view-environment/get/","text":"// workflow / com.squareup.workflow1.ui / ViewEnvironment / get get \u00b6 [androidJvm]\\ operator fun < T : Any > get (key: ViewEnvironmentKey < T >): T","title":"Get"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-view-environment/get/#get","text":"[androidJvm]\\ operator fun < T : Any > get (key: ViewEnvironmentKey < T >): T","title":"get"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-view-environment/hash-code/","text":"// workflow / com.squareup.workflow1.ui / ViewEnvironment / hashCode hashCode \u00b6 [androidJvm]\\ open override fun hashCode (): Int","title":"Hash code"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-view-environment/hash-code/#hashcode","text":"[androidJvm]\\ open override fun hashCode (): Int","title":"hashCode"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-view-environment/map/","text":"// workflow / com.squareup.workflow1.ui / ViewEnvironment / map map \u00b6 [androidJvm]\\ val map : Map < ViewEnvironmentKey <*>, Any >","title":"Map"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-view-environment/map/#map","text":"[androidJvm]\\ val map : Map < ViewEnvironmentKey <*>, Any >","title":"map"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-view-environment/plus/","text":"// workflow / com.squareup.workflow1.ui / ViewEnvironment / plus plus \u00b6 [androidJvm]\\ operator fun < T : Any > plus (pair: Pair < ViewEnvironmentKey < T >, T >): ViewEnvironment operator fun plus (other: ViewEnvironment ): ViewEnvironment","title":"Plus"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-view-environment/plus/#plus","text":"[androidJvm]\\ operator fun < T : Any > plus (pair: Pair < ViewEnvironmentKey < T >, T >): ViewEnvironment operator fun plus (other: ViewEnvironment ): ViewEnvironment","title":"plus"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-view-environment/to-string/","text":"// workflow / com.squareup.workflow1.ui / ViewEnvironment / toString toString \u00b6 [androidJvm]\\ open override fun toString (): String","title":"To string"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-view-environment/to-string/#tostring","text":"[androidJvm]\\ open override fun toString (): String","title":"toString"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-view-environment-key/","text":"// workflow / com.squareup.workflow1.ui / ViewEnvironmentKey ViewEnvironmentKey \u00b6 [androidJvm]\\ @WorkflowUiExperimentalApi abstract class ViewEnvironmentKey < T : Any >(type: KClass < T >) Defines a value that can be provided by a ViewEnvironment map, specifying its type and default value. Constructors \u00b6 ViewEnvironmentKey [androidJvm] fun < T : Any > ViewEnvironmentKey (type: KClass < T >) Functions \u00b6 Name Summary equals [androidJvm] operator override fun equals (other: Any ?): Boolean hashCode [androidJvm] override fun hashCode (): Int toString [androidJvm] open override fun toString (): String Properties \u00b6 Name Summary default [androidJvm] abstract val default : T Inheritors \u00b6 Name BackStackConfig ViewRegistry","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-view-environment-key/#viewenvironmentkey","text":"[androidJvm]\\ @WorkflowUiExperimentalApi abstract class ViewEnvironmentKey < T : Any >(type: KClass < T >) Defines a value that can be provided by a ViewEnvironment map, specifying its type and default value.","title":"ViewEnvironmentKey"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-view-environment-key/#constructors","text":"ViewEnvironmentKey [androidJvm] fun < T : Any > ViewEnvironmentKey (type: KClass < T >)","title":"Constructors"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-view-environment-key/#functions","text":"Name Summary equals [androidJvm] operator override fun equals (other: Any ?): Boolean hashCode [androidJvm] override fun hashCode (): Int toString [androidJvm] open override fun toString (): String","title":"Functions"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-view-environment-key/#properties","text":"Name Summary default [androidJvm] abstract val default : T","title":"Properties"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-view-environment-key/#inheritors","text":"Name BackStackConfig ViewRegistry","title":"Inheritors"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-view-environment-key/-view-environment-key/","text":"// workflow / com.squareup.workflow1.ui / ViewEnvironmentKey / ViewEnvironmentKey ViewEnvironmentKey \u00b6 [androidJvm]\\ fun < T : Any > ViewEnvironmentKey (type: KClass < T >)","title":" view environment key"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-view-environment-key/-view-environment-key/#viewenvironmentkey","text":"[androidJvm]\\ fun < T : Any > ViewEnvironmentKey (type: KClass < T >)","title":"ViewEnvironmentKey"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-view-environment-key/default/","text":"// workflow / com.squareup.workflow1.ui / ViewEnvironmentKey / default default \u00b6 [androidJvm]\\ abstract val default : T","title":"Default"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-view-environment-key/default/#default","text":"[androidJvm]\\ abstract val default : T","title":"default"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-view-environment-key/equals/","text":"// workflow / com.squareup.workflow1.ui / ViewEnvironmentKey / equals equals \u00b6 [androidJvm]\\ operator override fun equals (other: Any ?): Boolean","title":"Equals"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-view-environment-key/equals/#equals","text":"[androidJvm]\\ operator override fun equals (other: Any ?): Boolean","title":"equals"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-view-environment-key/hash-code/","text":"// workflow / com.squareup.workflow1.ui / ViewEnvironmentKey / hashCode hashCode \u00b6 [androidJvm]\\ override fun hashCode (): Int","title":"Hash code"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-view-environment-key/hash-code/#hashcode","text":"[androidJvm]\\ override fun hashCode (): Int","title":"hashCode"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-view-environment-key/to-string/","text":"// workflow / com.squareup.workflow1.ui / ViewEnvironmentKey / toString toString \u00b6 [androidJvm]\\ open override fun toString (): String","title":"To string"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-view-environment-key/to-string/#tostring","text":"[androidJvm]\\ open override fun toString (): String","title":"toString"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-view-factory/","text":"// workflow / com.squareup.workflow1.ui / ViewFactory ViewFactory \u00b6 [androidJvm]\\ @WorkflowUiExperimentalApi interface ViewFactory <in RenderingT : Any > Factory for View instances that can show renderings of type RenderingT . Two concrete ViewFactory implementations are provided: The various [bind](../-layout-runner/-companion/bind.md) methods on [LayoutRunner](../-layout-runner/index.md) allow easy use of Android XML layout resources and AndroidX ViewBinding. [BuilderViewFactory](../-builder-view-factory/index.md) allows views to be built from code. It\u2019s simplest to have your rendering classes implement AndroidViewRendering to associate them with appropriate an appropriate ViewFactory . For more flexibility, and to avoid coupling your workflow directly to the Android runtime, see ViewRegistry . Functions \u00b6 Name Summary buildView [androidJvm] abstract fun buildView (initialRendering: RenderingT , initialViewEnvironment: ViewEnvironment , contextForNewView: Context , container: ViewGroup ? = null): View Returns a View ready to display initialRendering (and any succeeding values) via View.showRendering . Properties \u00b6 Name Summary type [androidJvm] abstract val type : KClass <in RenderingT > Inheritors \u00b6 Name ComposeViewFactory BackStackContainer AlertContainer BuilderViewFactory DecorativeViewFactory Extensions \u00b6 Name Summary Preview [androidJvm] @WorkflowUiExperimentalApi @Composable fun < RenderingT : Any > ViewFactory < RenderingT >. Preview (rendering: RenderingT , modifier: Modifier = Modifier, placeholderModifier: Modifier = Modifier, viewEnvironmentUpdater: ( ViewEnvironment ) -> ViewEnvironment ? = null) Draws this ViewFactory using a special preview ViewRegistry .","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-view-factory/#viewfactory","text":"[androidJvm]\\ @WorkflowUiExperimentalApi interface ViewFactory <in RenderingT : Any > Factory for View instances that can show renderings of type RenderingT . Two concrete ViewFactory implementations are provided: The various [bind](../-layout-runner/-companion/bind.md) methods on [LayoutRunner](../-layout-runner/index.md) allow easy use of Android XML layout resources and AndroidX ViewBinding. [BuilderViewFactory](../-builder-view-factory/index.md) allows views to be built from code. It\u2019s simplest to have your rendering classes implement AndroidViewRendering to associate them with appropriate an appropriate ViewFactory . For more flexibility, and to avoid coupling your workflow directly to the Android runtime, see ViewRegistry .","title":"ViewFactory"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-view-factory/#functions","text":"Name Summary buildView [androidJvm] abstract fun buildView (initialRendering: RenderingT , initialViewEnvironment: ViewEnvironment , contextForNewView: Context , container: ViewGroup ? = null): View Returns a View ready to display initialRendering (and any succeeding values) via View.showRendering .","title":"Functions"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-view-factory/#properties","text":"Name Summary type [androidJvm] abstract val type : KClass <in RenderingT >","title":"Properties"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-view-factory/#inheritors","text":"Name ComposeViewFactory BackStackContainer AlertContainer BuilderViewFactory DecorativeViewFactory","title":"Inheritors"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-view-factory/#extensions","text":"Name Summary Preview [androidJvm] @WorkflowUiExperimentalApi @Composable fun < RenderingT : Any > ViewFactory < RenderingT >. Preview (rendering: RenderingT , modifier: Modifier = Modifier, placeholderModifier: Modifier = Modifier, viewEnvironmentUpdater: ( ViewEnvironment ) -> ViewEnvironment ? = null) Draws this ViewFactory using a special preview ViewRegistry .","title":"Extensions"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-view-factory/build-view/","text":"// workflow / com.squareup.workflow1.ui / ViewFactory / buildView buildView \u00b6 [androidJvm]\\ abstract fun buildView (initialRendering: RenderingT , initialViewEnvironment: ViewEnvironment , contextForNewView: Context , container: ViewGroup ? = null): View Returns a View ready to display initialRendering (and any succeeding values) via View.showRendering .","title":"Build view"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-view-factory/build-view/#buildview","text":"[androidJvm]\\ abstract fun buildView (initialRendering: RenderingT , initialViewEnvironment: ViewEnvironment , contextForNewView: Context , container: ViewGroup ? = null): View Returns a View ready to display initialRendering (and any succeeding values) via View.showRendering .","title":"buildView"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-view-factory/type/","text":"// workflow / com.squareup.workflow1.ui / ViewFactory / type type \u00b6 [androidJvm]\\ abstract val type : KClass <in RenderingT >","title":"Type"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-view-factory/type/#type","text":"[androidJvm]\\ abstract val type : KClass <in RenderingT >","title":"type"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-view-registry/","text":"// workflow / com.squareup.workflow1.ui / ViewRegistry ViewRegistry \u00b6 [androidJvm]\\ @WorkflowUiExperimentalApi interface ViewRegistry The ViewEnvironment service that can be used to display the stream of renderings from a workflow tree as View instances. This is the engine behind AndroidViewRendering , WorkflowViewStub and ViewFactory . Most apps can ignore ViewRegistry as an implementation detail, by using AndroidViewRendering to tie their rendering classes to view code. To avoid that coupling between workflow code and the Android runtime, registries can be loaded with ViewFactory instances at runtime, and provided as an optional parameter to WorkflowLayout.start . For example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 val AuthViewFactories = ViewRegistry( AuthorizingLayoutRunner, LoginLayoutRunner, SecondFactorLayoutRunner ) val TicTacToeViewFactories = ViewRegistry( NewGameLayoutRunner, GamePlayLayoutRunner, GameOverLayoutRunner ) val ApplicationViewFactories = ViewRegistry(ApplicationLayoutRunner) + AuthViewFactories + TicTacToeViewFactories override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val model: MyViewModel by viewModels() setContentView( WorkflowLayout(this).apply { start(model.renderings, ApplicationViewFactories) } ) } /** As always, use an androidx ViewModel for state that survives config change. */ class MyViewModel(savedState: SavedStateHandle) : ViewModel() { val renderings: StateFlow by lazy { renderWorkflowIn( workflow = rootWorkflow, scope = viewModelScope, savedStateHandle = savedState ) } } In the above example, it is assumed that the companion objects of the various decoupled LayoutRunner classes honor a convention of implementing ViewFactory , in aid of this kind of assembly. 1 2 3 4 5 6 7 8 class GamePlayLayoutRunner(view: View) : LayoutRunner { // ... companion object : ViewFactory by LayoutRunner.bind( R.layout.game_layout, ::GameLayoutRunner ) } Types \u00b6 Name Summary Companion [androidJvm] object Companion : ViewEnvironmentKey < ViewRegistry > Functions \u00b6 Name Summary getFactoryFor [androidJvm] abstract fun < RenderingT : Any > getFactoryFor (renderingType: KClass <out RenderingT >): ViewFactory < RenderingT >? This method is not for general use, use WorkflowViewStub instead. Properties \u00b6 Name Summary keys [androidJvm] abstract val keys : Set < KClass <*>> The set of unique keys which this registry can derive from the renderings passed to buildView and for which it knows how to create views. Extensions \u00b6 Name Summary buildView [androidJvm] @WorkflowUiExperimentalApi fun < RenderingT : Any > ViewRegistry . buildView (initialRendering: RenderingT , initialViewEnvironment: ViewEnvironment , contextForNewView: Context , container: ViewGroup ? = null, viewStarter: ViewStarter ? = null): View It is usually more convenient to use WorkflowViewStub or DecorativeViewFactory than to call this method directly. getFactoryForRendering [androidJvm] @WorkflowUiExperimentalApi fun < RenderingT : Any > ViewRegistry . getFactoryForRendering (rendering: RenderingT ): ViewFactory < RenderingT > It is usually more convenient to use WorkflowViewStub or DecorativeViewFactory than to call this method directly. plus [androidJvm] @WorkflowUiExperimentalApi operator fun ViewRegistry . plus (binding: ViewFactory <*>): ViewRegistry @WorkflowUiExperimentalApi operator fun ViewRegistry . plus (other: ViewRegistry ): ViewRegistry withCompositionRoot [androidJvm] @WorkflowUiExperimentalApi fun ViewRegistry . withCompositionRoot (root: CompositionRoot ): ViewRegistry Returns a ViewRegistry that ensures that any composeViewFactory factories registered in this registry will be wrapped exactly once with a CompositionRoot wrapper. See CompositionRoot for more information.","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-view-registry/#viewregistry","text":"[androidJvm]\\ @WorkflowUiExperimentalApi interface ViewRegistry The ViewEnvironment service that can be used to display the stream of renderings from a workflow tree as View instances. This is the engine behind AndroidViewRendering , WorkflowViewStub and ViewFactory . Most apps can ignore ViewRegistry as an implementation detail, by using AndroidViewRendering to tie their rendering classes to view code. To avoid that coupling between workflow code and the Android runtime, registries can be loaded with ViewFactory instances at runtime, and provided as an optional parameter to WorkflowLayout.start . For example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 val AuthViewFactories = ViewRegistry( AuthorizingLayoutRunner, LoginLayoutRunner, SecondFactorLayoutRunner ) val TicTacToeViewFactories = ViewRegistry( NewGameLayoutRunner, GamePlayLayoutRunner, GameOverLayoutRunner ) val ApplicationViewFactories = ViewRegistry(ApplicationLayoutRunner) + AuthViewFactories + TicTacToeViewFactories override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val model: MyViewModel by viewModels() setContentView( WorkflowLayout(this).apply { start(model.renderings, ApplicationViewFactories) } ) } /** As always, use an androidx ViewModel for state that survives config change. */ class MyViewModel(savedState: SavedStateHandle) : ViewModel() { val renderings: StateFlow by lazy { renderWorkflowIn( workflow = rootWorkflow, scope = viewModelScope, savedStateHandle = savedState ) } } In the above example, it is assumed that the companion objects of the various decoupled LayoutRunner classes honor a convention of implementing ViewFactory , in aid of this kind of assembly. 1 2 3 4 5 6 7 8 class GamePlayLayoutRunner(view: View) : LayoutRunner { // ... companion object : ViewFactory by LayoutRunner.bind( R.layout.game_layout, ::GameLayoutRunner ) }","title":"ViewRegistry"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-view-registry/#types","text":"Name Summary Companion [androidJvm] object Companion : ViewEnvironmentKey < ViewRegistry >","title":"Types"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-view-registry/#functions","text":"Name Summary getFactoryFor [androidJvm] abstract fun < RenderingT : Any > getFactoryFor (renderingType: KClass <out RenderingT >): ViewFactory < RenderingT >? This method is not for general use, use WorkflowViewStub instead.","title":"Functions"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-view-registry/#properties","text":"Name Summary keys [androidJvm] abstract val keys : Set < KClass <*>> The set of unique keys which this registry can derive from the renderings passed to buildView and for which it knows how to create views.","title":"Properties"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-view-registry/#extensions","text":"Name Summary buildView [androidJvm] @WorkflowUiExperimentalApi fun < RenderingT : Any > ViewRegistry . buildView (initialRendering: RenderingT , initialViewEnvironment: ViewEnvironment , contextForNewView: Context , container: ViewGroup ? = null, viewStarter: ViewStarter ? = null): View It is usually more convenient to use WorkflowViewStub or DecorativeViewFactory than to call this method directly. getFactoryForRendering [androidJvm] @WorkflowUiExperimentalApi fun < RenderingT : Any > ViewRegistry . getFactoryForRendering (rendering: RenderingT ): ViewFactory < RenderingT > It is usually more convenient to use WorkflowViewStub or DecorativeViewFactory than to call this method directly. plus [androidJvm] @WorkflowUiExperimentalApi operator fun ViewRegistry . plus (binding: ViewFactory <*>): ViewRegistry @WorkflowUiExperimentalApi operator fun ViewRegistry . plus (other: ViewRegistry ): ViewRegistry withCompositionRoot [androidJvm] @WorkflowUiExperimentalApi fun ViewRegistry . withCompositionRoot (root: CompositionRoot ): ViewRegistry Returns a ViewRegistry that ensures that any composeViewFactory factories registered in this registry will be wrapped exactly once with a CompositionRoot wrapper. See CompositionRoot for more information.","title":"Extensions"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-view-registry/get-factory-for/","text":"// workflow / com.squareup.workflow1.ui / ViewRegistry / getFactoryFor getFactoryFor \u00b6 [androidJvm]\\ abstract fun < RenderingT : Any > getFactoryFor (renderingType: KClass <out RenderingT >): ViewFactory < RenderingT >? This method is not for general use, use WorkflowViewStub instead. Returns the ViewFactory that was registered for the given renderingType , or null if none was found.","title":"Get factory for"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-view-registry/get-factory-for/#getfactoryfor","text":"[androidJvm]\\ abstract fun < RenderingT : Any > getFactoryFor (renderingType: KClass <out RenderingT >): ViewFactory < RenderingT >? This method is not for general use, use WorkflowViewStub instead. Returns the ViewFactory that was registered for the given renderingType , or null if none was found.","title":"getFactoryFor"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-view-registry/keys/","text":"// workflow / com.squareup.workflow1.ui / ViewRegistry / keys keys \u00b6 [androidJvm]\\ abstract val keys : Set < KClass <*>> The set of unique keys which this registry can derive from the renderings passed to buildView and for which it knows how to create views. Used to ensure that duplicate bindings are never registered.","title":"Keys"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-view-registry/keys/#keys","text":"[androidJvm]\\ abstract val keys : Set < KClass <*>> The set of unique keys which this registry can derive from the renderings passed to buildView and for which it knows how to create views. Used to ensure that duplicate bindings are never registered.","title":"keys"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-view-registry/-companion/","text":"// workflow / com.squareup.workflow1.ui / ViewRegistry / Companion Companion \u00b6 [androidJvm]\\ object Companion : ViewEnvironmentKey < ViewRegistry > Functions \u00b6 Name Summary equals [androidJvm] operator override fun equals (other: Any ?): Boolean hashCode [androidJvm] override fun hashCode (): Int toString [androidJvm] open override fun toString (): String Properties \u00b6 Name Summary default [androidJvm] open override val default : ViewRegistry","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-view-registry/-companion/#companion","text":"[androidJvm]\\ object Companion : ViewEnvironmentKey < ViewRegistry >","title":"Companion"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-view-registry/-companion/#functions","text":"Name Summary equals [androidJvm] operator override fun equals (other: Any ?): Boolean hashCode [androidJvm] override fun hashCode (): Int toString [androidJvm] open override fun toString (): String","title":"Functions"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-view-registry/-companion/#properties","text":"Name Summary default [androidJvm] open override val default : ViewRegistry","title":"Properties"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-view-registry/-companion/default/","text":"// workflow / com.squareup.workflow1.ui / ViewRegistry / Companion / default default \u00b6 [androidJvm]\\ open override val default : ViewRegistry","title":"Default"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-view-registry/-companion/default/#default","text":"[androidJvm]\\ open override val default : ViewRegistry","title":"default"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-view-starter/","text":"// workflow / com.squareup.workflow1.ui / ViewStarter ViewStarter \u00b6 [androidJvm]\\ @WorkflowUiExperimentalApi fun interface ViewStarter A wrapper for the function invoked when View.start is called, allowing for last second initialization of a newly built View . Provided via ViewRegistry.buildView or DecorativeViewFactory.viewStarter. While View.getRendering may be called from startView , it is not safe to assume that the type of the rendering retrieved matches the type the view was originally built to display. ViewFactories can be wrapped, and renderings can be mapped to other types. Functions \u00b6 Name Summary startView [androidJvm] abstract fun startView (view: View , doStart: () -> Unit ) Called from View.start . doStart must be invoked.","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-view-starter/#viewstarter","text":"[androidJvm]\\ @WorkflowUiExperimentalApi fun interface ViewStarter A wrapper for the function invoked when View.start is called, allowing for last second initialization of a newly built View . Provided via ViewRegistry.buildView or DecorativeViewFactory.viewStarter. While View.getRendering may be called from startView , it is not safe to assume that the type of the rendering retrieved matches the type the view was originally built to display. ViewFactories can be wrapped, and renderings can be mapped to other types.","title":"ViewStarter"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-view-starter/#functions","text":"Name Summary startView [androidJvm] abstract fun startView (view: View , doStart: () -> Unit ) Called from View.start . doStart must be invoked.","title":"Functions"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-view-starter/start-view/","text":"// workflow / com.squareup.workflow1.ui / ViewStarter / startView startView \u00b6 [androidJvm]\\ abstract fun startView (view: View , doStart: () -> Unit ) Called from View.start . doStart must be invoked.","title":"Start view"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-view-starter/start-view/#startview","text":"[androidJvm]\\ abstract fun startView (view: View , doStart: () -> Unit ) Called from View.start . doStart must be invoked.","title":"startView"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-workflow-layout/","text":"// workflow / com.squareup.workflow1.ui / WorkflowLayout WorkflowLayout \u00b6 [androidJvm]\\ @WorkflowUiExperimentalApi class WorkflowLayout (context: Context , attributeSet: AttributeSet ?) : FrameLayout A view that can be driven by a stream of renderings (and an optional ViewRegistry ) passed to its start method. id defaults to R.id.workflow_layout, as a convenience to ensure that view persistence will work without requiring authors to be immersed in Android arcana. See com.squareup.workflow1.ui.renderWorkflowIn for typical use with a com.squareup.workflow1.Workflow . Constructors \u00b6 WorkflowLayout [androidJvm] fun WorkflowLayout (context: Context , attributeSet: AttributeSet ? = null) Functions \u00b6 Name Summary addChildrenForAccessibility [androidJvm] open override fun addChildrenForAccessibility (p0: ArrayList < View >) addExtraDataToAccessibilityNodeInfo [androidJvm] open override fun addExtraDataToAccessibilityNodeInfo (p0: AccessibilityNodeInfo , p1: String , p2: Bundle ?) addFocusables [androidJvm] open fun addFocusables (p0: ArrayList < View >, p1: Int ) open override fun addFocusables (p0: ArrayList < View >, p1: Int , p2: Int ) addKeyboardNavigationClusters [androidJvm] open override fun addKeyboardNavigationClusters (p0: MutableCollection < View >, p1: Int ) addOnAttachStateChangeListener [androidJvm] open fun addOnAttachStateChangeListener (p0: View.OnAttachStateChangeListener ) addOnLayoutChangeListener [androidJvm] open fun addOnLayoutChangeListener (p0: View.OnLayoutChangeListener ) addOnUnhandledKeyEventListener [androidJvm] open fun addOnUnhandledKeyEventListener (p0: View.OnUnhandledKeyEventListener ) addStatesFromChildren [androidJvm] open fun addStatesFromChildren (): Boolean addTouchables [androidJvm] open override fun addTouchables (p0: ArrayList < View >) addView [androidJvm] open fun addView (p0: View ) open override fun addView (p0: View , p1: ViewGroup.LayoutParams ) open fun addView (p0: View , p1: Int ) open fun addView (p0: View , p1: Int , p2: ViewGroup.LayoutParams ) open fun addView (p0: View , p1: Int , p2: Int ) addViewInLayout [androidJvm] open fun addViewInLayout (p0: View , p1: Int , p2: ViewGroup.LayoutParams ): Boolean open fun addViewInLayout (p0: View , p1: Int , p2: ViewGroup.LayoutParams , p3: Boolean ): Boolean animate [androidJvm] open fun animate (): ViewPropertyAnimator announceForAccessibility [androidJvm] open fun announceForAccessibility (p0: CharSequence ) attachLayoutAnimationParameters [androidJvm] open fun attachLayoutAnimationParameters (p0: View , p1: ViewGroup.LayoutParams , p2: Int , p3: Int ) attachViewToParent [androidJvm] open fun attachViewToParent (p0: View , p1: Int , p2: ViewGroup.LayoutParams ) autofill [androidJvm] open fun autofill (p0: SparseArray < AutofillValue >) open fun autofill (p0: AutofillValue ) awakenScrollBars [androidJvm] open fun awakenScrollBars (): Boolean open fun awakenScrollBars (p0: Int ): Boolean open fun awakenScrollBars (p0: Int , p1: Boolean ): Boolean bringChildToFront [androidJvm] open override fun bringChildToFront (p0: View ) bringToFront [androidJvm] open fun bringToFront () buildLayer [androidJvm] open fun buildLayer () callOnClick [androidJvm] open fun callOnClick (): Boolean canAnimate [androidJvm] open fun canAnimate (): Boolean cancelDragAndDrop [androidJvm] fun cancelDragAndDrop () cancelLongPress [androidJvm] open fun cancelLongPress () cancelPendingInputEvents [androidJvm] fun cancelPendingInputEvents () canResolveLayoutDirection [androidJvm] open fun canResolveLayoutDirection (): Boolean canResolveTextAlignment [androidJvm] open fun canResolveTextAlignment (): Boolean canResolveTextDirection [androidJvm] open fun canResolveTextDirection (): Boolean canScrollHorizontally [androidJvm] open fun canScrollHorizontally (p0: Int ): Boolean canScrollVertically [androidJvm] open fun canScrollVertically (p0: Int ): Boolean checkInputConnectionProxy [androidJvm] open fun checkInputConnectionProxy (p0: View ): Boolean checkLayoutParams [androidJvm] open override fun checkLayoutParams (p0: ViewGroup.LayoutParams ): Boolean childDrawableStateChanged [androidJvm] open override fun childDrawableStateChanged (p0: View ) childHasTransientStateChanged [androidJvm] open override fun childHasTransientStateChanged (p0: View , p1: Boolean ) cleanupLayoutState [androidJvm] open fun cleanupLayoutState (p0: View ) clearAnimation [androidJvm] open fun clearAnimation () clearChildFocus [androidJvm] open override fun clearChildFocus (p0: View ) clearDisappearingChildren [androidJvm] open fun clearDisappearingChildren () clearFocus [androidJvm] open override fun clearFocus () clearViewTranslationCallback [androidJvm] open fun clearViewTranslationCallback () computeHorizontalScrollExtent [androidJvm] open fun computeHorizontalScrollExtent (): Int computeHorizontalScrollOffset [androidJvm] open fun computeHorizontalScrollOffset (): Int computeHorizontalScrollRange [androidJvm] open fun computeHorizontalScrollRange (): Int computeScroll [androidJvm] open fun computeScroll () computeSystemWindowInsets [androidJvm] open fun computeSystemWindowInsets (p0: WindowInsets , p1: Rect ): WindowInsets computeVerticalScrollExtent [androidJvm] open fun computeVerticalScrollExtent (): Int computeVerticalScrollOffset [androidJvm] open fun computeVerticalScrollOffset (): Int computeVerticalScrollRange [androidJvm] open fun computeVerticalScrollRange (): Int createAccessibilityNodeInfo [androidJvm] open fun createAccessibilityNodeInfo (): AccessibilityNodeInfo createContextMenu [androidJvm] open fun createContextMenu (p0: ContextMenu ) debug [androidJvm] open fun debug (p0: Int ) detachAllViewsFromParent [androidJvm] open fun detachAllViewsFromParent () detachViewFromParent [androidJvm] open fun detachViewFromParent (p0: View ) open fun detachViewFromParent (p0: Int ) detachViewsFromParent [androidJvm] open fun detachViewsFromParent (p0: Int , p1: Int ) dispatchApplyWindowInsets [androidJvm] open override fun dispatchApplyWindowInsets (p0: WindowInsets ): WindowInsets dispatchCapturedPointerEvent [androidJvm] open override fun dispatchCapturedPointerEvent (p0: MotionEvent ): Boolean dispatchConfigurationChanged [androidJvm] open override fun dispatchConfigurationChanged (p0: Configuration ) dispatchCreateViewTranslationRequest [androidJvm] open override fun dispatchCreateViewTranslationRequest (p0: MutableMap < AutofillId , LongArray >, p1: IntArray , p2: TranslationCapability , p3: MutableList < ViewTranslationRequest >) dispatchDisplayHint [androidJvm] open override fun dispatchDisplayHint (p0: Int ) dispatchDragEvent [androidJvm] open override fun dispatchDragEvent (p0: DragEvent ): Boolean dispatchDraw [androidJvm] open override fun dispatchDraw (p0: Canvas ) dispatchDrawableHotspotChanged [androidJvm] open override fun dispatchDrawableHotspotChanged (p0: Float , p1: Float ) dispatchFinishTemporaryDetach [androidJvm] open override fun dispatchFinishTemporaryDetach () dispatchFreezeSelfOnly [androidJvm] open fun dispatchFreezeSelfOnly (p0: SparseArray < Parcelable >) dispatchGenericFocusedEvent [androidJvm] open override fun dispatchGenericFocusedEvent (p0: MotionEvent ): Boolean dispatchGenericMotionEvent [androidJvm] open fun dispatchGenericMotionEvent (p0: MotionEvent ): Boolean dispatchGenericPointerEvent [androidJvm] open override fun dispatchGenericPointerEvent (p0: MotionEvent ): Boolean dispatchHoverEvent [androidJvm] open override fun dispatchHoverEvent (p0: MotionEvent ): Boolean dispatchKeyEvent [androidJvm] open override fun dispatchKeyEvent (p0: KeyEvent ): Boolean dispatchKeyEventPreIme [androidJvm] open override fun dispatchKeyEventPreIme (p0: KeyEvent ): Boolean dispatchKeyShortcutEvent [androidJvm] open override fun dispatchKeyShortcutEvent (p0: KeyEvent ): Boolean dispatchNestedFling [androidJvm] open fun dispatchNestedFling (p0: Float , p1: Float , p2: Boolean ): Boolean dispatchNestedPreFling [androidJvm] open fun dispatchNestedPreFling (p0: Float , p1: Float ): Boolean dispatchNestedPrePerformAccessibilityAction [androidJvm] open fun dispatchNestedPrePerformAccessibilityAction (p0: Int , p1: Bundle ): Boolean dispatchNestedPreScroll [androidJvm] open fun dispatchNestedPreScroll (p0: Int , p1: Int , p2: IntArray ?, p3: IntArray ?): Boolean dispatchNestedScroll [androidJvm] open fun dispatchNestedScroll (p0: Int , p1: Int , p2: Int , p3: Int , p4: IntArray ?): Boolean dispatchPointerCaptureChanged [androidJvm] open override fun dispatchPointerCaptureChanged (p0: Boolean ) dispatchPopulateAccessibilityEvent [androidJvm] open fun dispatchPopulateAccessibilityEvent (p0: AccessibilityEvent ): Boolean dispatchProvideAutofillStructure [androidJvm] open override fun dispatchProvideAutofillStructure (p0: ViewStructure , p1: Int ) dispatchProvideStructure [androidJvm] open override fun dispatchProvideStructure (p0: ViewStructure ) dispatchRestoreInstanceState [androidJvm] open override fun dispatchRestoreInstanceState (p0: SparseArray < Parcelable >) dispatchSaveInstanceState [androidJvm] open override fun dispatchSaveInstanceState (p0: SparseArray < Parcelable >) dispatchScrollCaptureSearch [androidJvm] open override fun dispatchScrollCaptureSearch (p0: Rect , p1: Point , p2: Consumer < ScrollCaptureTarget >) dispatchSetActivated [androidJvm] open override fun dispatchSetActivated (p0: Boolean ) dispatchSetPressed [androidJvm] open override fun dispatchSetPressed (p0: Boolean ) dispatchSetSelected [androidJvm] open override fun dispatchSetSelected (p0: Boolean ) dispatchStartTemporaryDetach [androidJvm] open override fun dispatchStartTemporaryDetach () dispatchThawSelfOnly [androidJvm] open fun dispatchThawSelfOnly (p0: SparseArray < Parcelable >) dispatchTouchEvent [androidJvm] open override fun dispatchTouchEvent (p0: MotionEvent ): Boolean dispatchTrackballEvent [androidJvm] open override fun dispatchTrackballEvent (p0: MotionEvent ): Boolean dispatchUnhandledMove [androidJvm] open override fun dispatchUnhandledMove (p0: View , p1: Int ): Boolean dispatchVisibilityChanged [androidJvm] open override fun dispatchVisibilityChanged (p0: View , p1: Int ) dispatchWindowFocusChanged [androidJvm] open override fun dispatchWindowFocusChanged (p0: Boolean ) dispatchWindowInsetsAnimationEnd [androidJvm] open override fun dispatchWindowInsetsAnimationEnd (p0: WindowInsetsAnimation ) dispatchWindowInsetsAnimationPrepare [androidJvm] open override fun dispatchWindowInsetsAnimationPrepare (p0: WindowInsetsAnimation ) dispatchWindowInsetsAnimationProgress [androidJvm] open override fun dispatchWindowInsetsAnimationProgress (p0: WindowInsets , p1: MutableList < WindowInsetsAnimation >): WindowInsets dispatchWindowInsetsAnimationStart [androidJvm] open override fun dispatchWindowInsetsAnimationStart (p0: WindowInsetsAnimation , p1: WindowInsetsAnimation.Bounds ): WindowInsetsAnimation.Bounds dispatchWindowVisibilityChanged [androidJvm] open override fun dispatchWindowVisibilityChanged (p0: Int ) draw [androidJvm] open fun draw (p0: Canvas ) drawableHotspotChanged [androidJvm] open fun drawableHotspotChanged (p0: Float , p1: Float ) drawableStateChanged [androidJvm] open override fun drawableStateChanged () drawChild [androidJvm] open fun drawChild (p0: Canvas , p1: View , p2: Long ): Boolean endViewTransition [androidJvm] open fun endViewTransition (p0: View ) findFocus [androidJvm] open override fun findFocus (): View findViewById [androidJvm] fun < T : View > findViewById (p0: Int ): T findViewsWithText [androidJvm] open override fun findViewsWithText (p0: ArrayList < View >, p1: CharSequence , p2: Int ) findViewWithTag [androidJvm] fun < T : View > findViewWithTag (p0: Any ): T focusableViewAvailable [androidJvm] open override fun focusableViewAvailable (p0: View ) focusSearch [androidJvm] open fun focusSearch (p0: Int ): View open override fun focusSearch (p0: View , p1: Int ): View forceHasOverlappingRendering [androidJvm] open fun forceHasOverlappingRendering (p0: Boolean ) forceLayout [androidJvm] open fun forceLayout () gatherTransparentRegion [androidJvm] open override fun gatherTransparentRegion (p0: Region ?): Boolean generateDefaultLayoutParams [androidJvm] open override fun generateDefaultLayoutParams (): FrameLayout.LayoutParams generateDisplayHash [androidJvm] open fun generateDisplayHash (p0: String , p1: Rect ?, p2: Executor , p3: DisplayHashResultCallback ) generateLayoutParams [androidJvm] open override fun generateLayoutParams (p0: AttributeSet ): FrameLayout.LayoutParams open override fun generateLayoutParams (p0: ViewGroup.LayoutParams ): ViewGroup.LayoutParams getAccessibilityClassName [androidJvm] open override fun getAccessibilityClassName (): CharSequence getAccessibilityDelegate [androidJvm] open fun getAccessibilityDelegate (): View.AccessibilityDelegate getAccessibilityLiveRegion [androidJvm] open fun getAccessibilityLiveRegion (): Int getAccessibilityNodeProvider [androidJvm] open fun getAccessibilityNodeProvider (): AccessibilityNodeProvider getAccessibilityPaneTitle [androidJvm] open fun getAccessibilityPaneTitle (): CharSequence ? getAccessibilityTraversalAfter [androidJvm] open fun getAccessibilityTraversalAfter (): Int getAccessibilityTraversalBefore [androidJvm] open fun getAccessibilityTraversalBefore (): Int getAlpha [androidJvm] open fun getAlpha (): Float getAnimation [androidJvm] open fun getAnimation (): Animation getAnimationMatrix [androidJvm] open fun getAnimationMatrix (): Matrix ? getApplicationWindowToken [androidJvm] open fun getApplicationWindowToken (): IBinder getAttributeResolutionStack [androidJvm] open fun getAttributeResolutionStack (p0: Int ): IntArray getAttributeSourceResourceMap [androidJvm] open fun getAttributeSourceResourceMap (): MutableMap < Int , Int > getAutofillHints [androidJvm] open fun getAutofillHints (): Array < String >? getAutofillId [androidJvm] fun getAutofillId (): AutofillId getAutofillType [androidJvm] open fun getAutofillType (): Int getAutofillValue [androidJvm] open fun getAutofillValue (): AutofillValue ? getBackground [androidJvm] open fun getBackground (): Drawable getBackgroundTintBlendMode [androidJvm] open fun getBackgroundTintBlendMode (): BlendMode ? getBackgroundTintList [androidJvm] open fun getBackgroundTintList (): ColorStateList ? getBackgroundTintMode [androidJvm] open fun getBackgroundTintMode (): PorterDuff.Mode ? getBaseline [androidJvm] open fun getBaseline (): Int getBottom [androidJvm] fun getBottom (): Int getBottomFadingEdgeStrength [androidJvm] open fun getBottomFadingEdgeStrength (): Float getBottomPaddingOffset [androidJvm] open fun getBottomPaddingOffset (): Int getCameraDistance [androidJvm] open fun getCameraDistance (): Float getChildAt [androidJvm] open fun getChildAt (p0: Int ): View getChildCount [androidJvm] open fun getChildCount (): Int getChildDrawingOrder [androidJvm] fun getChildDrawingOrder (p0: Int ): Int open fun getChildDrawingOrder (p0: Int , p1: Int ): Int getChildStaticTransformation [androidJvm] open fun getChildStaticTransformation (p0: View , p1: Transformation ): Boolean getChildVisibleRect [androidJvm] open override fun getChildVisibleRect (p0: View , p1: Rect , p2: Point ): Boolean getClipBounds [androidJvm] open fun getClipBounds (): Rect open fun getClipBounds (p0: Rect ): Boolean getClipChildren [androidJvm] open fun getClipChildren (): Boolean getClipToOutline [androidJvm] fun getClipToOutline (): Boolean getClipToPadding [androidJvm] open fun getClipToPadding (): Boolean getContentCaptureSession [androidJvm] fun getContentCaptureSession (): ContentCaptureSession ? getContentDescription [androidJvm] open fun getContentDescription (): CharSequence getContext [androidJvm] fun getContext (): Context getContextMenuInfo [androidJvm] open fun getContextMenuInfo (): ContextMenu.ContextMenuInfo getDefaultFocusHighlightEnabled [androidJvm] fun getDefaultFocusHighlightEnabled (): Boolean getDescendantFocusability [androidJvm] open fun getDescendantFocusability (): Int getDisplay [androidJvm] open fun getDisplay (): Display getDrawableState [androidJvm] fun getDrawableState (): IntArray getDrawingRect [androidJvm] open fun getDrawingRect (p0: Rect ) getDrawingTime [androidJvm] open fun getDrawingTime (): Long getElevation [androidJvm] open fun getElevation (): Float getExplicitStyle [androidJvm] open fun getExplicitStyle (): Int getFilterTouchesWhenObscured [androidJvm] open fun getFilterTouchesWhenObscured (): Boolean getFitsSystemWindows [androidJvm] open fun getFitsSystemWindows (): Boolean getFocusable [androidJvm] open fun getFocusable (): Int getFocusables [androidJvm] open fun getFocusables (p0: Int ): ArrayList < View > getFocusedChild [androidJvm] open fun getFocusedChild (): View getFocusedRect [androidJvm] open fun getFocusedRect (p0: Rect ) getForeground [androidJvm] open fun getForeground (): Drawable getForegroundGravity [androidJvm] open fun getForegroundGravity (): Int getForegroundTintBlendMode [androidJvm] open fun getForegroundTintBlendMode (): BlendMode ? getForegroundTintList [androidJvm] open fun getForegroundTintList (): ColorStateList ? getForegroundTintMode [androidJvm] open fun getForegroundTintMode (): PorterDuff.Mode ? getGlobalVisibleRect [androidJvm] fun getGlobalVisibleRect (p0: Rect ): Boolean open fun getGlobalVisibleRect (p0: Rect , p1: Point ): Boolean getHandler [androidJvm] open fun getHandler (): Handler getHasOverlappingRendering [androidJvm] fun getHasOverlappingRendering (): Boolean getHeight [androidJvm] fun getHeight (): Int getHitRect [androidJvm] open fun getHitRect (p0: Rect ) getHorizontalFadingEdgeLength [androidJvm] open fun getHorizontalFadingEdgeLength (): Int getHorizontalScrollbarHeight [androidJvm] open fun getHorizontalScrollbarHeight (): Int getHorizontalScrollbarThumbDrawable [androidJvm] open fun getHorizontalScrollbarThumbDrawable (): Drawable ? getHorizontalScrollbarTrackDrawable [androidJvm] open fun getHorizontalScrollbarTrackDrawable (): Drawable ? getId [androidJvm] open fun getId (): Int getImportantForAccessibility [androidJvm] open fun getImportantForAccessibility (): Int getImportantForAutofill [androidJvm] open fun getImportantForAutofill (): Int getImportantForContentCapture [androidJvm] open fun getImportantForContentCapture (): Int getKeepScreenOn [androidJvm] open fun getKeepScreenOn (): Boolean getKeyDispatcherState [androidJvm] open fun getKeyDispatcherState (): KeyEvent.DispatcherState getLabelFor [androidJvm] open fun getLabelFor (): Int getLayerType [androidJvm] open fun getLayerType (): Int getLayoutAnimation [androidJvm] open fun getLayoutAnimation (): LayoutAnimationController getLayoutAnimationListener [androidJvm] open fun getLayoutAnimationListener (): Animation.AnimationListener getLayoutDirection [androidJvm] open fun getLayoutDirection (): Int getLayoutMode [androidJvm] open fun getLayoutMode (): Int getLayoutParams [androidJvm] open fun getLayoutParams (): ViewGroup.LayoutParams getLayoutTransition [androidJvm] open fun getLayoutTransition (): LayoutTransition getLeft [androidJvm] fun getLeft (): Int getLeftFadingEdgeStrength [androidJvm] open fun getLeftFadingEdgeStrength (): Float getLeftPaddingOffset [androidJvm] open fun getLeftPaddingOffset (): Int getLocalVisibleRect [androidJvm] fun getLocalVisibleRect (p0: Rect ): Boolean getLocationInSurface [androidJvm] open fun getLocationInSurface (p0: IntArray ) getLocationInWindow [androidJvm] open fun getLocationInWindow (p0: IntArray ) getLocationOnScreen [androidJvm] open fun getLocationOnScreen (p0: IntArray ) getMatrix [androidJvm] open fun getMatrix (): Matrix getMeasureAllChildren [androidJvm] open fun getMeasureAllChildren (): Boolean getMeasuredHeight [androidJvm] fun getMeasuredHeight (): Int getMeasuredHeightAndState [androidJvm] fun getMeasuredHeightAndState (): Int getMeasuredState [androidJvm] fun getMeasuredState (): Int getMeasuredWidth [androidJvm] fun getMeasuredWidth (): Int getMeasuredWidthAndState [androidJvm] fun getMeasuredWidthAndState (): Int getMinimumHeight [androidJvm] open fun getMinimumHeight (): Int getMinimumWidth [androidJvm] open fun getMinimumWidth (): Int getNestedScrollAxes [androidJvm] open fun getNestedScrollAxes (): Int getNextClusterForwardId [androidJvm] open fun getNextClusterForwardId (): Int getNextFocusDownId [androidJvm] open fun getNextFocusDownId (): Int getNextFocusForwardId [androidJvm] open fun getNextFocusForwardId (): Int getNextFocusLeftId [androidJvm] open fun getNextFocusLeftId (): Int getNextFocusRightId [androidJvm] open fun getNextFocusRightId (): Int getNextFocusUpId [androidJvm] open fun getNextFocusUpId (): Int getOnFocusChangeListener [androidJvm] open fun getOnFocusChangeListener (): View.OnFocusChangeListener getOutlineAmbientShadowColor [androidJvm] open fun getOutlineAmbientShadowColor (): Int getOutlineProvider [androidJvm] open fun getOutlineProvider (): ViewOutlineProvider getOutlineSpotShadowColor [androidJvm] open fun getOutlineSpotShadowColor (): Int getOverlay [androidJvm] open override fun getOverlay (): ViewGroupOverlay getOverScrollMode [androidJvm] open fun getOverScrollMode (): Int getPaddingBottom [androidJvm] open fun getPaddingBottom (): Int getPaddingEnd [androidJvm] open fun getPaddingEnd (): Int getPaddingLeft [androidJvm] open fun getPaddingLeft (): Int getPaddingRight [androidJvm] open fun getPaddingRight (): Int getPaddingStart [androidJvm] open fun getPaddingStart (): Int getPaddingTop [androidJvm] open fun getPaddingTop (): Int getParent [androidJvm] fun getParent (): ViewParent getParentForAccessibility [androidJvm] open fun getParentForAccessibility (): ViewParent getPivotX [androidJvm] open fun getPivotX (): Float getPivotY [androidJvm] open fun getPivotY (): Float getPointerIcon [androidJvm] open fun getPointerIcon (): PointerIcon getReceiveContentMimeTypes [androidJvm] open fun getReceiveContentMimeTypes (): Array < String >? getResources [androidJvm] open fun getResources (): Resources getRevealOnFocusHint [androidJvm] fun getRevealOnFocusHint (): Boolean getRight [androidJvm] fun getRight (): Int getRightFadingEdgeStrength [androidJvm] open fun getRightFadingEdgeStrength (): Float getRightPaddingOffset [androidJvm] open fun getRightPaddingOffset (): Int getRootSurfaceControl [androidJvm] open fun getRootSurfaceControl (): AttachedSurfaceControl ? getRootView [androidJvm] open fun getRootView (): View getRootWindowInsets [androidJvm] open fun getRootWindowInsets (): WindowInsets getRotation [androidJvm] open fun getRotation (): Float getRotationX [androidJvm] open fun getRotationX (): Float getRotationY [androidJvm] open fun getRotationY (): Float getScaleX [androidJvm] open fun getScaleX (): Float getScaleY [androidJvm] open fun getScaleY (): Float getScrollBarDefaultDelayBeforeFade [androidJvm] open fun getScrollBarDefaultDelayBeforeFade (): Int getScrollBarFadeDuration [androidJvm] open fun getScrollBarFadeDuration (): Int getScrollBarSize [androidJvm] open fun getScrollBarSize (): Int getScrollBarStyle [androidJvm] open fun getScrollBarStyle (): Int getScrollCaptureHint [androidJvm] open fun getScrollCaptureHint (): Int getScrollIndicators [androidJvm] open fun getScrollIndicators (): Int getScrollX [androidJvm] fun getScrollX (): Int getScrollY [androidJvm] fun getScrollY (): Int getSolidColor [androidJvm] open fun getSolidColor (): Int getSourceLayoutResId [androidJvm] open fun getSourceLayoutResId (): Int getStateDescription [androidJvm] fun getStateDescription (): CharSequence ? getStateListAnimator [androidJvm] open fun getStateListAnimator (): StateListAnimator getSuggestedMinimumHeight [androidJvm] open fun getSuggestedMinimumHeight (): Int getSuggestedMinimumWidth [androidJvm] open fun getSuggestedMinimumWidth (): Int getSystemGestureExclusionRects [androidJvm] open fun getSystemGestureExclusionRects (): MutableList < Rect > getTag [androidJvm] open fun getTag (): Any open fun getTag (p0: Int ): Any getTextAlignment [androidJvm] open fun getTextAlignment (): Int getTextDirection [androidJvm] open fun getTextDirection (): Int getTooltipText [androidJvm] open fun getTooltipText (): CharSequence ? getTop [androidJvm] fun getTop (): Int getTopFadingEdgeStrength [androidJvm] open fun getTopFadingEdgeStrength (): Float getTopPaddingOffset [androidJvm] open fun getTopPaddingOffset (): Int getTouchables [androidJvm] open fun getTouchables (): ArrayList < View > getTouchDelegate [androidJvm] open fun getTouchDelegate (): TouchDelegate getTouchscreenBlocksFocus [androidJvm] open fun getTouchscreenBlocksFocus (): Boolean getTransitionAlpha [androidJvm] open fun getTransitionAlpha (): Float getTransitionName [androidJvm] open fun getTransitionName (): String getTranslationX [androidJvm] open fun getTranslationX (): Float getTranslationY [androidJvm] open fun getTranslationY (): Float getTranslationZ [androidJvm] open fun getTranslationZ (): Float getUniqueDrawingId [androidJvm] open fun getUniqueDrawingId (): Long getVerticalFadingEdgeLength [androidJvm] open fun getVerticalFadingEdgeLength (): Int getVerticalScrollbarPosition [androidJvm] open fun getVerticalScrollbarPosition (): Int getVerticalScrollbarThumbDrawable [androidJvm] open fun getVerticalScrollbarThumbDrawable (): Drawable ? getVerticalScrollbarTrackDrawable [androidJvm] open fun getVerticalScrollbarTrackDrawable (): Drawable ? getVerticalScrollbarWidth [androidJvm] open fun getVerticalScrollbarWidth (): Int getViewTranslationResponse [androidJvm] open fun getViewTranslationResponse (): ViewTranslationResponse ? getViewTreeObserver [androidJvm] open fun getViewTreeObserver (): ViewTreeObserver getVisibility [androidJvm] open fun getVisibility (): Int getWidth [androidJvm] fun getWidth (): Int getWindowAttachCount [androidJvm] open fun getWindowAttachCount (): Int getWindowId [androidJvm] open fun getWindowId (): WindowId getWindowInsetsController [androidJvm] open fun getWindowInsetsController (): WindowInsetsController ? getWindowToken [androidJvm] open fun getWindowToken (): IBinder getWindowVisibility [androidJvm] open fun getWindowVisibility (): Int getWindowVisibleDisplayFrame [androidJvm] open fun getWindowVisibleDisplayFrame (p0: Rect ) getX [androidJvm] open fun getX (): Float getY [androidJvm] open fun getY (): Float getZ [androidJvm] open fun getZ (): Float hasExplicitFocusable [androidJvm] open fun hasExplicitFocusable (): Boolean hasFocus [androidJvm] open override fun hasFocus (): Boolean hasFocusable [androidJvm] open fun hasFocusable (): Boolean hasNestedScrollingParent [androidJvm] open fun hasNestedScrollingParent (): Boolean hasOnClickListeners [androidJvm] open fun hasOnClickListeners (): Boolean hasOnLongClickListeners [androidJvm] open fun hasOnLongClickListeners (): Boolean hasOverlappingRendering [androidJvm] open fun hasOverlappingRendering (): Boolean hasPointerCapture [androidJvm] open fun hasPointerCapture (): Boolean hasTransientState [androidJvm] open override fun hasTransientState (): Boolean hasWindowFocus [androidJvm] open fun hasWindowFocus (): Boolean indexOfChild [androidJvm] open fun indexOfChild (p0: View ): Int invalidate [androidJvm] open fun invalidate () invalidateDrawable [androidJvm] open override fun invalidateDrawable (p0: Drawable ) invalidateOutline [androidJvm] open fun invalidateOutline () isAccessibilityFocused [androidJvm] open fun isAccessibilityFocused (): Boolean isAccessibilityHeading [androidJvm] open fun isAccessibilityHeading (): Boolean isActivated [androidJvm] open fun isActivated (): Boolean isAttachedToWindow [androidJvm] open fun isAttachedToWindow (): Boolean isChildrenDrawingOrderEnabled [androidJvm] open fun isChildrenDrawingOrderEnabled (): Boolean isClickable [androidJvm] open fun isClickable (): Boolean isContextClickable [androidJvm] open fun isContextClickable (): Boolean isDirty [androidJvm] open fun isDirty (): Boolean isDuplicateParentStateEnabled [androidJvm] open fun isDuplicateParentStateEnabled (): Boolean isEnabled [androidJvm] open fun isEnabled (): Boolean isFocusable [androidJvm] fun isFocusable (): Boolean isFocusableInTouchMode [androidJvm] fun isFocusableInTouchMode (): Boolean isFocused [androidJvm] open fun isFocused (): Boolean isFocusedByDefault [androidJvm] fun isFocusedByDefault (): Boolean isForceDarkAllowed [androidJvm] open fun isForceDarkAllowed (): Boolean isHapticFeedbackEnabled [androidJvm] open fun isHapticFeedbackEnabled (): Boolean isHardwareAccelerated [androidJvm] open fun isHardwareAccelerated (): Boolean isHorizontalFadingEdgeEnabled [androidJvm] open fun isHorizontalFadingEdgeEnabled (): Boolean isHorizontalScrollBarEnabled [androidJvm] open fun isHorizontalScrollBarEnabled (): Boolean isHovered [androidJvm] open fun isHovered (): Boolean isImportantForAccessibility [androidJvm] open fun isImportantForAccessibility (): Boolean isImportantForAutofill [androidJvm] fun isImportantForAutofill (): Boolean isImportantForContentCapture [androidJvm] fun isImportantForContentCapture (): Boolean isInEditMode [androidJvm] open fun isInEditMode (): Boolean isInLayout [androidJvm] open fun isInLayout (): Boolean isInTouchMode [androidJvm] open fun isInTouchMode (): Boolean isKeyboardNavigationCluster [androidJvm] fun isKeyboardNavigationCluster (): Boolean isLaidOut [androidJvm] open fun isLaidOut (): Boolean isLayoutDirectionResolved [androidJvm] open fun isLayoutDirectionResolved (): Boolean isLayoutRequested [androidJvm] open fun isLayoutRequested (): Boolean isLayoutSuppressed [androidJvm] open fun isLayoutSuppressed (): Boolean isLongClickable [androidJvm] open fun isLongClickable (): Boolean isMotionEventSplittingEnabled [androidJvm] open fun isMotionEventSplittingEnabled (): Boolean isNestedScrollingEnabled [androidJvm] open fun isNestedScrollingEnabled (): Boolean isOpaque [androidJvm] open fun isOpaque (): Boolean isPaddingOffsetRequired [androidJvm] open fun isPaddingOffsetRequired (): Boolean isPaddingRelative [androidJvm] open fun isPaddingRelative (): Boolean isPivotSet [androidJvm] open fun isPivotSet (): Boolean isPressed [androidJvm] open fun isPressed (): Boolean isSaveEnabled [androidJvm] open fun isSaveEnabled (): Boolean isSaveFromParentEnabled [androidJvm] open fun isSaveFromParentEnabled (): Boolean isScreenReaderFocusable [androidJvm] open fun isScreenReaderFocusable (): Boolean isScrollbarFadingEnabled [androidJvm] open fun isScrollbarFadingEnabled (): Boolean isScrollContainer [androidJvm] open fun isScrollContainer (): Boolean isSelected [androidJvm] open fun isSelected (): Boolean isShowingLayoutBounds [androidJvm] fun isShowingLayoutBounds (): Boolean isShown [androidJvm] open fun isShown (): Boolean isSoundEffectsEnabled [androidJvm] open fun isSoundEffectsEnabled (): Boolean isTemporarilyDetached [androidJvm] fun isTemporarilyDetached (): Boolean isTextAlignmentResolved [androidJvm] open fun isTextAlignmentResolved (): Boolean isTextDirectionResolved [androidJvm] open fun isTextDirectionResolved (): Boolean isTransitionGroup [androidJvm] open fun isTransitionGroup (): Boolean isVerticalFadingEdgeEnabled [androidJvm] open fun isVerticalFadingEdgeEnabled (): Boolean isVerticalScrollBarEnabled [androidJvm] open fun isVerticalScrollBarEnabled (): Boolean isVisibleToUserForAutofill [androidJvm] open fun isVisibleToUserForAutofill (p0: Int ): Boolean jumpDrawablesToCurrentState [androidJvm] open override fun jumpDrawablesToCurrentState () keyboardNavigationClusterSearch [androidJvm] open fun keyboardNavigationClusterSearch (p0: View , p1: Int ): View layout [androidJvm] override fun layout (p0: Int , p1: Int , p2: Int , p3: Int ) measure [androidJvm] fun measure (p0: Int , p1: Int ) measureChild [androidJvm] open fun measureChild (p0: View , p1: Int , p2: Int ) measureChildren [androidJvm] open fun measureChildren (p0: Int , p1: Int ) measureChildWithMargins [androidJvm] open fun measureChildWithMargins (p0: View , p1: Int , p2: Int , p3: Int , p4: Int ) notifySubtreeAccessibilityStateChanged [androidJvm] open override fun notifySubtreeAccessibilityStateChanged (p0: View , p1: View , p2: Int ) offsetDescendantRectToMyCoords [androidJvm] fun offsetDescendantRectToMyCoords (p0: View , p1: Rect ) offsetLeftAndRight [androidJvm] open fun offsetLeftAndRight (p0: Int ) offsetRectIntoDescendantCoords [androidJvm] fun offsetRectIntoDescendantCoords (p0: View , p1: Rect ) offsetTopAndBottom [androidJvm] open fun offsetTopAndBottom (p0: Int ) onAnimationEnd [androidJvm] open fun onAnimationEnd () onAnimationStart [androidJvm] open fun onAnimationStart () onApplyWindowInsets [androidJvm] open fun onApplyWindowInsets (p0: WindowInsets ): WindowInsets onAttachedToWindow [androidJvm] open override fun onAttachedToWindow () onCancelPendingInputEvents [androidJvm] open fun onCancelPendingInputEvents () onCapturedPointerEvent [androidJvm] open fun onCapturedPointerEvent (p0: MotionEvent ): Boolean onCheckIsTextEditor [androidJvm] open fun onCheckIsTextEditor (): Boolean onConfigurationChanged [androidJvm] open fun onConfigurationChanged (p0: Configuration ) onCreateContextMenu [androidJvm] open fun onCreateContextMenu (p0: ContextMenu ) onCreateDrawableState [androidJvm] open override fun onCreateDrawableState (p0: Int ): IntArray onCreateInputConnection [androidJvm] open fun onCreateInputConnection (p0: EditorInfo ): InputConnection onCreateViewTranslationRequest [androidJvm] open fun onCreateViewTranslationRequest (p0: IntArray , p1: Consumer < ViewTranslationRequest >) onCreateVirtualViewTranslationRequests [androidJvm] open fun onCreateVirtualViewTranslationRequests (p0: LongArray , p1: IntArray , p2: Consumer < ViewTranslationRequest >) onDescendantInvalidated [androidJvm] open override fun onDescendantInvalidated (p0: View , p1: View ) onDetachedFromWindow [androidJvm] open override fun onDetachedFromWindow () onDisplayHint [androidJvm] open fun onDisplayHint (p0: Int ) onDragEvent [androidJvm] open fun onDragEvent (p0: DragEvent ): Boolean onDraw [androidJvm] open fun onDraw (p0: Canvas ) onDrawForeground [androidJvm] open fun onDrawForeground (p0: Canvas ) onDrawScrollBars [androidJvm] fun onDrawScrollBars (p0: Canvas ) onFilterTouchEventForSecurity [androidJvm] open fun onFilterTouchEventForSecurity (p0: MotionEvent ): Boolean onFinishInflate [androidJvm] open fun onFinishInflate () onFinishTemporaryDetach [androidJvm] open fun onFinishTemporaryDetach () onFocusChanged [androidJvm] open fun onFocusChanged (p0: Boolean , p1: Int , p2: Rect ?) onGenericMotionEvent [androidJvm] open fun onGenericMotionEvent (p0: MotionEvent ): Boolean onHoverChanged [androidJvm] open fun onHoverChanged (p0: Boolean ) onHoverEvent [androidJvm] open fun onHoverEvent (p0: MotionEvent ): Boolean onInitializeAccessibilityEvent [androidJvm] open fun onInitializeAccessibilityEvent (p0: AccessibilityEvent ) onInitializeAccessibilityNodeInfo [androidJvm] open fun onInitializeAccessibilityNodeInfo (p0: AccessibilityNodeInfo ) onInterceptHoverEvent [androidJvm] open fun onInterceptHoverEvent (p0: MotionEvent ): Boolean onInterceptTouchEvent [androidJvm] open fun onInterceptTouchEvent (p0: MotionEvent ): Boolean onKeyDown [androidJvm] open override fun onKeyDown (p0: Int , p1: KeyEvent ): Boolean onKeyLongPress [androidJvm] open override fun onKeyLongPress (p0: Int , p1: KeyEvent ): Boolean onKeyMultiple [androidJvm] open override fun onKeyMultiple (p0: Int , p1: Int , p2: KeyEvent ): Boolean onKeyPreIme [androidJvm] open fun onKeyPreIme (p0: Int , p1: KeyEvent ): Boolean onKeyShortcut [androidJvm] open fun onKeyShortcut (p0: Int , p1: KeyEvent ): Boolean onKeyUp [androidJvm] open override fun onKeyUp (p0: Int , p1: KeyEvent ): Boolean onLayout [androidJvm] open override fun onLayout (p0: Boolean , p1: Int , p2: Int , p3: Int , p4: Int ) onMeasure [androidJvm] open override fun onMeasure (p0: Int , p1: Int ) onNestedFling [androidJvm] open override fun onNestedFling (p0: View , p1: Float , p2: Float , p3: Boolean ): Boolean onNestedPreFling [androidJvm] open override fun onNestedPreFling (p0: View , p1: Float , p2: Float ): Boolean onNestedPrePerformAccessibilityAction [androidJvm] open override fun onNestedPrePerformAccessibilityAction (p0: View , p1: Int , p2: Bundle ): Boolean onNestedPreScroll [androidJvm] open override fun onNestedPreScroll (p0: View , p1: Int , p2: Int , p3: IntArray ) onNestedScroll [androidJvm] open override fun onNestedScroll (p0: View , p1: Int , p2: Int , p3: Int , p4: Int ) onNestedScrollAccepted [androidJvm] open override fun onNestedScrollAccepted (p0: View , p1: View , p2: Int ) onOverScrolled [androidJvm] open fun onOverScrolled (p0: Int , p1: Int , p2: Boolean , p3: Boolean ) onPointerCaptureChange [androidJvm] open fun onPointerCaptureChange (p0: Boolean ) onPopulateAccessibilityEvent [androidJvm] open fun onPopulateAccessibilityEvent (p0: AccessibilityEvent ) onProvideAutofillStructure [androidJvm] open fun onProvideAutofillStructure (p0: ViewStructure , p1: Int ) onProvideAutofillVirtualStructure [androidJvm] open fun onProvideAutofillVirtualStructure (p0: ViewStructure , p1: Int ) onProvideContentCaptureStructure [androidJvm] open fun onProvideContentCaptureStructure (p0: ViewStructure , p1: Int ) onProvideStructure [androidJvm] open fun onProvideStructure (p0: ViewStructure ) onProvideVirtualStructure [androidJvm] open fun onProvideVirtualStructure (p0: ViewStructure ) onReceiveContent [androidJvm] open fun onReceiveContent (p0: ContentInfo ): ContentInfo ? onRequestFocusInDescendants [androidJvm] open fun onRequestFocusInDescendants (p0: Int , p1: Rect ): Boolean onRequestSendAccessibilityEvent [androidJvm] open fun onRequestSendAccessibilityEvent (p0: View , p1: AccessibilityEvent ): Boolean onResolvePointerIcon [androidJvm] open override fun onResolvePointerIcon (p0: MotionEvent , p1: Int ): PointerIcon onRtlPropertiesChanged [androidJvm] open fun onRtlPropertiesChanged (p0: Int ) onScreenStateChanged [androidJvm] open fun onScreenStateChanged (p0: Int ) onScrollCaptureSearch [androidJvm] open fun onScrollCaptureSearch (p0: Rect , p1: Point , p2: Consumer < ScrollCaptureTarget >) onScrollChanged [androidJvm] open fun onScrollChanged (p0: Int , p1: Int , p2: Int , p3: Int ) onSetAlpha [androidJvm] open fun onSetAlpha (p0: Int ): Boolean onSizeChanged [androidJvm] open fun onSizeChanged (p0: Int , p1: Int , p2: Int , p3: Int ) onStartNestedScroll [androidJvm] open override fun onStartNestedScroll (p0: View , p1: View , p2: Int ): Boolean onStartTemporaryDetach [androidJvm] open fun onStartTemporaryDetach () onStopNestedScroll [androidJvm] open override fun onStopNestedScroll (p0: View ) onTouchEvent [androidJvm] open fun onTouchEvent (p0: MotionEvent ): Boolean onTrackballEvent [androidJvm] open fun onTrackballEvent (p0: MotionEvent ): Boolean onViewAdded [androidJvm] open fun onViewAdded (p0: View ) onViewRemoved [androidJvm] open fun onViewRemoved (p0: View ) onViewTranslationResponse [androidJvm] open fun onViewTranslationResponse (p0: ViewTranslationResponse ) onVirtualViewTranslationResponses [androidJvm] open fun onVirtualViewTranslationResponses (p0: LongSparseArray < ViewTranslationResponse >) onVisibilityAggregated [androidJvm] open fun onVisibilityAggregated (p0: Boolean ) onVisibilityChanged [androidJvm] open fun onVisibilityChanged (p0: View , p1: Int ) onWindowFocusChanged [androidJvm] open fun onWindowFocusChanged (p0: Boolean ) onWindowVisibilityChanged [androidJvm] open fun onWindowVisibilityChanged (p0: Int ) overScrollBy [androidJvm] open fun overScrollBy (p0: Int , p1: Int , p2: Int , p3: Int , p4: Int , p5: Int , p6: Int , p7: Int , p8: Boolean ): Boolean performAccessibilityAction [androidJvm] open fun performAccessibilityAction (p0: Int , p1: Bundle ): Boolean performClick [androidJvm] open fun performClick (): Boolean performContextClick [androidJvm] open fun performContextClick (): Boolean open fun performContextClick (p0: Float , p1: Float ): Boolean performHapticFeedback [androidJvm] open fun performHapticFeedback (p0: Int ): Boolean open fun performHapticFeedback (p0: Int , p1: Int ): Boolean performLongClick [androidJvm] open fun performLongClick (): Boolean open fun performLongClick (p0: Float , p1: Float ): Boolean performReceiveContent [androidJvm] open fun performReceiveContent (p0: ContentInfo ): ContentInfo ? playSoundEffect [androidJvm] open fun playSoundEffect (p0: Int ) post [androidJvm] open fun post (p0: Runnable ): Boolean postDelayed [androidJvm] open fun postDelayed (p0: Runnable , p1: Long ): Boolean postInvalidate [androidJvm] open fun postInvalidate () open fun postInvalidate (p0: Int , p1: Int , p2: Int , p3: Int ) postInvalidateDelayed [androidJvm] open fun postInvalidateDelayed (p0: Long ) open fun postInvalidateDelayed (p0: Long , p1: Int , p2: Int , p3: Int , p4: Int ) postInvalidateOnAnimation [androidJvm] open fun postInvalidateOnAnimation () open fun postInvalidateOnAnimation (p0: Int , p1: Int , p2: Int , p3: Int ) postOnAnimation [androidJvm] open fun postOnAnimation (p0: Runnable ) postOnAnimationDelayed [androidJvm] open fun postOnAnimationDelayed (p0: Runnable , p1: Long ) recomputeViewAttributes [androidJvm] open override fun recomputeViewAttributes (p0: View ) refreshDrawableState [androidJvm] open fun refreshDrawableState () releasePointerCapture [androidJvm] open fun releasePointerCapture () removeAllViews [androidJvm] open fun removeAllViews () removeAllViewsInLayout [androidJvm] open fun removeAllViewsInLayout () removeCallbacks [androidJvm] open fun removeCallbacks (p0: Runnable ): Boolean removeDetachedView [androidJvm] open fun removeDetachedView (p0: View , p1: Boolean ) removeOnAttachStateChangeListener [androidJvm] open fun removeOnAttachStateChangeListener (p0: View.OnAttachStateChangeListener ) removeOnLayoutChangeListener [androidJvm] open fun removeOnLayoutChangeListener (p0: View.OnLayoutChangeListener ) removeOnUnhandledKeyEventListener [androidJvm] open fun removeOnUnhandledKeyEventListener (p0: View.OnUnhandledKeyEventListener ) removeView [androidJvm] open override fun removeView (p0: View ) removeViewAt [androidJvm] open fun removeViewAt (p0: Int ) removeViewInLayout [androidJvm] open fun removeViewInLayout (p0: View ) removeViews [androidJvm] open fun removeViews (p0: Int , p1: Int ) removeViewsInLayout [androidJvm] open fun removeViewsInLayout (p0: Int , p1: Int ) requestApplyInsets [androidJvm] open fun requestApplyInsets () requestChildFocus [androidJvm] open override fun requestChildFocus (p0: View , p1: View ) requestChildRectangleOnScreen [androidJvm] open override fun requestChildRectangleOnScreen (p0: View , p1: Rect , p2: Boolean ): Boolean requestDisallowInterceptTouchEvent [androidJvm] open override fun requestDisallowInterceptTouchEvent (p0: Boolean ) requestFocus [androidJvm] fun requestFocus (): Boolean fun requestFocus (p0: Int ): Boolean open override fun requestFocus (p0: Int , p1: Rect ): Boolean requestFocusFromTouch [androidJvm] fun requestFocusFromTouch (): Boolean requestLayout [androidJvm] open fun requestLayout () requestPointerCapture [androidJvm] open fun requestPointerCapture () requestRectangleOnScreen [androidJvm] open fun requestRectangleOnScreen (p0: Rect ): Boolean open fun requestRectangleOnScreen (p0: Rect , p1: Boolean ): Boolean requestSendAccessibilityEvent [androidJvm] open override fun requestSendAccessibilityEvent (p0: View , p1: AccessibilityEvent ): Boolean requestTransparentRegion [androidJvm] open override fun requestTransparentRegion (p0: View ) requestUnbufferedDispatch [androidJvm] fun requestUnbufferedDispatch (p0: MotionEvent ) fun requestUnbufferedDispatch (p0: Int ) requireViewById [androidJvm] fun < T : View > requireViewById (p0: Int ): T resetPivot [androidJvm] open fun resetPivot () restoreDefaultFocus [androidJvm] open override fun restoreDefaultFocus (): Boolean restoreHierarchyState [androidJvm] open fun restoreHierarchyState (p0: SparseArray < Parcelable >) saveAttributeDataForStyleable [androidJvm] fun saveAttributeDataForStyleable (p0: Context , p1: IntArray , p2: AttributeSet ?, p3: TypedArray , p4: Int , p5: Int ) saveHierarchyState [androidJvm] open fun saveHierarchyState (p0: SparseArray < Parcelable >) scheduleDrawable [androidJvm] open override fun scheduleDrawable (p0: Drawable , p1: Runnable , p2: Long ) scheduleLayoutAnimation [androidJvm] open fun scheduleLayoutAnimation () scrollBy [androidJvm] open fun scrollBy (p0: Int , p1: Int ) scrollTo [androidJvm] open fun scrollTo (p0: Int , p1: Int ) sendAccessibilityEvent [androidJvm] open override fun sendAccessibilityEvent (p0: Int ) sendAccessibilityEventUnchecked [androidJvm] open override fun sendAccessibilityEventUnchecked (p0: AccessibilityEvent ) setAccessibilityDelegate [androidJvm] open fun setAccessibilityDelegate (p0: View.AccessibilityDelegate ?) setAccessibilityHeading [androidJvm] open fun setAccessibilityHeading (p0: Boolean ) setAccessibilityLiveRegion [androidJvm] open fun setAccessibilityLiveRegion (p0: Int ) setAccessibilityPaneTitle [androidJvm] open fun setAccessibilityPaneTitle (p0: CharSequence ?) setAccessibilityTraversalAfter [androidJvm] open fun setAccessibilityTraversalAfter (p0: Int ) setAccessibilityTraversalBefore [androidJvm] open fun setAccessibilityTraversalBefore (p0: Int ) setActivated [androidJvm] open fun setActivated (p0: Boolean ) setAddStatesFromChildren [androidJvm] open fun setAddStatesFromChildren (p0: Boolean ) setAllowClickWhenDisabled [androidJvm] open fun setAllowClickWhenDisabled (p0: Boolean ) setAlpha [androidJvm] open fun setAlpha (p0: Float ) setAnimation [androidJvm] open fun setAnimation (p0: Animation ) setAnimationMatrix [androidJvm] open fun setAnimationMatrix (p0: Matrix ?) setAutofillHints [androidJvm] open fun setAutofillHints (vararg p0: String ) setAutofillId [androidJvm] open fun setAutofillId (p0: AutofillId ?) setBackground [androidJvm] open fun setBackground (p0: Drawable ) setBackgroundColor [androidJvm] open fun setBackgroundColor (p0: Int ) setBackgroundResource [androidJvm] open fun setBackgroundResource (p0: Int ) setBackgroundTintBlendMode [androidJvm] open fun setBackgroundTintBlendMode (p0: BlendMode ?) setBackgroundTintList [androidJvm] open fun setBackgroundTintList (p0: ColorStateList ?) setBackgroundTintMode [androidJvm] open fun setBackgroundTintMode (p0: PorterDuff.Mode ?) setBottom [androidJvm] fun setBottom (p0: Int ) setCameraDistance [androidJvm] open fun setCameraDistance (p0: Float ) setChildrenDrawingOrderEnabled [androidJvm] open fun setChildrenDrawingOrderEnabled (p0: Boolean ) setClickable [androidJvm] open fun setClickable (p0: Boolean ) setClipBounds [androidJvm] open fun setClipBounds (p0: Rect ) setClipChildren [androidJvm] open fun setClipChildren (p0: Boolean ) setClipToOutline [androidJvm] open fun setClipToOutline (p0: Boolean ) setClipToPadding [androidJvm] open fun setClipToPadding (p0: Boolean ) setContentCaptureSession [androidJvm] open fun setContentCaptureSession (p0: ContentCaptureSession ?) setContentDescription [androidJvm] open fun setContentDescription (p0: CharSequence ) setContextClickable [androidJvm] open fun setContextClickable (p0: Boolean ) setDefaultFocusHighlightEnabled [androidJvm] open fun setDefaultFocusHighlightEnabled (p0: Boolean ) setDescendantFocusability [androidJvm] open fun setDescendantFocusability (p0: Int ) setDuplicateParentStateEnabled [androidJvm] open fun setDuplicateParentStateEnabled (p0: Boolean ) setElevation [androidJvm] open fun setElevation (p0: Float ) setEnabled [androidJvm] open fun setEnabled (p0: Boolean ) setFadingEdgeLength [androidJvm] open fun setFadingEdgeLength (p0: Int ) setFilterTouchesWhenObscured [androidJvm] open fun setFilterTouchesWhenObscured (p0: Boolean ) setFitsSystemWindows [androidJvm] open fun setFitsSystemWindows (p0: Boolean ) setFocusable [androidJvm] open fun setFocusable (p0: Boolean ) open fun setFocusable (p0: Int ) setFocusableInTouchMode [androidJvm] open fun setFocusableInTouchMode (p0: Boolean ) setFocusedByDefault [androidJvm] open fun setFocusedByDefault (p0: Boolean ) setForceDarkAllowed [androidJvm] open fun setForceDarkAllowed (p0: Boolean ) setForeground [androidJvm] open fun setForeground (p0: Drawable ) setForegroundGravity [androidJvm] open override fun setForegroundGravity (p0: Int ) setForegroundTintBlendMode [androidJvm] open fun setForegroundTintBlendMode (p0: BlendMode ?) setForegroundTintList [androidJvm] open fun setForegroundTintList (p0: ColorStateList ?) setForegroundTintMode [androidJvm] open fun setForegroundTintMode (p0: PorterDuff.Mode ?) setHapticFeedbackEnabled [androidJvm] open fun setHapticFeedbackEnabled (p0: Boolean ) setHasTransientState [androidJvm] open fun setHasTransientState (p0: Boolean ) setHorizontalFadingEdgeEnabled [androidJvm] open fun setHorizontalFadingEdgeEnabled (p0: Boolean ) setHorizontalScrollBarEnabled [androidJvm] open fun setHorizontalScrollBarEnabled (p0: Boolean ) setHorizontalScrollbarThumbDrawable [androidJvm] open fun setHorizontalScrollbarThumbDrawable (p0: Drawable ?) setHorizontalScrollbarTrackDrawable [androidJvm] open fun setHorizontalScrollbarTrackDrawable (p0: Drawable ?) setHovered [androidJvm] open fun setHovered (p0: Boolean ) setId [androidJvm] open fun setId (p0: Int ) setImportantForAccessibility [androidJvm] open fun setImportantForAccessibility (p0: Int ) setImportantForAutofill [androidJvm] open fun setImportantForAutofill (p0: Int ) setImportantForContentCapture [androidJvm] open fun setImportantForContentCapture (p0: Int ) setKeepScreenOn [androidJvm] open fun setKeepScreenOn (p0: Boolean ) setKeyboardNavigationCluster [androidJvm] open fun setKeyboardNavigationCluster (p0: Boolean ) setLabelFor [androidJvm] open fun setLabelFor (p0: Int ) setLayerPaint [androidJvm] open fun setLayerPaint (p0: Paint ?) setLayerType [androidJvm] open fun setLayerType (p0: Int , p1: Paint ?) setLayoutAnimation [androidJvm] open fun setLayoutAnimation (p0: LayoutAnimationController ) setLayoutAnimationListener [androidJvm] open fun setLayoutAnimationListener (p0: Animation.AnimationListener ) setLayoutDirection [androidJvm] open fun setLayoutDirection (p0: Int ) setLayoutMode [androidJvm] open fun setLayoutMode (p0: Int ) setLayoutParams [androidJvm] open fun setLayoutParams (p0: ViewGroup.LayoutParams ) setLayoutTransition [androidJvm] open fun setLayoutTransition (p0: LayoutTransition ) setLeft [androidJvm] fun setLeft (p0: Int ) setLeftTopRightBottom [androidJvm] fun setLeftTopRightBottom (p0: Int , p1: Int , p2: Int , p3: Int ) setLongClickable [androidJvm] open fun setLongClickable (p0: Boolean ) setMeasureAllChildren [androidJvm] open fun setMeasureAllChildren (p0: Boolean ) setMeasuredDimension [androidJvm] fun setMeasuredDimension (p0: Int , p1: Int ) setMinimumHeight [androidJvm] open fun setMinimumHeight (p0: Int ) setMinimumWidth [androidJvm] open fun setMinimumWidth (p0: Int ) setMotionEventSplittingEnabled [androidJvm] open fun setMotionEventSplittingEnabled (p0: Boolean ) setNestedScrollingEnabled [androidJvm] open fun setNestedScrollingEnabled (p0: Boolean ) setNextClusterForwardId [androidJvm] open fun setNextClusterForwardId (p0: Int ) setNextFocusDownId [androidJvm] open fun setNextFocusDownId (p0: Int ) setNextFocusForwardId [androidJvm] open fun setNextFocusForwardId (p0: Int ) setNextFocusLeftId [androidJvm] open fun setNextFocusLeftId (p0: Int ) setNextFocusRightId [androidJvm] open fun setNextFocusRightId (p0: Int ) setNextFocusUpId [androidJvm] open fun setNextFocusUpId (p0: Int ) setOnApplyWindowInsetsListener [androidJvm] open fun setOnApplyWindowInsetsListener (p0: View.OnApplyWindowInsetsListener ) setOnCapturedPointerListener [androidJvm] open fun setOnCapturedPointerListener (p0: View.OnCapturedPointerListener ) setOnClickListener [androidJvm] open fun setOnClickListener (p0: View.OnClickListener ?) setOnContextClickListener [androidJvm] open fun setOnContextClickListener (p0: View.OnContextClickListener ?) setOnCreateContextMenuListener [androidJvm] open fun setOnCreateContextMenuListener (p0: View.OnCreateContextMenuListener ) setOnDragListener [androidJvm] open fun setOnDragListener (p0: View.OnDragListener ) setOnFocusChangeListener [androidJvm] open fun setOnFocusChangeListener (p0: View.OnFocusChangeListener ) setOnGenericMotionListener [androidJvm] open fun setOnGenericMotionListener (p0: View.OnGenericMotionListener ) setOnHierarchyChangeListener [androidJvm] open fun setOnHierarchyChangeListener (p0: ViewGroup.OnHierarchyChangeListener ) setOnHoverListener [androidJvm] open fun setOnHoverListener (p0: View.OnHoverListener ) setOnKeyListener [androidJvm] open fun setOnKeyListener (p0: View.OnKeyListener ) setOnLongClickListener [androidJvm] open fun setOnLongClickListener (p0: View.OnLongClickListener ?) setOnReceiveContentListener [androidJvm] open fun setOnReceiveContentListener (p0: Array < String >?, p1: OnReceiveContentListener ?) setOnScrollChangeListener [androidJvm] open fun setOnScrollChangeListener (p0: View.OnScrollChangeListener ) setOnTouchListener [androidJvm] open fun setOnTouchListener (p0: View.OnTouchListener ) setOutlineAmbientShadowColor [androidJvm] open fun setOutlineAmbientShadowColor (p0: Int ) setOutlineProvider [androidJvm] open fun setOutlineProvider (p0: ViewOutlineProvider ) setOutlineSpotShadowColor [androidJvm] open fun setOutlineSpotShadowColor (p0: Int ) setOverScrollMode [androidJvm] open fun setOverScrollMode (p0: Int ) setPadding [androidJvm] open fun setPadding (p0: Int , p1: Int , p2: Int , p3: Int ) setPaddingRelative [androidJvm] open fun setPaddingRelative (p0: Int , p1: Int , p2: Int , p3: Int ) setPivotX [androidJvm] open fun setPivotX (p0: Float ) setPivotY [androidJvm] open fun setPivotY (p0: Float ) setPointerIcon [androidJvm] open fun setPointerIcon (p0: PointerIcon ) setPressed [androidJvm] open fun setPressed (p0: Boolean ) setRenderEffect [androidJvm] open fun setRenderEffect (p0: RenderEffect ?) setRevealOnFocusHint [androidJvm] fun setRevealOnFocusHint (p0: Boolean ) setRight [androidJvm] fun setRight (p0: Int ) setRotation [androidJvm] open fun setRotation (p0: Float ) setRotationX [androidJvm] open fun setRotationX (p0: Float ) setRotationY [androidJvm] open fun setRotationY (p0: Float ) setSaveEnabled [androidJvm] open fun setSaveEnabled (p0: Boolean ) setSaveFromParentEnabled [androidJvm] open fun setSaveFromParentEnabled (p0: Boolean ) setScaleX [androidJvm] open fun setScaleX (p0: Float ) setScaleY [androidJvm] open fun setScaleY (p0: Float ) setScreenReaderFocusable [androidJvm] open fun setScreenReaderFocusable (p0: Boolean ) setScrollBarDefaultDelayBeforeFade [androidJvm] open fun setScrollBarDefaultDelayBeforeFade (p0: Int ) setScrollBarFadeDuration [androidJvm] open fun setScrollBarFadeDuration (p0: Int ) setScrollbarFadingEnabled [androidJvm] open fun setScrollbarFadingEnabled (p0: Boolean ) setScrollBarSize [androidJvm] open fun setScrollBarSize (p0: Int ) setScrollBarStyle [androidJvm] open fun setScrollBarStyle (p0: Int ) setScrollCaptureCallback [androidJvm] fun setScrollCaptureCallback (p0: ScrollCaptureCallback ?) setScrollCaptureHint [androidJvm] open fun setScrollCaptureHint (p0: Int ) setScrollContainer [androidJvm] open fun setScrollContainer (p0: Boolean ) setScrollIndicators [androidJvm] open fun setScrollIndicators (p0: Int ) open fun setScrollIndicators (p0: Int , p1: Int ) setScrollX [androidJvm] open fun setScrollX (p0: Int ) setScrollY [androidJvm] open fun setScrollY (p0: Int ) setSelected [androidJvm] open fun setSelected (p0: Boolean ) setSoundEffectsEnabled [androidJvm] open fun setSoundEffectsEnabled (p0: Boolean ) setStateDescription [androidJvm] open fun setStateDescription (p0: CharSequence ?) setStateListAnimator [androidJvm] open fun setStateListAnimator (p0: StateListAnimator ) setStaticTransformationsEnabled [androidJvm] open fun setStaticTransformationsEnabled (p0: Boolean ) setSystemGestureExclusionRects [androidJvm] open fun setSystemGestureExclusionRects (p0: MutableList < Rect >) setTag [androidJvm] open fun setTag (p0: Any ) open fun setTag (p0: Int , p1: Any ) setTextAlignment [androidJvm] open fun setTextAlignment (p0: Int ) setTextDirection [androidJvm] open fun setTextDirection (p0: Int ) setTooltipText [androidJvm] open fun setTooltipText (p0: CharSequence ?) setTop [androidJvm] fun setTop (p0: Int ) setTouchDelegate [androidJvm] open fun setTouchDelegate (p0: TouchDelegate ) setTouchscreenBlocksFocus [androidJvm] open fun setTouchscreenBlocksFocus (p0: Boolean ) setTransitionAlpha [androidJvm] open fun setTransitionAlpha (p0: Float ) setTransitionGroup [androidJvm] open fun setTransitionGroup (p0: Boolean ) setTransitionName [androidJvm] fun setTransitionName (p0: String ) setTransitionVisibility [androidJvm] open fun setTransitionVisibility (p0: Int ) setTranslationX [androidJvm] open fun setTranslationX (p0: Float ) setTranslationY [androidJvm] open fun setTranslationY (p0: Float ) setTranslationZ [androidJvm] open fun setTranslationZ (p0: Float ) setVerticalFadingEdgeEnabled [androidJvm] open fun setVerticalFadingEdgeEnabled (p0: Boolean ) setVerticalScrollBarEnabled [androidJvm] open fun setVerticalScrollBarEnabled (p0: Boolean ) setVerticalScrollbarPosition [androidJvm] open fun setVerticalScrollbarPosition (p0: Int ) setVerticalScrollbarThumbDrawable [androidJvm] open fun setVerticalScrollbarThumbDrawable (p0: Drawable ?) setVerticalScrollbarTrackDrawable [androidJvm] open fun setVerticalScrollbarTrackDrawable (p0: Drawable ?) setViewTranslationCallback [androidJvm] open fun setViewTranslationCallback (p0: ViewTranslationCallback ) setVisibility [androidJvm] open fun setVisibility (p0: Int ) setWillNotDraw [androidJvm] open fun setWillNotDraw (p0: Boolean ) setWindowInsetsAnimationCallback [androidJvm] open override fun setWindowInsetsAnimationCallback (p0: WindowInsetsAnimation.Callback ?) setX [androidJvm] open fun setX (p0: Float ) setY [androidJvm] open fun setY (p0: Float ) setZ [androidJvm] open fun setZ (p0: Float ) shouldDelayChildPressedState [androidJvm] open override fun shouldDelayChildPressedState (): Boolean showContextMenu [androidJvm] open fun showContextMenu (): Boolean open fun showContextMenu (p0: Float , p1: Float ): Boolean showContextMenuForChild [androidJvm] open override fun showContextMenuForChild (p0: View ): Boolean open override fun showContextMenuForChild (p0: View , p1: Float , p2: Float ): Boolean start [androidJvm] fun start (renderings: Flow< Any >, environment: ViewEnvironment = ViewEnvironment()) This is the most common way to bootstrap a Workflow driven UI. Collects renderings , and calls start with each one and environment . [androidJvm] fun start (renderings: Flow< Any >, registry: ViewRegistry ) A convenience overload that builds a ViewEnvironment around registry , for a bit less boilerplate. startActionMode [androidJvm] open fun startActionMode (p0: ActionMode.Callback ): ActionMode open fun startActionMode (p0: ActionMode.Callback , p1: Int ): ActionMode startActionModeForChild [androidJvm] open override fun startActionModeForChild (p0: View , p1: ActionMode.Callback ): ActionMode open override fun startActionModeForChild (p0: View , p1: ActionMode.Callback , p2: Int ): ActionMode startAnimation [androidJvm] open fun startAnimation (p0: Animation ) startDragAndDrop [androidJvm] fun startDragAndDrop (p0: ClipData , p1: View.DragShadowBuilder , p2: Any , p3: Int ): Boolean startLayoutAnimation [androidJvm] open fun startLayoutAnimation () startNestedScroll [androidJvm] open fun startNestedScroll (p0: Int ): Boolean startViewTransition [androidJvm] open fun startViewTransition (p0: View ) stopNestedScroll [androidJvm] open fun stopNestedScroll () suppressLayout [androidJvm] open fun suppressLayout (p0: Boolean ) toString [androidJvm] open override fun toString (): String transformMatrixToGlobal [androidJvm] open fun transformMatrixToGlobal (p0: Matrix ) transformMatrixToLocal [androidJvm] open fun transformMatrixToLocal (p0: Matrix ) unscheduleDrawable [androidJvm] open fun unscheduleDrawable (p0: Drawable ) open override fun unscheduleDrawable (p0: Drawable , p1: Runnable ) update [androidJvm] fun update (newRendering: Any , environment: ViewEnvironment ) Calls WorkflowViewStub.update on the WorkflowViewStub that is the only child of this view. updateDragShadow [androidJvm] fun updateDragShadow (p0: View.DragShadowBuilder ) updateViewLayout [androidJvm] open override fun updateViewLayout (p0: View , p1: ViewGroup.LayoutParams ) verifyDrawable [androidJvm] open fun verifyDrawable (p0: Drawable ): Boolean willNotDraw [androidJvm] open fun willNotDraw (): Boolean","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-workflow-layout/#workflowlayout","text":"[androidJvm]\\ @WorkflowUiExperimentalApi class WorkflowLayout (context: Context , attributeSet: AttributeSet ?) : FrameLayout A view that can be driven by a stream of renderings (and an optional ViewRegistry ) passed to its start method. id defaults to R.id.workflow_layout, as a convenience to ensure that view persistence will work without requiring authors to be immersed in Android arcana. See com.squareup.workflow1.ui.renderWorkflowIn for typical use with a com.squareup.workflow1.Workflow .","title":"WorkflowLayout"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-workflow-layout/#constructors","text":"WorkflowLayout [androidJvm] fun WorkflowLayout (context: Context , attributeSet: AttributeSet ? = null)","title":"Constructors"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-workflow-layout/#functions","text":"Name Summary addChildrenForAccessibility [androidJvm] open override fun addChildrenForAccessibility (p0: ArrayList < View >) addExtraDataToAccessibilityNodeInfo [androidJvm] open override fun addExtraDataToAccessibilityNodeInfo (p0: AccessibilityNodeInfo , p1: String , p2: Bundle ?) addFocusables [androidJvm] open fun addFocusables (p0: ArrayList < View >, p1: Int ) open override fun addFocusables (p0: ArrayList < View >, p1: Int , p2: Int ) addKeyboardNavigationClusters [androidJvm] open override fun addKeyboardNavigationClusters (p0: MutableCollection < View >, p1: Int ) addOnAttachStateChangeListener [androidJvm] open fun addOnAttachStateChangeListener (p0: View.OnAttachStateChangeListener ) addOnLayoutChangeListener [androidJvm] open fun addOnLayoutChangeListener (p0: View.OnLayoutChangeListener ) addOnUnhandledKeyEventListener [androidJvm] open fun addOnUnhandledKeyEventListener (p0: View.OnUnhandledKeyEventListener ) addStatesFromChildren [androidJvm] open fun addStatesFromChildren (): Boolean addTouchables [androidJvm] open override fun addTouchables (p0: ArrayList < View >) addView [androidJvm] open fun addView (p0: View ) open override fun addView (p0: View , p1: ViewGroup.LayoutParams ) open fun addView (p0: View , p1: Int ) open fun addView (p0: View , p1: Int , p2: ViewGroup.LayoutParams ) open fun addView (p0: View , p1: Int , p2: Int ) addViewInLayout [androidJvm] open fun addViewInLayout (p0: View , p1: Int , p2: ViewGroup.LayoutParams ): Boolean open fun addViewInLayout (p0: View , p1: Int , p2: ViewGroup.LayoutParams , p3: Boolean ): Boolean animate [androidJvm] open fun animate (): ViewPropertyAnimator announceForAccessibility [androidJvm] open fun announceForAccessibility (p0: CharSequence ) attachLayoutAnimationParameters [androidJvm] open fun attachLayoutAnimationParameters (p0: View , p1: ViewGroup.LayoutParams , p2: Int , p3: Int ) attachViewToParent [androidJvm] open fun attachViewToParent (p0: View , p1: Int , p2: ViewGroup.LayoutParams ) autofill [androidJvm] open fun autofill (p0: SparseArray < AutofillValue >) open fun autofill (p0: AutofillValue ) awakenScrollBars [androidJvm] open fun awakenScrollBars (): Boolean open fun awakenScrollBars (p0: Int ): Boolean open fun awakenScrollBars (p0: Int , p1: Boolean ): Boolean bringChildToFront [androidJvm] open override fun bringChildToFront (p0: View ) bringToFront [androidJvm] open fun bringToFront () buildLayer [androidJvm] open fun buildLayer () callOnClick [androidJvm] open fun callOnClick (): Boolean canAnimate [androidJvm] open fun canAnimate (): Boolean cancelDragAndDrop [androidJvm] fun cancelDragAndDrop () cancelLongPress [androidJvm] open fun cancelLongPress () cancelPendingInputEvents [androidJvm] fun cancelPendingInputEvents () canResolveLayoutDirection [androidJvm] open fun canResolveLayoutDirection (): Boolean canResolveTextAlignment [androidJvm] open fun canResolveTextAlignment (): Boolean canResolveTextDirection [androidJvm] open fun canResolveTextDirection (): Boolean canScrollHorizontally [androidJvm] open fun canScrollHorizontally (p0: Int ): Boolean canScrollVertically [androidJvm] open fun canScrollVertically (p0: Int ): Boolean checkInputConnectionProxy [androidJvm] open fun checkInputConnectionProxy (p0: View ): Boolean checkLayoutParams [androidJvm] open override fun checkLayoutParams (p0: ViewGroup.LayoutParams ): Boolean childDrawableStateChanged [androidJvm] open override fun childDrawableStateChanged (p0: View ) childHasTransientStateChanged [androidJvm] open override fun childHasTransientStateChanged (p0: View , p1: Boolean ) cleanupLayoutState [androidJvm] open fun cleanupLayoutState (p0: View ) clearAnimation [androidJvm] open fun clearAnimation () clearChildFocus [androidJvm] open override fun clearChildFocus (p0: View ) clearDisappearingChildren [androidJvm] open fun clearDisappearingChildren () clearFocus [androidJvm] open override fun clearFocus () clearViewTranslationCallback [androidJvm] open fun clearViewTranslationCallback () computeHorizontalScrollExtent [androidJvm] open fun computeHorizontalScrollExtent (): Int computeHorizontalScrollOffset [androidJvm] open fun computeHorizontalScrollOffset (): Int computeHorizontalScrollRange [androidJvm] open fun computeHorizontalScrollRange (): Int computeScroll [androidJvm] open fun computeScroll () computeSystemWindowInsets [androidJvm] open fun computeSystemWindowInsets (p0: WindowInsets , p1: Rect ): WindowInsets computeVerticalScrollExtent [androidJvm] open fun computeVerticalScrollExtent (): Int computeVerticalScrollOffset [androidJvm] open fun computeVerticalScrollOffset (): Int computeVerticalScrollRange [androidJvm] open fun computeVerticalScrollRange (): Int createAccessibilityNodeInfo [androidJvm] open fun createAccessibilityNodeInfo (): AccessibilityNodeInfo createContextMenu [androidJvm] open fun createContextMenu (p0: ContextMenu ) debug [androidJvm] open fun debug (p0: Int ) detachAllViewsFromParent [androidJvm] open fun detachAllViewsFromParent () detachViewFromParent [androidJvm] open fun detachViewFromParent (p0: View ) open fun detachViewFromParent (p0: Int ) detachViewsFromParent [androidJvm] open fun detachViewsFromParent (p0: Int , p1: Int ) dispatchApplyWindowInsets [androidJvm] open override fun dispatchApplyWindowInsets (p0: WindowInsets ): WindowInsets dispatchCapturedPointerEvent [androidJvm] open override fun dispatchCapturedPointerEvent (p0: MotionEvent ): Boolean dispatchConfigurationChanged [androidJvm] open override fun dispatchConfigurationChanged (p0: Configuration ) dispatchCreateViewTranslationRequest [androidJvm] open override fun dispatchCreateViewTranslationRequest (p0: MutableMap < AutofillId , LongArray >, p1: IntArray , p2: TranslationCapability , p3: MutableList < ViewTranslationRequest >) dispatchDisplayHint [androidJvm] open override fun dispatchDisplayHint (p0: Int ) dispatchDragEvent [androidJvm] open override fun dispatchDragEvent (p0: DragEvent ): Boolean dispatchDraw [androidJvm] open override fun dispatchDraw (p0: Canvas ) dispatchDrawableHotspotChanged [androidJvm] open override fun dispatchDrawableHotspotChanged (p0: Float , p1: Float ) dispatchFinishTemporaryDetach [androidJvm] open override fun dispatchFinishTemporaryDetach () dispatchFreezeSelfOnly [androidJvm] open fun dispatchFreezeSelfOnly (p0: SparseArray < Parcelable >) dispatchGenericFocusedEvent [androidJvm] open override fun dispatchGenericFocusedEvent (p0: MotionEvent ): Boolean dispatchGenericMotionEvent [androidJvm] open fun dispatchGenericMotionEvent (p0: MotionEvent ): Boolean dispatchGenericPointerEvent [androidJvm] open override fun dispatchGenericPointerEvent (p0: MotionEvent ): Boolean dispatchHoverEvent [androidJvm] open override fun dispatchHoverEvent (p0: MotionEvent ): Boolean dispatchKeyEvent [androidJvm] open override fun dispatchKeyEvent (p0: KeyEvent ): Boolean dispatchKeyEventPreIme [androidJvm] open override fun dispatchKeyEventPreIme (p0: KeyEvent ): Boolean dispatchKeyShortcutEvent [androidJvm] open override fun dispatchKeyShortcutEvent (p0: KeyEvent ): Boolean dispatchNestedFling [androidJvm] open fun dispatchNestedFling (p0: Float , p1: Float , p2: Boolean ): Boolean dispatchNestedPreFling [androidJvm] open fun dispatchNestedPreFling (p0: Float , p1: Float ): Boolean dispatchNestedPrePerformAccessibilityAction [androidJvm] open fun dispatchNestedPrePerformAccessibilityAction (p0: Int , p1: Bundle ): Boolean dispatchNestedPreScroll [androidJvm] open fun dispatchNestedPreScroll (p0: Int , p1: Int , p2: IntArray ?, p3: IntArray ?): Boolean dispatchNestedScroll [androidJvm] open fun dispatchNestedScroll (p0: Int , p1: Int , p2: Int , p3: Int , p4: IntArray ?): Boolean dispatchPointerCaptureChanged [androidJvm] open override fun dispatchPointerCaptureChanged (p0: Boolean ) dispatchPopulateAccessibilityEvent [androidJvm] open fun dispatchPopulateAccessibilityEvent (p0: AccessibilityEvent ): Boolean dispatchProvideAutofillStructure [androidJvm] open override fun dispatchProvideAutofillStructure (p0: ViewStructure , p1: Int ) dispatchProvideStructure [androidJvm] open override fun dispatchProvideStructure (p0: ViewStructure ) dispatchRestoreInstanceState [androidJvm] open override fun dispatchRestoreInstanceState (p0: SparseArray < Parcelable >) dispatchSaveInstanceState [androidJvm] open override fun dispatchSaveInstanceState (p0: SparseArray < Parcelable >) dispatchScrollCaptureSearch [androidJvm] open override fun dispatchScrollCaptureSearch (p0: Rect , p1: Point , p2: Consumer < ScrollCaptureTarget >) dispatchSetActivated [androidJvm] open override fun dispatchSetActivated (p0: Boolean ) dispatchSetPressed [androidJvm] open override fun dispatchSetPressed (p0: Boolean ) dispatchSetSelected [androidJvm] open override fun dispatchSetSelected (p0: Boolean ) dispatchStartTemporaryDetach [androidJvm] open override fun dispatchStartTemporaryDetach () dispatchThawSelfOnly [androidJvm] open fun dispatchThawSelfOnly (p0: SparseArray < Parcelable >) dispatchTouchEvent [androidJvm] open override fun dispatchTouchEvent (p0: MotionEvent ): Boolean dispatchTrackballEvent [androidJvm] open override fun dispatchTrackballEvent (p0: MotionEvent ): Boolean dispatchUnhandledMove [androidJvm] open override fun dispatchUnhandledMove (p0: View , p1: Int ): Boolean dispatchVisibilityChanged [androidJvm] open override fun dispatchVisibilityChanged (p0: View , p1: Int ) dispatchWindowFocusChanged [androidJvm] open override fun dispatchWindowFocusChanged (p0: Boolean ) dispatchWindowInsetsAnimationEnd [androidJvm] open override fun dispatchWindowInsetsAnimationEnd (p0: WindowInsetsAnimation ) dispatchWindowInsetsAnimationPrepare [androidJvm] open override fun dispatchWindowInsetsAnimationPrepare (p0: WindowInsetsAnimation ) dispatchWindowInsetsAnimationProgress [androidJvm] open override fun dispatchWindowInsetsAnimationProgress (p0: WindowInsets , p1: MutableList < WindowInsetsAnimation >): WindowInsets dispatchWindowInsetsAnimationStart [androidJvm] open override fun dispatchWindowInsetsAnimationStart (p0: WindowInsetsAnimation , p1: WindowInsetsAnimation.Bounds ): WindowInsetsAnimation.Bounds dispatchWindowVisibilityChanged [androidJvm] open override fun dispatchWindowVisibilityChanged (p0: Int ) draw [androidJvm] open fun draw (p0: Canvas ) drawableHotspotChanged [androidJvm] open fun drawableHotspotChanged (p0: Float , p1: Float ) drawableStateChanged [androidJvm] open override fun drawableStateChanged () drawChild [androidJvm] open fun drawChild (p0: Canvas , p1: View , p2: Long ): Boolean endViewTransition [androidJvm] open fun endViewTransition (p0: View ) findFocus [androidJvm] open override fun findFocus (): View findViewById [androidJvm] fun < T : View > findViewById (p0: Int ): T findViewsWithText [androidJvm] open override fun findViewsWithText (p0: ArrayList < View >, p1: CharSequence , p2: Int ) findViewWithTag [androidJvm] fun < T : View > findViewWithTag (p0: Any ): T focusableViewAvailable [androidJvm] open override fun focusableViewAvailable (p0: View ) focusSearch [androidJvm] open fun focusSearch (p0: Int ): View open override fun focusSearch (p0: View , p1: Int ): View forceHasOverlappingRendering [androidJvm] open fun forceHasOverlappingRendering (p0: Boolean ) forceLayout [androidJvm] open fun forceLayout () gatherTransparentRegion [androidJvm] open override fun gatherTransparentRegion (p0: Region ?): Boolean generateDefaultLayoutParams [androidJvm] open override fun generateDefaultLayoutParams (): FrameLayout.LayoutParams generateDisplayHash [androidJvm] open fun generateDisplayHash (p0: String , p1: Rect ?, p2: Executor , p3: DisplayHashResultCallback ) generateLayoutParams [androidJvm] open override fun generateLayoutParams (p0: AttributeSet ): FrameLayout.LayoutParams open override fun generateLayoutParams (p0: ViewGroup.LayoutParams ): ViewGroup.LayoutParams getAccessibilityClassName [androidJvm] open override fun getAccessibilityClassName (): CharSequence getAccessibilityDelegate [androidJvm] open fun getAccessibilityDelegate (): View.AccessibilityDelegate getAccessibilityLiveRegion [androidJvm] open fun getAccessibilityLiveRegion (): Int getAccessibilityNodeProvider [androidJvm] open fun getAccessibilityNodeProvider (): AccessibilityNodeProvider getAccessibilityPaneTitle [androidJvm] open fun getAccessibilityPaneTitle (): CharSequence ? getAccessibilityTraversalAfter [androidJvm] open fun getAccessibilityTraversalAfter (): Int getAccessibilityTraversalBefore [androidJvm] open fun getAccessibilityTraversalBefore (): Int getAlpha [androidJvm] open fun getAlpha (): Float getAnimation [androidJvm] open fun getAnimation (): Animation getAnimationMatrix [androidJvm] open fun getAnimationMatrix (): Matrix ? getApplicationWindowToken [androidJvm] open fun getApplicationWindowToken (): IBinder getAttributeResolutionStack [androidJvm] open fun getAttributeResolutionStack (p0: Int ): IntArray getAttributeSourceResourceMap [androidJvm] open fun getAttributeSourceResourceMap (): MutableMap < Int , Int > getAutofillHints [androidJvm] open fun getAutofillHints (): Array < String >? getAutofillId [androidJvm] fun getAutofillId (): AutofillId getAutofillType [androidJvm] open fun getAutofillType (): Int getAutofillValue [androidJvm] open fun getAutofillValue (): AutofillValue ? getBackground [androidJvm] open fun getBackground (): Drawable getBackgroundTintBlendMode [androidJvm] open fun getBackgroundTintBlendMode (): BlendMode ? getBackgroundTintList [androidJvm] open fun getBackgroundTintList (): ColorStateList ? getBackgroundTintMode [androidJvm] open fun getBackgroundTintMode (): PorterDuff.Mode ? getBaseline [androidJvm] open fun getBaseline (): Int getBottom [androidJvm] fun getBottom (): Int getBottomFadingEdgeStrength [androidJvm] open fun getBottomFadingEdgeStrength (): Float getBottomPaddingOffset [androidJvm] open fun getBottomPaddingOffset (): Int getCameraDistance [androidJvm] open fun getCameraDistance (): Float getChildAt [androidJvm] open fun getChildAt (p0: Int ): View getChildCount [androidJvm] open fun getChildCount (): Int getChildDrawingOrder [androidJvm] fun getChildDrawingOrder (p0: Int ): Int open fun getChildDrawingOrder (p0: Int , p1: Int ): Int getChildStaticTransformation [androidJvm] open fun getChildStaticTransformation (p0: View , p1: Transformation ): Boolean getChildVisibleRect [androidJvm] open override fun getChildVisibleRect (p0: View , p1: Rect , p2: Point ): Boolean getClipBounds [androidJvm] open fun getClipBounds (): Rect open fun getClipBounds (p0: Rect ): Boolean getClipChildren [androidJvm] open fun getClipChildren (): Boolean getClipToOutline [androidJvm] fun getClipToOutline (): Boolean getClipToPadding [androidJvm] open fun getClipToPadding (): Boolean getContentCaptureSession [androidJvm] fun getContentCaptureSession (): ContentCaptureSession ? getContentDescription [androidJvm] open fun getContentDescription (): CharSequence getContext [androidJvm] fun getContext (): Context getContextMenuInfo [androidJvm] open fun getContextMenuInfo (): ContextMenu.ContextMenuInfo getDefaultFocusHighlightEnabled [androidJvm] fun getDefaultFocusHighlightEnabled (): Boolean getDescendantFocusability [androidJvm] open fun getDescendantFocusability (): Int getDisplay [androidJvm] open fun getDisplay (): Display getDrawableState [androidJvm] fun getDrawableState (): IntArray getDrawingRect [androidJvm] open fun getDrawingRect (p0: Rect ) getDrawingTime [androidJvm] open fun getDrawingTime (): Long getElevation [androidJvm] open fun getElevation (): Float getExplicitStyle [androidJvm] open fun getExplicitStyle (): Int getFilterTouchesWhenObscured [androidJvm] open fun getFilterTouchesWhenObscured (): Boolean getFitsSystemWindows [androidJvm] open fun getFitsSystemWindows (): Boolean getFocusable [androidJvm] open fun getFocusable (): Int getFocusables [androidJvm] open fun getFocusables (p0: Int ): ArrayList < View > getFocusedChild [androidJvm] open fun getFocusedChild (): View getFocusedRect [androidJvm] open fun getFocusedRect (p0: Rect ) getForeground [androidJvm] open fun getForeground (): Drawable getForegroundGravity [androidJvm] open fun getForegroundGravity (): Int getForegroundTintBlendMode [androidJvm] open fun getForegroundTintBlendMode (): BlendMode ? getForegroundTintList [androidJvm] open fun getForegroundTintList (): ColorStateList ? getForegroundTintMode [androidJvm] open fun getForegroundTintMode (): PorterDuff.Mode ? getGlobalVisibleRect [androidJvm] fun getGlobalVisibleRect (p0: Rect ): Boolean open fun getGlobalVisibleRect (p0: Rect , p1: Point ): Boolean getHandler [androidJvm] open fun getHandler (): Handler getHasOverlappingRendering [androidJvm] fun getHasOverlappingRendering (): Boolean getHeight [androidJvm] fun getHeight (): Int getHitRect [androidJvm] open fun getHitRect (p0: Rect ) getHorizontalFadingEdgeLength [androidJvm] open fun getHorizontalFadingEdgeLength (): Int getHorizontalScrollbarHeight [androidJvm] open fun getHorizontalScrollbarHeight (): Int getHorizontalScrollbarThumbDrawable [androidJvm] open fun getHorizontalScrollbarThumbDrawable (): Drawable ? getHorizontalScrollbarTrackDrawable [androidJvm] open fun getHorizontalScrollbarTrackDrawable (): Drawable ? getId [androidJvm] open fun getId (): Int getImportantForAccessibility [androidJvm] open fun getImportantForAccessibility (): Int getImportantForAutofill [androidJvm] open fun getImportantForAutofill (): Int getImportantForContentCapture [androidJvm] open fun getImportantForContentCapture (): Int getKeepScreenOn [androidJvm] open fun getKeepScreenOn (): Boolean getKeyDispatcherState [androidJvm] open fun getKeyDispatcherState (): KeyEvent.DispatcherState getLabelFor [androidJvm] open fun getLabelFor (): Int getLayerType [androidJvm] open fun getLayerType (): Int getLayoutAnimation [androidJvm] open fun getLayoutAnimation (): LayoutAnimationController getLayoutAnimationListener [androidJvm] open fun getLayoutAnimationListener (): Animation.AnimationListener getLayoutDirection [androidJvm] open fun getLayoutDirection (): Int getLayoutMode [androidJvm] open fun getLayoutMode (): Int getLayoutParams [androidJvm] open fun getLayoutParams (): ViewGroup.LayoutParams getLayoutTransition [androidJvm] open fun getLayoutTransition (): LayoutTransition getLeft [androidJvm] fun getLeft (): Int getLeftFadingEdgeStrength [androidJvm] open fun getLeftFadingEdgeStrength (): Float getLeftPaddingOffset [androidJvm] open fun getLeftPaddingOffset (): Int getLocalVisibleRect [androidJvm] fun getLocalVisibleRect (p0: Rect ): Boolean getLocationInSurface [androidJvm] open fun getLocationInSurface (p0: IntArray ) getLocationInWindow [androidJvm] open fun getLocationInWindow (p0: IntArray ) getLocationOnScreen [androidJvm] open fun getLocationOnScreen (p0: IntArray ) getMatrix [androidJvm] open fun getMatrix (): Matrix getMeasureAllChildren [androidJvm] open fun getMeasureAllChildren (): Boolean getMeasuredHeight [androidJvm] fun getMeasuredHeight (): Int getMeasuredHeightAndState [androidJvm] fun getMeasuredHeightAndState (): Int getMeasuredState [androidJvm] fun getMeasuredState (): Int getMeasuredWidth [androidJvm] fun getMeasuredWidth (): Int getMeasuredWidthAndState [androidJvm] fun getMeasuredWidthAndState (): Int getMinimumHeight [androidJvm] open fun getMinimumHeight (): Int getMinimumWidth [androidJvm] open fun getMinimumWidth (): Int getNestedScrollAxes [androidJvm] open fun getNestedScrollAxes (): Int getNextClusterForwardId [androidJvm] open fun getNextClusterForwardId (): Int getNextFocusDownId [androidJvm] open fun getNextFocusDownId (): Int getNextFocusForwardId [androidJvm] open fun getNextFocusForwardId (): Int getNextFocusLeftId [androidJvm] open fun getNextFocusLeftId (): Int getNextFocusRightId [androidJvm] open fun getNextFocusRightId (): Int getNextFocusUpId [androidJvm] open fun getNextFocusUpId (): Int getOnFocusChangeListener [androidJvm] open fun getOnFocusChangeListener (): View.OnFocusChangeListener getOutlineAmbientShadowColor [androidJvm] open fun getOutlineAmbientShadowColor (): Int getOutlineProvider [androidJvm] open fun getOutlineProvider (): ViewOutlineProvider getOutlineSpotShadowColor [androidJvm] open fun getOutlineSpotShadowColor (): Int getOverlay [androidJvm] open override fun getOverlay (): ViewGroupOverlay getOverScrollMode [androidJvm] open fun getOverScrollMode (): Int getPaddingBottom [androidJvm] open fun getPaddingBottom (): Int getPaddingEnd [androidJvm] open fun getPaddingEnd (): Int getPaddingLeft [androidJvm] open fun getPaddingLeft (): Int getPaddingRight [androidJvm] open fun getPaddingRight (): Int getPaddingStart [androidJvm] open fun getPaddingStart (): Int getPaddingTop [androidJvm] open fun getPaddingTop (): Int getParent [androidJvm] fun getParent (): ViewParent getParentForAccessibility [androidJvm] open fun getParentForAccessibility (): ViewParent getPivotX [androidJvm] open fun getPivotX (): Float getPivotY [androidJvm] open fun getPivotY (): Float getPointerIcon [androidJvm] open fun getPointerIcon (): PointerIcon getReceiveContentMimeTypes [androidJvm] open fun getReceiveContentMimeTypes (): Array < String >? getResources [androidJvm] open fun getResources (): Resources getRevealOnFocusHint [androidJvm] fun getRevealOnFocusHint (): Boolean getRight [androidJvm] fun getRight (): Int getRightFadingEdgeStrength [androidJvm] open fun getRightFadingEdgeStrength (): Float getRightPaddingOffset [androidJvm] open fun getRightPaddingOffset (): Int getRootSurfaceControl [androidJvm] open fun getRootSurfaceControl (): AttachedSurfaceControl ? getRootView [androidJvm] open fun getRootView (): View getRootWindowInsets [androidJvm] open fun getRootWindowInsets (): WindowInsets getRotation [androidJvm] open fun getRotation (): Float getRotationX [androidJvm] open fun getRotationX (): Float getRotationY [androidJvm] open fun getRotationY (): Float getScaleX [androidJvm] open fun getScaleX (): Float getScaleY [androidJvm] open fun getScaleY (): Float getScrollBarDefaultDelayBeforeFade [androidJvm] open fun getScrollBarDefaultDelayBeforeFade (): Int getScrollBarFadeDuration [androidJvm] open fun getScrollBarFadeDuration (): Int getScrollBarSize [androidJvm] open fun getScrollBarSize (): Int getScrollBarStyle [androidJvm] open fun getScrollBarStyle (): Int getScrollCaptureHint [androidJvm] open fun getScrollCaptureHint (): Int getScrollIndicators [androidJvm] open fun getScrollIndicators (): Int getScrollX [androidJvm] fun getScrollX (): Int getScrollY [androidJvm] fun getScrollY (): Int getSolidColor [androidJvm] open fun getSolidColor (): Int getSourceLayoutResId [androidJvm] open fun getSourceLayoutResId (): Int getStateDescription [androidJvm] fun getStateDescription (): CharSequence ? getStateListAnimator [androidJvm] open fun getStateListAnimator (): StateListAnimator getSuggestedMinimumHeight [androidJvm] open fun getSuggestedMinimumHeight (): Int getSuggestedMinimumWidth [androidJvm] open fun getSuggestedMinimumWidth (): Int getSystemGestureExclusionRects [androidJvm] open fun getSystemGestureExclusionRects (): MutableList < Rect > getTag [androidJvm] open fun getTag (): Any open fun getTag (p0: Int ): Any getTextAlignment [androidJvm] open fun getTextAlignment (): Int getTextDirection [androidJvm] open fun getTextDirection (): Int getTooltipText [androidJvm] open fun getTooltipText (): CharSequence ? getTop [androidJvm] fun getTop (): Int getTopFadingEdgeStrength [androidJvm] open fun getTopFadingEdgeStrength (): Float getTopPaddingOffset [androidJvm] open fun getTopPaddingOffset (): Int getTouchables [androidJvm] open fun getTouchables (): ArrayList < View > getTouchDelegate [androidJvm] open fun getTouchDelegate (): TouchDelegate getTouchscreenBlocksFocus [androidJvm] open fun getTouchscreenBlocksFocus (): Boolean getTransitionAlpha [androidJvm] open fun getTransitionAlpha (): Float getTransitionName [androidJvm] open fun getTransitionName (): String getTranslationX [androidJvm] open fun getTranslationX (): Float getTranslationY [androidJvm] open fun getTranslationY (): Float getTranslationZ [androidJvm] open fun getTranslationZ (): Float getUniqueDrawingId [androidJvm] open fun getUniqueDrawingId (): Long getVerticalFadingEdgeLength [androidJvm] open fun getVerticalFadingEdgeLength (): Int getVerticalScrollbarPosition [androidJvm] open fun getVerticalScrollbarPosition (): Int getVerticalScrollbarThumbDrawable [androidJvm] open fun getVerticalScrollbarThumbDrawable (): Drawable ? getVerticalScrollbarTrackDrawable [androidJvm] open fun getVerticalScrollbarTrackDrawable (): Drawable ? getVerticalScrollbarWidth [androidJvm] open fun getVerticalScrollbarWidth (): Int getViewTranslationResponse [androidJvm] open fun getViewTranslationResponse (): ViewTranslationResponse ? getViewTreeObserver [androidJvm] open fun getViewTreeObserver (): ViewTreeObserver getVisibility [androidJvm] open fun getVisibility (): Int getWidth [androidJvm] fun getWidth (): Int getWindowAttachCount [androidJvm] open fun getWindowAttachCount (): Int getWindowId [androidJvm] open fun getWindowId (): WindowId getWindowInsetsController [androidJvm] open fun getWindowInsetsController (): WindowInsetsController ? getWindowToken [androidJvm] open fun getWindowToken (): IBinder getWindowVisibility [androidJvm] open fun getWindowVisibility (): Int getWindowVisibleDisplayFrame [androidJvm] open fun getWindowVisibleDisplayFrame (p0: Rect ) getX [androidJvm] open fun getX (): Float getY [androidJvm] open fun getY (): Float getZ [androidJvm] open fun getZ (): Float hasExplicitFocusable [androidJvm] open fun hasExplicitFocusable (): Boolean hasFocus [androidJvm] open override fun hasFocus (): Boolean hasFocusable [androidJvm] open fun hasFocusable (): Boolean hasNestedScrollingParent [androidJvm] open fun hasNestedScrollingParent (): Boolean hasOnClickListeners [androidJvm] open fun hasOnClickListeners (): Boolean hasOnLongClickListeners [androidJvm] open fun hasOnLongClickListeners (): Boolean hasOverlappingRendering [androidJvm] open fun hasOverlappingRendering (): Boolean hasPointerCapture [androidJvm] open fun hasPointerCapture (): Boolean hasTransientState [androidJvm] open override fun hasTransientState (): Boolean hasWindowFocus [androidJvm] open fun hasWindowFocus (): Boolean indexOfChild [androidJvm] open fun indexOfChild (p0: View ): Int invalidate [androidJvm] open fun invalidate () invalidateDrawable [androidJvm] open override fun invalidateDrawable (p0: Drawable ) invalidateOutline [androidJvm] open fun invalidateOutline () isAccessibilityFocused [androidJvm] open fun isAccessibilityFocused (): Boolean isAccessibilityHeading [androidJvm] open fun isAccessibilityHeading (): Boolean isActivated [androidJvm] open fun isActivated (): Boolean isAttachedToWindow [androidJvm] open fun isAttachedToWindow (): Boolean isChildrenDrawingOrderEnabled [androidJvm] open fun isChildrenDrawingOrderEnabled (): Boolean isClickable [androidJvm] open fun isClickable (): Boolean isContextClickable [androidJvm] open fun isContextClickable (): Boolean isDirty [androidJvm] open fun isDirty (): Boolean isDuplicateParentStateEnabled [androidJvm] open fun isDuplicateParentStateEnabled (): Boolean isEnabled [androidJvm] open fun isEnabled (): Boolean isFocusable [androidJvm] fun isFocusable (): Boolean isFocusableInTouchMode [androidJvm] fun isFocusableInTouchMode (): Boolean isFocused [androidJvm] open fun isFocused (): Boolean isFocusedByDefault [androidJvm] fun isFocusedByDefault (): Boolean isForceDarkAllowed [androidJvm] open fun isForceDarkAllowed (): Boolean isHapticFeedbackEnabled [androidJvm] open fun isHapticFeedbackEnabled (): Boolean isHardwareAccelerated [androidJvm] open fun isHardwareAccelerated (): Boolean isHorizontalFadingEdgeEnabled [androidJvm] open fun isHorizontalFadingEdgeEnabled (): Boolean isHorizontalScrollBarEnabled [androidJvm] open fun isHorizontalScrollBarEnabled (): Boolean isHovered [androidJvm] open fun isHovered (): Boolean isImportantForAccessibility [androidJvm] open fun isImportantForAccessibility (): Boolean isImportantForAutofill [androidJvm] fun isImportantForAutofill (): Boolean isImportantForContentCapture [androidJvm] fun isImportantForContentCapture (): Boolean isInEditMode [androidJvm] open fun isInEditMode (): Boolean isInLayout [androidJvm] open fun isInLayout (): Boolean isInTouchMode [androidJvm] open fun isInTouchMode (): Boolean isKeyboardNavigationCluster [androidJvm] fun isKeyboardNavigationCluster (): Boolean isLaidOut [androidJvm] open fun isLaidOut (): Boolean isLayoutDirectionResolved [androidJvm] open fun isLayoutDirectionResolved (): Boolean isLayoutRequested [androidJvm] open fun isLayoutRequested (): Boolean isLayoutSuppressed [androidJvm] open fun isLayoutSuppressed (): Boolean isLongClickable [androidJvm] open fun isLongClickable (): Boolean isMotionEventSplittingEnabled [androidJvm] open fun isMotionEventSplittingEnabled (): Boolean isNestedScrollingEnabled [androidJvm] open fun isNestedScrollingEnabled (): Boolean isOpaque [androidJvm] open fun isOpaque (): Boolean isPaddingOffsetRequired [androidJvm] open fun isPaddingOffsetRequired (): Boolean isPaddingRelative [androidJvm] open fun isPaddingRelative (): Boolean isPivotSet [androidJvm] open fun isPivotSet (): Boolean isPressed [androidJvm] open fun isPressed (): Boolean isSaveEnabled [androidJvm] open fun isSaveEnabled (): Boolean isSaveFromParentEnabled [androidJvm] open fun isSaveFromParentEnabled (): Boolean isScreenReaderFocusable [androidJvm] open fun isScreenReaderFocusable (): Boolean isScrollbarFadingEnabled [androidJvm] open fun isScrollbarFadingEnabled (): Boolean isScrollContainer [androidJvm] open fun isScrollContainer (): Boolean isSelected [androidJvm] open fun isSelected (): Boolean isShowingLayoutBounds [androidJvm] fun isShowingLayoutBounds (): Boolean isShown [androidJvm] open fun isShown (): Boolean isSoundEffectsEnabled [androidJvm] open fun isSoundEffectsEnabled (): Boolean isTemporarilyDetached [androidJvm] fun isTemporarilyDetached (): Boolean isTextAlignmentResolved [androidJvm] open fun isTextAlignmentResolved (): Boolean isTextDirectionResolved [androidJvm] open fun isTextDirectionResolved (): Boolean isTransitionGroup [androidJvm] open fun isTransitionGroup (): Boolean isVerticalFadingEdgeEnabled [androidJvm] open fun isVerticalFadingEdgeEnabled (): Boolean isVerticalScrollBarEnabled [androidJvm] open fun isVerticalScrollBarEnabled (): Boolean isVisibleToUserForAutofill [androidJvm] open fun isVisibleToUserForAutofill (p0: Int ): Boolean jumpDrawablesToCurrentState [androidJvm] open override fun jumpDrawablesToCurrentState () keyboardNavigationClusterSearch [androidJvm] open fun keyboardNavigationClusterSearch (p0: View , p1: Int ): View layout [androidJvm] override fun layout (p0: Int , p1: Int , p2: Int , p3: Int ) measure [androidJvm] fun measure (p0: Int , p1: Int ) measureChild [androidJvm] open fun measureChild (p0: View , p1: Int , p2: Int ) measureChildren [androidJvm] open fun measureChildren (p0: Int , p1: Int ) measureChildWithMargins [androidJvm] open fun measureChildWithMargins (p0: View , p1: Int , p2: Int , p3: Int , p4: Int ) notifySubtreeAccessibilityStateChanged [androidJvm] open override fun notifySubtreeAccessibilityStateChanged (p0: View , p1: View , p2: Int ) offsetDescendantRectToMyCoords [androidJvm] fun offsetDescendantRectToMyCoords (p0: View , p1: Rect ) offsetLeftAndRight [androidJvm] open fun offsetLeftAndRight (p0: Int ) offsetRectIntoDescendantCoords [androidJvm] fun offsetRectIntoDescendantCoords (p0: View , p1: Rect ) offsetTopAndBottom [androidJvm] open fun offsetTopAndBottom (p0: Int ) onAnimationEnd [androidJvm] open fun onAnimationEnd () onAnimationStart [androidJvm] open fun onAnimationStart () onApplyWindowInsets [androidJvm] open fun onApplyWindowInsets (p0: WindowInsets ): WindowInsets onAttachedToWindow [androidJvm] open override fun onAttachedToWindow () onCancelPendingInputEvents [androidJvm] open fun onCancelPendingInputEvents () onCapturedPointerEvent [androidJvm] open fun onCapturedPointerEvent (p0: MotionEvent ): Boolean onCheckIsTextEditor [androidJvm] open fun onCheckIsTextEditor (): Boolean onConfigurationChanged [androidJvm] open fun onConfigurationChanged (p0: Configuration ) onCreateContextMenu [androidJvm] open fun onCreateContextMenu (p0: ContextMenu ) onCreateDrawableState [androidJvm] open override fun onCreateDrawableState (p0: Int ): IntArray onCreateInputConnection [androidJvm] open fun onCreateInputConnection (p0: EditorInfo ): InputConnection onCreateViewTranslationRequest [androidJvm] open fun onCreateViewTranslationRequest (p0: IntArray , p1: Consumer < ViewTranslationRequest >) onCreateVirtualViewTranslationRequests [androidJvm] open fun onCreateVirtualViewTranslationRequests (p0: LongArray , p1: IntArray , p2: Consumer < ViewTranslationRequest >) onDescendantInvalidated [androidJvm] open override fun onDescendantInvalidated (p0: View , p1: View ) onDetachedFromWindow [androidJvm] open override fun onDetachedFromWindow () onDisplayHint [androidJvm] open fun onDisplayHint (p0: Int ) onDragEvent [androidJvm] open fun onDragEvent (p0: DragEvent ): Boolean onDraw [androidJvm] open fun onDraw (p0: Canvas ) onDrawForeground [androidJvm] open fun onDrawForeground (p0: Canvas ) onDrawScrollBars [androidJvm] fun onDrawScrollBars (p0: Canvas ) onFilterTouchEventForSecurity [androidJvm] open fun onFilterTouchEventForSecurity (p0: MotionEvent ): Boolean onFinishInflate [androidJvm] open fun onFinishInflate () onFinishTemporaryDetach [androidJvm] open fun onFinishTemporaryDetach () onFocusChanged [androidJvm] open fun onFocusChanged (p0: Boolean , p1: Int , p2: Rect ?) onGenericMotionEvent [androidJvm] open fun onGenericMotionEvent (p0: MotionEvent ): Boolean onHoverChanged [androidJvm] open fun onHoverChanged (p0: Boolean ) onHoverEvent [androidJvm] open fun onHoverEvent (p0: MotionEvent ): Boolean onInitializeAccessibilityEvent [androidJvm] open fun onInitializeAccessibilityEvent (p0: AccessibilityEvent ) onInitializeAccessibilityNodeInfo [androidJvm] open fun onInitializeAccessibilityNodeInfo (p0: AccessibilityNodeInfo ) onInterceptHoverEvent [androidJvm] open fun onInterceptHoverEvent (p0: MotionEvent ): Boolean onInterceptTouchEvent [androidJvm] open fun onInterceptTouchEvent (p0: MotionEvent ): Boolean onKeyDown [androidJvm] open override fun onKeyDown (p0: Int , p1: KeyEvent ): Boolean onKeyLongPress [androidJvm] open override fun onKeyLongPress (p0: Int , p1: KeyEvent ): Boolean onKeyMultiple [androidJvm] open override fun onKeyMultiple (p0: Int , p1: Int , p2: KeyEvent ): Boolean onKeyPreIme [androidJvm] open fun onKeyPreIme (p0: Int , p1: KeyEvent ): Boolean onKeyShortcut [androidJvm] open fun onKeyShortcut (p0: Int , p1: KeyEvent ): Boolean onKeyUp [androidJvm] open override fun onKeyUp (p0: Int , p1: KeyEvent ): Boolean onLayout [androidJvm] open override fun onLayout (p0: Boolean , p1: Int , p2: Int , p3: Int , p4: Int ) onMeasure [androidJvm] open override fun onMeasure (p0: Int , p1: Int ) onNestedFling [androidJvm] open override fun onNestedFling (p0: View , p1: Float , p2: Float , p3: Boolean ): Boolean onNestedPreFling [androidJvm] open override fun onNestedPreFling (p0: View , p1: Float , p2: Float ): Boolean onNestedPrePerformAccessibilityAction [androidJvm] open override fun onNestedPrePerformAccessibilityAction (p0: View , p1: Int , p2: Bundle ): Boolean onNestedPreScroll [androidJvm] open override fun onNestedPreScroll (p0: View , p1: Int , p2: Int , p3: IntArray ) onNestedScroll [androidJvm] open override fun onNestedScroll (p0: View , p1: Int , p2: Int , p3: Int , p4: Int ) onNestedScrollAccepted [androidJvm] open override fun onNestedScrollAccepted (p0: View , p1: View , p2: Int ) onOverScrolled [androidJvm] open fun onOverScrolled (p0: Int , p1: Int , p2: Boolean , p3: Boolean ) onPointerCaptureChange [androidJvm] open fun onPointerCaptureChange (p0: Boolean ) onPopulateAccessibilityEvent [androidJvm] open fun onPopulateAccessibilityEvent (p0: AccessibilityEvent ) onProvideAutofillStructure [androidJvm] open fun onProvideAutofillStructure (p0: ViewStructure , p1: Int ) onProvideAutofillVirtualStructure [androidJvm] open fun onProvideAutofillVirtualStructure (p0: ViewStructure , p1: Int ) onProvideContentCaptureStructure [androidJvm] open fun onProvideContentCaptureStructure (p0: ViewStructure , p1: Int ) onProvideStructure [androidJvm] open fun onProvideStructure (p0: ViewStructure ) onProvideVirtualStructure [androidJvm] open fun onProvideVirtualStructure (p0: ViewStructure ) onReceiveContent [androidJvm] open fun onReceiveContent (p0: ContentInfo ): ContentInfo ? onRequestFocusInDescendants [androidJvm] open fun onRequestFocusInDescendants (p0: Int , p1: Rect ): Boolean onRequestSendAccessibilityEvent [androidJvm] open fun onRequestSendAccessibilityEvent (p0: View , p1: AccessibilityEvent ): Boolean onResolvePointerIcon [androidJvm] open override fun onResolvePointerIcon (p0: MotionEvent , p1: Int ): PointerIcon onRtlPropertiesChanged [androidJvm] open fun onRtlPropertiesChanged (p0: Int ) onScreenStateChanged [androidJvm] open fun onScreenStateChanged (p0: Int ) onScrollCaptureSearch [androidJvm] open fun onScrollCaptureSearch (p0: Rect , p1: Point , p2: Consumer < ScrollCaptureTarget >) onScrollChanged [androidJvm] open fun onScrollChanged (p0: Int , p1: Int , p2: Int , p3: Int ) onSetAlpha [androidJvm] open fun onSetAlpha (p0: Int ): Boolean onSizeChanged [androidJvm] open fun onSizeChanged (p0: Int , p1: Int , p2: Int , p3: Int ) onStartNestedScroll [androidJvm] open override fun onStartNestedScroll (p0: View , p1: View , p2: Int ): Boolean onStartTemporaryDetach [androidJvm] open fun onStartTemporaryDetach () onStopNestedScroll [androidJvm] open override fun onStopNestedScroll (p0: View ) onTouchEvent [androidJvm] open fun onTouchEvent (p0: MotionEvent ): Boolean onTrackballEvent [androidJvm] open fun onTrackballEvent (p0: MotionEvent ): Boolean onViewAdded [androidJvm] open fun onViewAdded (p0: View ) onViewRemoved [androidJvm] open fun onViewRemoved (p0: View ) onViewTranslationResponse [androidJvm] open fun onViewTranslationResponse (p0: ViewTranslationResponse ) onVirtualViewTranslationResponses [androidJvm] open fun onVirtualViewTranslationResponses (p0: LongSparseArray < ViewTranslationResponse >) onVisibilityAggregated [androidJvm] open fun onVisibilityAggregated (p0: Boolean ) onVisibilityChanged [androidJvm] open fun onVisibilityChanged (p0: View , p1: Int ) onWindowFocusChanged [androidJvm] open fun onWindowFocusChanged (p0: Boolean ) onWindowVisibilityChanged [androidJvm] open fun onWindowVisibilityChanged (p0: Int ) overScrollBy [androidJvm] open fun overScrollBy (p0: Int , p1: Int , p2: Int , p3: Int , p4: Int , p5: Int , p6: Int , p7: Int , p8: Boolean ): Boolean performAccessibilityAction [androidJvm] open fun performAccessibilityAction (p0: Int , p1: Bundle ): Boolean performClick [androidJvm] open fun performClick (): Boolean performContextClick [androidJvm] open fun performContextClick (): Boolean open fun performContextClick (p0: Float , p1: Float ): Boolean performHapticFeedback [androidJvm] open fun performHapticFeedback (p0: Int ): Boolean open fun performHapticFeedback (p0: Int , p1: Int ): Boolean performLongClick [androidJvm] open fun performLongClick (): Boolean open fun performLongClick (p0: Float , p1: Float ): Boolean performReceiveContent [androidJvm] open fun performReceiveContent (p0: ContentInfo ): ContentInfo ? playSoundEffect [androidJvm] open fun playSoundEffect (p0: Int ) post [androidJvm] open fun post (p0: Runnable ): Boolean postDelayed [androidJvm] open fun postDelayed (p0: Runnable , p1: Long ): Boolean postInvalidate [androidJvm] open fun postInvalidate () open fun postInvalidate (p0: Int , p1: Int , p2: Int , p3: Int ) postInvalidateDelayed [androidJvm] open fun postInvalidateDelayed (p0: Long ) open fun postInvalidateDelayed (p0: Long , p1: Int , p2: Int , p3: Int , p4: Int ) postInvalidateOnAnimation [androidJvm] open fun postInvalidateOnAnimation () open fun postInvalidateOnAnimation (p0: Int , p1: Int , p2: Int , p3: Int ) postOnAnimation [androidJvm] open fun postOnAnimation (p0: Runnable ) postOnAnimationDelayed [androidJvm] open fun postOnAnimationDelayed (p0: Runnable , p1: Long ) recomputeViewAttributes [androidJvm] open override fun recomputeViewAttributes (p0: View ) refreshDrawableState [androidJvm] open fun refreshDrawableState () releasePointerCapture [androidJvm] open fun releasePointerCapture () removeAllViews [androidJvm] open fun removeAllViews () removeAllViewsInLayout [androidJvm] open fun removeAllViewsInLayout () removeCallbacks [androidJvm] open fun removeCallbacks (p0: Runnable ): Boolean removeDetachedView [androidJvm] open fun removeDetachedView (p0: View , p1: Boolean ) removeOnAttachStateChangeListener [androidJvm] open fun removeOnAttachStateChangeListener (p0: View.OnAttachStateChangeListener ) removeOnLayoutChangeListener [androidJvm] open fun removeOnLayoutChangeListener (p0: View.OnLayoutChangeListener ) removeOnUnhandledKeyEventListener [androidJvm] open fun removeOnUnhandledKeyEventListener (p0: View.OnUnhandledKeyEventListener ) removeView [androidJvm] open override fun removeView (p0: View ) removeViewAt [androidJvm] open fun removeViewAt (p0: Int ) removeViewInLayout [androidJvm] open fun removeViewInLayout (p0: View ) removeViews [androidJvm] open fun removeViews (p0: Int , p1: Int ) removeViewsInLayout [androidJvm] open fun removeViewsInLayout (p0: Int , p1: Int ) requestApplyInsets [androidJvm] open fun requestApplyInsets () requestChildFocus [androidJvm] open override fun requestChildFocus (p0: View , p1: View ) requestChildRectangleOnScreen [androidJvm] open override fun requestChildRectangleOnScreen (p0: View , p1: Rect , p2: Boolean ): Boolean requestDisallowInterceptTouchEvent [androidJvm] open override fun requestDisallowInterceptTouchEvent (p0: Boolean ) requestFocus [androidJvm] fun requestFocus (): Boolean fun requestFocus (p0: Int ): Boolean open override fun requestFocus (p0: Int , p1: Rect ): Boolean requestFocusFromTouch [androidJvm] fun requestFocusFromTouch (): Boolean requestLayout [androidJvm] open fun requestLayout () requestPointerCapture [androidJvm] open fun requestPointerCapture () requestRectangleOnScreen [androidJvm] open fun requestRectangleOnScreen (p0: Rect ): Boolean open fun requestRectangleOnScreen (p0: Rect , p1: Boolean ): Boolean requestSendAccessibilityEvent [androidJvm] open override fun requestSendAccessibilityEvent (p0: View , p1: AccessibilityEvent ): Boolean requestTransparentRegion [androidJvm] open override fun requestTransparentRegion (p0: View ) requestUnbufferedDispatch [androidJvm] fun requestUnbufferedDispatch (p0: MotionEvent ) fun requestUnbufferedDispatch (p0: Int ) requireViewById [androidJvm] fun < T : View > requireViewById (p0: Int ): T resetPivot [androidJvm] open fun resetPivot () restoreDefaultFocus [androidJvm] open override fun restoreDefaultFocus (): Boolean restoreHierarchyState [androidJvm] open fun restoreHierarchyState (p0: SparseArray < Parcelable >) saveAttributeDataForStyleable [androidJvm] fun saveAttributeDataForStyleable (p0: Context , p1: IntArray , p2: AttributeSet ?, p3: TypedArray , p4: Int , p5: Int ) saveHierarchyState [androidJvm] open fun saveHierarchyState (p0: SparseArray < Parcelable >) scheduleDrawable [androidJvm] open override fun scheduleDrawable (p0: Drawable , p1: Runnable , p2: Long ) scheduleLayoutAnimation [androidJvm] open fun scheduleLayoutAnimation () scrollBy [androidJvm] open fun scrollBy (p0: Int , p1: Int ) scrollTo [androidJvm] open fun scrollTo (p0: Int , p1: Int ) sendAccessibilityEvent [androidJvm] open override fun sendAccessibilityEvent (p0: Int ) sendAccessibilityEventUnchecked [androidJvm] open override fun sendAccessibilityEventUnchecked (p0: AccessibilityEvent ) setAccessibilityDelegate [androidJvm] open fun setAccessibilityDelegate (p0: View.AccessibilityDelegate ?) setAccessibilityHeading [androidJvm] open fun setAccessibilityHeading (p0: Boolean ) setAccessibilityLiveRegion [androidJvm] open fun setAccessibilityLiveRegion (p0: Int ) setAccessibilityPaneTitle [androidJvm] open fun setAccessibilityPaneTitle (p0: CharSequence ?) setAccessibilityTraversalAfter [androidJvm] open fun setAccessibilityTraversalAfter (p0: Int ) setAccessibilityTraversalBefore [androidJvm] open fun setAccessibilityTraversalBefore (p0: Int ) setActivated [androidJvm] open fun setActivated (p0: Boolean ) setAddStatesFromChildren [androidJvm] open fun setAddStatesFromChildren (p0: Boolean ) setAllowClickWhenDisabled [androidJvm] open fun setAllowClickWhenDisabled (p0: Boolean ) setAlpha [androidJvm] open fun setAlpha (p0: Float ) setAnimation [androidJvm] open fun setAnimation (p0: Animation ) setAnimationMatrix [androidJvm] open fun setAnimationMatrix (p0: Matrix ?) setAutofillHints [androidJvm] open fun setAutofillHints (vararg p0: String ) setAutofillId [androidJvm] open fun setAutofillId (p0: AutofillId ?) setBackground [androidJvm] open fun setBackground (p0: Drawable ) setBackgroundColor [androidJvm] open fun setBackgroundColor (p0: Int ) setBackgroundResource [androidJvm] open fun setBackgroundResource (p0: Int ) setBackgroundTintBlendMode [androidJvm] open fun setBackgroundTintBlendMode (p0: BlendMode ?) setBackgroundTintList [androidJvm] open fun setBackgroundTintList (p0: ColorStateList ?) setBackgroundTintMode [androidJvm] open fun setBackgroundTintMode (p0: PorterDuff.Mode ?) setBottom [androidJvm] fun setBottom (p0: Int ) setCameraDistance [androidJvm] open fun setCameraDistance (p0: Float ) setChildrenDrawingOrderEnabled [androidJvm] open fun setChildrenDrawingOrderEnabled (p0: Boolean ) setClickable [androidJvm] open fun setClickable (p0: Boolean ) setClipBounds [androidJvm] open fun setClipBounds (p0: Rect ) setClipChildren [androidJvm] open fun setClipChildren (p0: Boolean ) setClipToOutline [androidJvm] open fun setClipToOutline (p0: Boolean ) setClipToPadding [androidJvm] open fun setClipToPadding (p0: Boolean ) setContentCaptureSession [androidJvm] open fun setContentCaptureSession (p0: ContentCaptureSession ?) setContentDescription [androidJvm] open fun setContentDescription (p0: CharSequence ) setContextClickable [androidJvm] open fun setContextClickable (p0: Boolean ) setDefaultFocusHighlightEnabled [androidJvm] open fun setDefaultFocusHighlightEnabled (p0: Boolean ) setDescendantFocusability [androidJvm] open fun setDescendantFocusability (p0: Int ) setDuplicateParentStateEnabled [androidJvm] open fun setDuplicateParentStateEnabled (p0: Boolean ) setElevation [androidJvm] open fun setElevation (p0: Float ) setEnabled [androidJvm] open fun setEnabled (p0: Boolean ) setFadingEdgeLength [androidJvm] open fun setFadingEdgeLength (p0: Int ) setFilterTouchesWhenObscured [androidJvm] open fun setFilterTouchesWhenObscured (p0: Boolean ) setFitsSystemWindows [androidJvm] open fun setFitsSystemWindows (p0: Boolean ) setFocusable [androidJvm] open fun setFocusable (p0: Boolean ) open fun setFocusable (p0: Int ) setFocusableInTouchMode [androidJvm] open fun setFocusableInTouchMode (p0: Boolean ) setFocusedByDefault [androidJvm] open fun setFocusedByDefault (p0: Boolean ) setForceDarkAllowed [androidJvm] open fun setForceDarkAllowed (p0: Boolean ) setForeground [androidJvm] open fun setForeground (p0: Drawable ) setForegroundGravity [androidJvm] open override fun setForegroundGravity (p0: Int ) setForegroundTintBlendMode [androidJvm] open fun setForegroundTintBlendMode (p0: BlendMode ?) setForegroundTintList [androidJvm] open fun setForegroundTintList (p0: ColorStateList ?) setForegroundTintMode [androidJvm] open fun setForegroundTintMode (p0: PorterDuff.Mode ?) setHapticFeedbackEnabled [androidJvm] open fun setHapticFeedbackEnabled (p0: Boolean ) setHasTransientState [androidJvm] open fun setHasTransientState (p0: Boolean ) setHorizontalFadingEdgeEnabled [androidJvm] open fun setHorizontalFadingEdgeEnabled (p0: Boolean ) setHorizontalScrollBarEnabled [androidJvm] open fun setHorizontalScrollBarEnabled (p0: Boolean ) setHorizontalScrollbarThumbDrawable [androidJvm] open fun setHorizontalScrollbarThumbDrawable (p0: Drawable ?) setHorizontalScrollbarTrackDrawable [androidJvm] open fun setHorizontalScrollbarTrackDrawable (p0: Drawable ?) setHovered [androidJvm] open fun setHovered (p0: Boolean ) setId [androidJvm] open fun setId (p0: Int ) setImportantForAccessibility [androidJvm] open fun setImportantForAccessibility (p0: Int ) setImportantForAutofill [androidJvm] open fun setImportantForAutofill (p0: Int ) setImportantForContentCapture [androidJvm] open fun setImportantForContentCapture (p0: Int ) setKeepScreenOn [androidJvm] open fun setKeepScreenOn (p0: Boolean ) setKeyboardNavigationCluster [androidJvm] open fun setKeyboardNavigationCluster (p0: Boolean ) setLabelFor [androidJvm] open fun setLabelFor (p0: Int ) setLayerPaint [androidJvm] open fun setLayerPaint (p0: Paint ?) setLayerType [androidJvm] open fun setLayerType (p0: Int , p1: Paint ?) setLayoutAnimation [androidJvm] open fun setLayoutAnimation (p0: LayoutAnimationController ) setLayoutAnimationListener [androidJvm] open fun setLayoutAnimationListener (p0: Animation.AnimationListener ) setLayoutDirection [androidJvm] open fun setLayoutDirection (p0: Int ) setLayoutMode [androidJvm] open fun setLayoutMode (p0: Int ) setLayoutParams [androidJvm] open fun setLayoutParams (p0: ViewGroup.LayoutParams ) setLayoutTransition [androidJvm] open fun setLayoutTransition (p0: LayoutTransition ) setLeft [androidJvm] fun setLeft (p0: Int ) setLeftTopRightBottom [androidJvm] fun setLeftTopRightBottom (p0: Int , p1: Int , p2: Int , p3: Int ) setLongClickable [androidJvm] open fun setLongClickable (p0: Boolean ) setMeasureAllChildren [androidJvm] open fun setMeasureAllChildren (p0: Boolean ) setMeasuredDimension [androidJvm] fun setMeasuredDimension (p0: Int , p1: Int ) setMinimumHeight [androidJvm] open fun setMinimumHeight (p0: Int ) setMinimumWidth [androidJvm] open fun setMinimumWidth (p0: Int ) setMotionEventSplittingEnabled [androidJvm] open fun setMotionEventSplittingEnabled (p0: Boolean ) setNestedScrollingEnabled [androidJvm] open fun setNestedScrollingEnabled (p0: Boolean ) setNextClusterForwardId [androidJvm] open fun setNextClusterForwardId (p0: Int ) setNextFocusDownId [androidJvm] open fun setNextFocusDownId (p0: Int ) setNextFocusForwardId [androidJvm] open fun setNextFocusForwardId (p0: Int ) setNextFocusLeftId [androidJvm] open fun setNextFocusLeftId (p0: Int ) setNextFocusRightId [androidJvm] open fun setNextFocusRightId (p0: Int ) setNextFocusUpId [androidJvm] open fun setNextFocusUpId (p0: Int ) setOnApplyWindowInsetsListener [androidJvm] open fun setOnApplyWindowInsetsListener (p0: View.OnApplyWindowInsetsListener ) setOnCapturedPointerListener [androidJvm] open fun setOnCapturedPointerListener (p0: View.OnCapturedPointerListener ) setOnClickListener [androidJvm] open fun setOnClickListener (p0: View.OnClickListener ?) setOnContextClickListener [androidJvm] open fun setOnContextClickListener (p0: View.OnContextClickListener ?) setOnCreateContextMenuListener [androidJvm] open fun setOnCreateContextMenuListener (p0: View.OnCreateContextMenuListener ) setOnDragListener [androidJvm] open fun setOnDragListener (p0: View.OnDragListener ) setOnFocusChangeListener [androidJvm] open fun setOnFocusChangeListener (p0: View.OnFocusChangeListener ) setOnGenericMotionListener [androidJvm] open fun setOnGenericMotionListener (p0: View.OnGenericMotionListener ) setOnHierarchyChangeListener [androidJvm] open fun setOnHierarchyChangeListener (p0: ViewGroup.OnHierarchyChangeListener ) setOnHoverListener [androidJvm] open fun setOnHoverListener (p0: View.OnHoverListener ) setOnKeyListener [androidJvm] open fun setOnKeyListener (p0: View.OnKeyListener ) setOnLongClickListener [androidJvm] open fun setOnLongClickListener (p0: View.OnLongClickListener ?) setOnReceiveContentListener [androidJvm] open fun setOnReceiveContentListener (p0: Array < String >?, p1: OnReceiveContentListener ?) setOnScrollChangeListener [androidJvm] open fun setOnScrollChangeListener (p0: View.OnScrollChangeListener ) setOnTouchListener [androidJvm] open fun setOnTouchListener (p0: View.OnTouchListener ) setOutlineAmbientShadowColor [androidJvm] open fun setOutlineAmbientShadowColor (p0: Int ) setOutlineProvider [androidJvm] open fun setOutlineProvider (p0: ViewOutlineProvider ) setOutlineSpotShadowColor [androidJvm] open fun setOutlineSpotShadowColor (p0: Int ) setOverScrollMode [androidJvm] open fun setOverScrollMode (p0: Int ) setPadding [androidJvm] open fun setPadding (p0: Int , p1: Int , p2: Int , p3: Int ) setPaddingRelative [androidJvm] open fun setPaddingRelative (p0: Int , p1: Int , p2: Int , p3: Int ) setPivotX [androidJvm] open fun setPivotX (p0: Float ) setPivotY [androidJvm] open fun setPivotY (p0: Float ) setPointerIcon [androidJvm] open fun setPointerIcon (p0: PointerIcon ) setPressed [androidJvm] open fun setPressed (p0: Boolean ) setRenderEffect [androidJvm] open fun setRenderEffect (p0: RenderEffect ?) setRevealOnFocusHint [androidJvm] fun setRevealOnFocusHint (p0: Boolean ) setRight [androidJvm] fun setRight (p0: Int ) setRotation [androidJvm] open fun setRotation (p0: Float ) setRotationX [androidJvm] open fun setRotationX (p0: Float ) setRotationY [androidJvm] open fun setRotationY (p0: Float ) setSaveEnabled [androidJvm] open fun setSaveEnabled (p0: Boolean ) setSaveFromParentEnabled [androidJvm] open fun setSaveFromParentEnabled (p0: Boolean ) setScaleX [androidJvm] open fun setScaleX (p0: Float ) setScaleY [androidJvm] open fun setScaleY (p0: Float ) setScreenReaderFocusable [androidJvm] open fun setScreenReaderFocusable (p0: Boolean ) setScrollBarDefaultDelayBeforeFade [androidJvm] open fun setScrollBarDefaultDelayBeforeFade (p0: Int ) setScrollBarFadeDuration [androidJvm] open fun setScrollBarFadeDuration (p0: Int ) setScrollbarFadingEnabled [androidJvm] open fun setScrollbarFadingEnabled (p0: Boolean ) setScrollBarSize [androidJvm] open fun setScrollBarSize (p0: Int ) setScrollBarStyle [androidJvm] open fun setScrollBarStyle (p0: Int ) setScrollCaptureCallback [androidJvm] fun setScrollCaptureCallback (p0: ScrollCaptureCallback ?) setScrollCaptureHint [androidJvm] open fun setScrollCaptureHint (p0: Int ) setScrollContainer [androidJvm] open fun setScrollContainer (p0: Boolean ) setScrollIndicators [androidJvm] open fun setScrollIndicators (p0: Int ) open fun setScrollIndicators (p0: Int , p1: Int ) setScrollX [androidJvm] open fun setScrollX (p0: Int ) setScrollY [androidJvm] open fun setScrollY (p0: Int ) setSelected [androidJvm] open fun setSelected (p0: Boolean ) setSoundEffectsEnabled [androidJvm] open fun setSoundEffectsEnabled (p0: Boolean ) setStateDescription [androidJvm] open fun setStateDescription (p0: CharSequence ?) setStateListAnimator [androidJvm] open fun setStateListAnimator (p0: StateListAnimator ) setStaticTransformationsEnabled [androidJvm] open fun setStaticTransformationsEnabled (p0: Boolean ) setSystemGestureExclusionRects [androidJvm] open fun setSystemGestureExclusionRects (p0: MutableList < Rect >) setTag [androidJvm] open fun setTag (p0: Any ) open fun setTag (p0: Int , p1: Any ) setTextAlignment [androidJvm] open fun setTextAlignment (p0: Int ) setTextDirection [androidJvm] open fun setTextDirection (p0: Int ) setTooltipText [androidJvm] open fun setTooltipText (p0: CharSequence ?) setTop [androidJvm] fun setTop (p0: Int ) setTouchDelegate [androidJvm] open fun setTouchDelegate (p0: TouchDelegate ) setTouchscreenBlocksFocus [androidJvm] open fun setTouchscreenBlocksFocus (p0: Boolean ) setTransitionAlpha [androidJvm] open fun setTransitionAlpha (p0: Float ) setTransitionGroup [androidJvm] open fun setTransitionGroup (p0: Boolean ) setTransitionName [androidJvm] fun setTransitionName (p0: String ) setTransitionVisibility [androidJvm] open fun setTransitionVisibility (p0: Int ) setTranslationX [androidJvm] open fun setTranslationX (p0: Float ) setTranslationY [androidJvm] open fun setTranslationY (p0: Float ) setTranslationZ [androidJvm] open fun setTranslationZ (p0: Float ) setVerticalFadingEdgeEnabled [androidJvm] open fun setVerticalFadingEdgeEnabled (p0: Boolean ) setVerticalScrollBarEnabled [androidJvm] open fun setVerticalScrollBarEnabled (p0: Boolean ) setVerticalScrollbarPosition [androidJvm] open fun setVerticalScrollbarPosition (p0: Int ) setVerticalScrollbarThumbDrawable [androidJvm] open fun setVerticalScrollbarThumbDrawable (p0: Drawable ?) setVerticalScrollbarTrackDrawable [androidJvm] open fun setVerticalScrollbarTrackDrawable (p0: Drawable ?) setViewTranslationCallback [androidJvm] open fun setViewTranslationCallback (p0: ViewTranslationCallback ) setVisibility [androidJvm] open fun setVisibility (p0: Int ) setWillNotDraw [androidJvm] open fun setWillNotDraw (p0: Boolean ) setWindowInsetsAnimationCallback [androidJvm] open override fun setWindowInsetsAnimationCallback (p0: WindowInsetsAnimation.Callback ?) setX [androidJvm] open fun setX (p0: Float ) setY [androidJvm] open fun setY (p0: Float ) setZ [androidJvm] open fun setZ (p0: Float ) shouldDelayChildPressedState [androidJvm] open override fun shouldDelayChildPressedState (): Boolean showContextMenu [androidJvm] open fun showContextMenu (): Boolean open fun showContextMenu (p0: Float , p1: Float ): Boolean showContextMenuForChild [androidJvm] open override fun showContextMenuForChild (p0: View ): Boolean open override fun showContextMenuForChild (p0: View , p1: Float , p2: Float ): Boolean start [androidJvm] fun start (renderings: Flow< Any >, environment: ViewEnvironment = ViewEnvironment()) This is the most common way to bootstrap a Workflow driven UI. Collects renderings , and calls start with each one and environment . [androidJvm] fun start (renderings: Flow< Any >, registry: ViewRegistry ) A convenience overload that builds a ViewEnvironment around registry , for a bit less boilerplate. startActionMode [androidJvm] open fun startActionMode (p0: ActionMode.Callback ): ActionMode open fun startActionMode (p0: ActionMode.Callback , p1: Int ): ActionMode startActionModeForChild [androidJvm] open override fun startActionModeForChild (p0: View , p1: ActionMode.Callback ): ActionMode open override fun startActionModeForChild (p0: View , p1: ActionMode.Callback , p2: Int ): ActionMode startAnimation [androidJvm] open fun startAnimation (p0: Animation ) startDragAndDrop [androidJvm] fun startDragAndDrop (p0: ClipData , p1: View.DragShadowBuilder , p2: Any , p3: Int ): Boolean startLayoutAnimation [androidJvm] open fun startLayoutAnimation () startNestedScroll [androidJvm] open fun startNestedScroll (p0: Int ): Boolean startViewTransition [androidJvm] open fun startViewTransition (p0: View ) stopNestedScroll [androidJvm] open fun stopNestedScroll () suppressLayout [androidJvm] open fun suppressLayout (p0: Boolean ) toString [androidJvm] open override fun toString (): String transformMatrixToGlobal [androidJvm] open fun transformMatrixToGlobal (p0: Matrix ) transformMatrixToLocal [androidJvm] open fun transformMatrixToLocal (p0: Matrix ) unscheduleDrawable [androidJvm] open fun unscheduleDrawable (p0: Drawable ) open override fun unscheduleDrawable (p0: Drawable , p1: Runnable ) update [androidJvm] fun update (newRendering: Any , environment: ViewEnvironment ) Calls WorkflowViewStub.update on the WorkflowViewStub that is the only child of this view. updateDragShadow [androidJvm] fun updateDragShadow (p0: View.DragShadowBuilder ) updateViewLayout [androidJvm] open override fun updateViewLayout (p0: View , p1: ViewGroup.LayoutParams ) verifyDrawable [androidJvm] open fun verifyDrawable (p0: Drawable ): Boolean willNotDraw [androidJvm] open fun willNotDraw (): Boolean","title":"Functions"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-workflow-layout/-workflow-layout/","text":"// workflow / com.squareup.workflow1.ui / WorkflowLayout / WorkflowLayout WorkflowLayout \u00b6 [androidJvm]\\ fun WorkflowLayout (context: Context , attributeSet: AttributeSet ? = null)","title":" workflow layout"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-workflow-layout/-workflow-layout/#workflowlayout","text":"[androidJvm]\\ fun WorkflowLayout (context: Context , attributeSet: AttributeSet ? = null)","title":"WorkflowLayout"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-workflow-layout/start/","text":"// workflow / com.squareup.workflow1.ui / WorkflowLayout / start start \u00b6 [androidJvm]\\ fun start (renderings: Flow< Any >, environment: ViewEnvironment = ViewEnvironment()) This is the most common way to bootstrap a Workflow driven UI. Collects renderings , and calls start with each one and environment . [androidJvm]\\ fun start (renderings: Flow< Any >, registry: ViewRegistry ) A convenience overload that builds a ViewEnvironment around registry , for a bit less boilerplate.","title":"Start"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-workflow-layout/start/#start","text":"[androidJvm]\\ fun start (renderings: Flow< Any >, environment: ViewEnvironment = ViewEnvironment()) This is the most common way to bootstrap a Workflow driven UI. Collects renderings , and calls start with each one and environment . [androidJvm]\\ fun start (renderings: Flow< Any >, registry: ViewRegistry ) A convenience overload that builds a ViewEnvironment around registry , for a bit less boilerplate.","title":"start"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-workflow-layout/update/","text":"// workflow / com.squareup.workflow1.ui / WorkflowLayout / update update \u00b6 [androidJvm]\\ fun update (newRendering: Any , environment: ViewEnvironment ) Calls WorkflowViewStub.update on the WorkflowViewStub that is the only child of this view. This is the method called from start . It is exposed to allow clients to make their own choices about how exactly to consume a stream of renderings.","title":"Update"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-workflow-layout/update/#update","text":"[androidJvm]\\ fun update (newRendering: Any , environment: ViewEnvironment ) Calls WorkflowViewStub.update on the WorkflowViewStub that is the only child of this view. This is the method called from start . It is exposed to allow clients to make their own choices about how exactly to consume a stream of renderings.","title":"update"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-workflow-ui-experimental-api/","text":"// workflow / com.squareup.workflow1.ui / WorkflowUiExperimentalApi WorkflowUiExperimentalApi \u00b6 [jvm]\\ @ Target (allowedTargets = [ AnnotationTarget.CLASS , AnnotationTarget.PROPERTY , AnnotationTarget.FUNCTION , AnnotationTarget.TYPEALIAS ]) annotation class WorkflowUiExperimentalApi Marks Workflow user interface APIs which are still in flux. Annotated code SHOULD NOT be used in library code or app code that you are not prepared to update when changing even minor workflow versions. Proceed with caution, and be ready to have the rug pulled out from under you. Constructors \u00b6 WorkflowUiExperimentalApi [jvm] fun WorkflowUiExperimentalApi ()","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-workflow-ui-experimental-api/#workflowuiexperimentalapi","text":"[jvm]\\ @ Target (allowedTargets = [ AnnotationTarget.CLASS , AnnotationTarget.PROPERTY , AnnotationTarget.FUNCTION , AnnotationTarget.TYPEALIAS ]) annotation class WorkflowUiExperimentalApi Marks Workflow user interface APIs which are still in flux. Annotated code SHOULD NOT be used in library code or app code that you are not prepared to update when changing even minor workflow versions. Proceed with caution, and be ready to have the rug pulled out from under you.","title":"WorkflowUiExperimentalApi"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-workflow-ui-experimental-api/#constructors","text":"WorkflowUiExperimentalApi [jvm] fun WorkflowUiExperimentalApi ()","title":"Constructors"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-workflow-ui-experimental-api/-workflow-ui-experimental-api/","text":"// workflow / com.squareup.workflow1.ui / WorkflowUiExperimentalApi / WorkflowUiExperimentalApi WorkflowUiExperimentalApi \u00b6 [jvm]\\ fun WorkflowUiExperimentalApi ()","title":" workflow ui experimental api"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-workflow-ui-experimental-api/-workflow-ui-experimental-api/#workflowuiexperimentalapi","text":"[jvm]\\ fun WorkflowUiExperimentalApi ()","title":"WorkflowUiExperimentalApi"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-workflow-view-stub/","text":"// workflow / com.squareup.workflow1.ui / WorkflowViewStub WorkflowViewStub \u00b6 [androidJvm]\\ @WorkflowUiExperimentalApi class WorkflowViewStub @ JvmOverloads constructor(context: Context , attributeSet: AttributeSet ?, defStyle: Int , defStyleRes: Int ) : View A placeholder View that can replace itself with ones driven by workflow renderings, similar to android.view.ViewStub . Usage \u00b6 In the XML layout for a container view, place a WorkflowViewStub where you want child renderings to be displayed. E.g.: 1 \u2026 Then in your LayoutRunner , pull the view out with findViewById like any other view and [update](update.md) it in your [LayoutRunner.showRendering](../-layout-runner/show-rendering.md) method: 1 2 class YourLayoutRunner(view: View) {\\ private val childStub = view.findViewById&lt;WorkflowViewStub&gt;(R.id.child_stub)\\ \\ // Totally optional, since this view is also accessible as [childStub.actual].\\ // Note that R.id.child was set in XML via the square:inflatedId parameter.\\ private val child: View by lazy {\\ view.findViewById<View>(R.id.child)\\ }\\ \\ override fun showRendering(\\ rendering: YourRendering,\\ viewEnvironment: ViewEnvironment\\ ) {\\ childStub.update(rendering.childRendering, viewEnvironment)\\ }\\ } NB : If you\u2019re using a stub in a RelativeLayout or ConstraintLayout, relationships should be tied to the stub\u2019s app:inflatedId, not its android:id. Use updatesVisibility and setBackground for more control of how update effects the visibility and backgrounds of created views. Use replaceOldViewInParent to customize replacing actual with a new view, e.g. for animated transitions. Constructors \u00b6 WorkflowViewStub [androidJvm] @ JvmOverloads fun WorkflowViewStub (context: Context , attributeSet: AttributeSet ? = null, defStyle: Int = 0, defStyleRes: Int = 0) Functions \u00b6 Name Summary addChildrenForAccessibility [androidJvm] open fun addChildrenForAccessibility (p0: ArrayList < View >) addExtraDataToAccessibilityNodeInfo [androidJvm] open fun addExtraDataToAccessibilityNodeInfo (p0: AccessibilityNodeInfo , p1: String , p2: Bundle ?) addFocusables [androidJvm] open fun addFocusables (p0: ArrayList < View >, p1: Int ) open fun addFocusables (p0: ArrayList < View >, p1: Int , p2: Int ) addKeyboardNavigationClusters [androidJvm] open fun addKeyboardNavigationClusters (p0: MutableCollection < View >, p1: Int ) addOnAttachStateChangeListener [androidJvm] open fun addOnAttachStateChangeListener (p0: View.OnAttachStateChangeListener ) addOnLayoutChangeListener [androidJvm] open fun addOnLayoutChangeListener (p0: View.OnLayoutChangeListener ) addOnUnhandledKeyEventListener [androidJvm] open fun addOnUnhandledKeyEventListener (p0: View.OnUnhandledKeyEventListener ) addTouchables [androidJvm] open fun addTouchables (p0: ArrayList < View >) animate [androidJvm] open fun animate (): ViewPropertyAnimator announceForAccessibility [androidJvm] open fun announceForAccessibility (p0: CharSequence ) autofill [androidJvm] open fun autofill (p0: SparseArray < AutofillValue >) open fun autofill (p0: AutofillValue ) awakenScrollBars [androidJvm] open fun awakenScrollBars (): Boolean open fun awakenScrollBars (p0: Int ): Boolean open fun awakenScrollBars (p0: Int , p1: Boolean ): Boolean bringToFront [androidJvm] open fun bringToFront () buildLayer [androidJvm] open fun buildLayer () callOnClick [androidJvm] open fun callOnClick (): Boolean cancelDragAndDrop [androidJvm] fun cancelDragAndDrop () cancelLongPress [androidJvm] open fun cancelLongPress () cancelPendingInputEvents [androidJvm] fun cancelPendingInputEvents () canResolveLayoutDirection [androidJvm] open fun canResolveLayoutDirection (): Boolean canResolveTextAlignment [androidJvm] open fun canResolveTextAlignment (): Boolean canResolveTextDirection [androidJvm] open fun canResolveTextDirection (): Boolean canScrollHorizontally [androidJvm] open fun canScrollHorizontally (p0: Int ): Boolean canScrollVertically [androidJvm] open fun canScrollVertically (p0: Int ): Boolean checkInputConnectionProxy [androidJvm] open fun checkInputConnectionProxy (p0: View ): Boolean clearAnimation [androidJvm] open fun clearAnimation () clearFocus [androidJvm] open fun clearFocus () clearViewTranslationCallback [androidJvm] open fun clearViewTranslationCallback () computeHorizontalScrollExtent [androidJvm] open fun computeHorizontalScrollExtent (): Int computeHorizontalScrollOffset [androidJvm] open fun computeHorizontalScrollOffset (): Int computeHorizontalScrollRange [androidJvm] open fun computeHorizontalScrollRange (): Int computeScroll [androidJvm] open fun computeScroll () computeSystemWindowInsets [androidJvm] open fun computeSystemWindowInsets (p0: WindowInsets , p1: Rect ): WindowInsets computeVerticalScrollExtent [androidJvm] open fun computeVerticalScrollExtent (): Int computeVerticalScrollOffset [androidJvm] open fun computeVerticalScrollOffset (): Int computeVerticalScrollRange [androidJvm] open fun computeVerticalScrollRange (): Int createAccessibilityNodeInfo [androidJvm] open fun createAccessibilityNodeInfo (): AccessibilityNodeInfo createContextMenu [androidJvm] open fun createContextMenu (p0: ContextMenu ) dispatchApplyWindowInsets [androidJvm] open fun dispatchApplyWindowInsets (p0: WindowInsets ): WindowInsets dispatchCapturedPointerEvent [androidJvm] open fun dispatchCapturedPointerEvent (p0: MotionEvent ): Boolean dispatchConfigurationChanged [androidJvm] open fun dispatchConfigurationChanged (p0: Configuration ) dispatchCreateViewTranslationRequest [androidJvm] open fun dispatchCreateViewTranslationRequest (p0: MutableMap < AutofillId , LongArray >, p1: IntArray , p2: TranslationCapability , p3: MutableList < ViewTranslationRequest >) dispatchDisplayHint [androidJvm] open fun dispatchDisplayHint (p0: Int ) dispatchDragEvent [androidJvm] open fun dispatchDragEvent (p0: DragEvent ): Boolean dispatchDraw [androidJvm] open fun dispatchDraw (p0: Canvas ) dispatchDrawableHotspotChanged [androidJvm] open fun dispatchDrawableHotspotChanged (p0: Float , p1: Float ) dispatchFinishTemporaryDetach [androidJvm] open fun dispatchFinishTemporaryDetach () dispatchGenericFocusedEvent [androidJvm] open fun dispatchGenericFocusedEvent (p0: MotionEvent ): Boolean dispatchGenericMotionEvent [androidJvm] open fun dispatchGenericMotionEvent (p0: MotionEvent ): Boolean dispatchGenericPointerEvent [androidJvm] open fun dispatchGenericPointerEvent (p0: MotionEvent ): Boolean dispatchHoverEvent [androidJvm] open fun dispatchHoverEvent (p0: MotionEvent ): Boolean dispatchKeyEvent [androidJvm] open fun dispatchKeyEvent (p0: KeyEvent ): Boolean dispatchKeyEventPreIme [androidJvm] open fun dispatchKeyEventPreIme (p0: KeyEvent ): Boolean dispatchKeyShortcutEvent [androidJvm] open fun dispatchKeyShortcutEvent (p0: KeyEvent ): Boolean dispatchNestedFling [androidJvm] open fun dispatchNestedFling (p0: Float , p1: Float , p2: Boolean ): Boolean dispatchNestedPreFling [androidJvm] open fun dispatchNestedPreFling (p0: Float , p1: Float ): Boolean dispatchNestedPrePerformAccessibilityAction [androidJvm] open fun dispatchNestedPrePerformAccessibilityAction (p0: Int , p1: Bundle ): Boolean dispatchNestedPreScroll [androidJvm] open fun dispatchNestedPreScroll (p0: Int , p1: Int , p2: IntArray ?, p3: IntArray ?): Boolean dispatchNestedScroll [androidJvm] open fun dispatchNestedScroll (p0: Int , p1: Int , p2: Int , p3: Int , p4: IntArray ?): Boolean dispatchPointerCaptureChanged [androidJvm] open fun dispatchPointerCaptureChanged (p0: Boolean ) dispatchPopulateAccessibilityEvent [androidJvm] open fun dispatchPopulateAccessibilityEvent (p0: AccessibilityEvent ): Boolean dispatchProvideAutofillStructure [androidJvm] open fun dispatchProvideAutofillStructure (p0: ViewStructure , p1: Int ) dispatchProvideStructure [androidJvm] open fun dispatchProvideStructure (p0: ViewStructure ) dispatchRestoreInstanceState [androidJvm] open fun dispatchRestoreInstanceState (p0: SparseArray < Parcelable >) dispatchSaveInstanceState [androidJvm] open fun dispatchSaveInstanceState (p0: SparseArray < Parcelable >) dispatchScrollCaptureSearch [androidJvm] open fun dispatchScrollCaptureSearch (p0: Rect , p1: Point , p2: Consumer < ScrollCaptureTarget >) dispatchSetActivated [androidJvm] open fun dispatchSetActivated (p0: Boolean ) dispatchSetPressed [androidJvm] open fun dispatchSetPressed (p0: Boolean ) dispatchSetSelected [androidJvm] open fun dispatchSetSelected (p0: Boolean ) dispatchStartTemporaryDetach [androidJvm] open fun dispatchStartTemporaryDetach () dispatchTouchEvent [androidJvm] open fun dispatchTouchEvent (p0: MotionEvent ): Boolean dispatchTrackballEvent [androidJvm] open fun dispatchTrackballEvent (p0: MotionEvent ): Boolean dispatchUnhandledMove [androidJvm] open fun dispatchUnhandledMove (p0: View , p1: Int ): Boolean dispatchVisibilityChanged [androidJvm] open fun dispatchVisibilityChanged (p0: View , p1: Int ) dispatchWindowFocusChanged [androidJvm] open fun dispatchWindowFocusChanged (p0: Boolean ) dispatchWindowInsetsAnimationEnd [androidJvm] open fun dispatchWindowInsetsAnimationEnd (p0: WindowInsetsAnimation ) dispatchWindowInsetsAnimationPrepare [androidJvm] open fun dispatchWindowInsetsAnimationPrepare (p0: WindowInsetsAnimation ) dispatchWindowInsetsAnimationProgress [androidJvm] open fun dispatchWindowInsetsAnimationProgress (p0: WindowInsets , p1: MutableList < WindowInsetsAnimation >): WindowInsets dispatchWindowInsetsAnimationStart [androidJvm] open fun dispatchWindowInsetsAnimationStart (p0: WindowInsetsAnimation , p1: WindowInsetsAnimation.Bounds ): WindowInsetsAnimation.Bounds dispatchWindowVisibilityChanged [androidJvm] open fun dispatchWindowVisibilityChanged (p0: Int ) draw [androidJvm] open fun draw (p0: Canvas ) drawableHotspotChanged [androidJvm] open fun drawableHotspotChanged (p0: Float , p1: Float ) drawableStateChanged [androidJvm] open fun drawableStateChanged () findFocus [androidJvm] open fun findFocus (): View findViewById [androidJvm] fun < T : View > findViewById (p0: Int ): T findViewsWithText [androidJvm] open fun findViewsWithText (p0: ArrayList < View >, p1: CharSequence , p2: Int ) findViewWithTag [androidJvm] fun < T : View > findViewWithTag (p0: Any ): T focusSearch [androidJvm] open fun focusSearch (p0: Int ): View forceHasOverlappingRendering [androidJvm] open fun forceHasOverlappingRendering (p0: Boolean ) forceLayout [androidJvm] open fun forceLayout () gatherTransparentRegion [androidJvm] open fun gatherTransparentRegion (p0: Region ?): Boolean generateDisplayHash [androidJvm] open fun generateDisplayHash (p0: String , p1: Rect ?, p2: Executor , p3: DisplayHashResultCallback ) getAccessibilityClassName [androidJvm] open fun getAccessibilityClassName (): CharSequence getAccessibilityDelegate [androidJvm] open fun getAccessibilityDelegate (): View.AccessibilityDelegate getAccessibilityLiveRegion [androidJvm] open fun getAccessibilityLiveRegion (): Int getAccessibilityNodeProvider [androidJvm] open fun getAccessibilityNodeProvider (): AccessibilityNodeProvider getAccessibilityPaneTitle [androidJvm] open fun getAccessibilityPaneTitle (): CharSequence ? getAccessibilityTraversalAfter [androidJvm] open fun getAccessibilityTraversalAfter (): Int getAccessibilityTraversalBefore [androidJvm] open fun getAccessibilityTraversalBefore (): Int getAlpha [androidJvm] open fun getAlpha (): Float getAnimation [androidJvm] open fun getAnimation (): Animation getAnimationMatrix [androidJvm] open fun getAnimationMatrix (): Matrix ? getApplicationWindowToken [androidJvm] open fun getApplicationWindowToken (): IBinder getAttributeResolutionStack [androidJvm] open fun getAttributeResolutionStack (p0: Int ): IntArray getAttributeSourceResourceMap [androidJvm] open fun getAttributeSourceResourceMap (): MutableMap < Int , Int > getAutofillHints [androidJvm] open fun getAutofillHints (): Array < String >? getAutofillId [androidJvm] fun getAutofillId (): AutofillId getAutofillType [androidJvm] open fun getAutofillType (): Int getAutofillValue [androidJvm] open fun getAutofillValue (): AutofillValue ? getBackground [androidJvm] open fun getBackground (): Drawable getBackgroundTintBlendMode [androidJvm] open fun getBackgroundTintBlendMode (): BlendMode ? getBackgroundTintList [androidJvm] open fun getBackgroundTintList (): ColorStateList ? getBackgroundTintMode [androidJvm] open fun getBackgroundTintMode (): PorterDuff.Mode ? getBaseline [androidJvm] open fun getBaseline (): Int getBottom [androidJvm] fun getBottom (): Int getBottomFadingEdgeStrength [androidJvm] open fun getBottomFadingEdgeStrength (): Float getBottomPaddingOffset [androidJvm] open fun getBottomPaddingOffset (): Int getCameraDistance [androidJvm] open fun getCameraDistance (): Float getClipBounds [androidJvm] open fun getClipBounds (): Rect open fun getClipBounds (p0: Rect ): Boolean getClipToOutline [androidJvm] fun getClipToOutline (): Boolean getContentCaptureSession [androidJvm] fun getContentCaptureSession (): ContentCaptureSession ? getContentDescription [androidJvm] open fun getContentDescription (): CharSequence getContext [androidJvm] fun getContext (): Context getContextMenuInfo [androidJvm] open fun getContextMenuInfo (): ContextMenu.ContextMenuInfo getDefaultFocusHighlightEnabled [androidJvm] fun getDefaultFocusHighlightEnabled (): Boolean getDisplay [androidJvm] open fun getDisplay (): Display getDrawableState [androidJvm] fun getDrawableState (): IntArray getDrawingRect [androidJvm] open fun getDrawingRect (p0: Rect ) getDrawingTime [androidJvm] open fun getDrawingTime (): Long getElevation [androidJvm] open fun getElevation (): Float getExplicitStyle [androidJvm] open fun getExplicitStyle (): Int getFilterTouchesWhenObscured [androidJvm] open fun getFilterTouchesWhenObscured (): Boolean getFitsSystemWindows [androidJvm] open fun getFitsSystemWindows (): Boolean getFocusable [androidJvm] open fun getFocusable (): Int getFocusables [androidJvm] open fun getFocusables (p0: Int ): ArrayList < View > getFocusedRect [androidJvm] open fun getFocusedRect (p0: Rect ) getForeground [androidJvm] open fun getForeground (): Drawable getForegroundGravity [androidJvm] open fun getForegroundGravity (): Int getForegroundTintBlendMode [androidJvm] open fun getForegroundTintBlendMode (): BlendMode ? getForegroundTintList [androidJvm] open fun getForegroundTintList (): ColorStateList ? getForegroundTintMode [androidJvm] open fun getForegroundTintMode (): PorterDuff.Mode ? getGlobalVisibleRect [androidJvm] fun getGlobalVisibleRect (p0: Rect ): Boolean open fun getGlobalVisibleRect (p0: Rect , p1: Point ): Boolean getHandler [androidJvm] open fun getHandler (): Handler getHasOverlappingRendering [androidJvm] fun getHasOverlappingRendering (): Boolean getHeight [androidJvm] fun getHeight (): Int getHitRect [androidJvm] open fun getHitRect (p0: Rect ) getHorizontalFadingEdgeLength [androidJvm] open fun getHorizontalFadingEdgeLength (): Int getHorizontalScrollbarHeight [androidJvm] open fun getHorizontalScrollbarHeight (): Int getHorizontalScrollbarThumbDrawable [androidJvm] open fun getHorizontalScrollbarThumbDrawable (): Drawable ? getHorizontalScrollbarTrackDrawable [androidJvm] open fun getHorizontalScrollbarTrackDrawable (): Drawable ? getId [androidJvm] open fun getId (): Int getImportantForAccessibility [androidJvm] open fun getImportantForAccessibility (): Int getImportantForAutofill [androidJvm] open fun getImportantForAutofill (): Int getImportantForContentCapture [androidJvm] open fun getImportantForContentCapture (): Int getKeepScreenOn [androidJvm] open fun getKeepScreenOn (): Boolean getKeyDispatcherState [androidJvm] open fun getKeyDispatcherState (): KeyEvent.DispatcherState getLabelFor [androidJvm] open fun getLabelFor (): Int getLayerType [androidJvm] open fun getLayerType (): Int getLayoutDirection [androidJvm] open fun getLayoutDirection (): Int getLayoutParams [androidJvm] open fun getLayoutParams (): ViewGroup.LayoutParams getLeft [androidJvm] fun getLeft (): Int getLeftFadingEdgeStrength [androidJvm] open fun getLeftFadingEdgeStrength (): Float getLeftPaddingOffset [androidJvm] open fun getLeftPaddingOffset (): Int getLocalVisibleRect [androidJvm] fun getLocalVisibleRect (p0: Rect ): Boolean getLocationInSurface [androidJvm] open fun getLocationInSurface (p0: IntArray ) getLocationInWindow [androidJvm] open fun getLocationInWindow (p0: IntArray ) getLocationOnScreen [androidJvm] open fun getLocationOnScreen (p0: IntArray ) getMatrix [androidJvm] open fun getMatrix (): Matrix getMeasuredHeight [androidJvm] fun getMeasuredHeight (): Int getMeasuredHeightAndState [androidJvm] fun getMeasuredHeightAndState (): Int getMeasuredState [androidJvm] fun getMeasuredState (): Int getMeasuredWidth [androidJvm] fun getMeasuredWidth (): Int getMeasuredWidthAndState [androidJvm] fun getMeasuredWidthAndState (): Int getMinimumHeight [androidJvm] open fun getMinimumHeight (): Int getMinimumWidth [androidJvm] open fun getMinimumWidth (): Int getNextClusterForwardId [androidJvm] open fun getNextClusterForwardId (): Int getNextFocusDownId [androidJvm] open fun getNextFocusDownId (): Int getNextFocusForwardId [androidJvm] open fun getNextFocusForwardId (): Int getNextFocusLeftId [androidJvm] open fun getNextFocusLeftId (): Int getNextFocusRightId [androidJvm] open fun getNextFocusRightId (): Int getNextFocusUpId [androidJvm] open fun getNextFocusUpId (): Int getOnFocusChangeListener [androidJvm] open fun getOnFocusChangeListener (): View.OnFocusChangeListener getOutlineAmbientShadowColor [androidJvm] open fun getOutlineAmbientShadowColor (): Int getOutlineProvider [androidJvm] open fun getOutlineProvider (): ViewOutlineProvider getOutlineSpotShadowColor [androidJvm] open fun getOutlineSpotShadowColor (): Int getOverlay [androidJvm] open fun getOverlay (): ViewOverlay getOverScrollMode [androidJvm] open fun getOverScrollMode (): Int getPaddingBottom [androidJvm] open fun getPaddingBottom (): Int getPaddingEnd [androidJvm] open fun getPaddingEnd (): Int getPaddingLeft [androidJvm] open fun getPaddingLeft (): Int getPaddingRight [androidJvm] open fun getPaddingRight (): Int getPaddingStart [androidJvm] open fun getPaddingStart (): Int getPaddingTop [androidJvm] open fun getPaddingTop (): Int getParent [androidJvm] fun getParent (): ViewParent getParentForAccessibility [androidJvm] open fun getParentForAccessibility (): ViewParent getPivotX [androidJvm] open fun getPivotX (): Float getPivotY [androidJvm] open fun getPivotY (): Float getPointerIcon [androidJvm] open fun getPointerIcon (): PointerIcon getReceiveContentMimeTypes [androidJvm] open fun getReceiveContentMimeTypes (): Array < String >? getResources [androidJvm] open fun getResources (): Resources getRevealOnFocusHint [androidJvm] fun getRevealOnFocusHint (): Boolean getRight [androidJvm] fun getRight (): Int getRightFadingEdgeStrength [androidJvm] open fun getRightFadingEdgeStrength (): Float getRightPaddingOffset [androidJvm] open fun getRightPaddingOffset (): Int getRootSurfaceControl [androidJvm] open fun getRootSurfaceControl (): AttachedSurfaceControl ? getRootView [androidJvm] open fun getRootView (): View getRootWindowInsets [androidJvm] open fun getRootWindowInsets (): WindowInsets getRotation [androidJvm] open fun getRotation (): Float getRotationX [androidJvm] open fun getRotationX (): Float getRotationY [androidJvm] open fun getRotationY (): Float getScaleX [androidJvm] open fun getScaleX (): Float getScaleY [androidJvm] open fun getScaleY (): Float getScrollBarDefaultDelayBeforeFade [androidJvm] open fun getScrollBarDefaultDelayBeforeFade (): Int getScrollBarFadeDuration [androidJvm] open fun getScrollBarFadeDuration (): Int getScrollBarSize [androidJvm] open fun getScrollBarSize (): Int getScrollBarStyle [androidJvm] open fun getScrollBarStyle (): Int getScrollCaptureHint [androidJvm] open fun getScrollCaptureHint (): Int getScrollIndicators [androidJvm] open fun getScrollIndicators (): Int getScrollX [androidJvm] fun getScrollX (): Int getScrollY [androidJvm] fun getScrollY (): Int getSolidColor [androidJvm] open fun getSolidColor (): Int getSourceLayoutResId [androidJvm] open fun getSourceLayoutResId (): Int getStateDescription [androidJvm] fun getStateDescription (): CharSequence ? getStateListAnimator [androidJvm] open fun getStateListAnimator (): StateListAnimator getSuggestedMinimumHeight [androidJvm] open fun getSuggestedMinimumHeight (): Int getSuggestedMinimumWidth [androidJvm] open fun getSuggestedMinimumWidth (): Int getSystemGestureExclusionRects [androidJvm] open fun getSystemGestureExclusionRects (): MutableList < Rect > getTag [androidJvm] open fun getTag (): Any open fun getTag (p0: Int ): Any getTextAlignment [androidJvm] open fun getTextAlignment (): Int getTextDirection [androidJvm] open fun getTextDirection (): Int getTooltipText [androidJvm] open fun getTooltipText (): CharSequence ? getTop [androidJvm] fun getTop (): Int getTopFadingEdgeStrength [androidJvm] open fun getTopFadingEdgeStrength (): Float getTopPaddingOffset [androidJvm] open fun getTopPaddingOffset (): Int getTouchables [androidJvm] open fun getTouchables (): ArrayList < View > getTouchDelegate [androidJvm] open fun getTouchDelegate (): TouchDelegate getTransitionAlpha [androidJvm] open fun getTransitionAlpha (): Float getTransitionName [androidJvm] open fun getTransitionName (): String getTranslationX [androidJvm] open fun getTranslationX (): Float getTranslationY [androidJvm] open fun getTranslationY (): Float getTranslationZ [androidJvm] open fun getTranslationZ (): Float getUniqueDrawingId [androidJvm] open fun getUniqueDrawingId (): Long getVerticalFadingEdgeLength [androidJvm] open fun getVerticalFadingEdgeLength (): Int getVerticalScrollbarPosition [androidJvm] open fun getVerticalScrollbarPosition (): Int getVerticalScrollbarThumbDrawable [androidJvm] open fun getVerticalScrollbarThumbDrawable (): Drawable ? getVerticalScrollbarTrackDrawable [androidJvm] open fun getVerticalScrollbarTrackDrawable (): Drawable ? getVerticalScrollbarWidth [androidJvm] open fun getVerticalScrollbarWidth (): Int getViewTranslationResponse [androidJvm] open fun getViewTranslationResponse (): ViewTranslationResponse ? getViewTreeObserver [androidJvm] open fun getViewTreeObserver (): ViewTreeObserver getVisibility [androidJvm] open override fun getVisibility (): Int Returns the visibility of actual . (Bear in mind that the initial value of actual is this stub.) getWidth [androidJvm] fun getWidth (): Int getWindowAttachCount [androidJvm] open fun getWindowAttachCount (): Int getWindowId [androidJvm] open fun getWindowId (): WindowId getWindowInsetsController [androidJvm] open fun getWindowInsetsController (): WindowInsetsController ? getWindowToken [androidJvm] open fun getWindowToken (): IBinder getWindowVisibility [androidJvm] open fun getWindowVisibility (): Int getWindowVisibleDisplayFrame [androidJvm] open fun getWindowVisibleDisplayFrame (p0: Rect ) getX [androidJvm] open fun getX (): Float getY [androidJvm] open fun getY (): Float getZ [androidJvm] open fun getZ (): Float hasExplicitFocusable [androidJvm] open fun hasExplicitFocusable (): Boolean hasFocus [androidJvm] open fun hasFocus (): Boolean hasFocusable [androidJvm] open fun hasFocusable (): Boolean hasNestedScrollingParent [androidJvm] open fun hasNestedScrollingParent (): Boolean hasOnClickListeners [androidJvm] open fun hasOnClickListeners (): Boolean hasOnLongClickListeners [androidJvm] open fun hasOnLongClickListeners (): Boolean hasOverlappingRendering [androidJvm] open fun hasOverlappingRendering (): Boolean hasPointerCapture [androidJvm] open fun hasPointerCapture (): Boolean hasTransientState [androidJvm] open fun hasTransientState (): Boolean hasWindowFocus [androidJvm] open fun hasWindowFocus (): Boolean invalidate [androidJvm] open fun invalidate () invalidateDrawable [androidJvm] open override fun invalidateDrawable (p0: Drawable ) invalidateOutline [androidJvm] open fun invalidateOutline () isAccessibilityFocused [androidJvm] open fun isAccessibilityFocused (): Boolean isAccessibilityHeading [androidJvm] open fun isAccessibilityHeading (): Boolean isActivated [androidJvm] open fun isActivated (): Boolean isAttachedToWindow [androidJvm] open fun isAttachedToWindow (): Boolean isClickable [androidJvm] open fun isClickable (): Boolean isContextClickable [androidJvm] open fun isContextClickable (): Boolean isDirty [androidJvm] open fun isDirty (): Boolean isDuplicateParentStateEnabled [androidJvm] open fun isDuplicateParentStateEnabled (): Boolean isEnabled [androidJvm] open fun isEnabled (): Boolean isFocusable [androidJvm] fun isFocusable (): Boolean isFocusableInTouchMode [androidJvm] fun isFocusableInTouchMode (): Boolean isFocused [androidJvm] open fun isFocused (): Boolean isFocusedByDefault [androidJvm] fun isFocusedByDefault (): Boolean isForceDarkAllowed [androidJvm] open fun isForceDarkAllowed (): Boolean isHapticFeedbackEnabled [androidJvm] open fun isHapticFeedbackEnabled (): Boolean isHardwareAccelerated [androidJvm] open fun isHardwareAccelerated (): Boolean isHorizontalFadingEdgeEnabled [androidJvm] open fun isHorizontalFadingEdgeEnabled (): Boolean isHorizontalScrollBarEnabled [androidJvm] open fun isHorizontalScrollBarEnabled (): Boolean isHovered [androidJvm] open fun isHovered (): Boolean isImportantForAccessibility [androidJvm] open fun isImportantForAccessibility (): Boolean isImportantForAutofill [androidJvm] fun isImportantForAutofill (): Boolean isImportantForContentCapture [androidJvm] fun isImportantForContentCapture (): Boolean isInEditMode [androidJvm] open fun isInEditMode (): Boolean isInLayout [androidJvm] open fun isInLayout (): Boolean isInTouchMode [androidJvm] open fun isInTouchMode (): Boolean isKeyboardNavigationCluster [androidJvm] fun isKeyboardNavigationCluster (): Boolean isLaidOut [androidJvm] open fun isLaidOut (): Boolean isLayoutDirectionResolved [androidJvm] open fun isLayoutDirectionResolved (): Boolean isLayoutRequested [androidJvm] open fun isLayoutRequested (): Boolean isLongClickable [androidJvm] open fun isLongClickable (): Boolean isNestedScrollingEnabled [androidJvm] open fun isNestedScrollingEnabled (): Boolean isOpaque [androidJvm] open fun isOpaque (): Boolean isPaddingOffsetRequired [androidJvm] open fun isPaddingOffsetRequired (): Boolean isPaddingRelative [androidJvm] open fun isPaddingRelative (): Boolean isPivotSet [androidJvm] open fun isPivotSet (): Boolean isPressed [androidJvm] open fun isPressed (): Boolean isSaveEnabled [androidJvm] open fun isSaveEnabled (): Boolean isSaveFromParentEnabled [androidJvm] open fun isSaveFromParentEnabled (): Boolean isScreenReaderFocusable [androidJvm] open fun isScreenReaderFocusable (): Boolean isScrollbarFadingEnabled [androidJvm] open fun isScrollbarFadingEnabled (): Boolean isScrollContainer [androidJvm] open fun isScrollContainer (): Boolean isSelected [androidJvm] open fun isSelected (): Boolean isShowingLayoutBounds [androidJvm] fun isShowingLayoutBounds (): Boolean isShown [androidJvm] open fun isShown (): Boolean isSoundEffectsEnabled [androidJvm] open fun isSoundEffectsEnabled (): Boolean isTemporarilyDetached [androidJvm] fun isTemporarilyDetached (): Boolean isTextAlignmentResolved [androidJvm] open fun isTextAlignmentResolved (): Boolean isTextDirectionResolved [androidJvm] open fun isTextDirectionResolved (): Boolean isVerticalFadingEdgeEnabled [androidJvm] open fun isVerticalFadingEdgeEnabled (): Boolean isVerticalScrollBarEnabled [androidJvm] open fun isVerticalScrollBarEnabled (): Boolean isVisibleToUserForAutofill [androidJvm] open fun isVisibleToUserForAutofill (p0: Int ): Boolean jumpDrawablesToCurrentState [androidJvm] open fun jumpDrawablesToCurrentState () keyboardNavigationClusterSearch [androidJvm] open fun keyboardNavigationClusterSearch (p0: View , p1: Int ): View layout [androidJvm] open fun layout (p0: Int , p1: Int , p2: Int , p3: Int ) measure [androidJvm] fun measure (p0: Int , p1: Int ) offsetLeftAndRight [androidJvm] open fun offsetLeftAndRight (p0: Int ) offsetTopAndBottom [androidJvm] open fun offsetTopAndBottom (p0: Int ) onAnimationEnd [androidJvm] open fun onAnimationEnd () onAnimationStart [androidJvm] open fun onAnimationStart () onApplyWindowInsets [androidJvm] open fun onApplyWindowInsets (p0: WindowInsets ): WindowInsets onAttachedToWindow [androidJvm] open fun onAttachedToWindow () onCancelPendingInputEvents [androidJvm] open fun onCancelPendingInputEvents () onCapturedPointerEvent [androidJvm] open fun onCapturedPointerEvent (p0: MotionEvent ): Boolean onCheckIsTextEditor [androidJvm] open fun onCheckIsTextEditor (): Boolean onConfigurationChanged [androidJvm] open fun onConfigurationChanged (p0: Configuration ) onCreateContextMenu [androidJvm] open fun onCreateContextMenu (p0: ContextMenu ) onCreateDrawableState [androidJvm] open fun onCreateDrawableState (p0: Int ): IntArray onCreateInputConnection [androidJvm] open fun onCreateInputConnection (p0: EditorInfo ): InputConnection onCreateViewTranslationRequest [androidJvm] open fun onCreateViewTranslationRequest (p0: IntArray , p1: Consumer < ViewTranslationRequest >) onCreateVirtualViewTranslationRequests [androidJvm] open fun onCreateVirtualViewTranslationRequests (p0: LongArray , p1: IntArray , p2: Consumer < ViewTranslationRequest >) onDetachedFromWindow [androidJvm] open fun onDetachedFromWindow () onDisplayHint [androidJvm] open fun onDisplayHint (p0: Int ) onDragEvent [androidJvm] open fun onDragEvent (p0: DragEvent ): Boolean onDraw [androidJvm] open fun onDraw (p0: Canvas ) onDrawForeground [androidJvm] open fun onDrawForeground (p0: Canvas ) onDrawScrollBars [androidJvm] fun onDrawScrollBars (p0: Canvas ) onFilterTouchEventForSecurity [androidJvm] open fun onFilterTouchEventForSecurity (p0: MotionEvent ): Boolean onFinishInflate [androidJvm] open fun onFinishInflate () onFinishTemporaryDetach [androidJvm] open fun onFinishTemporaryDetach () onFocusChanged [androidJvm] open fun onFocusChanged (p0: Boolean , p1: Int , p2: Rect ?) onGenericMotionEvent [androidJvm] open fun onGenericMotionEvent (p0: MotionEvent ): Boolean onHoverChanged [androidJvm] open fun onHoverChanged (p0: Boolean ) onHoverEvent [androidJvm] open fun onHoverEvent (p0: MotionEvent ): Boolean onInitializeAccessibilityEvent [androidJvm] open fun onInitializeAccessibilityEvent (p0: AccessibilityEvent ) onInitializeAccessibilityNodeInfo [androidJvm] open fun onInitializeAccessibilityNodeInfo (p0: AccessibilityNodeInfo ) onKeyDown [androidJvm] open override fun onKeyDown (p0: Int , p1: KeyEvent ): Boolean onKeyLongPress [androidJvm] open override fun onKeyLongPress (p0: Int , p1: KeyEvent ): Boolean onKeyMultiple [androidJvm] open override fun onKeyMultiple (p0: Int , p1: Int , p2: KeyEvent ): Boolean onKeyPreIme [androidJvm] open fun onKeyPreIme (p0: Int , p1: KeyEvent ): Boolean onKeyShortcut [androidJvm] open fun onKeyShortcut (p0: Int , p1: KeyEvent ): Boolean onKeyUp [androidJvm] open override fun onKeyUp (p0: Int , p1: KeyEvent ): Boolean onLayout [androidJvm] open fun onLayout (p0: Boolean , p1: Int , p2: Int , p3: Int , p4: Int ) onMeasure [androidJvm] open fun onMeasure (p0: Int , p1: Int ) onOverScrolled [androidJvm] open fun onOverScrolled (p0: Int , p1: Int , p2: Boolean , p3: Boolean ) onPointerCaptureChange [androidJvm] open fun onPointerCaptureChange (p0: Boolean ) onPopulateAccessibilityEvent [androidJvm] open fun onPopulateAccessibilityEvent (p0: AccessibilityEvent ) onProvideAutofillStructure [androidJvm] open fun onProvideAutofillStructure (p0: ViewStructure , p1: Int ) onProvideAutofillVirtualStructure [androidJvm] open fun onProvideAutofillVirtualStructure (p0: ViewStructure , p1: Int ) onProvideContentCaptureStructure [androidJvm] open fun onProvideContentCaptureStructure (p0: ViewStructure , p1: Int ) onProvideStructure [androidJvm] open fun onProvideStructure (p0: ViewStructure ) onProvideVirtualStructure [androidJvm] open fun onProvideVirtualStructure (p0: ViewStructure ) onReceiveContent [androidJvm] open fun onReceiveContent (p0: ContentInfo ): ContentInfo ? onResolvePointerIcon [androidJvm] open fun onResolvePointerIcon (p0: MotionEvent , p1: Int ): PointerIcon onRestoreInstanceState [androidJvm] open fun onRestoreInstanceState (p0: Parcelable ) onRtlPropertiesChanged [androidJvm] open fun onRtlPropertiesChanged (p0: Int ) onSaveInstanceState [androidJvm] open fun onSaveInstanceState (): Parcelable ? onScreenStateChanged [androidJvm] open fun onScreenStateChanged (p0: Int ) onScrollCaptureSearch [androidJvm] open fun onScrollCaptureSearch (p0: Rect , p1: Point , p2: Consumer < ScrollCaptureTarget >) onScrollChanged [androidJvm] open fun onScrollChanged (p0: Int , p1: Int , p2: Int , p3: Int ) onSetAlpha [androidJvm] open fun onSetAlpha (p0: Int ): Boolean onSizeChanged [androidJvm] open fun onSizeChanged (p0: Int , p1: Int , p2: Int , p3: Int ) onStartTemporaryDetach [androidJvm] open fun onStartTemporaryDetach () onTouchEvent [androidJvm] open fun onTouchEvent (p0: MotionEvent ): Boolean onTrackballEvent [androidJvm] open fun onTrackballEvent (p0: MotionEvent ): Boolean onViewTranslationResponse [androidJvm] open fun onViewTranslationResponse (p0: ViewTranslationResponse ) onVirtualViewTranslationResponses [androidJvm] open fun onVirtualViewTranslationResponses (p0: LongSparseArray < ViewTranslationResponse >) onVisibilityAggregated [androidJvm] open fun onVisibilityAggregated (p0: Boolean ) onVisibilityChanged [androidJvm] open fun onVisibilityChanged (p0: View , p1: Int ) onWindowFocusChanged [androidJvm] open fun onWindowFocusChanged (p0: Boolean ) onWindowVisibilityChanged [androidJvm] open fun onWindowVisibilityChanged (p0: Int ) overScrollBy [androidJvm] open fun overScrollBy (p0: Int , p1: Int , p2: Int , p3: Int , p4: Int , p5: Int , p6: Int , p7: Int , p8: Boolean ): Boolean performAccessibilityAction [androidJvm] open fun performAccessibilityAction (p0: Int , p1: Bundle ): Boolean performClick [androidJvm] open fun performClick (): Boolean performContextClick [androidJvm] open fun performContextClick (): Boolean open fun performContextClick (p0: Float , p1: Float ): Boolean performHapticFeedback [androidJvm] open fun performHapticFeedback (p0: Int ): Boolean open fun performHapticFeedback (p0: Int , p1: Int ): Boolean performLongClick [androidJvm] open fun performLongClick (): Boolean open fun performLongClick (p0: Float , p1: Float ): Boolean performReceiveContent [androidJvm] open fun performReceiveContent (p0: ContentInfo ): ContentInfo ? playSoundEffect [androidJvm] open fun playSoundEffect (p0: Int ) post [androidJvm] open fun post (p0: Runnable ): Boolean postDelayed [androidJvm] open fun postDelayed (p0: Runnable , p1: Long ): Boolean postInvalidate [androidJvm] open fun postInvalidate () open fun postInvalidate (p0: Int , p1: Int , p2: Int , p3: Int ) postInvalidateDelayed [androidJvm] open fun postInvalidateDelayed (p0: Long ) open fun postInvalidateDelayed (p0: Long , p1: Int , p2: Int , p3: Int , p4: Int ) postInvalidateOnAnimation [androidJvm] open fun postInvalidateOnAnimation () open fun postInvalidateOnAnimation (p0: Int , p1: Int , p2: Int , p3: Int ) postOnAnimation [androidJvm] open fun postOnAnimation (p0: Runnable ) postOnAnimationDelayed [androidJvm] open fun postOnAnimationDelayed (p0: Runnable , p1: Long ) refreshDrawableState [androidJvm] open fun refreshDrawableState () releasePointerCapture [androidJvm] open fun releasePointerCapture () removeCallbacks [androidJvm] open fun removeCallbacks (p0: Runnable ): Boolean removeOnAttachStateChangeListener [androidJvm] open fun removeOnAttachStateChangeListener (p0: View.OnAttachStateChangeListener ) removeOnLayoutChangeListener [androidJvm] open fun removeOnLayoutChangeListener (p0: View.OnLayoutChangeListener ) removeOnUnhandledKeyEventListener [androidJvm] open fun removeOnUnhandledKeyEventListener (p0: View.OnUnhandledKeyEventListener ) requestApplyInsets [androidJvm] open fun requestApplyInsets () requestFocus [androidJvm] fun requestFocus (): Boolean fun requestFocus (p0: Int ): Boolean open fun requestFocus (p0: Int , p1: Rect ): Boolean requestFocusFromTouch [androidJvm] fun requestFocusFromTouch (): Boolean requestLayout [androidJvm] open fun requestLayout () requestPointerCapture [androidJvm] open fun requestPointerCapture () requestRectangleOnScreen [androidJvm] open fun requestRectangleOnScreen (p0: Rect ): Boolean open fun requestRectangleOnScreen (p0: Rect , p1: Boolean ): Boolean requestUnbufferedDispatch [androidJvm] fun requestUnbufferedDispatch (p0: MotionEvent ) fun requestUnbufferedDispatch (p0: Int ) requireViewById [androidJvm] fun < T : View > requireViewById (p0: Int ): T resetPivot [androidJvm] open fun resetPivot () restoreDefaultFocus [androidJvm] open fun restoreDefaultFocus (): Boolean restoreHierarchyState [androidJvm] open fun restoreHierarchyState (p0: SparseArray < Parcelable >) saveAttributeDataForStyleable [androidJvm] fun saveAttributeDataForStyleable (p0: Context , p1: IntArray , p2: AttributeSet ?, p3: TypedArray , p4: Int , p5: Int ) saveHierarchyState [androidJvm] open fun saveHierarchyState (p0: SparseArray < Parcelable >) scheduleDrawable [androidJvm] open override fun scheduleDrawable (p0: Drawable , p1: Runnable , p2: Long ) scrollBy [androidJvm] open fun scrollBy (p0: Int , p1: Int ) scrollTo [androidJvm] open fun scrollTo (p0: Int , p1: Int ) sendAccessibilityEvent [androidJvm] open override fun sendAccessibilityEvent (p0: Int ) sendAccessibilityEventUnchecked [androidJvm] open override fun sendAccessibilityEventUnchecked (p0: AccessibilityEvent ) setAccessibilityDelegate [androidJvm] open fun setAccessibilityDelegate (p0: View.AccessibilityDelegate ?) setAccessibilityHeading [androidJvm] open fun setAccessibilityHeading (p0: Boolean ) setAccessibilityLiveRegion [androidJvm] open fun setAccessibilityLiveRegion (p0: Int ) setAccessibilityPaneTitle [androidJvm] open fun setAccessibilityPaneTitle (p0: CharSequence ?) setAccessibilityTraversalAfter [androidJvm] open fun setAccessibilityTraversalAfter (p0: Int ) setAccessibilityTraversalBefore [androidJvm] open fun setAccessibilityTraversalBefore (p0: Int ) setActivated [androidJvm] open fun setActivated (p0: Boolean ) setAllowClickWhenDisabled [androidJvm] open fun setAllowClickWhenDisabled (p0: Boolean ) setAlpha [androidJvm] open fun setAlpha (p0: Float ) setAnimation [androidJvm] open fun setAnimation (p0: Animation ) setAnimationMatrix [androidJvm] open fun setAnimationMatrix (p0: Matrix ?) setAutofillHints [androidJvm] open fun setAutofillHints (vararg p0: String ) setAutofillId [androidJvm] open fun setAutofillId (p0: AutofillId ?) setBackground [androidJvm] open override fun setBackground (background: Drawable ?) Sets the background of this stub as usual, and also that of actual if the given background is not null. Any new views created by update will be assigned this background, again if it is not null. setBackgroundColor [androidJvm] open fun setBackgroundColor (p0: Int ) setBackgroundResource [androidJvm] open fun setBackgroundResource (p0: Int ) setBackgroundTintBlendMode [androidJvm] open fun setBackgroundTintBlendMode (p0: BlendMode ?) setBackgroundTintList [androidJvm] open fun setBackgroundTintList (p0: ColorStateList ?) setBackgroundTintMode [androidJvm] open fun setBackgroundTintMode (p0: PorterDuff.Mode ?) setBottom [androidJvm] fun setBottom (p0: Int ) setCameraDistance [androidJvm] open fun setCameraDistance (p0: Float ) setClickable [androidJvm] open fun setClickable (p0: Boolean ) setClipBounds [androidJvm] open fun setClipBounds (p0: Rect ) setClipToOutline [androidJvm] open fun setClipToOutline (p0: Boolean ) setContentCaptureSession [androidJvm] open fun setContentCaptureSession (p0: ContentCaptureSession ?) setContentDescription [androidJvm] open fun setContentDescription (p0: CharSequence ) setContextClickable [androidJvm] open fun setContextClickable (p0: Boolean ) setDefaultFocusHighlightEnabled [androidJvm] open fun setDefaultFocusHighlightEnabled (p0: Boolean ) setDuplicateParentStateEnabled [androidJvm] open fun setDuplicateParentStateEnabled (p0: Boolean ) setElevation [androidJvm] open fun setElevation (p0: Float ) setEnabled [androidJvm] open fun setEnabled (p0: Boolean ) setFadingEdgeLength [androidJvm] open fun setFadingEdgeLength (p0: Int ) setFilterTouchesWhenObscured [androidJvm] open fun setFilterTouchesWhenObscured (p0: Boolean ) setFitsSystemWindows [androidJvm] open fun setFitsSystemWindows (p0: Boolean ) setFocusable [androidJvm] open fun setFocusable (p0: Boolean ) open fun setFocusable (p0: Int ) setFocusableInTouchMode [androidJvm] open fun setFocusableInTouchMode (p0: Boolean ) setFocusedByDefault [androidJvm] open fun setFocusedByDefault (p0: Boolean ) setForceDarkAllowed [androidJvm] open fun setForceDarkAllowed (p0: Boolean ) setForeground [androidJvm] open fun setForeground (p0: Drawable ) setForegroundGravity [androidJvm] open fun setForegroundGravity (p0: Int ) setForegroundTintBlendMode [androidJvm] open fun setForegroundTintBlendMode (p0: BlendMode ?) setForegroundTintList [androidJvm] open fun setForegroundTintList (p0: ColorStateList ?) setForegroundTintMode [androidJvm] open fun setForegroundTintMode (p0: PorterDuff.Mode ?) setHapticFeedbackEnabled [androidJvm] open fun setHapticFeedbackEnabled (p0: Boolean ) setHasTransientState [androidJvm] open fun setHasTransientState (p0: Boolean ) setHorizontalFadingEdgeEnabled [androidJvm] open fun setHorizontalFadingEdgeEnabled (p0: Boolean ) setHorizontalScrollBarEnabled [androidJvm] open fun setHorizontalScrollBarEnabled (p0: Boolean ) setHorizontalScrollbarThumbDrawable [androidJvm] open fun setHorizontalScrollbarThumbDrawable (p0: Drawable ?) setHorizontalScrollbarTrackDrawable [androidJvm] open fun setHorizontalScrollbarTrackDrawable (p0: Drawable ?) setHovered [androidJvm] open fun setHovered (p0: Boolean ) setId [androidJvm] open override fun setId (@ IdRes id: Int ) setImportantForAccessibility [androidJvm] open fun setImportantForAccessibility (p0: Int ) setImportantForAutofill [androidJvm] open fun setImportantForAutofill (p0: Int ) setImportantForContentCapture [androidJvm] open fun setImportantForContentCapture (p0: Int ) setKeepScreenOn [androidJvm] open fun setKeepScreenOn (p0: Boolean ) setKeyboardNavigationCluster [androidJvm] open fun setKeyboardNavigationCluster (p0: Boolean ) setLabelFor [androidJvm] open fun setLabelFor (p0: Int ) setLayerPaint [androidJvm] open fun setLayerPaint (p0: Paint ?) setLayerType [androidJvm] open fun setLayerType (p0: Int , p1: Paint ?) setLayoutDirection [androidJvm] open fun setLayoutDirection (p0: Int ) setLayoutParams [androidJvm] open fun setLayoutParams (p0: ViewGroup.LayoutParams ) setLeft [androidJvm] fun setLeft (p0: Int ) setLeftTopRightBottom [androidJvm] fun setLeftTopRightBottom (p0: Int , p1: Int , p2: Int , p3: Int ) setLongClickable [androidJvm] open fun setLongClickable (p0: Boolean ) setMeasuredDimension [androidJvm] fun setMeasuredDimension (p0: Int , p1: Int ) setMinimumHeight [androidJvm] open fun setMinimumHeight (p0: Int ) setMinimumWidth [androidJvm] open fun setMinimumWidth (p0: Int ) setNestedScrollingEnabled [androidJvm] open fun setNestedScrollingEnabled (p0: Boolean ) setNextClusterForwardId [androidJvm] open fun setNextClusterForwardId (p0: Int ) setNextFocusDownId [androidJvm] open fun setNextFocusDownId (p0: Int ) setNextFocusForwardId [androidJvm] open fun setNextFocusForwardId (p0: Int ) setNextFocusLeftId [androidJvm] open fun setNextFocusLeftId (p0: Int ) setNextFocusRightId [androidJvm] open fun setNextFocusRightId (p0: Int ) setNextFocusUpId [androidJvm] open fun setNextFocusUpId (p0: Int ) setOnApplyWindowInsetsListener [androidJvm] open fun setOnApplyWindowInsetsListener (p0: View.OnApplyWindowInsetsListener ) setOnCapturedPointerListener [androidJvm] open fun setOnCapturedPointerListener (p0: View.OnCapturedPointerListener ) setOnClickListener [androidJvm] open fun setOnClickListener (p0: View.OnClickListener ?) setOnContextClickListener [androidJvm] open fun setOnContextClickListener (p0: View.OnContextClickListener ?) setOnCreateContextMenuListener [androidJvm] open fun setOnCreateContextMenuListener (p0: View.OnCreateContextMenuListener ) setOnDragListener [androidJvm] open fun setOnDragListener (p0: View.OnDragListener ) setOnFocusChangeListener [androidJvm] open fun setOnFocusChangeListener (p0: View.OnFocusChangeListener ) setOnGenericMotionListener [androidJvm] open fun setOnGenericMotionListener (p0: View.OnGenericMotionListener ) setOnHoverListener [androidJvm] open fun setOnHoverListener (p0: View.OnHoverListener ) setOnKeyListener [androidJvm] open fun setOnKeyListener (p0: View.OnKeyListener ) setOnLongClickListener [androidJvm] open fun setOnLongClickListener (p0: View.OnLongClickListener ?) setOnReceiveContentListener [androidJvm] open fun setOnReceiveContentListener (p0: Array < String >?, p1: OnReceiveContentListener ?) setOnScrollChangeListener [androidJvm] open fun setOnScrollChangeListener (p0: View.OnScrollChangeListener ) setOnTouchListener [androidJvm] open fun setOnTouchListener (p0: View.OnTouchListener ) setOutlineAmbientShadowColor [androidJvm] open fun setOutlineAmbientShadowColor (p0: Int ) setOutlineProvider [androidJvm] open fun setOutlineProvider (p0: ViewOutlineProvider ) setOutlineSpotShadowColor [androidJvm] open fun setOutlineSpotShadowColor (p0: Int ) setOverScrollMode [androidJvm] open fun setOverScrollMode (p0: Int ) setPadding [androidJvm] open fun setPadding (p0: Int , p1: Int , p2: Int , p3: Int ) setPaddingRelative [androidJvm] open fun setPaddingRelative (p0: Int , p1: Int , p2: Int , p3: Int ) setPivotX [androidJvm] open fun setPivotX (p0: Float ) setPivotY [androidJvm] open fun setPivotY (p0: Float ) setPointerIcon [androidJvm] open fun setPointerIcon (p0: PointerIcon ) setPressed [androidJvm] open fun setPressed (p0: Boolean ) setRenderEffect [androidJvm] open fun setRenderEffect (p0: RenderEffect ?) setRevealOnFocusHint [androidJvm] fun setRevealOnFocusHint (p0: Boolean ) setRight [androidJvm] fun setRight (p0: Int ) setRotation [androidJvm] open fun setRotation (p0: Float ) setRotationX [androidJvm] open fun setRotationX (p0: Float ) setRotationY [androidJvm] open fun setRotationY (p0: Float ) setSaveEnabled [androidJvm] open fun setSaveEnabled (p0: Boolean ) setSaveFromParentEnabled [androidJvm] open fun setSaveFromParentEnabled (p0: Boolean ) setScaleX [androidJvm] open fun setScaleX (p0: Float ) setScaleY [androidJvm] open fun setScaleY (p0: Float ) setScreenReaderFocusable [androidJvm] open fun setScreenReaderFocusable (p0: Boolean ) setScrollBarDefaultDelayBeforeFade [androidJvm] open fun setScrollBarDefaultDelayBeforeFade (p0: Int ) setScrollBarFadeDuration [androidJvm] open fun setScrollBarFadeDuration (p0: Int ) setScrollbarFadingEnabled [androidJvm] open fun setScrollbarFadingEnabled (p0: Boolean ) setScrollBarSize [androidJvm] open fun setScrollBarSize (p0: Int ) setScrollBarStyle [androidJvm] open fun setScrollBarStyle (p0: Int ) setScrollCaptureCallback [androidJvm] fun setScrollCaptureCallback (p0: ScrollCaptureCallback ?) setScrollCaptureHint [androidJvm] open fun setScrollCaptureHint (p0: Int ) setScrollContainer [androidJvm] open fun setScrollContainer (p0: Boolean ) setScrollIndicators [androidJvm] open fun setScrollIndicators (p0: Int ) open fun setScrollIndicators (p0: Int , p1: Int ) setScrollX [androidJvm] open fun setScrollX (p0: Int ) setScrollY [androidJvm] open fun setScrollY (p0: Int ) setSelected [androidJvm] open fun setSelected (p0: Boolean ) setSoundEffectsEnabled [androidJvm] open fun setSoundEffectsEnabled (p0: Boolean ) setStateDescription [androidJvm] open fun setStateDescription (p0: CharSequence ?) setStateListAnimator [androidJvm] open fun setStateListAnimator (p0: StateListAnimator ) setSystemGestureExclusionRects [androidJvm] open fun setSystemGestureExclusionRects (p0: MutableList < Rect >) setTag [androidJvm] open fun setTag (p0: Any ) open fun setTag (p0: Int , p1: Any ) setTextAlignment [androidJvm] open fun setTextAlignment (p0: Int ) setTextDirection [androidJvm] open fun setTextDirection (p0: Int ) setTooltipText [androidJvm] open fun setTooltipText (p0: CharSequence ?) setTop [androidJvm] fun setTop (p0: Int ) setTouchDelegate [androidJvm] open fun setTouchDelegate (p0: TouchDelegate ) setTransitionAlpha [androidJvm] open fun setTransitionAlpha (p0: Float ) setTransitionName [androidJvm] fun setTransitionName (p0: String ) setTransitionVisibility [androidJvm] open fun setTransitionVisibility (p0: Int ) setTranslationX [androidJvm] open fun setTranslationX (p0: Float ) setTranslationY [androidJvm] open fun setTranslationY (p0: Float ) setTranslationZ [androidJvm] open fun setTranslationZ (p0: Float ) setVerticalFadingEdgeEnabled [androidJvm] open fun setVerticalFadingEdgeEnabled (p0: Boolean ) setVerticalScrollBarEnabled [androidJvm] open fun setVerticalScrollBarEnabled (p0: Boolean ) setVerticalScrollbarPosition [androidJvm] open fun setVerticalScrollbarPosition (p0: Int ) setVerticalScrollbarThumbDrawable [androidJvm] open fun setVerticalScrollbarThumbDrawable (p0: Drawable ?) setVerticalScrollbarTrackDrawable [androidJvm] open fun setVerticalScrollbarTrackDrawable (p0: Drawable ?) setViewTranslationCallback [androidJvm] open fun setViewTranslationCallback (p0: ViewTranslationCallback ) setVisibility [androidJvm] open override fun setVisibility (visibility: Int ) Sets the visibility of actual . If updatesVisibility is true, the visibility of new views created by update will copied from actual . (Bear in mind that the initial value of actual is this stub.) setWillNotDraw [androidJvm] open fun setWillNotDraw (p0: Boolean ) setWindowInsetsAnimationCallback [androidJvm] open fun setWindowInsetsAnimationCallback (p0: WindowInsetsAnimation.Callback ?) setX [androidJvm] open fun setX (p0: Float ) setY [androidJvm] open fun setY (p0: Float ) setZ [androidJvm] open fun setZ (p0: Float ) showContextMenu [androidJvm] open fun showContextMenu (): Boolean open fun showContextMenu (p0: Float , p1: Float ): Boolean startActionMode [androidJvm] open fun startActionMode (p0: ActionMode.Callback ): ActionMode open fun startActionMode (p0: ActionMode.Callback , p1: Int ): ActionMode startAnimation [androidJvm] open fun startAnimation (p0: Animation ) startDragAndDrop [androidJvm] fun startDragAndDrop (p0: ClipData , p1: View.DragShadowBuilder , p2: Any , p3: Int ): Boolean startNestedScroll [androidJvm] open fun startNestedScroll (p0: Int ): Boolean stopNestedScroll [androidJvm] open fun stopNestedScroll () toString [androidJvm] open override fun toString (): String transformMatrixToGlobal [androidJvm] open fun transformMatrixToGlobal (p0: Matrix ) transformMatrixToLocal [androidJvm] open fun transformMatrixToLocal (p0: Matrix ) unscheduleDrawable [androidJvm] open fun unscheduleDrawable (p0: Drawable ) open override fun unscheduleDrawable (p0: Drawable , p1: Runnable ) update [androidJvm] fun update (rendering: Any , viewEnvironment: ViewEnvironment ): View Replaces this view with one that can display rendering . If the receiver has already been replaced, updates the replacement if it canShowRendering . If the current replacement can\u2019t handle rendering , a new view is put in its place. updateDragShadow [androidJvm] fun updateDragShadow (p0: View.DragShadowBuilder ) verifyDrawable [androidJvm] open fun verifyDrawable (p0: Drawable ): Boolean willNotDraw [androidJvm] open fun willNotDraw (): Boolean Properties \u00b6 Name Summary actual [androidJvm] var actual : View On-demand access to the view created by the last call to update , or this WorkflowViewStub instance if none has yet been made. inflatedId [androidJvm] @ IdRes var inflatedId : Int The id to be assigned to new views created by update . If the inflated id is View.NO_ID (its default value), new views keep their original ids. replaceOldViewInParent [androidJvm] var replaceOldViewInParent : ( ViewGroup , View ) -> Unit Function called from update to replace this stub, or the current actual , with a new view. Can be updated to provide custom transition effects. updatesVisibility [androidJvm] var updatesVisibility : Boolean = true If true, the visibility of views created by update will be copied from that of actual . Bear in mind that the initial value of actual is this stub.","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-workflow-view-stub/#workflowviewstub","text":"[androidJvm]\\ @WorkflowUiExperimentalApi class WorkflowViewStub @ JvmOverloads constructor(context: Context , attributeSet: AttributeSet ?, defStyle: Int , defStyleRes: Int ) : View A placeholder View that can replace itself with ones driven by workflow renderings, similar to android.view.ViewStub .","title":"WorkflowViewStub"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-workflow-view-stub/#usage","text":"In the XML layout for a container view, place a WorkflowViewStub where you want child renderings to be displayed. E.g.: 1 \u2026 Then in your LayoutRunner , pull the view out with findViewById like any other view and [update](update.md) it in your [LayoutRunner.showRendering](../-layout-runner/show-rendering.md) method: 1 2 class YourLayoutRunner(view: View) {\\ private val childStub = view.findViewById&lt;WorkflowViewStub&gt;(R.id.child_stub)\\ \\ // Totally optional, since this view is also accessible as [childStub.actual].\\ // Note that R.id.child was set in XML via the square:inflatedId parameter.\\ private val child: View by lazy {\\ view.findViewById<View>(R.id.child)\\ }\\ \\ override fun showRendering(\\ rendering: YourRendering,\\ viewEnvironment: ViewEnvironment\\ ) {\\ childStub.update(rendering.childRendering, viewEnvironment)\\ }\\ } NB : If you\u2019re using a stub in a RelativeLayout or ConstraintLayout, relationships should be tied to the stub\u2019s app:inflatedId, not its android:id. Use updatesVisibility and setBackground for more control of how update effects the visibility and backgrounds of created views. Use replaceOldViewInParent to customize replacing actual with a new view, e.g. for animated transitions.","title":"Usage"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-workflow-view-stub/#constructors","text":"WorkflowViewStub [androidJvm] @ JvmOverloads fun WorkflowViewStub (context: Context , attributeSet: AttributeSet ? = null, defStyle: Int = 0, defStyleRes: Int = 0)","title":"Constructors"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-workflow-view-stub/#functions","text":"Name Summary addChildrenForAccessibility [androidJvm] open fun addChildrenForAccessibility (p0: ArrayList < View >) addExtraDataToAccessibilityNodeInfo [androidJvm] open fun addExtraDataToAccessibilityNodeInfo (p0: AccessibilityNodeInfo , p1: String , p2: Bundle ?) addFocusables [androidJvm] open fun addFocusables (p0: ArrayList < View >, p1: Int ) open fun addFocusables (p0: ArrayList < View >, p1: Int , p2: Int ) addKeyboardNavigationClusters [androidJvm] open fun addKeyboardNavigationClusters (p0: MutableCollection < View >, p1: Int ) addOnAttachStateChangeListener [androidJvm] open fun addOnAttachStateChangeListener (p0: View.OnAttachStateChangeListener ) addOnLayoutChangeListener [androidJvm] open fun addOnLayoutChangeListener (p0: View.OnLayoutChangeListener ) addOnUnhandledKeyEventListener [androidJvm] open fun addOnUnhandledKeyEventListener (p0: View.OnUnhandledKeyEventListener ) addTouchables [androidJvm] open fun addTouchables (p0: ArrayList < View >) animate [androidJvm] open fun animate (): ViewPropertyAnimator announceForAccessibility [androidJvm] open fun announceForAccessibility (p0: CharSequence ) autofill [androidJvm] open fun autofill (p0: SparseArray < AutofillValue >) open fun autofill (p0: AutofillValue ) awakenScrollBars [androidJvm] open fun awakenScrollBars (): Boolean open fun awakenScrollBars (p0: Int ): Boolean open fun awakenScrollBars (p0: Int , p1: Boolean ): Boolean bringToFront [androidJvm] open fun bringToFront () buildLayer [androidJvm] open fun buildLayer () callOnClick [androidJvm] open fun callOnClick (): Boolean cancelDragAndDrop [androidJvm] fun cancelDragAndDrop () cancelLongPress [androidJvm] open fun cancelLongPress () cancelPendingInputEvents [androidJvm] fun cancelPendingInputEvents () canResolveLayoutDirection [androidJvm] open fun canResolveLayoutDirection (): Boolean canResolveTextAlignment [androidJvm] open fun canResolveTextAlignment (): Boolean canResolveTextDirection [androidJvm] open fun canResolveTextDirection (): Boolean canScrollHorizontally [androidJvm] open fun canScrollHorizontally (p0: Int ): Boolean canScrollVertically [androidJvm] open fun canScrollVertically (p0: Int ): Boolean checkInputConnectionProxy [androidJvm] open fun checkInputConnectionProxy (p0: View ): Boolean clearAnimation [androidJvm] open fun clearAnimation () clearFocus [androidJvm] open fun clearFocus () clearViewTranslationCallback [androidJvm] open fun clearViewTranslationCallback () computeHorizontalScrollExtent [androidJvm] open fun computeHorizontalScrollExtent (): Int computeHorizontalScrollOffset [androidJvm] open fun computeHorizontalScrollOffset (): Int computeHorizontalScrollRange [androidJvm] open fun computeHorizontalScrollRange (): Int computeScroll [androidJvm] open fun computeScroll () computeSystemWindowInsets [androidJvm] open fun computeSystemWindowInsets (p0: WindowInsets , p1: Rect ): WindowInsets computeVerticalScrollExtent [androidJvm] open fun computeVerticalScrollExtent (): Int computeVerticalScrollOffset [androidJvm] open fun computeVerticalScrollOffset (): Int computeVerticalScrollRange [androidJvm] open fun computeVerticalScrollRange (): Int createAccessibilityNodeInfo [androidJvm] open fun createAccessibilityNodeInfo (): AccessibilityNodeInfo createContextMenu [androidJvm] open fun createContextMenu (p0: ContextMenu ) dispatchApplyWindowInsets [androidJvm] open fun dispatchApplyWindowInsets (p0: WindowInsets ): WindowInsets dispatchCapturedPointerEvent [androidJvm] open fun dispatchCapturedPointerEvent (p0: MotionEvent ): Boolean dispatchConfigurationChanged [androidJvm] open fun dispatchConfigurationChanged (p0: Configuration ) dispatchCreateViewTranslationRequest [androidJvm] open fun dispatchCreateViewTranslationRequest (p0: MutableMap < AutofillId , LongArray >, p1: IntArray , p2: TranslationCapability , p3: MutableList < ViewTranslationRequest >) dispatchDisplayHint [androidJvm] open fun dispatchDisplayHint (p0: Int ) dispatchDragEvent [androidJvm] open fun dispatchDragEvent (p0: DragEvent ): Boolean dispatchDraw [androidJvm] open fun dispatchDraw (p0: Canvas ) dispatchDrawableHotspotChanged [androidJvm] open fun dispatchDrawableHotspotChanged (p0: Float , p1: Float ) dispatchFinishTemporaryDetach [androidJvm] open fun dispatchFinishTemporaryDetach () dispatchGenericFocusedEvent [androidJvm] open fun dispatchGenericFocusedEvent (p0: MotionEvent ): Boolean dispatchGenericMotionEvent [androidJvm] open fun dispatchGenericMotionEvent (p0: MotionEvent ): Boolean dispatchGenericPointerEvent [androidJvm] open fun dispatchGenericPointerEvent (p0: MotionEvent ): Boolean dispatchHoverEvent [androidJvm] open fun dispatchHoverEvent (p0: MotionEvent ): Boolean dispatchKeyEvent [androidJvm] open fun dispatchKeyEvent (p0: KeyEvent ): Boolean dispatchKeyEventPreIme [androidJvm] open fun dispatchKeyEventPreIme (p0: KeyEvent ): Boolean dispatchKeyShortcutEvent [androidJvm] open fun dispatchKeyShortcutEvent (p0: KeyEvent ): Boolean dispatchNestedFling [androidJvm] open fun dispatchNestedFling (p0: Float , p1: Float , p2: Boolean ): Boolean dispatchNestedPreFling [androidJvm] open fun dispatchNestedPreFling (p0: Float , p1: Float ): Boolean dispatchNestedPrePerformAccessibilityAction [androidJvm] open fun dispatchNestedPrePerformAccessibilityAction (p0: Int , p1: Bundle ): Boolean dispatchNestedPreScroll [androidJvm] open fun dispatchNestedPreScroll (p0: Int , p1: Int , p2: IntArray ?, p3: IntArray ?): Boolean dispatchNestedScroll [androidJvm] open fun dispatchNestedScroll (p0: Int , p1: Int , p2: Int , p3: Int , p4: IntArray ?): Boolean dispatchPointerCaptureChanged [androidJvm] open fun dispatchPointerCaptureChanged (p0: Boolean ) dispatchPopulateAccessibilityEvent [androidJvm] open fun dispatchPopulateAccessibilityEvent (p0: AccessibilityEvent ): Boolean dispatchProvideAutofillStructure [androidJvm] open fun dispatchProvideAutofillStructure (p0: ViewStructure , p1: Int ) dispatchProvideStructure [androidJvm] open fun dispatchProvideStructure (p0: ViewStructure ) dispatchRestoreInstanceState [androidJvm] open fun dispatchRestoreInstanceState (p0: SparseArray < Parcelable >) dispatchSaveInstanceState [androidJvm] open fun dispatchSaveInstanceState (p0: SparseArray < Parcelable >) dispatchScrollCaptureSearch [androidJvm] open fun dispatchScrollCaptureSearch (p0: Rect , p1: Point , p2: Consumer < ScrollCaptureTarget >) dispatchSetActivated [androidJvm] open fun dispatchSetActivated (p0: Boolean ) dispatchSetPressed [androidJvm] open fun dispatchSetPressed (p0: Boolean ) dispatchSetSelected [androidJvm] open fun dispatchSetSelected (p0: Boolean ) dispatchStartTemporaryDetach [androidJvm] open fun dispatchStartTemporaryDetach () dispatchTouchEvent [androidJvm] open fun dispatchTouchEvent (p0: MotionEvent ): Boolean dispatchTrackballEvent [androidJvm] open fun dispatchTrackballEvent (p0: MotionEvent ): Boolean dispatchUnhandledMove [androidJvm] open fun dispatchUnhandledMove (p0: View , p1: Int ): Boolean dispatchVisibilityChanged [androidJvm] open fun dispatchVisibilityChanged (p0: View , p1: Int ) dispatchWindowFocusChanged [androidJvm] open fun dispatchWindowFocusChanged (p0: Boolean ) dispatchWindowInsetsAnimationEnd [androidJvm] open fun dispatchWindowInsetsAnimationEnd (p0: WindowInsetsAnimation ) dispatchWindowInsetsAnimationPrepare [androidJvm] open fun dispatchWindowInsetsAnimationPrepare (p0: WindowInsetsAnimation ) dispatchWindowInsetsAnimationProgress [androidJvm] open fun dispatchWindowInsetsAnimationProgress (p0: WindowInsets , p1: MutableList < WindowInsetsAnimation >): WindowInsets dispatchWindowInsetsAnimationStart [androidJvm] open fun dispatchWindowInsetsAnimationStart (p0: WindowInsetsAnimation , p1: WindowInsetsAnimation.Bounds ): WindowInsetsAnimation.Bounds dispatchWindowVisibilityChanged [androidJvm] open fun dispatchWindowVisibilityChanged (p0: Int ) draw [androidJvm] open fun draw (p0: Canvas ) drawableHotspotChanged [androidJvm] open fun drawableHotspotChanged (p0: Float , p1: Float ) drawableStateChanged [androidJvm] open fun drawableStateChanged () findFocus [androidJvm] open fun findFocus (): View findViewById [androidJvm] fun < T : View > findViewById (p0: Int ): T findViewsWithText [androidJvm] open fun findViewsWithText (p0: ArrayList < View >, p1: CharSequence , p2: Int ) findViewWithTag [androidJvm] fun < T : View > findViewWithTag (p0: Any ): T focusSearch [androidJvm] open fun focusSearch (p0: Int ): View forceHasOverlappingRendering [androidJvm] open fun forceHasOverlappingRendering (p0: Boolean ) forceLayout [androidJvm] open fun forceLayout () gatherTransparentRegion [androidJvm] open fun gatherTransparentRegion (p0: Region ?): Boolean generateDisplayHash [androidJvm] open fun generateDisplayHash (p0: String , p1: Rect ?, p2: Executor , p3: DisplayHashResultCallback ) getAccessibilityClassName [androidJvm] open fun getAccessibilityClassName (): CharSequence getAccessibilityDelegate [androidJvm] open fun getAccessibilityDelegate (): View.AccessibilityDelegate getAccessibilityLiveRegion [androidJvm] open fun getAccessibilityLiveRegion (): Int getAccessibilityNodeProvider [androidJvm] open fun getAccessibilityNodeProvider (): AccessibilityNodeProvider getAccessibilityPaneTitle [androidJvm] open fun getAccessibilityPaneTitle (): CharSequence ? getAccessibilityTraversalAfter [androidJvm] open fun getAccessibilityTraversalAfter (): Int getAccessibilityTraversalBefore [androidJvm] open fun getAccessibilityTraversalBefore (): Int getAlpha [androidJvm] open fun getAlpha (): Float getAnimation [androidJvm] open fun getAnimation (): Animation getAnimationMatrix [androidJvm] open fun getAnimationMatrix (): Matrix ? getApplicationWindowToken [androidJvm] open fun getApplicationWindowToken (): IBinder getAttributeResolutionStack [androidJvm] open fun getAttributeResolutionStack (p0: Int ): IntArray getAttributeSourceResourceMap [androidJvm] open fun getAttributeSourceResourceMap (): MutableMap < Int , Int > getAutofillHints [androidJvm] open fun getAutofillHints (): Array < String >? getAutofillId [androidJvm] fun getAutofillId (): AutofillId getAutofillType [androidJvm] open fun getAutofillType (): Int getAutofillValue [androidJvm] open fun getAutofillValue (): AutofillValue ? getBackground [androidJvm] open fun getBackground (): Drawable getBackgroundTintBlendMode [androidJvm] open fun getBackgroundTintBlendMode (): BlendMode ? getBackgroundTintList [androidJvm] open fun getBackgroundTintList (): ColorStateList ? getBackgroundTintMode [androidJvm] open fun getBackgroundTintMode (): PorterDuff.Mode ? getBaseline [androidJvm] open fun getBaseline (): Int getBottom [androidJvm] fun getBottom (): Int getBottomFadingEdgeStrength [androidJvm] open fun getBottomFadingEdgeStrength (): Float getBottomPaddingOffset [androidJvm] open fun getBottomPaddingOffset (): Int getCameraDistance [androidJvm] open fun getCameraDistance (): Float getClipBounds [androidJvm] open fun getClipBounds (): Rect open fun getClipBounds (p0: Rect ): Boolean getClipToOutline [androidJvm] fun getClipToOutline (): Boolean getContentCaptureSession [androidJvm] fun getContentCaptureSession (): ContentCaptureSession ? getContentDescription [androidJvm] open fun getContentDescription (): CharSequence getContext [androidJvm] fun getContext (): Context getContextMenuInfo [androidJvm] open fun getContextMenuInfo (): ContextMenu.ContextMenuInfo getDefaultFocusHighlightEnabled [androidJvm] fun getDefaultFocusHighlightEnabled (): Boolean getDisplay [androidJvm] open fun getDisplay (): Display getDrawableState [androidJvm] fun getDrawableState (): IntArray getDrawingRect [androidJvm] open fun getDrawingRect (p0: Rect ) getDrawingTime [androidJvm] open fun getDrawingTime (): Long getElevation [androidJvm] open fun getElevation (): Float getExplicitStyle [androidJvm] open fun getExplicitStyle (): Int getFilterTouchesWhenObscured [androidJvm] open fun getFilterTouchesWhenObscured (): Boolean getFitsSystemWindows [androidJvm] open fun getFitsSystemWindows (): Boolean getFocusable [androidJvm] open fun getFocusable (): Int getFocusables [androidJvm] open fun getFocusables (p0: Int ): ArrayList < View > getFocusedRect [androidJvm] open fun getFocusedRect (p0: Rect ) getForeground [androidJvm] open fun getForeground (): Drawable getForegroundGravity [androidJvm] open fun getForegroundGravity (): Int getForegroundTintBlendMode [androidJvm] open fun getForegroundTintBlendMode (): BlendMode ? getForegroundTintList [androidJvm] open fun getForegroundTintList (): ColorStateList ? getForegroundTintMode [androidJvm] open fun getForegroundTintMode (): PorterDuff.Mode ? getGlobalVisibleRect [androidJvm] fun getGlobalVisibleRect (p0: Rect ): Boolean open fun getGlobalVisibleRect (p0: Rect , p1: Point ): Boolean getHandler [androidJvm] open fun getHandler (): Handler getHasOverlappingRendering [androidJvm] fun getHasOverlappingRendering (): Boolean getHeight [androidJvm] fun getHeight (): Int getHitRect [androidJvm] open fun getHitRect (p0: Rect ) getHorizontalFadingEdgeLength [androidJvm] open fun getHorizontalFadingEdgeLength (): Int getHorizontalScrollbarHeight [androidJvm] open fun getHorizontalScrollbarHeight (): Int getHorizontalScrollbarThumbDrawable [androidJvm] open fun getHorizontalScrollbarThumbDrawable (): Drawable ? getHorizontalScrollbarTrackDrawable [androidJvm] open fun getHorizontalScrollbarTrackDrawable (): Drawable ? getId [androidJvm] open fun getId (): Int getImportantForAccessibility [androidJvm] open fun getImportantForAccessibility (): Int getImportantForAutofill [androidJvm] open fun getImportantForAutofill (): Int getImportantForContentCapture [androidJvm] open fun getImportantForContentCapture (): Int getKeepScreenOn [androidJvm] open fun getKeepScreenOn (): Boolean getKeyDispatcherState [androidJvm] open fun getKeyDispatcherState (): KeyEvent.DispatcherState getLabelFor [androidJvm] open fun getLabelFor (): Int getLayerType [androidJvm] open fun getLayerType (): Int getLayoutDirection [androidJvm] open fun getLayoutDirection (): Int getLayoutParams [androidJvm] open fun getLayoutParams (): ViewGroup.LayoutParams getLeft [androidJvm] fun getLeft (): Int getLeftFadingEdgeStrength [androidJvm] open fun getLeftFadingEdgeStrength (): Float getLeftPaddingOffset [androidJvm] open fun getLeftPaddingOffset (): Int getLocalVisibleRect [androidJvm] fun getLocalVisibleRect (p0: Rect ): Boolean getLocationInSurface [androidJvm] open fun getLocationInSurface (p0: IntArray ) getLocationInWindow [androidJvm] open fun getLocationInWindow (p0: IntArray ) getLocationOnScreen [androidJvm] open fun getLocationOnScreen (p0: IntArray ) getMatrix [androidJvm] open fun getMatrix (): Matrix getMeasuredHeight [androidJvm] fun getMeasuredHeight (): Int getMeasuredHeightAndState [androidJvm] fun getMeasuredHeightAndState (): Int getMeasuredState [androidJvm] fun getMeasuredState (): Int getMeasuredWidth [androidJvm] fun getMeasuredWidth (): Int getMeasuredWidthAndState [androidJvm] fun getMeasuredWidthAndState (): Int getMinimumHeight [androidJvm] open fun getMinimumHeight (): Int getMinimumWidth [androidJvm] open fun getMinimumWidth (): Int getNextClusterForwardId [androidJvm] open fun getNextClusterForwardId (): Int getNextFocusDownId [androidJvm] open fun getNextFocusDownId (): Int getNextFocusForwardId [androidJvm] open fun getNextFocusForwardId (): Int getNextFocusLeftId [androidJvm] open fun getNextFocusLeftId (): Int getNextFocusRightId [androidJvm] open fun getNextFocusRightId (): Int getNextFocusUpId [androidJvm] open fun getNextFocusUpId (): Int getOnFocusChangeListener [androidJvm] open fun getOnFocusChangeListener (): View.OnFocusChangeListener getOutlineAmbientShadowColor [androidJvm] open fun getOutlineAmbientShadowColor (): Int getOutlineProvider [androidJvm] open fun getOutlineProvider (): ViewOutlineProvider getOutlineSpotShadowColor [androidJvm] open fun getOutlineSpotShadowColor (): Int getOverlay [androidJvm] open fun getOverlay (): ViewOverlay getOverScrollMode [androidJvm] open fun getOverScrollMode (): Int getPaddingBottom [androidJvm] open fun getPaddingBottom (): Int getPaddingEnd [androidJvm] open fun getPaddingEnd (): Int getPaddingLeft [androidJvm] open fun getPaddingLeft (): Int getPaddingRight [androidJvm] open fun getPaddingRight (): Int getPaddingStart [androidJvm] open fun getPaddingStart (): Int getPaddingTop [androidJvm] open fun getPaddingTop (): Int getParent [androidJvm] fun getParent (): ViewParent getParentForAccessibility [androidJvm] open fun getParentForAccessibility (): ViewParent getPivotX [androidJvm] open fun getPivotX (): Float getPivotY [androidJvm] open fun getPivotY (): Float getPointerIcon [androidJvm] open fun getPointerIcon (): PointerIcon getReceiveContentMimeTypes [androidJvm] open fun getReceiveContentMimeTypes (): Array < String >? getResources [androidJvm] open fun getResources (): Resources getRevealOnFocusHint [androidJvm] fun getRevealOnFocusHint (): Boolean getRight [androidJvm] fun getRight (): Int getRightFadingEdgeStrength [androidJvm] open fun getRightFadingEdgeStrength (): Float getRightPaddingOffset [androidJvm] open fun getRightPaddingOffset (): Int getRootSurfaceControl [androidJvm] open fun getRootSurfaceControl (): AttachedSurfaceControl ? getRootView [androidJvm] open fun getRootView (): View getRootWindowInsets [androidJvm] open fun getRootWindowInsets (): WindowInsets getRotation [androidJvm] open fun getRotation (): Float getRotationX [androidJvm] open fun getRotationX (): Float getRotationY [androidJvm] open fun getRotationY (): Float getScaleX [androidJvm] open fun getScaleX (): Float getScaleY [androidJvm] open fun getScaleY (): Float getScrollBarDefaultDelayBeforeFade [androidJvm] open fun getScrollBarDefaultDelayBeforeFade (): Int getScrollBarFadeDuration [androidJvm] open fun getScrollBarFadeDuration (): Int getScrollBarSize [androidJvm] open fun getScrollBarSize (): Int getScrollBarStyle [androidJvm] open fun getScrollBarStyle (): Int getScrollCaptureHint [androidJvm] open fun getScrollCaptureHint (): Int getScrollIndicators [androidJvm] open fun getScrollIndicators (): Int getScrollX [androidJvm] fun getScrollX (): Int getScrollY [androidJvm] fun getScrollY (): Int getSolidColor [androidJvm] open fun getSolidColor (): Int getSourceLayoutResId [androidJvm] open fun getSourceLayoutResId (): Int getStateDescription [androidJvm] fun getStateDescription (): CharSequence ? getStateListAnimator [androidJvm] open fun getStateListAnimator (): StateListAnimator getSuggestedMinimumHeight [androidJvm] open fun getSuggestedMinimumHeight (): Int getSuggestedMinimumWidth [androidJvm] open fun getSuggestedMinimumWidth (): Int getSystemGestureExclusionRects [androidJvm] open fun getSystemGestureExclusionRects (): MutableList < Rect > getTag [androidJvm] open fun getTag (): Any open fun getTag (p0: Int ): Any getTextAlignment [androidJvm] open fun getTextAlignment (): Int getTextDirection [androidJvm] open fun getTextDirection (): Int getTooltipText [androidJvm] open fun getTooltipText (): CharSequence ? getTop [androidJvm] fun getTop (): Int getTopFadingEdgeStrength [androidJvm] open fun getTopFadingEdgeStrength (): Float getTopPaddingOffset [androidJvm] open fun getTopPaddingOffset (): Int getTouchables [androidJvm] open fun getTouchables (): ArrayList < View > getTouchDelegate [androidJvm] open fun getTouchDelegate (): TouchDelegate getTransitionAlpha [androidJvm] open fun getTransitionAlpha (): Float getTransitionName [androidJvm] open fun getTransitionName (): String getTranslationX [androidJvm] open fun getTranslationX (): Float getTranslationY [androidJvm] open fun getTranslationY (): Float getTranslationZ [androidJvm] open fun getTranslationZ (): Float getUniqueDrawingId [androidJvm] open fun getUniqueDrawingId (): Long getVerticalFadingEdgeLength [androidJvm] open fun getVerticalFadingEdgeLength (): Int getVerticalScrollbarPosition [androidJvm] open fun getVerticalScrollbarPosition (): Int getVerticalScrollbarThumbDrawable [androidJvm] open fun getVerticalScrollbarThumbDrawable (): Drawable ? getVerticalScrollbarTrackDrawable [androidJvm] open fun getVerticalScrollbarTrackDrawable (): Drawable ? getVerticalScrollbarWidth [androidJvm] open fun getVerticalScrollbarWidth (): Int getViewTranslationResponse [androidJvm] open fun getViewTranslationResponse (): ViewTranslationResponse ? getViewTreeObserver [androidJvm] open fun getViewTreeObserver (): ViewTreeObserver getVisibility [androidJvm] open override fun getVisibility (): Int Returns the visibility of actual . (Bear in mind that the initial value of actual is this stub.) getWidth [androidJvm] fun getWidth (): Int getWindowAttachCount [androidJvm] open fun getWindowAttachCount (): Int getWindowId [androidJvm] open fun getWindowId (): WindowId getWindowInsetsController [androidJvm] open fun getWindowInsetsController (): WindowInsetsController ? getWindowToken [androidJvm] open fun getWindowToken (): IBinder getWindowVisibility [androidJvm] open fun getWindowVisibility (): Int getWindowVisibleDisplayFrame [androidJvm] open fun getWindowVisibleDisplayFrame (p0: Rect ) getX [androidJvm] open fun getX (): Float getY [androidJvm] open fun getY (): Float getZ [androidJvm] open fun getZ (): Float hasExplicitFocusable [androidJvm] open fun hasExplicitFocusable (): Boolean hasFocus [androidJvm] open fun hasFocus (): Boolean hasFocusable [androidJvm] open fun hasFocusable (): Boolean hasNestedScrollingParent [androidJvm] open fun hasNestedScrollingParent (): Boolean hasOnClickListeners [androidJvm] open fun hasOnClickListeners (): Boolean hasOnLongClickListeners [androidJvm] open fun hasOnLongClickListeners (): Boolean hasOverlappingRendering [androidJvm] open fun hasOverlappingRendering (): Boolean hasPointerCapture [androidJvm] open fun hasPointerCapture (): Boolean hasTransientState [androidJvm] open fun hasTransientState (): Boolean hasWindowFocus [androidJvm] open fun hasWindowFocus (): Boolean invalidate [androidJvm] open fun invalidate () invalidateDrawable [androidJvm] open override fun invalidateDrawable (p0: Drawable ) invalidateOutline [androidJvm] open fun invalidateOutline () isAccessibilityFocused [androidJvm] open fun isAccessibilityFocused (): Boolean isAccessibilityHeading [androidJvm] open fun isAccessibilityHeading (): Boolean isActivated [androidJvm] open fun isActivated (): Boolean isAttachedToWindow [androidJvm] open fun isAttachedToWindow (): Boolean isClickable [androidJvm] open fun isClickable (): Boolean isContextClickable [androidJvm] open fun isContextClickable (): Boolean isDirty [androidJvm] open fun isDirty (): Boolean isDuplicateParentStateEnabled [androidJvm] open fun isDuplicateParentStateEnabled (): Boolean isEnabled [androidJvm] open fun isEnabled (): Boolean isFocusable [androidJvm] fun isFocusable (): Boolean isFocusableInTouchMode [androidJvm] fun isFocusableInTouchMode (): Boolean isFocused [androidJvm] open fun isFocused (): Boolean isFocusedByDefault [androidJvm] fun isFocusedByDefault (): Boolean isForceDarkAllowed [androidJvm] open fun isForceDarkAllowed (): Boolean isHapticFeedbackEnabled [androidJvm] open fun isHapticFeedbackEnabled (): Boolean isHardwareAccelerated [androidJvm] open fun isHardwareAccelerated (): Boolean isHorizontalFadingEdgeEnabled [androidJvm] open fun isHorizontalFadingEdgeEnabled (): Boolean isHorizontalScrollBarEnabled [androidJvm] open fun isHorizontalScrollBarEnabled (): Boolean isHovered [androidJvm] open fun isHovered (): Boolean isImportantForAccessibility [androidJvm] open fun isImportantForAccessibility (): Boolean isImportantForAutofill [androidJvm] fun isImportantForAutofill (): Boolean isImportantForContentCapture [androidJvm] fun isImportantForContentCapture (): Boolean isInEditMode [androidJvm] open fun isInEditMode (): Boolean isInLayout [androidJvm] open fun isInLayout (): Boolean isInTouchMode [androidJvm] open fun isInTouchMode (): Boolean isKeyboardNavigationCluster [androidJvm] fun isKeyboardNavigationCluster (): Boolean isLaidOut [androidJvm] open fun isLaidOut (): Boolean isLayoutDirectionResolved [androidJvm] open fun isLayoutDirectionResolved (): Boolean isLayoutRequested [androidJvm] open fun isLayoutRequested (): Boolean isLongClickable [androidJvm] open fun isLongClickable (): Boolean isNestedScrollingEnabled [androidJvm] open fun isNestedScrollingEnabled (): Boolean isOpaque [androidJvm] open fun isOpaque (): Boolean isPaddingOffsetRequired [androidJvm] open fun isPaddingOffsetRequired (): Boolean isPaddingRelative [androidJvm] open fun isPaddingRelative (): Boolean isPivotSet [androidJvm] open fun isPivotSet (): Boolean isPressed [androidJvm] open fun isPressed (): Boolean isSaveEnabled [androidJvm] open fun isSaveEnabled (): Boolean isSaveFromParentEnabled [androidJvm] open fun isSaveFromParentEnabled (): Boolean isScreenReaderFocusable [androidJvm] open fun isScreenReaderFocusable (): Boolean isScrollbarFadingEnabled [androidJvm] open fun isScrollbarFadingEnabled (): Boolean isScrollContainer [androidJvm] open fun isScrollContainer (): Boolean isSelected [androidJvm] open fun isSelected (): Boolean isShowingLayoutBounds [androidJvm] fun isShowingLayoutBounds (): Boolean isShown [androidJvm] open fun isShown (): Boolean isSoundEffectsEnabled [androidJvm] open fun isSoundEffectsEnabled (): Boolean isTemporarilyDetached [androidJvm] fun isTemporarilyDetached (): Boolean isTextAlignmentResolved [androidJvm] open fun isTextAlignmentResolved (): Boolean isTextDirectionResolved [androidJvm] open fun isTextDirectionResolved (): Boolean isVerticalFadingEdgeEnabled [androidJvm] open fun isVerticalFadingEdgeEnabled (): Boolean isVerticalScrollBarEnabled [androidJvm] open fun isVerticalScrollBarEnabled (): Boolean isVisibleToUserForAutofill [androidJvm] open fun isVisibleToUserForAutofill (p0: Int ): Boolean jumpDrawablesToCurrentState [androidJvm] open fun jumpDrawablesToCurrentState () keyboardNavigationClusterSearch [androidJvm] open fun keyboardNavigationClusterSearch (p0: View , p1: Int ): View layout [androidJvm] open fun layout (p0: Int , p1: Int , p2: Int , p3: Int ) measure [androidJvm] fun measure (p0: Int , p1: Int ) offsetLeftAndRight [androidJvm] open fun offsetLeftAndRight (p0: Int ) offsetTopAndBottom [androidJvm] open fun offsetTopAndBottom (p0: Int ) onAnimationEnd [androidJvm] open fun onAnimationEnd () onAnimationStart [androidJvm] open fun onAnimationStart () onApplyWindowInsets [androidJvm] open fun onApplyWindowInsets (p0: WindowInsets ): WindowInsets onAttachedToWindow [androidJvm] open fun onAttachedToWindow () onCancelPendingInputEvents [androidJvm] open fun onCancelPendingInputEvents () onCapturedPointerEvent [androidJvm] open fun onCapturedPointerEvent (p0: MotionEvent ): Boolean onCheckIsTextEditor [androidJvm] open fun onCheckIsTextEditor (): Boolean onConfigurationChanged [androidJvm] open fun onConfigurationChanged (p0: Configuration ) onCreateContextMenu [androidJvm] open fun onCreateContextMenu (p0: ContextMenu ) onCreateDrawableState [androidJvm] open fun onCreateDrawableState (p0: Int ): IntArray onCreateInputConnection [androidJvm] open fun onCreateInputConnection (p0: EditorInfo ): InputConnection onCreateViewTranslationRequest [androidJvm] open fun onCreateViewTranslationRequest (p0: IntArray , p1: Consumer < ViewTranslationRequest >) onCreateVirtualViewTranslationRequests [androidJvm] open fun onCreateVirtualViewTranslationRequests (p0: LongArray , p1: IntArray , p2: Consumer < ViewTranslationRequest >) onDetachedFromWindow [androidJvm] open fun onDetachedFromWindow () onDisplayHint [androidJvm] open fun onDisplayHint (p0: Int ) onDragEvent [androidJvm] open fun onDragEvent (p0: DragEvent ): Boolean onDraw [androidJvm] open fun onDraw (p0: Canvas ) onDrawForeground [androidJvm] open fun onDrawForeground (p0: Canvas ) onDrawScrollBars [androidJvm] fun onDrawScrollBars (p0: Canvas ) onFilterTouchEventForSecurity [androidJvm] open fun onFilterTouchEventForSecurity (p0: MotionEvent ): Boolean onFinishInflate [androidJvm] open fun onFinishInflate () onFinishTemporaryDetach [androidJvm] open fun onFinishTemporaryDetach () onFocusChanged [androidJvm] open fun onFocusChanged (p0: Boolean , p1: Int , p2: Rect ?) onGenericMotionEvent [androidJvm] open fun onGenericMotionEvent (p0: MotionEvent ): Boolean onHoverChanged [androidJvm] open fun onHoverChanged (p0: Boolean ) onHoverEvent [androidJvm] open fun onHoverEvent (p0: MotionEvent ): Boolean onInitializeAccessibilityEvent [androidJvm] open fun onInitializeAccessibilityEvent (p0: AccessibilityEvent ) onInitializeAccessibilityNodeInfo [androidJvm] open fun onInitializeAccessibilityNodeInfo (p0: AccessibilityNodeInfo ) onKeyDown [androidJvm] open override fun onKeyDown (p0: Int , p1: KeyEvent ): Boolean onKeyLongPress [androidJvm] open override fun onKeyLongPress (p0: Int , p1: KeyEvent ): Boolean onKeyMultiple [androidJvm] open override fun onKeyMultiple (p0: Int , p1: Int , p2: KeyEvent ): Boolean onKeyPreIme [androidJvm] open fun onKeyPreIme (p0: Int , p1: KeyEvent ): Boolean onKeyShortcut [androidJvm] open fun onKeyShortcut (p0: Int , p1: KeyEvent ): Boolean onKeyUp [androidJvm] open override fun onKeyUp (p0: Int , p1: KeyEvent ): Boolean onLayout [androidJvm] open fun onLayout (p0: Boolean , p1: Int , p2: Int , p3: Int , p4: Int ) onMeasure [androidJvm] open fun onMeasure (p0: Int , p1: Int ) onOverScrolled [androidJvm] open fun onOverScrolled (p0: Int , p1: Int , p2: Boolean , p3: Boolean ) onPointerCaptureChange [androidJvm] open fun onPointerCaptureChange (p0: Boolean ) onPopulateAccessibilityEvent [androidJvm] open fun onPopulateAccessibilityEvent (p0: AccessibilityEvent ) onProvideAutofillStructure [androidJvm] open fun onProvideAutofillStructure (p0: ViewStructure , p1: Int ) onProvideAutofillVirtualStructure [androidJvm] open fun onProvideAutofillVirtualStructure (p0: ViewStructure , p1: Int ) onProvideContentCaptureStructure [androidJvm] open fun onProvideContentCaptureStructure (p0: ViewStructure , p1: Int ) onProvideStructure [androidJvm] open fun onProvideStructure (p0: ViewStructure ) onProvideVirtualStructure [androidJvm] open fun onProvideVirtualStructure (p0: ViewStructure ) onReceiveContent [androidJvm] open fun onReceiveContent (p0: ContentInfo ): ContentInfo ? onResolvePointerIcon [androidJvm] open fun onResolvePointerIcon (p0: MotionEvent , p1: Int ): PointerIcon onRestoreInstanceState [androidJvm] open fun onRestoreInstanceState (p0: Parcelable ) onRtlPropertiesChanged [androidJvm] open fun onRtlPropertiesChanged (p0: Int ) onSaveInstanceState [androidJvm] open fun onSaveInstanceState (): Parcelable ? onScreenStateChanged [androidJvm] open fun onScreenStateChanged (p0: Int ) onScrollCaptureSearch [androidJvm] open fun onScrollCaptureSearch (p0: Rect , p1: Point , p2: Consumer < ScrollCaptureTarget >) onScrollChanged [androidJvm] open fun onScrollChanged (p0: Int , p1: Int , p2: Int , p3: Int ) onSetAlpha [androidJvm] open fun onSetAlpha (p0: Int ): Boolean onSizeChanged [androidJvm] open fun onSizeChanged (p0: Int , p1: Int , p2: Int , p3: Int ) onStartTemporaryDetach [androidJvm] open fun onStartTemporaryDetach () onTouchEvent [androidJvm] open fun onTouchEvent (p0: MotionEvent ): Boolean onTrackballEvent [androidJvm] open fun onTrackballEvent (p0: MotionEvent ): Boolean onViewTranslationResponse [androidJvm] open fun onViewTranslationResponse (p0: ViewTranslationResponse ) onVirtualViewTranslationResponses [androidJvm] open fun onVirtualViewTranslationResponses (p0: LongSparseArray < ViewTranslationResponse >) onVisibilityAggregated [androidJvm] open fun onVisibilityAggregated (p0: Boolean ) onVisibilityChanged [androidJvm] open fun onVisibilityChanged (p0: View , p1: Int ) onWindowFocusChanged [androidJvm] open fun onWindowFocusChanged (p0: Boolean ) onWindowVisibilityChanged [androidJvm] open fun onWindowVisibilityChanged (p0: Int ) overScrollBy [androidJvm] open fun overScrollBy (p0: Int , p1: Int , p2: Int , p3: Int , p4: Int , p5: Int , p6: Int , p7: Int , p8: Boolean ): Boolean performAccessibilityAction [androidJvm] open fun performAccessibilityAction (p0: Int , p1: Bundle ): Boolean performClick [androidJvm] open fun performClick (): Boolean performContextClick [androidJvm] open fun performContextClick (): Boolean open fun performContextClick (p0: Float , p1: Float ): Boolean performHapticFeedback [androidJvm] open fun performHapticFeedback (p0: Int ): Boolean open fun performHapticFeedback (p0: Int , p1: Int ): Boolean performLongClick [androidJvm] open fun performLongClick (): Boolean open fun performLongClick (p0: Float , p1: Float ): Boolean performReceiveContent [androidJvm] open fun performReceiveContent (p0: ContentInfo ): ContentInfo ? playSoundEffect [androidJvm] open fun playSoundEffect (p0: Int ) post [androidJvm] open fun post (p0: Runnable ): Boolean postDelayed [androidJvm] open fun postDelayed (p0: Runnable , p1: Long ): Boolean postInvalidate [androidJvm] open fun postInvalidate () open fun postInvalidate (p0: Int , p1: Int , p2: Int , p3: Int ) postInvalidateDelayed [androidJvm] open fun postInvalidateDelayed (p0: Long ) open fun postInvalidateDelayed (p0: Long , p1: Int , p2: Int , p3: Int , p4: Int ) postInvalidateOnAnimation [androidJvm] open fun postInvalidateOnAnimation () open fun postInvalidateOnAnimation (p0: Int , p1: Int , p2: Int , p3: Int ) postOnAnimation [androidJvm] open fun postOnAnimation (p0: Runnable ) postOnAnimationDelayed [androidJvm] open fun postOnAnimationDelayed (p0: Runnable , p1: Long ) refreshDrawableState [androidJvm] open fun refreshDrawableState () releasePointerCapture [androidJvm] open fun releasePointerCapture () removeCallbacks [androidJvm] open fun removeCallbacks (p0: Runnable ): Boolean removeOnAttachStateChangeListener [androidJvm] open fun removeOnAttachStateChangeListener (p0: View.OnAttachStateChangeListener ) removeOnLayoutChangeListener [androidJvm] open fun removeOnLayoutChangeListener (p0: View.OnLayoutChangeListener ) removeOnUnhandledKeyEventListener [androidJvm] open fun removeOnUnhandledKeyEventListener (p0: View.OnUnhandledKeyEventListener ) requestApplyInsets [androidJvm] open fun requestApplyInsets () requestFocus [androidJvm] fun requestFocus (): Boolean fun requestFocus (p0: Int ): Boolean open fun requestFocus (p0: Int , p1: Rect ): Boolean requestFocusFromTouch [androidJvm] fun requestFocusFromTouch (): Boolean requestLayout [androidJvm] open fun requestLayout () requestPointerCapture [androidJvm] open fun requestPointerCapture () requestRectangleOnScreen [androidJvm] open fun requestRectangleOnScreen (p0: Rect ): Boolean open fun requestRectangleOnScreen (p0: Rect , p1: Boolean ): Boolean requestUnbufferedDispatch [androidJvm] fun requestUnbufferedDispatch (p0: MotionEvent ) fun requestUnbufferedDispatch (p0: Int ) requireViewById [androidJvm] fun < T : View > requireViewById (p0: Int ): T resetPivot [androidJvm] open fun resetPivot () restoreDefaultFocus [androidJvm] open fun restoreDefaultFocus (): Boolean restoreHierarchyState [androidJvm] open fun restoreHierarchyState (p0: SparseArray < Parcelable >) saveAttributeDataForStyleable [androidJvm] fun saveAttributeDataForStyleable (p0: Context , p1: IntArray , p2: AttributeSet ?, p3: TypedArray , p4: Int , p5: Int ) saveHierarchyState [androidJvm] open fun saveHierarchyState (p0: SparseArray < Parcelable >) scheduleDrawable [androidJvm] open override fun scheduleDrawable (p0: Drawable , p1: Runnable , p2: Long ) scrollBy [androidJvm] open fun scrollBy (p0: Int , p1: Int ) scrollTo [androidJvm] open fun scrollTo (p0: Int , p1: Int ) sendAccessibilityEvent [androidJvm] open override fun sendAccessibilityEvent (p0: Int ) sendAccessibilityEventUnchecked [androidJvm] open override fun sendAccessibilityEventUnchecked (p0: AccessibilityEvent ) setAccessibilityDelegate [androidJvm] open fun setAccessibilityDelegate (p0: View.AccessibilityDelegate ?) setAccessibilityHeading [androidJvm] open fun setAccessibilityHeading (p0: Boolean ) setAccessibilityLiveRegion [androidJvm] open fun setAccessibilityLiveRegion (p0: Int ) setAccessibilityPaneTitle [androidJvm] open fun setAccessibilityPaneTitle (p0: CharSequence ?) setAccessibilityTraversalAfter [androidJvm] open fun setAccessibilityTraversalAfter (p0: Int ) setAccessibilityTraversalBefore [androidJvm] open fun setAccessibilityTraversalBefore (p0: Int ) setActivated [androidJvm] open fun setActivated (p0: Boolean ) setAllowClickWhenDisabled [androidJvm] open fun setAllowClickWhenDisabled (p0: Boolean ) setAlpha [androidJvm] open fun setAlpha (p0: Float ) setAnimation [androidJvm] open fun setAnimation (p0: Animation ) setAnimationMatrix [androidJvm] open fun setAnimationMatrix (p0: Matrix ?) setAutofillHints [androidJvm] open fun setAutofillHints (vararg p0: String ) setAutofillId [androidJvm] open fun setAutofillId (p0: AutofillId ?) setBackground [androidJvm] open override fun setBackground (background: Drawable ?) Sets the background of this stub as usual, and also that of actual if the given background is not null. Any new views created by update will be assigned this background, again if it is not null. setBackgroundColor [androidJvm] open fun setBackgroundColor (p0: Int ) setBackgroundResource [androidJvm] open fun setBackgroundResource (p0: Int ) setBackgroundTintBlendMode [androidJvm] open fun setBackgroundTintBlendMode (p0: BlendMode ?) setBackgroundTintList [androidJvm] open fun setBackgroundTintList (p0: ColorStateList ?) setBackgroundTintMode [androidJvm] open fun setBackgroundTintMode (p0: PorterDuff.Mode ?) setBottom [androidJvm] fun setBottom (p0: Int ) setCameraDistance [androidJvm] open fun setCameraDistance (p0: Float ) setClickable [androidJvm] open fun setClickable (p0: Boolean ) setClipBounds [androidJvm] open fun setClipBounds (p0: Rect ) setClipToOutline [androidJvm] open fun setClipToOutline (p0: Boolean ) setContentCaptureSession [androidJvm] open fun setContentCaptureSession (p0: ContentCaptureSession ?) setContentDescription [androidJvm] open fun setContentDescription (p0: CharSequence ) setContextClickable [androidJvm] open fun setContextClickable (p0: Boolean ) setDefaultFocusHighlightEnabled [androidJvm] open fun setDefaultFocusHighlightEnabled (p0: Boolean ) setDuplicateParentStateEnabled [androidJvm] open fun setDuplicateParentStateEnabled (p0: Boolean ) setElevation [androidJvm] open fun setElevation (p0: Float ) setEnabled [androidJvm] open fun setEnabled (p0: Boolean ) setFadingEdgeLength [androidJvm] open fun setFadingEdgeLength (p0: Int ) setFilterTouchesWhenObscured [androidJvm] open fun setFilterTouchesWhenObscured (p0: Boolean ) setFitsSystemWindows [androidJvm] open fun setFitsSystemWindows (p0: Boolean ) setFocusable [androidJvm] open fun setFocusable (p0: Boolean ) open fun setFocusable (p0: Int ) setFocusableInTouchMode [androidJvm] open fun setFocusableInTouchMode (p0: Boolean ) setFocusedByDefault [androidJvm] open fun setFocusedByDefault (p0: Boolean ) setForceDarkAllowed [androidJvm] open fun setForceDarkAllowed (p0: Boolean ) setForeground [androidJvm] open fun setForeground (p0: Drawable ) setForegroundGravity [androidJvm] open fun setForegroundGravity (p0: Int ) setForegroundTintBlendMode [androidJvm] open fun setForegroundTintBlendMode (p0: BlendMode ?) setForegroundTintList [androidJvm] open fun setForegroundTintList (p0: ColorStateList ?) setForegroundTintMode [androidJvm] open fun setForegroundTintMode (p0: PorterDuff.Mode ?) setHapticFeedbackEnabled [androidJvm] open fun setHapticFeedbackEnabled (p0: Boolean ) setHasTransientState [androidJvm] open fun setHasTransientState (p0: Boolean ) setHorizontalFadingEdgeEnabled [androidJvm] open fun setHorizontalFadingEdgeEnabled (p0: Boolean ) setHorizontalScrollBarEnabled [androidJvm] open fun setHorizontalScrollBarEnabled (p0: Boolean ) setHorizontalScrollbarThumbDrawable [androidJvm] open fun setHorizontalScrollbarThumbDrawable (p0: Drawable ?) setHorizontalScrollbarTrackDrawable [androidJvm] open fun setHorizontalScrollbarTrackDrawable (p0: Drawable ?) setHovered [androidJvm] open fun setHovered (p0: Boolean ) setId [androidJvm] open override fun setId (@ IdRes id: Int ) setImportantForAccessibility [androidJvm] open fun setImportantForAccessibility (p0: Int ) setImportantForAutofill [androidJvm] open fun setImportantForAutofill (p0: Int ) setImportantForContentCapture [androidJvm] open fun setImportantForContentCapture (p0: Int ) setKeepScreenOn [androidJvm] open fun setKeepScreenOn (p0: Boolean ) setKeyboardNavigationCluster [androidJvm] open fun setKeyboardNavigationCluster (p0: Boolean ) setLabelFor [androidJvm] open fun setLabelFor (p0: Int ) setLayerPaint [androidJvm] open fun setLayerPaint (p0: Paint ?) setLayerType [androidJvm] open fun setLayerType (p0: Int , p1: Paint ?) setLayoutDirection [androidJvm] open fun setLayoutDirection (p0: Int ) setLayoutParams [androidJvm] open fun setLayoutParams (p0: ViewGroup.LayoutParams ) setLeft [androidJvm] fun setLeft (p0: Int ) setLeftTopRightBottom [androidJvm] fun setLeftTopRightBottom (p0: Int , p1: Int , p2: Int , p3: Int ) setLongClickable [androidJvm] open fun setLongClickable (p0: Boolean ) setMeasuredDimension [androidJvm] fun setMeasuredDimension (p0: Int , p1: Int ) setMinimumHeight [androidJvm] open fun setMinimumHeight (p0: Int ) setMinimumWidth [androidJvm] open fun setMinimumWidth (p0: Int ) setNestedScrollingEnabled [androidJvm] open fun setNestedScrollingEnabled (p0: Boolean ) setNextClusterForwardId [androidJvm] open fun setNextClusterForwardId (p0: Int ) setNextFocusDownId [androidJvm] open fun setNextFocusDownId (p0: Int ) setNextFocusForwardId [androidJvm] open fun setNextFocusForwardId (p0: Int ) setNextFocusLeftId [androidJvm] open fun setNextFocusLeftId (p0: Int ) setNextFocusRightId [androidJvm] open fun setNextFocusRightId (p0: Int ) setNextFocusUpId [androidJvm] open fun setNextFocusUpId (p0: Int ) setOnApplyWindowInsetsListener [androidJvm] open fun setOnApplyWindowInsetsListener (p0: View.OnApplyWindowInsetsListener ) setOnCapturedPointerListener [androidJvm] open fun setOnCapturedPointerListener (p0: View.OnCapturedPointerListener ) setOnClickListener [androidJvm] open fun setOnClickListener (p0: View.OnClickListener ?) setOnContextClickListener [androidJvm] open fun setOnContextClickListener (p0: View.OnContextClickListener ?) setOnCreateContextMenuListener [androidJvm] open fun setOnCreateContextMenuListener (p0: View.OnCreateContextMenuListener ) setOnDragListener [androidJvm] open fun setOnDragListener (p0: View.OnDragListener ) setOnFocusChangeListener [androidJvm] open fun setOnFocusChangeListener (p0: View.OnFocusChangeListener ) setOnGenericMotionListener [androidJvm] open fun setOnGenericMotionListener (p0: View.OnGenericMotionListener ) setOnHoverListener [androidJvm] open fun setOnHoverListener (p0: View.OnHoverListener ) setOnKeyListener [androidJvm] open fun setOnKeyListener (p0: View.OnKeyListener ) setOnLongClickListener [androidJvm] open fun setOnLongClickListener (p0: View.OnLongClickListener ?) setOnReceiveContentListener [androidJvm] open fun setOnReceiveContentListener (p0: Array < String >?, p1: OnReceiveContentListener ?) setOnScrollChangeListener [androidJvm] open fun setOnScrollChangeListener (p0: View.OnScrollChangeListener ) setOnTouchListener [androidJvm] open fun setOnTouchListener (p0: View.OnTouchListener ) setOutlineAmbientShadowColor [androidJvm] open fun setOutlineAmbientShadowColor (p0: Int ) setOutlineProvider [androidJvm] open fun setOutlineProvider (p0: ViewOutlineProvider ) setOutlineSpotShadowColor [androidJvm] open fun setOutlineSpotShadowColor (p0: Int ) setOverScrollMode [androidJvm] open fun setOverScrollMode (p0: Int ) setPadding [androidJvm] open fun setPadding (p0: Int , p1: Int , p2: Int , p3: Int ) setPaddingRelative [androidJvm] open fun setPaddingRelative (p0: Int , p1: Int , p2: Int , p3: Int ) setPivotX [androidJvm] open fun setPivotX (p0: Float ) setPivotY [androidJvm] open fun setPivotY (p0: Float ) setPointerIcon [androidJvm] open fun setPointerIcon (p0: PointerIcon ) setPressed [androidJvm] open fun setPressed (p0: Boolean ) setRenderEffect [androidJvm] open fun setRenderEffect (p0: RenderEffect ?) setRevealOnFocusHint [androidJvm] fun setRevealOnFocusHint (p0: Boolean ) setRight [androidJvm] fun setRight (p0: Int ) setRotation [androidJvm] open fun setRotation (p0: Float ) setRotationX [androidJvm] open fun setRotationX (p0: Float ) setRotationY [androidJvm] open fun setRotationY (p0: Float ) setSaveEnabled [androidJvm] open fun setSaveEnabled (p0: Boolean ) setSaveFromParentEnabled [androidJvm] open fun setSaveFromParentEnabled (p0: Boolean ) setScaleX [androidJvm] open fun setScaleX (p0: Float ) setScaleY [androidJvm] open fun setScaleY (p0: Float ) setScreenReaderFocusable [androidJvm] open fun setScreenReaderFocusable (p0: Boolean ) setScrollBarDefaultDelayBeforeFade [androidJvm] open fun setScrollBarDefaultDelayBeforeFade (p0: Int ) setScrollBarFadeDuration [androidJvm] open fun setScrollBarFadeDuration (p0: Int ) setScrollbarFadingEnabled [androidJvm] open fun setScrollbarFadingEnabled (p0: Boolean ) setScrollBarSize [androidJvm] open fun setScrollBarSize (p0: Int ) setScrollBarStyle [androidJvm] open fun setScrollBarStyle (p0: Int ) setScrollCaptureCallback [androidJvm] fun setScrollCaptureCallback (p0: ScrollCaptureCallback ?) setScrollCaptureHint [androidJvm] open fun setScrollCaptureHint (p0: Int ) setScrollContainer [androidJvm] open fun setScrollContainer (p0: Boolean ) setScrollIndicators [androidJvm] open fun setScrollIndicators (p0: Int ) open fun setScrollIndicators (p0: Int , p1: Int ) setScrollX [androidJvm] open fun setScrollX (p0: Int ) setScrollY [androidJvm] open fun setScrollY (p0: Int ) setSelected [androidJvm] open fun setSelected (p0: Boolean ) setSoundEffectsEnabled [androidJvm] open fun setSoundEffectsEnabled (p0: Boolean ) setStateDescription [androidJvm] open fun setStateDescription (p0: CharSequence ?) setStateListAnimator [androidJvm] open fun setStateListAnimator (p0: StateListAnimator ) setSystemGestureExclusionRects [androidJvm] open fun setSystemGestureExclusionRects (p0: MutableList < Rect >) setTag [androidJvm] open fun setTag (p0: Any ) open fun setTag (p0: Int , p1: Any ) setTextAlignment [androidJvm] open fun setTextAlignment (p0: Int ) setTextDirection [androidJvm] open fun setTextDirection (p0: Int ) setTooltipText [androidJvm] open fun setTooltipText (p0: CharSequence ?) setTop [androidJvm] fun setTop (p0: Int ) setTouchDelegate [androidJvm] open fun setTouchDelegate (p0: TouchDelegate ) setTransitionAlpha [androidJvm] open fun setTransitionAlpha (p0: Float ) setTransitionName [androidJvm] fun setTransitionName (p0: String ) setTransitionVisibility [androidJvm] open fun setTransitionVisibility (p0: Int ) setTranslationX [androidJvm] open fun setTranslationX (p0: Float ) setTranslationY [androidJvm] open fun setTranslationY (p0: Float ) setTranslationZ [androidJvm] open fun setTranslationZ (p0: Float ) setVerticalFadingEdgeEnabled [androidJvm] open fun setVerticalFadingEdgeEnabled (p0: Boolean ) setVerticalScrollBarEnabled [androidJvm] open fun setVerticalScrollBarEnabled (p0: Boolean ) setVerticalScrollbarPosition [androidJvm] open fun setVerticalScrollbarPosition (p0: Int ) setVerticalScrollbarThumbDrawable [androidJvm] open fun setVerticalScrollbarThumbDrawable (p0: Drawable ?) setVerticalScrollbarTrackDrawable [androidJvm] open fun setVerticalScrollbarTrackDrawable (p0: Drawable ?) setViewTranslationCallback [androidJvm] open fun setViewTranslationCallback (p0: ViewTranslationCallback ) setVisibility [androidJvm] open override fun setVisibility (visibility: Int ) Sets the visibility of actual . If updatesVisibility is true, the visibility of new views created by update will copied from actual . (Bear in mind that the initial value of actual is this stub.) setWillNotDraw [androidJvm] open fun setWillNotDraw (p0: Boolean ) setWindowInsetsAnimationCallback [androidJvm] open fun setWindowInsetsAnimationCallback (p0: WindowInsetsAnimation.Callback ?) setX [androidJvm] open fun setX (p0: Float ) setY [androidJvm] open fun setY (p0: Float ) setZ [androidJvm] open fun setZ (p0: Float ) showContextMenu [androidJvm] open fun showContextMenu (): Boolean open fun showContextMenu (p0: Float , p1: Float ): Boolean startActionMode [androidJvm] open fun startActionMode (p0: ActionMode.Callback ): ActionMode open fun startActionMode (p0: ActionMode.Callback , p1: Int ): ActionMode startAnimation [androidJvm] open fun startAnimation (p0: Animation ) startDragAndDrop [androidJvm] fun startDragAndDrop (p0: ClipData , p1: View.DragShadowBuilder , p2: Any , p3: Int ): Boolean startNestedScroll [androidJvm] open fun startNestedScroll (p0: Int ): Boolean stopNestedScroll [androidJvm] open fun stopNestedScroll () toString [androidJvm] open override fun toString (): String transformMatrixToGlobal [androidJvm] open fun transformMatrixToGlobal (p0: Matrix ) transformMatrixToLocal [androidJvm] open fun transformMatrixToLocal (p0: Matrix ) unscheduleDrawable [androidJvm] open fun unscheduleDrawable (p0: Drawable ) open override fun unscheduleDrawable (p0: Drawable , p1: Runnable ) update [androidJvm] fun update (rendering: Any , viewEnvironment: ViewEnvironment ): View Replaces this view with one that can display rendering . If the receiver has already been replaced, updates the replacement if it canShowRendering . If the current replacement can\u2019t handle rendering , a new view is put in its place. updateDragShadow [androidJvm] fun updateDragShadow (p0: View.DragShadowBuilder ) verifyDrawable [androidJvm] open fun verifyDrawable (p0: Drawable ): Boolean willNotDraw [androidJvm] open fun willNotDraw (): Boolean","title":"Functions"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-workflow-view-stub/#properties","text":"Name Summary actual [androidJvm] var actual : View On-demand access to the view created by the last call to update , or this WorkflowViewStub instance if none has yet been made. inflatedId [androidJvm] @ IdRes var inflatedId : Int The id to be assigned to new views created by update . If the inflated id is View.NO_ID (its default value), new views keep their original ids. replaceOldViewInParent [androidJvm] var replaceOldViewInParent : ( ViewGroup , View ) -> Unit Function called from update to replace this stub, or the current actual , with a new view. Can be updated to provide custom transition effects. updatesVisibility [androidJvm] var updatesVisibility : Boolean = true If true, the visibility of views created by update will be copied from that of actual . Bear in mind that the initial value of actual is this stub.","title":"Properties"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-workflow-view-stub/-workflow-view-stub/","text":"// workflow / com.squareup.workflow1.ui / WorkflowViewStub / WorkflowViewStub WorkflowViewStub \u00b6 [androidJvm]\\ @ JvmOverloads fun WorkflowViewStub (context: Context , attributeSet: AttributeSet ? = null, defStyle: Int = 0, defStyleRes: Int = 0)","title":" workflow view stub"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-workflow-view-stub/-workflow-view-stub/#workflowviewstub","text":"[androidJvm]\\ @ JvmOverloads fun WorkflowViewStub (context: Context , attributeSet: AttributeSet ? = null, defStyle: Int = 0, defStyleRes: Int = 0)","title":"WorkflowViewStub"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-workflow-view-stub/actual/","text":"// workflow / com.squareup.workflow1.ui / WorkflowViewStub / actual actual \u00b6 [androidJvm]\\ var actual : View On-demand access to the view created by the last call to update , or this WorkflowViewStub instance if none has yet been made.","title":"Actual"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-workflow-view-stub/actual/#actual","text":"[androidJvm]\\ var actual : View On-demand access to the view created by the last call to update , or this WorkflowViewStub instance if none has yet been made.","title":"actual"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-workflow-view-stub/get-visibility/","text":"// workflow / com.squareup.workflow1.ui / WorkflowViewStub / getVisibility getVisibility \u00b6 [androidJvm]\\ open override fun getVisibility (): Int Returns the visibility of actual . (Bear in mind that the initial value of actual is this stub.)","title":"Get visibility"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-workflow-view-stub/get-visibility/#getvisibility","text":"[androidJvm]\\ open override fun getVisibility (): Int Returns the visibility of actual . (Bear in mind that the initial value of actual is this stub.)","title":"getVisibility"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-workflow-view-stub/inflated-id/","text":"// workflow / com.squareup.workflow1.ui / WorkflowViewStub / inflatedId inflatedId \u00b6 [androidJvm]\\ @ IdRes var inflatedId : Int The id to be assigned to new views created by update . If the inflated id is View.NO_ID (its default value), new views keep their original ids.","title":"Inflated id"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-workflow-view-stub/inflated-id/#inflatedid","text":"[androidJvm]\\ @ IdRes var inflatedId : Int The id to be assigned to new views created by update . If the inflated id is View.NO_ID (its default value), new views keep their original ids.","title":"inflatedId"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-workflow-view-stub/replace-old-view-in-parent/","text":"// workflow / com.squareup.workflow1.ui / WorkflowViewStub / replaceOldViewInParent replaceOldViewInParent \u00b6 [androidJvm]\\ var replaceOldViewInParent : ( ViewGroup , View ) -> Unit Function called from update to replace this stub, or the current actual , with a new view. Can be updated to provide custom transition effects. Note that this method is responsible for copying the layoutParams from the stub to the new view. Also note that in a WorkflowViewStub that has never been updated, actual is the stub itself.","title":"Replace old view in parent"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-workflow-view-stub/replace-old-view-in-parent/#replaceoldviewinparent","text":"[androidJvm]\\ var replaceOldViewInParent : ( ViewGroup , View ) -> Unit Function called from update to replace this stub, or the current actual , with a new view. Can be updated to provide custom transition effects. Note that this method is responsible for copying the layoutParams from the stub to the new view. Also note that in a WorkflowViewStub that has never been updated, actual is the stub itself.","title":"replaceOldViewInParent"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-workflow-view-stub/set-background/","text":"// workflow / com.squareup.workflow1.ui / WorkflowViewStub / setBackground setBackground \u00b6 [androidJvm]\\ open override fun setBackground (background: Drawable ?) Sets the background of this stub as usual, and also that of actual if the given background is not null. Any new views created by update will be assigned this background, again if it is not null.","title":"Set background"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-workflow-view-stub/set-background/#setbackground","text":"[androidJvm]\\ open override fun setBackground (background: Drawable ?) Sets the background of this stub as usual, and also that of actual if the given background is not null. Any new views created by update will be assigned this background, again if it is not null.","title":"setBackground"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-workflow-view-stub/set-id/","text":"// workflow / com.squareup.workflow1.ui / WorkflowViewStub / setId setId \u00b6 [androidJvm]\\ open override fun setId (@ IdRes id: Int )","title":"Set id"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-workflow-view-stub/set-id/#setid","text":"[androidJvm]\\ open override fun setId (@ IdRes id: Int )","title":"setId"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-workflow-view-stub/set-visibility/","text":"// workflow / com.squareup.workflow1.ui / WorkflowViewStub / setVisibility setVisibility \u00b6 [androidJvm]\\ open override fun setVisibility (visibility: Int ) Sets the visibility of actual . If updatesVisibility is true, the visibility of new views created by update will copied from actual . (Bear in mind that the initial value of actual is this stub.)","title":"Set visibility"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-workflow-view-stub/set-visibility/#setvisibility","text":"[androidJvm]\\ open override fun setVisibility (visibility: Int ) Sets the visibility of actual . If updatesVisibility is true, the visibility of new views created by update will copied from actual . (Bear in mind that the initial value of actual is this stub.)","title":"setVisibility"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-workflow-view-stub/update/","text":"// workflow / com.squareup.workflow1.ui / WorkflowViewStub / update update \u00b6 [androidJvm]\\ fun update (rendering: Any , viewEnvironment: ViewEnvironment ): View Replaces this view with one that can display rendering . If the receiver has already been replaced, updates the replacement if it canShowRendering . If the current replacement can\u2019t handle rendering , a new view is put in its place. The id of any view created by this method will be set to to inflatedId , unless that value is View.NO_ID . The background of any view created by this method will be copied from getBackground, if that value is non-null. If updatesVisibility is true, the visibility of any view created by this method will be copied from actual . (Bear in mind that the initial value of actual is this stub.) Return \u00b6 the view that showed rendering Throws \u00b6 kotlin.IllegalArgumentException if no binding can be find for the type of rendering kotlin.IllegalStateException if the matching ViewFactory fails to call View.bindShowRendering when constructing the view","title":"Update"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-workflow-view-stub/update/#update","text":"[androidJvm]\\ fun update (rendering: Any , viewEnvironment: ViewEnvironment ): View Replaces this view with one that can display rendering . If the receiver has already been replaced, updates the replacement if it canShowRendering . If the current replacement can\u2019t handle rendering , a new view is put in its place. The id of any view created by this method will be set to to inflatedId , unless that value is View.NO_ID . The background of any view created by this method will be copied from getBackground, if that value is non-null. If updatesVisibility is true, the visibility of any view created by this method will be copied from actual . (Bear in mind that the initial value of actual is this stub.)","title":"update"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-workflow-view-stub/update/#return","text":"the view that showed rendering","title":"Return"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-workflow-view-stub/update/#throws","text":"kotlin.IllegalArgumentException if no binding can be find for the type of rendering kotlin.IllegalStateException if the matching ViewFactory fails to call View.bindShowRendering when constructing the view","title":"Throws"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-workflow-view-stub/updates-visibility/","text":"// workflow / com.squareup.workflow1.ui / WorkflowViewStub / updatesVisibility updatesVisibility \u00b6 [androidJvm]\\ var updatesVisibility : Boolean = true If true, the visibility of views created by update will be copied from that of actual . Bear in mind that the initial value of actual is this stub.","title":"Updates visibility"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui/-workflow-view-stub/updates-visibility/#updatesvisibility","text":"[androidJvm]\\ var updatesVisibility : Boolean = true If true, the visibility of views created by update will be copied from that of actual . Bear in mind that the initial value of actual is this stub.","title":"updatesVisibility"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.androidx/","text":"// workflow / com.squareup.workflow1.ui.androidx Package com.squareup.workflow1.ui.androidx \u00b6 Types \u00b6 Name Summary WorkflowAndroidXSupport [androidJvm] object WorkflowAndroidXSupport Namespace for some helper functions for interacting with the AndroidX libraries. WorkflowLifecycleOwner [androidJvm] @WorkflowUiExperimentalApi interface WorkflowLifecycleOwner : LifecycleOwner An extension of LifecycleOwner that is always owned by a View , is logically a child lifecycle of the next-nearest ViewTreeLifecycleOwner above it (it mirrors its parent\u2019s lifecycle until it\u2019s destroyed), and can be asked to destroy itself early.","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.androidx/#package-comsquareupworkflow1uiandroidx","text":"","title":"Package com.squareup.workflow1.ui.androidx"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.androidx/#types","text":"Name Summary WorkflowAndroidXSupport [androidJvm] object WorkflowAndroidXSupport Namespace for some helper functions for interacting with the AndroidX libraries. WorkflowLifecycleOwner [androidJvm] @WorkflowUiExperimentalApi interface WorkflowLifecycleOwner : LifecycleOwner An extension of LifecycleOwner that is always owned by a View , is logically a child lifecycle of the next-nearest ViewTreeLifecycleOwner above it (it mirrors its parent\u2019s lifecycle until it\u2019s destroyed), and can be asked to destroy itself early.","title":"Types"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.androidx/-workflow-android-x-support/","text":"// workflow / com.squareup.workflow1.ui.androidx / WorkflowAndroidXSupport WorkflowAndroidXSupport \u00b6 [androidJvm]\\ object WorkflowAndroidXSupport Namespace for some helper functions for interacting with the AndroidX libraries. Functions \u00b6 Name Summary lifecycleOwnerFromViewTreeOrContext [androidJvm] @WorkflowUiExperimentalApi fun lifecycleOwnerFromViewTreeOrContext (view: View ): LifecycleOwner ? Tries to get the parent lifecycle from the current view via ViewTreeLifecycleOwner , if that fails it looks up the context chain for a LifecycleOwner , and if that fails it just returns null. This differs from ViewTreeLifecycleOwner.get because it will check the View.getContext if no owner is found in the view tree. stateRegistryOwnerFromViewTreeOrContext [androidJvm] @WorkflowUiExperimentalApi fun stateRegistryOwnerFromViewTreeOrContext (view: View ): SavedStateRegistryOwner ? Tries to get the parent SavedStateRegistryOwner from the current view via ViewTreeSavedStateRegistryOwner , if that fails it looks up the context chain for a registry owner, and if that fails it just returns null. This differs from ViewTreeSavedStateRegistryOwner.get because it will check the View.getContext if no owner is found in the view tree.","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.androidx/-workflow-android-x-support/#workflowandroidxsupport","text":"[androidJvm]\\ object WorkflowAndroidXSupport Namespace for some helper functions for interacting with the AndroidX libraries.","title":"WorkflowAndroidXSupport"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.androidx/-workflow-android-x-support/#functions","text":"Name Summary lifecycleOwnerFromViewTreeOrContext [androidJvm] @WorkflowUiExperimentalApi fun lifecycleOwnerFromViewTreeOrContext (view: View ): LifecycleOwner ? Tries to get the parent lifecycle from the current view via ViewTreeLifecycleOwner , if that fails it looks up the context chain for a LifecycleOwner , and if that fails it just returns null. This differs from ViewTreeLifecycleOwner.get because it will check the View.getContext if no owner is found in the view tree. stateRegistryOwnerFromViewTreeOrContext [androidJvm] @WorkflowUiExperimentalApi fun stateRegistryOwnerFromViewTreeOrContext (view: View ): SavedStateRegistryOwner ? Tries to get the parent SavedStateRegistryOwner from the current view via ViewTreeSavedStateRegistryOwner , if that fails it looks up the context chain for a registry owner, and if that fails it just returns null. This differs from ViewTreeSavedStateRegistryOwner.get because it will check the View.getContext if no owner is found in the view tree.","title":"Functions"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.androidx/-workflow-android-x-support/lifecycle-owner-from-view-tree-or-context/","text":"// workflow / com.squareup.workflow1.ui.androidx / WorkflowAndroidXSupport / lifecycleOwnerFromViewTreeOrContext lifecycleOwnerFromViewTreeOrContext \u00b6 [androidJvm]\\ @WorkflowUiExperimentalApi fun lifecycleOwnerFromViewTreeOrContext (view: View ): LifecycleOwner ? Tries to get the parent lifecycle from the current view via ViewTreeLifecycleOwner , if that fails it looks up the context chain for a LifecycleOwner , and if that fails it just returns null. This differs from ViewTreeLifecycleOwner.get because it will check the View.getContext if no owner is found in the view tree.","title":"Lifecycle owner from view tree or context"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.androidx/-workflow-android-x-support/lifecycle-owner-from-view-tree-or-context/#lifecycleownerfromviewtreeorcontext","text":"[androidJvm]\\ @WorkflowUiExperimentalApi fun lifecycleOwnerFromViewTreeOrContext (view: View ): LifecycleOwner ? Tries to get the parent lifecycle from the current view via ViewTreeLifecycleOwner , if that fails it looks up the context chain for a LifecycleOwner , and if that fails it just returns null. This differs from ViewTreeLifecycleOwner.get because it will check the View.getContext if no owner is found in the view tree.","title":"lifecycleOwnerFromViewTreeOrContext"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.androidx/-workflow-android-x-support/state-registry-owner-from-view-tree-or-context/","text":"// workflow / com.squareup.workflow1.ui.androidx / WorkflowAndroidXSupport / stateRegistryOwnerFromViewTreeOrContext stateRegistryOwnerFromViewTreeOrContext \u00b6 [androidJvm]\\ @WorkflowUiExperimentalApi fun stateRegistryOwnerFromViewTreeOrContext (view: View ): SavedStateRegistryOwner ? Tries to get the parent SavedStateRegistryOwner from the current view via ViewTreeSavedStateRegistryOwner , if that fails it looks up the context chain for a registry owner, and if that fails it just returns null. This differs from ViewTreeSavedStateRegistryOwner.get because it will check the View.getContext if no owner is found in the view tree.","title":"State registry owner from view tree or context"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.androidx/-workflow-android-x-support/state-registry-owner-from-view-tree-or-context/#stateregistryownerfromviewtreeorcontext","text":"[androidJvm]\\ @WorkflowUiExperimentalApi fun stateRegistryOwnerFromViewTreeOrContext (view: View ): SavedStateRegistryOwner ? Tries to get the parent SavedStateRegistryOwner from the current view via ViewTreeSavedStateRegistryOwner , if that fails it looks up the context chain for a registry owner, and if that fails it just returns null. This differs from ViewTreeSavedStateRegistryOwner.get because it will check the View.getContext if no owner is found in the view tree.","title":"stateRegistryOwnerFromViewTreeOrContext"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.androidx/-workflow-lifecycle-owner/","text":"// workflow / com.squareup.workflow1.ui.androidx / WorkflowLifecycleOwner WorkflowLifecycleOwner \u00b6 [androidJvm]\\ @WorkflowUiExperimentalApi interface WorkflowLifecycleOwner : LifecycleOwner An extension of LifecycleOwner that is always owned by a View , is logically a child lifecycle of the next-nearest ViewTreeLifecycleOwner above it (it mirrors its parent\u2019s lifecycle until it\u2019s destroyed), and can be asked to destroy itself early. This type is meant to help integrate with ViewTreeLifecycleOwner by allowing the creation of a tree of LifecycleOwner s that mirrors the view tree. Custom container views that use ViewRegistry.buildView to create their children must ensure they call destroyOnDetach on the outgoing view before they replace children with new views. If this is not done, then certain processes that are started by that view\u2019s subtree may continue to run long after the view has been detached, and memory and other resources may be leaked. Note that WorkflowViewStub takes care of this chore itself. Set a WorkflowLifecycleOwner on a view by calling installOn , and read it back using get . Types \u00b6 Name Summary Companion [androidJvm] object Companion Functions \u00b6 Name Summary destroyOnDetach [androidJvm] abstract fun destroyOnDetach () If the owning view is attached, flags this lifecycle to be set to DESTROYED as soon as the owning view is detached . If the view is not attached (either because it\u2019s never been attached, or because it was attached and then detached), then it will destroy the lifecycle immediately. getLifecycle [androidJvm] @ NonNull abstract fun getLifecycle (): Lifecycle","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.androidx/-workflow-lifecycle-owner/#workflowlifecycleowner","text":"[androidJvm]\\ @WorkflowUiExperimentalApi interface WorkflowLifecycleOwner : LifecycleOwner An extension of LifecycleOwner that is always owned by a View , is logically a child lifecycle of the next-nearest ViewTreeLifecycleOwner above it (it mirrors its parent\u2019s lifecycle until it\u2019s destroyed), and can be asked to destroy itself early. This type is meant to help integrate with ViewTreeLifecycleOwner by allowing the creation of a tree of LifecycleOwner s that mirrors the view tree. Custom container views that use ViewRegistry.buildView to create their children must ensure they call destroyOnDetach on the outgoing view before they replace children with new views. If this is not done, then certain processes that are started by that view\u2019s subtree may continue to run long after the view has been detached, and memory and other resources may be leaked. Note that WorkflowViewStub takes care of this chore itself. Set a WorkflowLifecycleOwner on a view by calling installOn , and read it back using get .","title":"WorkflowLifecycleOwner"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.androidx/-workflow-lifecycle-owner/#types","text":"Name Summary Companion [androidJvm] object Companion","title":"Types"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.androidx/-workflow-lifecycle-owner/#functions","text":"Name Summary destroyOnDetach [androidJvm] abstract fun destroyOnDetach () If the owning view is attached, flags this lifecycle to be set to DESTROYED as soon as the owning view is detached . If the view is not attached (either because it\u2019s never been attached, or because it was attached and then detached), then it will destroy the lifecycle immediately. getLifecycle [androidJvm] @ NonNull abstract fun getLifecycle (): Lifecycle","title":"Functions"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.androidx/-workflow-lifecycle-owner/destroy-on-detach/","text":"// workflow / com.squareup.workflow1.ui.androidx / WorkflowLifecycleOwner / destroyOnDetach destroyOnDetach \u00b6 [androidJvm]\\ abstract fun destroyOnDetach () If the owning view is attached, flags this lifecycle to be set to DESTROYED as soon as the owning view is detached . If the view is not attached (either because it\u2019s never been attached, or because it was attached and then detached), then it will destroy the lifecycle immediately.","title":"Destroy on detach"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.androidx/-workflow-lifecycle-owner/destroy-on-detach/#destroyondetach","text":"[androidJvm]\\ abstract fun destroyOnDetach () If the owning view is attached, flags this lifecycle to be set to DESTROYED as soon as the owning view is detached . If the view is not attached (either because it\u2019s never been attached, or because it was attached and then detached), then it will destroy the lifecycle immediately.","title":"destroyOnDetach"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.androidx/-workflow-lifecycle-owner/-companion/","text":"// workflow / com.squareup.workflow1.ui.androidx / WorkflowLifecycleOwner / Companion Companion \u00b6 [androidJvm]\\ object Companion Functions \u00b6 Name Summary get [androidJvm] fun get (view: View ): WorkflowLifecycleOwner ? Looks for the nearest ViewTreeLifecycleOwner on view and returns it if it\u2019s an instance of WorkflowLifecycleOwner . Convenience function for retrieving the owner set by installOn . installOn [androidJvm] fun installOn (view: View , findParentLifecycle: ( View ) -> Lifecycle ? = { v -> findParentViewTreeLifecycle(v) }) Creates a new WorkflowLifecycleOwner and sets it on view \u2018s tags so it can be later retrieved with get .","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.androidx/-workflow-lifecycle-owner/-companion/#companion","text":"[androidJvm]\\ object Companion","title":"Companion"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.androidx/-workflow-lifecycle-owner/-companion/#functions","text":"Name Summary get [androidJvm] fun get (view: View ): WorkflowLifecycleOwner ? Looks for the nearest ViewTreeLifecycleOwner on view and returns it if it\u2019s an instance of WorkflowLifecycleOwner . Convenience function for retrieving the owner set by installOn . installOn [androidJvm] fun installOn (view: View , findParentLifecycle: ( View ) -> Lifecycle ? = { v -> findParentViewTreeLifecycle(v) }) Creates a new WorkflowLifecycleOwner and sets it on view \u2018s tags so it can be later retrieved with get .","title":"Functions"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.androidx/-workflow-lifecycle-owner/-companion/get/","text":"// workflow / com.squareup.workflow1.ui.androidx / WorkflowLifecycleOwner / Companion / get get \u00b6 [androidJvm]\\ fun get (view: View ): WorkflowLifecycleOwner ? Looks for the nearest ViewTreeLifecycleOwner on view and returns it if it\u2019s an instance of WorkflowLifecycleOwner . Convenience function for retrieving the owner set by installOn .","title":"Get"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.androidx/-workflow-lifecycle-owner/-companion/get/#get","text":"[androidJvm]\\ fun get (view: View ): WorkflowLifecycleOwner ? Looks for the nearest ViewTreeLifecycleOwner on view and returns it if it\u2019s an instance of WorkflowLifecycleOwner . Convenience function for retrieving the owner set by installOn .","title":"get"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.androidx/-workflow-lifecycle-owner/-companion/install-on/","text":"// workflow / com.squareup.workflow1.ui.androidx / WorkflowLifecycleOwner / Companion / installOn installOn \u00b6 [androidJvm]\\ fun installOn (view: View , findParentLifecycle: ( View ) -> Lifecycle ? = { v -> findParentViewTreeLifecycle(v) }) Creates a new WorkflowLifecycleOwner and sets it on view \u2018s tags so it can be later retrieved with get . It\u2019s very important that, once this function is called with a given view, that EITHER: The view gets attached at least once to ensure that the lifecycle eventually gets destroyed (because its parent is destroyed), or Someone eventually calls [destroyOnDetach](../destroy-on-detach.md), which will either schedule the lifecycle to destroyed if the view is attached, or destroy it immediately if it's detached. If this is not done, any observers registered with the Lifecycle may be leaked as they will never see the destroy event. Parameters \u00b6 androidJvm findParentLifecycle A function that is called whenever view is attached, and should return the Lifecycle to use as the parent lifecycle. If not specified, defaults to looking up the view tree by calling ViewTreeLifecycleOwner.get on view \u2018s parent, and if none is found, then looking up view \u2018s context wrapper chain for something that implements LifecycleOwner . This only needs to be passed if view will be used as the root of a new view hierarchy, e.g. for a new dialog. If no parent lifecycle is found, then the lifecycle will become RESUMED when it\u2019s attached for the first time, and stay in that state until it is re-attached with a non-null parent or destroyOnDetach is called.","title":"Install on"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.androidx/-workflow-lifecycle-owner/-companion/install-on/#installon","text":"[androidJvm]\\ fun installOn (view: View , findParentLifecycle: ( View ) -> Lifecycle ? = { v -> findParentViewTreeLifecycle(v) }) Creates a new WorkflowLifecycleOwner and sets it on view \u2018s tags so it can be later retrieved with get . It\u2019s very important that, once this function is called with a given view, that EITHER: The view gets attached at least once to ensure that the lifecycle eventually gets destroyed (because its parent is destroyed), or Someone eventually calls [destroyOnDetach](../destroy-on-detach.md), which will either schedule the lifecycle to destroyed if the view is attached, or destroy it immediately if it's detached. If this is not done, any observers registered with the Lifecycle may be leaked as they will never see the destroy event.","title":"installOn"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.androidx/-workflow-lifecycle-owner/-companion/install-on/#parameters","text":"androidJvm findParentLifecycle A function that is called whenever view is attached, and should return the Lifecycle to use as the parent lifecycle. If not specified, defaults to looking up the view tree by calling ViewTreeLifecycleOwner.get on view \u2018s parent, and if none is found, then looking up view \u2018s context wrapper chain for something that implements LifecycleOwner . This only needs to be passed if view will be used as the root of a new view hierarchy, e.g. for a new dialog. If no parent lifecycle is found, then the lifecycle will become RESUMED when it\u2019s attached for the first time, and stay in that state until it is re-attached with a non-null parent or destroyOnDetach is called.","title":"Parameters"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/","text":"// workflow / com.squareup.workflow1.ui.backstack Package com.squareup.workflow1.ui.backstack \u00b6 Types \u00b6 Name Summary BackStackConfig [androidJvm] @WorkflowUiExperimentalApi enum BackStackConfig : Enum < BackStackConfig > Informs views whether they\u2019re children of a BackStackContainer , and if so whether they\u2019re the first frame or not . BackStackContainer [androidJvm] @WorkflowUiExperimentalApi open class BackStackContainer @ JvmOverloads constructor(context: Context , attributeSet: AttributeSet ?, defStyle: Int , defStyleRes: Int ) : FrameLayout A container view that can display a stream of BackStackScreen instances. BackStackScreen [jvm] @ WorkflowUiExperimentalApi class BackStackScreen < StackedT : Any >(bottom: StackedT , rest: List < StackedT >) Represents an active screen ( top ), and a set of previously visited screens to which we may return ( backStack ). By rendering the entire history we allow the UI to do things like maintain cached view state, implement drag-back gestures without waiting for the workflow, etc. ViewStateCache [androidJvm] @WorkflowUiExperimentalApi class ViewStateCache : Parcelable Handles persistence chores for container views that manage a set of Named renderings, showing a view for one at a time \u2013 think back stacks or tab sets. Functions \u00b6 Name Summary toBackStackScreen [jvm] @ WorkflowUiExperimentalApi fun < T : Any > List < T >. toBackStackScreen (): BackStackScreen < T > toBackStackScreenOrNull [jvm] @ WorkflowUiExperimentalApi fun < T : Any > List < T >. toBackStackScreenOrNull (): BackStackScreen < T >? withBackStackStateKeyPrefix [androidJvm] fun ViewEnvironment . withBackStackStateKeyPrefix (prefix: String ): ViewEnvironment Sets a disambiguation prefix used by BackStackContainer when managing androidx.savedstate.SavedStateRegistryOwner . Allows parent containers to use multiple BackStackContainer instances at once.","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/#package-comsquareupworkflow1uibackstack","text":"","title":"Package com.squareup.workflow1.ui.backstack"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/#types","text":"Name Summary BackStackConfig [androidJvm] @WorkflowUiExperimentalApi enum BackStackConfig : Enum < BackStackConfig > Informs views whether they\u2019re children of a BackStackContainer , and if so whether they\u2019re the first frame or not . BackStackContainer [androidJvm] @WorkflowUiExperimentalApi open class BackStackContainer @ JvmOverloads constructor(context: Context , attributeSet: AttributeSet ?, defStyle: Int , defStyleRes: Int ) : FrameLayout A container view that can display a stream of BackStackScreen instances. BackStackScreen [jvm] @ WorkflowUiExperimentalApi class BackStackScreen < StackedT : Any >(bottom: StackedT , rest: List < StackedT >) Represents an active screen ( top ), and a set of previously visited screens to which we may return ( backStack ). By rendering the entire history we allow the UI to do things like maintain cached view state, implement drag-back gestures without waiting for the workflow, etc. ViewStateCache [androidJvm] @WorkflowUiExperimentalApi class ViewStateCache : Parcelable Handles persistence chores for container views that manage a set of Named renderings, showing a view for one at a time \u2013 think back stacks or tab sets.","title":"Types"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/#functions","text":"Name Summary toBackStackScreen [jvm] @ WorkflowUiExperimentalApi fun < T : Any > List < T >. toBackStackScreen (): BackStackScreen < T > toBackStackScreenOrNull [jvm] @ WorkflowUiExperimentalApi fun < T : Any > List < T >. toBackStackScreenOrNull (): BackStackScreen < T >? withBackStackStateKeyPrefix [androidJvm] fun ViewEnvironment . withBackStackStateKeyPrefix (prefix: String ): ViewEnvironment Sets a disambiguation prefix used by BackStackContainer when managing androidx.savedstate.SavedStateRegistryOwner . Allows parent containers to use multiple BackStackContainer instances at once.","title":"Functions"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/to-back-stack-screen-or-null/","text":"// workflow / com.squareup.workflow1.ui.backstack / toBackStackScreenOrNull toBackStackScreenOrNull \u00b6 [jvm]\\ @ WorkflowUiExperimentalApi fun < T : Any > List < T >. toBackStackScreenOrNull (): BackStackScreen < T >?","title":"To back stack screen or null"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/to-back-stack-screen-or-null/#tobackstackscreenornull","text":"[jvm]\\ @ WorkflowUiExperimentalApi fun < T : Any > List < T >. toBackStackScreenOrNull (): BackStackScreen < T >?","title":"toBackStackScreenOrNull"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/to-back-stack-screen/","text":"// workflow / com.squareup.workflow1.ui.backstack / toBackStackScreen toBackStackScreen \u00b6 [jvm]\\ @ WorkflowUiExperimentalApi fun < T : Any > List < T >. toBackStackScreen (): BackStackScreen < T >","title":"To back stack screen"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/to-back-stack-screen/#tobackstackscreen","text":"[jvm]\\ @ WorkflowUiExperimentalApi fun < T : Any > List < T >. toBackStackScreen (): BackStackScreen < T >","title":"toBackStackScreen"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/with-back-stack-state-key-prefix/","text":"// workflow / com.squareup.workflow1.ui.backstack / withBackStackStateKeyPrefix withBackStackStateKeyPrefix \u00b6 [androidJvm]\\ fun ViewEnvironment . withBackStackStateKeyPrefix (prefix: String ): ViewEnvironment Sets a disambiguation prefix used by BackStackContainer when managing androidx.savedstate.SavedStateRegistryOwner . Allows parent containers to use multiple BackStackContainer instances at once.","title":"With back stack state key prefix"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/with-back-stack-state-key-prefix/#withbackstackstatekeyprefix","text":"[androidJvm]\\ fun ViewEnvironment . withBackStackStateKeyPrefix (prefix: String ): ViewEnvironment Sets a disambiguation prefix used by BackStackContainer when managing androidx.savedstate.SavedStateRegistryOwner . Allows parent containers to use multiple BackStackContainer instances at once.","title":"withBackStackStateKeyPrefix"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-back-stack-config/","text":"// workflow / com.squareup.workflow1.ui.backstack / BackStackConfig BackStackConfig \u00b6 [androidJvm]\\ @WorkflowUiExperimentalApi enum BackStackConfig : Enum < BackStackConfig > Informs views whether they\u2019re children of a BackStackContainer , and if so whether they\u2019re the first frame or not . Entries \u00b6 Other [androidJvm] Other () This rendering is in a BackStackScreen but is not the first frame. Useful as a hint to enable \u201cgo back\u201d behavior. First [androidJvm] First () This rendering is the first frame in a BackStackScreen. Useful as a hint to disable \u201cgo back\u201d behavior, or replace it with \u201cgo up\u201d behavior. None [androidJvm] None () There is no BackStackContainer above here. Types \u00b6 Name Summary Companion [androidJvm] object Companion : ViewEnvironmentKey < BackStackConfig > Properties \u00b6 Name Summary name [androidJvm] val name : String ordinal [androidJvm] val ordinal : Int","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-back-stack-config/#backstackconfig","text":"[androidJvm]\\ @WorkflowUiExperimentalApi enum BackStackConfig : Enum < BackStackConfig > Informs views whether they\u2019re children of a BackStackContainer , and if so whether they\u2019re the first frame or not .","title":"BackStackConfig"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-back-stack-config/#entries","text":"Other [androidJvm] Other () This rendering is in a BackStackScreen but is not the first frame. Useful as a hint to enable \u201cgo back\u201d behavior. First [androidJvm] First () This rendering is the first frame in a BackStackScreen. Useful as a hint to disable \u201cgo back\u201d behavior, or replace it with \u201cgo up\u201d behavior. None [androidJvm] None () There is no BackStackContainer above here.","title":"Entries"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-back-stack-config/#types","text":"Name Summary Companion [androidJvm] object Companion : ViewEnvironmentKey < BackStackConfig >","title":"Types"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-back-stack-config/#properties","text":"Name Summary name [androidJvm] val name : String ordinal [androidJvm] val ordinal : Int","title":"Properties"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-back-stack-config/-companion/","text":"// workflow / com.squareup.workflow1.ui.backstack / BackStackConfig / Companion Companion \u00b6 [androidJvm]\\ object Companion : ViewEnvironmentKey < BackStackConfig > Functions \u00b6 Name Summary equals [androidJvm] operator override fun equals (other: Any ?): Boolean hashCode [androidJvm] override fun hashCode (): Int toString [androidJvm] open override fun toString (): String Properties \u00b6 Name Summary default [androidJvm] open override val default : BackStackConfig","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-back-stack-config/-companion/#companion","text":"[androidJvm]\\ object Companion : ViewEnvironmentKey < BackStackConfig >","title":"Companion"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-back-stack-config/-companion/#functions","text":"Name Summary equals [androidJvm] operator override fun equals (other: Any ?): Boolean hashCode [androidJvm] override fun hashCode (): Int toString [androidJvm] open override fun toString (): String","title":"Functions"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-back-stack-config/-companion/#properties","text":"Name Summary default [androidJvm] open override val default : BackStackConfig","title":"Properties"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-back-stack-config/-companion/default/","text":"// workflow / com.squareup.workflow1.ui.backstack / BackStackConfig / Companion / default default \u00b6 [androidJvm]\\ open override val default : BackStackConfig","title":"Default"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-back-stack-config/-companion/default/#default","text":"[androidJvm]\\ open override val default : BackStackConfig","title":"default"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-back-stack-config/-first/","text":"// workflow / com.squareup.workflow1.ui.backstack / BackStackConfig / First First \u00b6 [androidJvm]\\ First () This rendering is the first frame in a BackStackScreen. Useful as a hint to disable \u201cgo back\u201d behavior, or replace it with \u201cgo up\u201d behavior. Properties \u00b6 Name Summary name [androidJvm] val name : String ordinal [androidJvm] val ordinal : Int","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-back-stack-config/-first/#first","text":"[androidJvm]\\ First () This rendering is the first frame in a BackStackScreen. Useful as a hint to disable \u201cgo back\u201d behavior, or replace it with \u201cgo up\u201d behavior.","title":"First"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-back-stack-config/-first/#properties","text":"Name Summary name [androidJvm] val name : String ordinal [androidJvm] val ordinal : Int","title":"Properties"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-back-stack-config/-none/","text":"// workflow / com.squareup.workflow1.ui.backstack / BackStackConfig / None None \u00b6 [androidJvm]\\ None () There is no BackStackContainer above here. Properties \u00b6 Name Summary name [androidJvm] val name : String ordinal [androidJvm] val ordinal : Int","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-back-stack-config/-none/#none","text":"[androidJvm]\\ None () There is no BackStackContainer above here.","title":"None"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-back-stack-config/-none/#properties","text":"Name Summary name [androidJvm] val name : String ordinal [androidJvm] val ordinal : Int","title":"Properties"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-back-stack-config/-other/","text":"// workflow / com.squareup.workflow1.ui.backstack / BackStackConfig / Other Other \u00b6 [androidJvm]\\ Other () This rendering is in a BackStackScreen but is not the first frame. Useful as a hint to enable \u201cgo back\u201d behavior. Properties \u00b6 Name Summary name [androidJvm] val name : String ordinal [androidJvm] val ordinal : Int","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-back-stack-config/-other/#other","text":"[androidJvm]\\ Other () This rendering is in a BackStackScreen but is not the first frame. Useful as a hint to enable \u201cgo back\u201d behavior.","title":"Other"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-back-stack-config/-other/#properties","text":"Name Summary name [androidJvm] val name : String ordinal [androidJvm] val ordinal : Int","title":"Properties"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-back-stack-container/","text":"// workflow / com.squareup.workflow1.ui.backstack / BackStackContainer BackStackContainer \u00b6 [androidJvm]\\ @WorkflowUiExperimentalApi open class BackStackContainer @ JvmOverloads constructor(context: Context , attributeSet: AttributeSet ?, defStyle: Int , defStyleRes: Int ) : FrameLayout A container view that can display a stream of BackStackScreen instances. This container supports saving and restoring the view state of each of its subviews corresponding to the renderings in its BackStackScreen. It supports two distinct state mechanisms: Classic view hierarchy state ([View.onSaveInstanceState](../../com.squareup.workflow1.ui/-workflow-view-stub/index.md#1773232604%2FFunctions%2F576965167)/[View.onRestoreInstanceState](../../com.squareup.workflow1.ui/-workflow-view-stub/index.md#-648840093%2FFunctions%2F576965167)) AndroidX [SavedStateRegistry](https://developer.android.com/reference/kotlin/androidx/savedstate/SavedStateRegistry.html) via [ViewTreeSavedStateRegistryOwner](https://developer.android.com/reference/kotlin/androidx/savedstate/ViewTreeSavedStateRegistryOwner.html). A note about SavedStateRegistry support. \u00b6 The SavedStateRegistry API involves defining string keys to associate with state bundles. These keys must be unique relative to the instance of the registry they are saved in. To support this requirement, BackStackContainer tries to generate a best-effort unique key by combining its fully-qualified class name with both its view ID and the compatibility key of its rendering. This method isn\u2019t guaranteed to give a unique registry key, but it should be good enough: If you need to nest multiple BackStackContainer s under the same SavedStateRegistry, just wrap each BackStackScreen with a Named, or give each BackStackContainer a unique view ID. There\u2019s a potential issue here where if our ID is changed to something else, then another BackStackContainer is added with our old ID, that container will overwrite our state. Since they\u2019d both be using the same key, SavedStateRegistry would throw an exception. As long as this container is detached before its ID is changed, it shouldn\u2019t be a problem. Constructors \u00b6 BackStackContainer [androidJvm] @ JvmOverloads fun BackStackContainer (context: Context , attributeSet: AttributeSet ? = null, defStyle: Int = 0, defStyleRes: Int = 0) Types \u00b6 Name Summary Companion [androidJvm] object Companion : ViewFactory <BackStackScreen<*>> Functions \u00b6 Name Summary addChildrenForAccessibility [androidJvm] open override fun addChildrenForAccessibility (p0: ArrayList < View >) addExtraDataToAccessibilityNodeInfo [androidJvm] open override fun addExtraDataToAccessibilityNodeInfo (p0: AccessibilityNodeInfo , p1: String , p2: Bundle ?) addFocusables [androidJvm] open fun addFocusables (p0: ArrayList < View >, p1: Int ) open override fun addFocusables (p0: ArrayList < View >, p1: Int , p2: Int ) addKeyboardNavigationClusters [androidJvm] open override fun addKeyboardNavigationClusters (p0: MutableCollection < View >, p1: Int ) addOnAttachStateChangeListener [androidJvm] open fun addOnAttachStateChangeListener (p0: View.OnAttachStateChangeListener ) addOnLayoutChangeListener [androidJvm] open fun addOnLayoutChangeListener (p0: View.OnLayoutChangeListener ) addOnUnhandledKeyEventListener [androidJvm] open fun addOnUnhandledKeyEventListener (p0: View.OnUnhandledKeyEventListener ) addStatesFromChildren [androidJvm] open fun addStatesFromChildren (): Boolean addTouchables [androidJvm] open override fun addTouchables (p0: ArrayList < View >) addView [androidJvm] open fun addView (p0: View ) open override fun addView (p0: View , p1: ViewGroup.LayoutParams ) open fun addView (p0: View , p1: Int ) open fun addView (p0: View , p1: Int , p2: ViewGroup.LayoutParams ) open fun addView (p0: View , p1: Int , p2: Int ) addViewInLayout [androidJvm] open fun addViewInLayout (p0: View , p1: Int , p2: ViewGroup.LayoutParams ): Boolean open fun addViewInLayout (p0: View , p1: Int , p2: ViewGroup.LayoutParams , p3: Boolean ): Boolean animate [androidJvm] open fun animate (): ViewPropertyAnimator announceForAccessibility [androidJvm] open fun announceForAccessibility (p0: CharSequence ) attachLayoutAnimationParameters [androidJvm] open fun attachLayoutAnimationParameters (p0: View , p1: ViewGroup.LayoutParams , p2: Int , p3: Int ) attachViewToParent [androidJvm] open fun attachViewToParent (p0: View , p1: Int , p2: ViewGroup.LayoutParams ) autofill [androidJvm] open fun autofill (p0: SparseArray < AutofillValue >) open fun autofill (p0: AutofillValue ) awakenScrollBars [androidJvm] open fun awakenScrollBars (): Boolean open fun awakenScrollBars (p0: Int ): Boolean open fun awakenScrollBars (p0: Int , p1: Boolean ): Boolean bringChildToFront [androidJvm] open override fun bringChildToFront (p0: View ) bringToFront [androidJvm] open fun bringToFront () buildLayer [androidJvm] open fun buildLayer () callOnClick [androidJvm] open fun callOnClick (): Boolean canAnimate [androidJvm] open fun canAnimate (): Boolean cancelDragAndDrop [androidJvm] fun cancelDragAndDrop () cancelLongPress [androidJvm] open fun cancelLongPress () cancelPendingInputEvents [androidJvm] fun cancelPendingInputEvents () canResolveLayoutDirection [androidJvm] open fun canResolveLayoutDirection (): Boolean canResolveTextAlignment [androidJvm] open fun canResolveTextAlignment (): Boolean canResolveTextDirection [androidJvm] open fun canResolveTextDirection (): Boolean canScrollHorizontally [androidJvm] open fun canScrollHorizontally (p0: Int ): Boolean canScrollVertically [androidJvm] open fun canScrollVertically (p0: Int ): Boolean checkInputConnectionProxy [androidJvm] open fun checkInputConnectionProxy (p0: View ): Boolean checkLayoutParams [androidJvm] open override fun checkLayoutParams (p0: ViewGroup.LayoutParams ): Boolean childDrawableStateChanged [androidJvm] open override fun childDrawableStateChanged (p0: View ) childHasTransientStateChanged [androidJvm] open override fun childHasTransientStateChanged (p0: View , p1: Boolean ) cleanupLayoutState [androidJvm] open fun cleanupLayoutState (p0: View ) clearAnimation [androidJvm] open fun clearAnimation () clearChildFocus [androidJvm] open override fun clearChildFocus (p0: View ) clearDisappearingChildren [androidJvm] open fun clearDisappearingChildren () clearFocus [androidJvm] open override fun clearFocus () clearViewTranslationCallback [androidJvm] open fun clearViewTranslationCallback () computeHorizontalScrollExtent [androidJvm] open fun computeHorizontalScrollExtent (): Int computeHorizontalScrollOffset [androidJvm] open fun computeHorizontalScrollOffset (): Int computeHorizontalScrollRange [androidJvm] open fun computeHorizontalScrollRange (): Int computeScroll [androidJvm] open fun computeScroll () computeSystemWindowInsets [androidJvm] open fun computeSystemWindowInsets (p0: WindowInsets , p1: Rect ): WindowInsets computeVerticalScrollExtent [androidJvm] open fun computeVerticalScrollExtent (): Int computeVerticalScrollOffset [androidJvm] open fun computeVerticalScrollOffset (): Int computeVerticalScrollRange [androidJvm] open fun computeVerticalScrollRange (): Int createAccessibilityNodeInfo [androidJvm] open fun createAccessibilityNodeInfo (): AccessibilityNodeInfo createContextMenu [androidJvm] open fun createContextMenu (p0: ContextMenu ) debug [androidJvm] open fun debug (p0: Int ) detachAllViewsFromParent [androidJvm] open fun detachAllViewsFromParent () detachViewFromParent [androidJvm] open fun detachViewFromParent (p0: View ) open fun detachViewFromParent (p0: Int ) detachViewsFromParent [androidJvm] open fun detachViewsFromParent (p0: Int , p1: Int ) dispatchApplyWindowInsets [androidJvm] open override fun dispatchApplyWindowInsets (p0: WindowInsets ): WindowInsets dispatchCapturedPointerEvent [androidJvm] open override fun dispatchCapturedPointerEvent (p0: MotionEvent ): Boolean dispatchConfigurationChanged [androidJvm] open override fun dispatchConfigurationChanged (p0: Configuration ) dispatchCreateViewTranslationRequest [androidJvm] open override fun dispatchCreateViewTranslationRequest (p0: MutableMap < AutofillId , LongArray >, p1: IntArray , p2: TranslationCapability , p3: MutableList < ViewTranslationRequest >) dispatchDisplayHint [androidJvm] open override fun dispatchDisplayHint (p0: Int ) dispatchDragEvent [androidJvm] open override fun dispatchDragEvent (p0: DragEvent ): Boolean dispatchDraw [androidJvm] open override fun dispatchDraw (p0: Canvas ) dispatchDrawableHotspotChanged [androidJvm] open override fun dispatchDrawableHotspotChanged (p0: Float , p1: Float ) dispatchFinishTemporaryDetach [androidJvm] open override fun dispatchFinishTemporaryDetach () dispatchFreezeSelfOnly [androidJvm] open fun dispatchFreezeSelfOnly (p0: SparseArray < Parcelable >) dispatchGenericFocusedEvent [androidJvm] open override fun dispatchGenericFocusedEvent (p0: MotionEvent ): Boolean dispatchGenericMotionEvent [androidJvm] open fun dispatchGenericMotionEvent (p0: MotionEvent ): Boolean dispatchGenericPointerEvent [androidJvm] open override fun dispatchGenericPointerEvent (p0: MotionEvent ): Boolean dispatchHoverEvent [androidJvm] open override fun dispatchHoverEvent (p0: MotionEvent ): Boolean dispatchKeyEvent [androidJvm] open override fun dispatchKeyEvent (p0: KeyEvent ): Boolean dispatchKeyEventPreIme [androidJvm] open override fun dispatchKeyEventPreIme (p0: KeyEvent ): Boolean dispatchKeyShortcutEvent [androidJvm] open override fun dispatchKeyShortcutEvent (p0: KeyEvent ): Boolean dispatchNestedFling [androidJvm] open fun dispatchNestedFling (p0: Float , p1: Float , p2: Boolean ): Boolean dispatchNestedPreFling [androidJvm] open fun dispatchNestedPreFling (p0: Float , p1: Float ): Boolean dispatchNestedPrePerformAccessibilityAction [androidJvm] open fun dispatchNestedPrePerformAccessibilityAction (p0: Int , p1: Bundle ): Boolean dispatchNestedPreScroll [androidJvm] open fun dispatchNestedPreScroll (p0: Int , p1: Int , p2: IntArray ?, p3: IntArray ?): Boolean dispatchNestedScroll [androidJvm] open fun dispatchNestedScroll (p0: Int , p1: Int , p2: Int , p3: Int , p4: IntArray ?): Boolean dispatchPointerCaptureChanged [androidJvm] open override fun dispatchPointerCaptureChanged (p0: Boolean ) dispatchPopulateAccessibilityEvent [androidJvm] open fun dispatchPopulateAccessibilityEvent (p0: AccessibilityEvent ): Boolean dispatchProvideAutofillStructure [androidJvm] open override fun dispatchProvideAutofillStructure (p0: ViewStructure , p1: Int ) dispatchProvideStructure [androidJvm] open override fun dispatchProvideStructure (p0: ViewStructure ) dispatchRestoreInstanceState [androidJvm] open override fun dispatchRestoreInstanceState (p0: SparseArray < Parcelable >) dispatchSaveInstanceState [androidJvm] open override fun dispatchSaveInstanceState (p0: SparseArray < Parcelable >) dispatchScrollCaptureSearch [androidJvm] open override fun dispatchScrollCaptureSearch (p0: Rect , p1: Point , p2: Consumer < ScrollCaptureTarget >) dispatchSetActivated [androidJvm] open override fun dispatchSetActivated (p0: Boolean ) dispatchSetPressed [androidJvm] open override fun dispatchSetPressed (p0: Boolean ) dispatchSetSelected [androidJvm] open override fun dispatchSetSelected (p0: Boolean ) dispatchStartTemporaryDetach [androidJvm] open override fun dispatchStartTemporaryDetach () dispatchThawSelfOnly [androidJvm] open fun dispatchThawSelfOnly (p0: SparseArray < Parcelable >) dispatchTouchEvent [androidJvm] open override fun dispatchTouchEvent (p0: MotionEvent ): Boolean dispatchTrackballEvent [androidJvm] open override fun dispatchTrackballEvent (p0: MotionEvent ): Boolean dispatchUnhandledMove [androidJvm] open override fun dispatchUnhandledMove (p0: View , p1: Int ): Boolean dispatchVisibilityChanged [androidJvm] open override fun dispatchVisibilityChanged (p0: View , p1: Int ) dispatchWindowFocusChanged [androidJvm] open override fun dispatchWindowFocusChanged (p0: Boolean ) dispatchWindowInsetsAnimationEnd [androidJvm] open override fun dispatchWindowInsetsAnimationEnd (p0: WindowInsetsAnimation ) dispatchWindowInsetsAnimationPrepare [androidJvm] open override fun dispatchWindowInsetsAnimationPrepare (p0: WindowInsetsAnimation ) dispatchWindowInsetsAnimationProgress [androidJvm] open override fun dispatchWindowInsetsAnimationProgress (p0: WindowInsets , p1: MutableList < WindowInsetsAnimation >): WindowInsets dispatchWindowInsetsAnimationStart [androidJvm] open override fun dispatchWindowInsetsAnimationStart (p0: WindowInsetsAnimation , p1: WindowInsetsAnimation.Bounds ): WindowInsetsAnimation.Bounds dispatchWindowVisibilityChanged [androidJvm] open override fun dispatchWindowVisibilityChanged (p0: Int ) draw [androidJvm] open fun draw (p0: Canvas ) drawableHotspotChanged [androidJvm] open fun drawableHotspotChanged (p0: Float , p1: Float ) drawableStateChanged [androidJvm] open override fun drawableStateChanged () drawChild [androidJvm] open fun drawChild (p0: Canvas , p1: View , p2: Long ): Boolean endViewTransition [androidJvm] open fun endViewTransition (p0: View ) findFocus [androidJvm] open override fun findFocus (): View findViewById [androidJvm] fun < T : View > findViewById (p0: Int ): T findViewsWithText [androidJvm] open override fun findViewsWithText (p0: ArrayList < View >, p1: CharSequence , p2: Int ) findViewWithTag [androidJvm] fun < T : View > findViewWithTag (p0: Any ): T focusableViewAvailable [androidJvm] open override fun focusableViewAvailable (p0: View ) focusSearch [androidJvm] open fun focusSearch (p0: Int ): View open override fun focusSearch (p0: View , p1: Int ): View forceHasOverlappingRendering [androidJvm] open fun forceHasOverlappingRendering (p0: Boolean ) forceLayout [androidJvm] open fun forceLayout () gatherTransparentRegion [androidJvm] open override fun gatherTransparentRegion (p0: Region ?): Boolean generateDefaultLayoutParams [androidJvm] open override fun generateDefaultLayoutParams (): FrameLayout.LayoutParams generateDisplayHash [androidJvm] open fun generateDisplayHash (p0: String , p1: Rect ?, p2: Executor , p3: DisplayHashResultCallback ) generateLayoutParams [androidJvm] open override fun generateLayoutParams (p0: AttributeSet ): FrameLayout.LayoutParams open override fun generateLayoutParams (p0: ViewGroup.LayoutParams ): ViewGroup.LayoutParams getAccessibilityClassName [androidJvm] open override fun getAccessibilityClassName (): CharSequence getAccessibilityDelegate [androidJvm] open fun getAccessibilityDelegate (): View.AccessibilityDelegate getAccessibilityLiveRegion [androidJvm] open fun getAccessibilityLiveRegion (): Int getAccessibilityNodeProvider [androidJvm] open fun getAccessibilityNodeProvider (): AccessibilityNodeProvider getAccessibilityPaneTitle [androidJvm] open fun getAccessibilityPaneTitle (): CharSequence ? getAccessibilityTraversalAfter [androidJvm] open fun getAccessibilityTraversalAfter (): Int getAccessibilityTraversalBefore [androidJvm] open fun getAccessibilityTraversalBefore (): Int getAlpha [androidJvm] open fun getAlpha (): Float getAnimation [androidJvm] open fun getAnimation (): Animation getAnimationMatrix [androidJvm] open fun getAnimationMatrix (): Matrix ? getApplicationWindowToken [androidJvm] open fun getApplicationWindowToken (): IBinder getAttributeResolutionStack [androidJvm] open fun getAttributeResolutionStack (p0: Int ): IntArray getAttributeSourceResourceMap [androidJvm] open fun getAttributeSourceResourceMap (): MutableMap < Int , Int > getAutofillHints [androidJvm] open fun getAutofillHints (): Array < String >? getAutofillId [androidJvm] fun getAutofillId (): AutofillId getAutofillType [androidJvm] open fun getAutofillType (): Int getAutofillValue [androidJvm] open fun getAutofillValue (): AutofillValue ? getBackground [androidJvm] open fun getBackground (): Drawable getBackgroundTintBlendMode [androidJvm] open fun getBackgroundTintBlendMode (): BlendMode ? getBackgroundTintList [androidJvm] open fun getBackgroundTintList (): ColorStateList ? getBackgroundTintMode [androidJvm] open fun getBackgroundTintMode (): PorterDuff.Mode ? getBaseline [androidJvm] open fun getBaseline (): Int getBottom [androidJvm] fun getBottom (): Int getBottomFadingEdgeStrength [androidJvm] open fun getBottomFadingEdgeStrength (): Float getBottomPaddingOffset [androidJvm] open fun getBottomPaddingOffset (): Int getCameraDistance [androidJvm] open fun getCameraDistance (): Float getChildAt [androidJvm] open fun getChildAt (p0: Int ): View getChildCount [androidJvm] open fun getChildCount (): Int getChildDrawingOrder [androidJvm] fun getChildDrawingOrder (p0: Int ): Int open fun getChildDrawingOrder (p0: Int , p1: Int ): Int getChildStaticTransformation [androidJvm] open fun getChildStaticTransformation (p0: View , p1: Transformation ): Boolean getChildVisibleRect [androidJvm] open override fun getChildVisibleRect (p0: View , p1: Rect , p2: Point ): Boolean getClipBounds [androidJvm] open fun getClipBounds (): Rect open fun getClipBounds (p0: Rect ): Boolean getClipChildren [androidJvm] open fun getClipChildren (): Boolean getClipToOutline [androidJvm] fun getClipToOutline (): Boolean getClipToPadding [androidJvm] open fun getClipToPadding (): Boolean getContentCaptureSession [androidJvm] fun getContentCaptureSession (): ContentCaptureSession ? getContentDescription [androidJvm] open fun getContentDescription (): CharSequence getContext [androidJvm] fun getContext (): Context getContextMenuInfo [androidJvm] open fun getContextMenuInfo (): ContextMenu.ContextMenuInfo getDefaultFocusHighlightEnabled [androidJvm] fun getDefaultFocusHighlightEnabled (): Boolean getDescendantFocusability [androidJvm] open fun getDescendantFocusability (): Int getDisplay [androidJvm] open fun getDisplay (): Display getDrawableState [androidJvm] fun getDrawableState (): IntArray getDrawingRect [androidJvm] open fun getDrawingRect (p0: Rect ) getDrawingTime [androidJvm] open fun getDrawingTime (): Long getElevation [androidJvm] open fun getElevation (): Float getExplicitStyle [androidJvm] open fun getExplicitStyle (): Int getFilterTouchesWhenObscured [androidJvm] open fun getFilterTouchesWhenObscured (): Boolean getFitsSystemWindows [androidJvm] open fun getFitsSystemWindows (): Boolean getFocusable [androidJvm] open fun getFocusable (): Int getFocusables [androidJvm] open fun getFocusables (p0: Int ): ArrayList < View > getFocusedChild [androidJvm] open fun getFocusedChild (): View getFocusedRect [androidJvm] open fun getFocusedRect (p0: Rect ) getForeground [androidJvm] open fun getForeground (): Drawable getForegroundGravity [androidJvm] open fun getForegroundGravity (): Int getForegroundTintBlendMode [androidJvm] open fun getForegroundTintBlendMode (): BlendMode ? getForegroundTintList [androidJvm] open fun getForegroundTintList (): ColorStateList ? getForegroundTintMode [androidJvm] open fun getForegroundTintMode (): PorterDuff.Mode ? getGlobalVisibleRect [androidJvm] fun getGlobalVisibleRect (p0: Rect ): Boolean open fun getGlobalVisibleRect (p0: Rect , p1: Point ): Boolean getHandler [androidJvm] open fun getHandler (): Handler getHasOverlappingRendering [androidJvm] fun getHasOverlappingRendering (): Boolean getHeight [androidJvm] fun getHeight (): Int getHitRect [androidJvm] open fun getHitRect (p0: Rect ) getHorizontalFadingEdgeLength [androidJvm] open fun getHorizontalFadingEdgeLength (): Int getHorizontalScrollbarHeight [androidJvm] open fun getHorizontalScrollbarHeight (): Int getHorizontalScrollbarThumbDrawable [androidJvm] open fun getHorizontalScrollbarThumbDrawable (): Drawable ? getHorizontalScrollbarTrackDrawable [androidJvm] open fun getHorizontalScrollbarTrackDrawable (): Drawable ? getId [androidJvm] open fun getId (): Int getImportantForAccessibility [androidJvm] open fun getImportantForAccessibility (): Int getImportantForAutofill [androidJvm] open fun getImportantForAutofill (): Int getImportantForContentCapture [androidJvm] open fun getImportantForContentCapture (): Int getKeepScreenOn [androidJvm] open fun getKeepScreenOn (): Boolean getKeyDispatcherState [androidJvm] open fun getKeyDispatcherState (): KeyEvent.DispatcherState getLabelFor [androidJvm] open fun getLabelFor (): Int getLayerType [androidJvm] open fun getLayerType (): Int getLayoutAnimation [androidJvm] open fun getLayoutAnimation (): LayoutAnimationController getLayoutAnimationListener [androidJvm] open fun getLayoutAnimationListener (): Animation.AnimationListener getLayoutDirection [androidJvm] open fun getLayoutDirection (): Int getLayoutMode [androidJvm] open fun getLayoutMode (): Int getLayoutParams [androidJvm] open fun getLayoutParams (): ViewGroup.LayoutParams getLayoutTransition [androidJvm] open fun getLayoutTransition (): LayoutTransition getLeft [androidJvm] fun getLeft (): Int getLeftFadingEdgeStrength [androidJvm] open fun getLeftFadingEdgeStrength (): Float getLeftPaddingOffset [androidJvm] open fun getLeftPaddingOffset (): Int getLocalVisibleRect [androidJvm] fun getLocalVisibleRect (p0: Rect ): Boolean getLocationInSurface [androidJvm] open fun getLocationInSurface (p0: IntArray ) getLocationInWindow [androidJvm] open fun getLocationInWindow (p0: IntArray ) getLocationOnScreen [androidJvm] open fun getLocationOnScreen (p0: IntArray ) getMatrix [androidJvm] open fun getMatrix (): Matrix getMeasureAllChildren [androidJvm] open fun getMeasureAllChildren (): Boolean getMeasuredHeight [androidJvm] fun getMeasuredHeight (): Int getMeasuredHeightAndState [androidJvm] fun getMeasuredHeightAndState (): Int getMeasuredState [androidJvm] fun getMeasuredState (): Int getMeasuredWidth [androidJvm] fun getMeasuredWidth (): Int getMeasuredWidthAndState [androidJvm] fun getMeasuredWidthAndState (): Int getMinimumHeight [androidJvm] open fun getMinimumHeight (): Int getMinimumWidth [androidJvm] open fun getMinimumWidth (): Int getNestedScrollAxes [androidJvm] open fun getNestedScrollAxes (): Int getNextClusterForwardId [androidJvm] open fun getNextClusterForwardId (): Int getNextFocusDownId [androidJvm] open fun getNextFocusDownId (): Int getNextFocusForwardId [androidJvm] open fun getNextFocusForwardId (): Int getNextFocusLeftId [androidJvm] open fun getNextFocusLeftId (): Int getNextFocusRightId [androidJvm] open fun getNextFocusRightId (): Int getNextFocusUpId [androidJvm] open fun getNextFocusUpId (): Int getOnFocusChangeListener [androidJvm] open fun getOnFocusChangeListener (): View.OnFocusChangeListener getOutlineAmbientShadowColor [androidJvm] open fun getOutlineAmbientShadowColor (): Int getOutlineProvider [androidJvm] open fun getOutlineProvider (): ViewOutlineProvider getOutlineSpotShadowColor [androidJvm] open fun getOutlineSpotShadowColor (): Int getOverlay [androidJvm] open override fun getOverlay (): ViewGroupOverlay getOverScrollMode [androidJvm] open fun getOverScrollMode (): Int getPaddingBottom [androidJvm] open fun getPaddingBottom (): Int getPaddingEnd [androidJvm] open fun getPaddingEnd (): Int getPaddingLeft [androidJvm] open fun getPaddingLeft (): Int getPaddingRight [androidJvm] open fun getPaddingRight (): Int getPaddingStart [androidJvm] open fun getPaddingStart (): Int getPaddingTop [androidJvm] open fun getPaddingTop (): Int getParent [androidJvm] fun getParent (): ViewParent getParentForAccessibility [androidJvm] open fun getParentForAccessibility (): ViewParent getPivotX [androidJvm] open fun getPivotX (): Float getPivotY [androidJvm] open fun getPivotY (): Float getPointerIcon [androidJvm] open fun getPointerIcon (): PointerIcon getReceiveContentMimeTypes [androidJvm] open fun getReceiveContentMimeTypes (): Array < String >? getResources [androidJvm] open fun getResources (): Resources getRevealOnFocusHint [androidJvm] fun getRevealOnFocusHint (): Boolean getRight [androidJvm] fun getRight (): Int getRightFadingEdgeStrength [androidJvm] open fun getRightFadingEdgeStrength (): Float getRightPaddingOffset [androidJvm] open fun getRightPaddingOffset (): Int getRootSurfaceControl [androidJvm] open fun getRootSurfaceControl (): AttachedSurfaceControl ? getRootView [androidJvm] open fun getRootView (): View getRootWindowInsets [androidJvm] open fun getRootWindowInsets (): WindowInsets getRotation [androidJvm] open fun getRotation (): Float getRotationX [androidJvm] open fun getRotationX (): Float getRotationY [androidJvm] open fun getRotationY (): Float getScaleX [androidJvm] open fun getScaleX (): Float getScaleY [androidJvm] open fun getScaleY (): Float getScrollBarDefaultDelayBeforeFade [androidJvm] open fun getScrollBarDefaultDelayBeforeFade (): Int getScrollBarFadeDuration [androidJvm] open fun getScrollBarFadeDuration (): Int getScrollBarSize [androidJvm] open fun getScrollBarSize (): Int getScrollBarStyle [androidJvm] open fun getScrollBarStyle (): Int getScrollCaptureHint [androidJvm] open fun getScrollCaptureHint (): Int getScrollIndicators [androidJvm] open fun getScrollIndicators (): Int getScrollX [androidJvm] fun getScrollX (): Int getScrollY [androidJvm] fun getScrollY (): Int getSolidColor [androidJvm] open fun getSolidColor (): Int getSourceLayoutResId [androidJvm] open fun getSourceLayoutResId (): Int getStateDescription [androidJvm] fun getStateDescription (): CharSequence ? getStateListAnimator [androidJvm] open fun getStateListAnimator (): StateListAnimator getSuggestedMinimumHeight [androidJvm] open fun getSuggestedMinimumHeight (): Int getSuggestedMinimumWidth [androidJvm] open fun getSuggestedMinimumWidth (): Int getSystemGestureExclusionRects [androidJvm] open fun getSystemGestureExclusionRects (): MutableList < Rect > getTag [androidJvm] open fun getTag (): Any open fun getTag (p0: Int ): Any getTextAlignment [androidJvm] open fun getTextAlignment (): Int getTextDirection [androidJvm] open fun getTextDirection (): Int getTooltipText [androidJvm] open fun getTooltipText (): CharSequence ? getTop [androidJvm] fun getTop (): Int getTopFadingEdgeStrength [androidJvm] open fun getTopFadingEdgeStrength (): Float getTopPaddingOffset [androidJvm] open fun getTopPaddingOffset (): Int getTouchables [androidJvm] open fun getTouchables (): ArrayList < View > getTouchDelegate [androidJvm] open fun getTouchDelegate (): TouchDelegate getTouchscreenBlocksFocus [androidJvm] open fun getTouchscreenBlocksFocus (): Boolean getTransitionAlpha [androidJvm] open fun getTransitionAlpha (): Float getTransitionName [androidJvm] open fun getTransitionName (): String getTranslationX [androidJvm] open fun getTranslationX (): Float getTranslationY [androidJvm] open fun getTranslationY (): Float getTranslationZ [androidJvm] open fun getTranslationZ (): Float getUniqueDrawingId [androidJvm] open fun getUniqueDrawingId (): Long getVerticalFadingEdgeLength [androidJvm] open fun getVerticalFadingEdgeLength (): Int getVerticalScrollbarPosition [androidJvm] open fun getVerticalScrollbarPosition (): Int getVerticalScrollbarThumbDrawable [androidJvm] open fun getVerticalScrollbarThumbDrawable (): Drawable ? getVerticalScrollbarTrackDrawable [androidJvm] open fun getVerticalScrollbarTrackDrawable (): Drawable ? getVerticalScrollbarWidth [androidJvm] open fun getVerticalScrollbarWidth (): Int getViewTranslationResponse [androidJvm] open fun getViewTranslationResponse (): ViewTranslationResponse ? getViewTreeObserver [androidJvm] open fun getViewTreeObserver (): ViewTreeObserver getVisibility [androidJvm] open fun getVisibility (): Int getWidth [androidJvm] fun getWidth (): Int getWindowAttachCount [androidJvm] open fun getWindowAttachCount (): Int getWindowId [androidJvm] open fun getWindowId (): WindowId getWindowInsetsController [androidJvm] open fun getWindowInsetsController (): WindowInsetsController ? getWindowToken [androidJvm] open fun getWindowToken (): IBinder getWindowVisibility [androidJvm] open fun getWindowVisibility (): Int getWindowVisibleDisplayFrame [androidJvm] open fun getWindowVisibleDisplayFrame (p0: Rect ) getX [androidJvm] open fun getX (): Float getY [androidJvm] open fun getY (): Float getZ [androidJvm] open fun getZ (): Float hasExplicitFocusable [androidJvm] open fun hasExplicitFocusable (): Boolean hasFocus [androidJvm] open override fun hasFocus (): Boolean hasFocusable [androidJvm] open fun hasFocusable (): Boolean hasNestedScrollingParent [androidJvm] open fun hasNestedScrollingParent (): Boolean hasOnClickListeners [androidJvm] open fun hasOnClickListeners (): Boolean hasOnLongClickListeners [androidJvm] open fun hasOnLongClickListeners (): Boolean hasOverlappingRendering [androidJvm] open fun hasOverlappingRendering (): Boolean hasPointerCapture [androidJvm] open fun hasPointerCapture (): Boolean hasTransientState [androidJvm] open override fun hasTransientState (): Boolean hasWindowFocus [androidJvm] open fun hasWindowFocus (): Boolean indexOfChild [androidJvm] open fun indexOfChild (p0: View ): Int invalidate [androidJvm] open fun invalidate () invalidateDrawable [androidJvm] open override fun invalidateDrawable (p0: Drawable ) invalidateOutline [androidJvm] open fun invalidateOutline () isAccessibilityFocused [androidJvm] open fun isAccessibilityFocused (): Boolean isAccessibilityHeading [androidJvm] open fun isAccessibilityHeading (): Boolean isActivated [androidJvm] open fun isActivated (): Boolean isAttachedToWindow [androidJvm] open fun isAttachedToWindow (): Boolean isChildrenDrawingOrderEnabled [androidJvm] open fun isChildrenDrawingOrderEnabled (): Boolean isClickable [androidJvm] open fun isClickable (): Boolean isContextClickable [androidJvm] open fun isContextClickable (): Boolean isDirty [androidJvm] open fun isDirty (): Boolean isDuplicateParentStateEnabled [androidJvm] open fun isDuplicateParentStateEnabled (): Boolean isEnabled [androidJvm] open fun isEnabled (): Boolean isFocusable [androidJvm] fun isFocusable (): Boolean isFocusableInTouchMode [androidJvm] fun isFocusableInTouchMode (): Boolean isFocused [androidJvm] open fun isFocused (): Boolean isFocusedByDefault [androidJvm] fun isFocusedByDefault (): Boolean isForceDarkAllowed [androidJvm] open fun isForceDarkAllowed (): Boolean isHapticFeedbackEnabled [androidJvm] open fun isHapticFeedbackEnabled (): Boolean isHardwareAccelerated [androidJvm] open fun isHardwareAccelerated (): Boolean isHorizontalFadingEdgeEnabled [androidJvm] open fun isHorizontalFadingEdgeEnabled (): Boolean isHorizontalScrollBarEnabled [androidJvm] open fun isHorizontalScrollBarEnabled (): Boolean isHovered [androidJvm] open fun isHovered (): Boolean isImportantForAccessibility [androidJvm] open fun isImportantForAccessibility (): Boolean isImportantForAutofill [androidJvm] fun isImportantForAutofill (): Boolean isImportantForContentCapture [androidJvm] fun isImportantForContentCapture (): Boolean isInEditMode [androidJvm] open fun isInEditMode (): Boolean isInLayout [androidJvm] open fun isInLayout (): Boolean isInTouchMode [androidJvm] open fun isInTouchMode (): Boolean isKeyboardNavigationCluster [androidJvm] fun isKeyboardNavigationCluster (): Boolean isLaidOut [androidJvm] open fun isLaidOut (): Boolean isLayoutDirectionResolved [androidJvm] open fun isLayoutDirectionResolved (): Boolean isLayoutRequested [androidJvm] open fun isLayoutRequested (): Boolean isLayoutSuppressed [androidJvm] open fun isLayoutSuppressed (): Boolean isLongClickable [androidJvm] open fun isLongClickable (): Boolean isMotionEventSplittingEnabled [androidJvm] open fun isMotionEventSplittingEnabled (): Boolean isNestedScrollingEnabled [androidJvm] open fun isNestedScrollingEnabled (): Boolean isOpaque [androidJvm] open fun isOpaque (): Boolean isPaddingOffsetRequired [androidJvm] open fun isPaddingOffsetRequired (): Boolean isPaddingRelative [androidJvm] open fun isPaddingRelative (): Boolean isPivotSet [androidJvm] open fun isPivotSet (): Boolean isPressed [androidJvm] open fun isPressed (): Boolean isSaveEnabled [androidJvm] open fun isSaveEnabled (): Boolean isSaveFromParentEnabled [androidJvm] open fun isSaveFromParentEnabled (): Boolean isScreenReaderFocusable [androidJvm] open fun isScreenReaderFocusable (): Boolean isScrollbarFadingEnabled [androidJvm] open fun isScrollbarFadingEnabled (): Boolean isScrollContainer [androidJvm] open fun isScrollContainer (): Boolean isSelected [androidJvm] open fun isSelected (): Boolean isShowingLayoutBounds [androidJvm] fun isShowingLayoutBounds (): Boolean isShown [androidJvm] open fun isShown (): Boolean isSoundEffectsEnabled [androidJvm] open fun isSoundEffectsEnabled (): Boolean isTemporarilyDetached [androidJvm] fun isTemporarilyDetached (): Boolean isTextAlignmentResolved [androidJvm] open fun isTextAlignmentResolved (): Boolean isTextDirectionResolved [androidJvm] open fun isTextDirectionResolved (): Boolean isTransitionGroup [androidJvm] open fun isTransitionGroup (): Boolean isVerticalFadingEdgeEnabled [androidJvm] open fun isVerticalFadingEdgeEnabled (): Boolean isVerticalScrollBarEnabled [androidJvm] open fun isVerticalScrollBarEnabled (): Boolean isVisibleToUserForAutofill [androidJvm] open fun isVisibleToUserForAutofill (p0: Int ): Boolean jumpDrawablesToCurrentState [androidJvm] open override fun jumpDrawablesToCurrentState () keyboardNavigationClusterSearch [androidJvm] open fun keyboardNavigationClusterSearch (p0: View , p1: Int ): View layout [androidJvm] override fun layout (p0: Int , p1: Int , p2: Int , p3: Int ) measure [androidJvm] fun measure (p0: Int , p1: Int ) measureChild [androidJvm] open fun measureChild (p0: View , p1: Int , p2: Int ) measureChildren [androidJvm] open fun measureChildren (p0: Int , p1: Int ) measureChildWithMargins [androidJvm] open fun measureChildWithMargins (p0: View , p1: Int , p2: Int , p3: Int , p4: Int ) notifySubtreeAccessibilityStateChanged [androidJvm] open override fun notifySubtreeAccessibilityStateChanged (p0: View , p1: View , p2: Int ) offsetDescendantRectToMyCoords [androidJvm] fun offsetDescendantRectToMyCoords (p0: View , p1: Rect ) offsetLeftAndRight [androidJvm] open fun offsetLeftAndRight (p0: Int ) offsetRectIntoDescendantCoords [androidJvm] fun offsetRectIntoDescendantCoords (p0: View , p1: Rect ) offsetTopAndBottom [androidJvm] open fun offsetTopAndBottom (p0: Int ) onAnimationEnd [androidJvm] open fun onAnimationEnd () onAnimationStart [androidJvm] open fun onAnimationStart () onApplyWindowInsets [androidJvm] open fun onApplyWindowInsets (p0: WindowInsets ): WindowInsets onCancelPendingInputEvents [androidJvm] open fun onCancelPendingInputEvents () onCapturedPointerEvent [androidJvm] open fun onCapturedPointerEvent (p0: MotionEvent ): Boolean onCheckIsTextEditor [androidJvm] open fun onCheckIsTextEditor (): Boolean onConfigurationChanged [androidJvm] open fun onConfigurationChanged (p0: Configuration ) onCreateContextMenu [androidJvm] open fun onCreateContextMenu (p0: ContextMenu ) onCreateDrawableState [androidJvm] open override fun onCreateDrawableState (p0: Int ): IntArray onCreateInputConnection [androidJvm] open fun onCreateInputConnection (p0: EditorInfo ): InputConnection onCreateViewTranslationRequest [androidJvm] open fun onCreateViewTranslationRequest (p0: IntArray , p1: Consumer < ViewTranslationRequest >) onCreateVirtualViewTranslationRequests [androidJvm] open fun onCreateVirtualViewTranslationRequests (p0: LongArray , p1: IntArray , p2: Consumer < ViewTranslationRequest >) onDescendantInvalidated [androidJvm] open override fun onDescendantInvalidated (p0: View , p1: View ) onDisplayHint [androidJvm] open fun onDisplayHint (p0: Int ) onDragEvent [androidJvm] open fun onDragEvent (p0: DragEvent ): Boolean onDraw [androidJvm] open fun onDraw (p0: Canvas ) onDrawForeground [androidJvm] open fun onDrawForeground (p0: Canvas ) onDrawScrollBars [androidJvm] fun onDrawScrollBars (p0: Canvas ) onFilterTouchEventForSecurity [androidJvm] open fun onFilterTouchEventForSecurity (p0: MotionEvent ): Boolean onFinishInflate [androidJvm] open fun onFinishInflate () onFinishTemporaryDetach [androidJvm] open fun onFinishTemporaryDetach () onFocusChanged [androidJvm] open fun onFocusChanged (p0: Boolean , p1: Int , p2: Rect ?) onGenericMotionEvent [androidJvm] open fun onGenericMotionEvent (p0: MotionEvent ): Boolean onHoverChanged [androidJvm] open fun onHoverChanged (p0: Boolean ) onHoverEvent [androidJvm] open fun onHoverEvent (p0: MotionEvent ): Boolean onInitializeAccessibilityEvent [androidJvm] open fun onInitializeAccessibilityEvent (p0: AccessibilityEvent ) onInitializeAccessibilityNodeInfo [androidJvm] open fun onInitializeAccessibilityNodeInfo (p0: AccessibilityNodeInfo ) onInterceptHoverEvent [androidJvm] open fun onInterceptHoverEvent (p0: MotionEvent ): Boolean onInterceptTouchEvent [androidJvm] open fun onInterceptTouchEvent (p0: MotionEvent ): Boolean onKeyDown [androidJvm] open override fun onKeyDown (p0: Int , p1: KeyEvent ): Boolean onKeyLongPress [androidJvm] open override fun onKeyLongPress (p0: Int , p1: KeyEvent ): Boolean onKeyMultiple [androidJvm] open override fun onKeyMultiple (p0: Int , p1: Int , p2: KeyEvent ): Boolean onKeyPreIme [androidJvm] open fun onKeyPreIme (p0: Int , p1: KeyEvent ): Boolean onKeyShortcut [androidJvm] open fun onKeyShortcut (p0: Int , p1: KeyEvent ): Boolean onKeyUp [androidJvm] open override fun onKeyUp (p0: Int , p1: KeyEvent ): Boolean onLayout [androidJvm] open override fun onLayout (p0: Boolean , p1: Int , p2: Int , p3: Int , p4: Int ) onMeasure [androidJvm] open override fun onMeasure (p0: Int , p1: Int ) onNestedFling [androidJvm] open override fun onNestedFling (p0: View , p1: Float , p2: Float , p3: Boolean ): Boolean onNestedPreFling [androidJvm] open override fun onNestedPreFling (p0: View , p1: Float , p2: Float ): Boolean onNestedPrePerformAccessibilityAction [androidJvm] open override fun onNestedPrePerformAccessibilityAction (p0: View , p1: Int , p2: Bundle ): Boolean onNestedPreScroll [androidJvm] open override fun onNestedPreScroll (p0: View , p1: Int , p2: Int , p3: IntArray ) onNestedScroll [androidJvm] open override fun onNestedScroll (p0: View , p1: Int , p2: Int , p3: Int , p4: Int ) onNestedScrollAccepted [androidJvm] open override fun onNestedScrollAccepted (p0: View , p1: View , p2: Int ) onOverScrolled [androidJvm] open fun onOverScrolled (p0: Int , p1: Int , p2: Boolean , p3: Boolean ) onPointerCaptureChange [androidJvm] open fun onPointerCaptureChange (p0: Boolean ) onPopulateAccessibilityEvent [androidJvm] open fun onPopulateAccessibilityEvent (p0: AccessibilityEvent ) onProvideAutofillStructure [androidJvm] open fun onProvideAutofillStructure (p0: ViewStructure , p1: Int ) onProvideAutofillVirtualStructure [androidJvm] open fun onProvideAutofillVirtualStructure (p0: ViewStructure , p1: Int ) onProvideContentCaptureStructure [androidJvm] open fun onProvideContentCaptureStructure (p0: ViewStructure , p1: Int ) onProvideStructure [androidJvm] open fun onProvideStructure (p0: ViewStructure ) onProvideVirtualStructure [androidJvm] open fun onProvideVirtualStructure (p0: ViewStructure ) onReceiveContent [androidJvm] open fun onReceiveContent (p0: ContentInfo ): ContentInfo ? onRequestFocusInDescendants [androidJvm] open fun onRequestFocusInDescendants (p0: Int , p1: Rect ): Boolean onRequestSendAccessibilityEvent [androidJvm] open fun onRequestSendAccessibilityEvent (p0: View , p1: AccessibilityEvent ): Boolean onResolvePointerIcon [androidJvm] open override fun onResolvePointerIcon (p0: MotionEvent , p1: Int ): PointerIcon onRtlPropertiesChanged [androidJvm] open fun onRtlPropertiesChanged (p0: Int ) onScreenStateChanged [androidJvm] open fun onScreenStateChanged (p0: Int ) onScrollCaptureSearch [androidJvm] open fun onScrollCaptureSearch (p0: Rect , p1: Point , p2: Consumer < ScrollCaptureTarget >) onScrollChanged [androidJvm] open fun onScrollChanged (p0: Int , p1: Int , p2: Int , p3: Int ) onSetAlpha [androidJvm] open fun onSetAlpha (p0: Int ): Boolean onSizeChanged [androidJvm] open fun onSizeChanged (p0: Int , p1: Int , p2: Int , p3: Int ) onStartNestedScroll [androidJvm] open override fun onStartNestedScroll (p0: View , p1: View , p2: Int ): Boolean onStartTemporaryDetach [androidJvm] open fun onStartTemporaryDetach () onStopNestedScroll [androidJvm] open override fun onStopNestedScroll (p0: View ) onTouchEvent [androidJvm] open fun onTouchEvent (p0: MotionEvent ): Boolean onTrackballEvent [androidJvm] open fun onTrackballEvent (p0: MotionEvent ): Boolean onViewAdded [androidJvm] open fun onViewAdded (p0: View ) onViewRemoved [androidJvm] open fun onViewRemoved (p0: View ) onViewTranslationResponse [androidJvm] open fun onViewTranslationResponse (p0: ViewTranslationResponse ) onVirtualViewTranslationResponses [androidJvm] open fun onVirtualViewTranslationResponses (p0: LongSparseArray < ViewTranslationResponse >) onVisibilityAggregated [androidJvm] open fun onVisibilityAggregated (p0: Boolean ) onVisibilityChanged [androidJvm] open fun onVisibilityChanged (p0: View , p1: Int ) onWindowFocusChanged [androidJvm] open fun onWindowFocusChanged (p0: Boolean ) onWindowVisibilityChanged [androidJvm] open fun onWindowVisibilityChanged (p0: Int ) overScrollBy [androidJvm] open fun overScrollBy (p0: Int , p1: Int , p2: Int , p3: Int , p4: Int , p5: Int , p6: Int , p7: Int , p8: Boolean ): Boolean performAccessibilityAction [androidJvm] open fun performAccessibilityAction (p0: Int , p1: Bundle ): Boolean performClick [androidJvm] open fun performClick (): Boolean performContextClick [androidJvm] open fun performContextClick (): Boolean open fun performContextClick (p0: Float , p1: Float ): Boolean performHapticFeedback [androidJvm] open fun performHapticFeedback (p0: Int ): Boolean open fun performHapticFeedback (p0: Int , p1: Int ): Boolean performLongClick [androidJvm] open fun performLongClick (): Boolean open fun performLongClick (p0: Float , p1: Float ): Boolean performReceiveContent [androidJvm] open fun performReceiveContent (p0: ContentInfo ): ContentInfo ? playSoundEffect [androidJvm] open fun playSoundEffect (p0: Int ) post [androidJvm] open fun post (p0: Runnable ): Boolean postDelayed [androidJvm] open fun postDelayed (p0: Runnable , p1: Long ): Boolean postInvalidate [androidJvm] open fun postInvalidate () open fun postInvalidate (p0: Int , p1: Int , p2: Int , p3: Int ) postInvalidateDelayed [androidJvm] open fun postInvalidateDelayed (p0: Long ) open fun postInvalidateDelayed (p0: Long , p1: Int , p2: Int , p3: Int , p4: Int ) postInvalidateOnAnimation [androidJvm] open fun postInvalidateOnAnimation () open fun postInvalidateOnAnimation (p0: Int , p1: Int , p2: Int , p3: Int ) postOnAnimation [androidJvm] open fun postOnAnimation (p0: Runnable ) postOnAnimationDelayed [androidJvm] open fun postOnAnimationDelayed (p0: Runnable , p1: Long ) recomputeViewAttributes [androidJvm] open override fun recomputeViewAttributes (p0: View ) refreshDrawableState [androidJvm] open fun refreshDrawableState () releasePointerCapture [androidJvm] open fun releasePointerCapture () removeAllViews [androidJvm] open fun removeAllViews () removeAllViewsInLayout [androidJvm] open fun removeAllViewsInLayout () removeCallbacks [androidJvm] open fun removeCallbacks (p0: Runnable ): Boolean removeDetachedView [androidJvm] open fun removeDetachedView (p0: View , p1: Boolean ) removeOnAttachStateChangeListener [androidJvm] open fun removeOnAttachStateChangeListener (p0: View.OnAttachStateChangeListener ) removeOnLayoutChangeListener [androidJvm] open fun removeOnLayoutChangeListener (p0: View.OnLayoutChangeListener ) removeOnUnhandledKeyEventListener [androidJvm] open fun removeOnUnhandledKeyEventListener (p0: View.OnUnhandledKeyEventListener ) removeView [androidJvm] open override fun removeView (p0: View ) removeViewAt [androidJvm] open fun removeViewAt (p0: Int ) removeViewInLayout [androidJvm] open fun removeViewInLayout (p0: View ) removeViews [androidJvm] open fun removeViews (p0: Int , p1: Int ) removeViewsInLayout [androidJvm] open fun removeViewsInLayout (p0: Int , p1: Int ) requestApplyInsets [androidJvm] open fun requestApplyInsets () requestChildFocus [androidJvm] open override fun requestChildFocus (p0: View , p1: View ) requestChildRectangleOnScreen [androidJvm] open override fun requestChildRectangleOnScreen (p0: View , p1: Rect , p2: Boolean ): Boolean requestDisallowInterceptTouchEvent [androidJvm] open override fun requestDisallowInterceptTouchEvent (p0: Boolean ) requestFocus [androidJvm] fun requestFocus (): Boolean fun requestFocus (p0: Int ): Boolean open override fun requestFocus (p0: Int , p1: Rect ): Boolean requestFocusFromTouch [androidJvm] fun requestFocusFromTouch (): Boolean requestLayout [androidJvm] open fun requestLayout () requestPointerCapture [androidJvm] open fun requestPointerCapture () requestRectangleOnScreen [androidJvm] open fun requestRectangleOnScreen (p0: Rect ): Boolean open fun requestRectangleOnScreen (p0: Rect , p1: Boolean ): Boolean requestSendAccessibilityEvent [androidJvm] open override fun requestSendAccessibilityEvent (p0: View , p1: AccessibilityEvent ): Boolean requestTransparentRegion [androidJvm] open override fun requestTransparentRegion (p0: View ) requestUnbufferedDispatch [androidJvm] fun requestUnbufferedDispatch (p0: MotionEvent ) fun requestUnbufferedDispatch (p0: Int ) requireViewById [androidJvm] fun < T : View > requireViewById (p0: Int ): T resetPivot [androidJvm] open fun resetPivot () restoreDefaultFocus [androidJvm] open override fun restoreDefaultFocus (): Boolean restoreHierarchyState [androidJvm] open fun restoreHierarchyState (p0: SparseArray < Parcelable >) saveAttributeDataForStyleable [androidJvm] fun saveAttributeDataForStyleable (p0: Context , p1: IntArray , p2: AttributeSet ?, p3: TypedArray , p4: Int , p5: Int ) saveHierarchyState [androidJvm] open fun saveHierarchyState (p0: SparseArray < Parcelable >) scheduleDrawable [androidJvm] open override fun scheduleDrawable (p0: Drawable , p1: Runnable , p2: Long ) scheduleLayoutAnimation [androidJvm] open fun scheduleLayoutAnimation () scrollBy [androidJvm] open fun scrollBy (p0: Int , p1: Int ) scrollTo [androidJvm] open fun scrollTo (p0: Int , p1: Int ) sendAccessibilityEvent [androidJvm] open override fun sendAccessibilityEvent (p0: Int ) sendAccessibilityEventUnchecked [androidJvm] open override fun sendAccessibilityEventUnchecked (p0: AccessibilityEvent ) setAccessibilityDelegate [androidJvm] open fun setAccessibilityDelegate (p0: View.AccessibilityDelegate ?) setAccessibilityHeading [androidJvm] open fun setAccessibilityHeading (p0: Boolean ) setAccessibilityLiveRegion [androidJvm] open fun setAccessibilityLiveRegion (p0: Int ) setAccessibilityPaneTitle [androidJvm] open fun setAccessibilityPaneTitle (p0: CharSequence ?) setAccessibilityTraversalAfter [androidJvm] open fun setAccessibilityTraversalAfter (p0: Int ) setAccessibilityTraversalBefore [androidJvm] open fun setAccessibilityTraversalBefore (p0: Int ) setActivated [androidJvm] open fun setActivated (p0: Boolean ) setAddStatesFromChildren [androidJvm] open fun setAddStatesFromChildren (p0: Boolean ) setAllowClickWhenDisabled [androidJvm] open fun setAllowClickWhenDisabled (p0: Boolean ) setAlpha [androidJvm] open fun setAlpha (p0: Float ) setAnimation [androidJvm] open fun setAnimation (p0: Animation ) setAnimationMatrix [androidJvm] open fun setAnimationMatrix (p0: Matrix ?) setAutofillHints [androidJvm] open fun setAutofillHints (vararg p0: String ) setAutofillId [androidJvm] open fun setAutofillId (p0: AutofillId ?) setBackground [androidJvm] open fun setBackground (p0: Drawable ) setBackgroundColor [androidJvm] open fun setBackgroundColor (p0: Int ) setBackgroundResource [androidJvm] open fun setBackgroundResource (p0: Int ) setBackgroundTintBlendMode [androidJvm] open fun setBackgroundTintBlendMode (p0: BlendMode ?) setBackgroundTintList [androidJvm] open fun setBackgroundTintList (p0: ColorStateList ?) setBackgroundTintMode [androidJvm] open fun setBackgroundTintMode (p0: PorterDuff.Mode ?) setBottom [androidJvm] fun setBottom (p0: Int ) setCameraDistance [androidJvm] open fun setCameraDistance (p0: Float ) setChildrenDrawingOrderEnabled [androidJvm] open fun setChildrenDrawingOrderEnabled (p0: Boolean ) setClickable [androidJvm] open fun setClickable (p0: Boolean ) setClipBounds [androidJvm] open fun setClipBounds (p0: Rect ) setClipChildren [androidJvm] open fun setClipChildren (p0: Boolean ) setClipToOutline [androidJvm] open fun setClipToOutline (p0: Boolean ) setClipToPadding [androidJvm] open fun setClipToPadding (p0: Boolean ) setContentCaptureSession [androidJvm] open fun setContentCaptureSession (p0: ContentCaptureSession ?) setContentDescription [androidJvm] open fun setContentDescription (p0: CharSequence ) setContextClickable [androidJvm] open fun setContextClickable (p0: Boolean ) setDefaultFocusHighlightEnabled [androidJvm] open fun setDefaultFocusHighlightEnabled (p0: Boolean ) setDescendantFocusability [androidJvm] open fun setDescendantFocusability (p0: Int ) setDuplicateParentStateEnabled [androidJvm] open fun setDuplicateParentStateEnabled (p0: Boolean ) setElevation [androidJvm] open fun setElevation (p0: Float ) setEnabled [androidJvm] open fun setEnabled (p0: Boolean ) setFadingEdgeLength [androidJvm] open fun setFadingEdgeLength (p0: Int ) setFilterTouchesWhenObscured [androidJvm] open fun setFilterTouchesWhenObscured (p0: Boolean ) setFitsSystemWindows [androidJvm] open fun setFitsSystemWindows (p0: Boolean ) setFocusable [androidJvm] open fun setFocusable (p0: Boolean ) open fun setFocusable (p0: Int ) setFocusableInTouchMode [androidJvm] open fun setFocusableInTouchMode (p0: Boolean ) setFocusedByDefault [androidJvm] open fun setFocusedByDefault (p0: Boolean ) setForceDarkAllowed [androidJvm] open fun setForceDarkAllowed (p0: Boolean ) setForeground [androidJvm] open fun setForeground (p0: Drawable ) setForegroundGravity [androidJvm] open override fun setForegroundGravity (p0: Int ) setForegroundTintBlendMode [androidJvm] open fun setForegroundTintBlendMode (p0: BlendMode ?) setForegroundTintList [androidJvm] open fun setForegroundTintList (p0: ColorStateList ?) setForegroundTintMode [androidJvm] open fun setForegroundTintMode (p0: PorterDuff.Mode ?) setHapticFeedbackEnabled [androidJvm] open fun setHapticFeedbackEnabled (p0: Boolean ) setHasTransientState [androidJvm] open fun setHasTransientState (p0: Boolean ) setHorizontalFadingEdgeEnabled [androidJvm] open fun setHorizontalFadingEdgeEnabled (p0: Boolean ) setHorizontalScrollBarEnabled [androidJvm] open fun setHorizontalScrollBarEnabled (p0: Boolean ) setHorizontalScrollbarThumbDrawable [androidJvm] open fun setHorizontalScrollbarThumbDrawable (p0: Drawable ?) setHorizontalScrollbarTrackDrawable [androidJvm] open fun setHorizontalScrollbarTrackDrawable (p0: Drawable ?) setHovered [androidJvm] open fun setHovered (p0: Boolean ) setId [androidJvm] open fun setId (p0: Int ) setImportantForAccessibility [androidJvm] open fun setImportantForAccessibility (p0: Int ) setImportantForAutofill [androidJvm] open fun setImportantForAutofill (p0: Int ) setImportantForContentCapture [androidJvm] open fun setImportantForContentCapture (p0: Int ) setKeepScreenOn [androidJvm] open fun setKeepScreenOn (p0: Boolean ) setKeyboardNavigationCluster [androidJvm] open fun setKeyboardNavigationCluster (p0: Boolean ) setLabelFor [androidJvm] open fun setLabelFor (p0: Int ) setLayerPaint [androidJvm] open fun setLayerPaint (p0: Paint ?) setLayerType [androidJvm] open fun setLayerType (p0: Int , p1: Paint ?) setLayoutAnimation [androidJvm] open fun setLayoutAnimation (p0: LayoutAnimationController ) setLayoutAnimationListener [androidJvm] open fun setLayoutAnimationListener (p0: Animation.AnimationListener ) setLayoutDirection [androidJvm] open fun setLayoutDirection (p0: Int ) setLayoutMode [androidJvm] open fun setLayoutMode (p0: Int ) setLayoutParams [androidJvm] open fun setLayoutParams (p0: ViewGroup.LayoutParams ) setLayoutTransition [androidJvm] open fun setLayoutTransition (p0: LayoutTransition ) setLeft [androidJvm] fun setLeft (p0: Int ) setLeftTopRightBottom [androidJvm] fun setLeftTopRightBottom (p0: Int , p1: Int , p2: Int , p3: Int ) setLongClickable [androidJvm] open fun setLongClickable (p0: Boolean ) setMeasureAllChildren [androidJvm] open fun setMeasureAllChildren (p0: Boolean ) setMeasuredDimension [androidJvm] fun setMeasuredDimension (p0: Int , p1: Int ) setMinimumHeight [androidJvm] open fun setMinimumHeight (p0: Int ) setMinimumWidth [androidJvm] open fun setMinimumWidth (p0: Int ) setMotionEventSplittingEnabled [androidJvm] open fun setMotionEventSplittingEnabled (p0: Boolean ) setNestedScrollingEnabled [androidJvm] open fun setNestedScrollingEnabled (p0: Boolean ) setNextClusterForwardId [androidJvm] open fun setNextClusterForwardId (p0: Int ) setNextFocusDownId [androidJvm] open fun setNextFocusDownId (p0: Int ) setNextFocusForwardId [androidJvm] open fun setNextFocusForwardId (p0: Int ) setNextFocusLeftId [androidJvm] open fun setNextFocusLeftId (p0: Int ) setNextFocusRightId [androidJvm] open fun setNextFocusRightId (p0: Int ) setNextFocusUpId [androidJvm] open fun setNextFocusUpId (p0: Int ) setOnApplyWindowInsetsListener [androidJvm] open fun setOnApplyWindowInsetsListener (p0: View.OnApplyWindowInsetsListener ) setOnCapturedPointerListener [androidJvm] open fun setOnCapturedPointerListener (p0: View.OnCapturedPointerListener ) setOnClickListener [androidJvm] open fun setOnClickListener (p0: View.OnClickListener ?) setOnContextClickListener [androidJvm] open fun setOnContextClickListener (p0: View.OnContextClickListener ?) setOnCreateContextMenuListener [androidJvm] open fun setOnCreateContextMenuListener (p0: View.OnCreateContextMenuListener ) setOnDragListener [androidJvm] open fun setOnDragListener (p0: View.OnDragListener ) setOnFocusChangeListener [androidJvm] open fun setOnFocusChangeListener (p0: View.OnFocusChangeListener ) setOnGenericMotionListener [androidJvm] open fun setOnGenericMotionListener (p0: View.OnGenericMotionListener ) setOnHierarchyChangeListener [androidJvm] open fun setOnHierarchyChangeListener (p0: ViewGroup.OnHierarchyChangeListener ) setOnHoverListener [androidJvm] open fun setOnHoverListener (p0: View.OnHoverListener ) setOnKeyListener [androidJvm] open fun setOnKeyListener (p0: View.OnKeyListener ) setOnLongClickListener [androidJvm] open fun setOnLongClickListener (p0: View.OnLongClickListener ?) setOnReceiveContentListener [androidJvm] open fun setOnReceiveContentListener (p0: Array < String >?, p1: OnReceiveContentListener ?) setOnScrollChangeListener [androidJvm] open fun setOnScrollChangeListener (p0: View.OnScrollChangeListener ) setOnTouchListener [androidJvm] open fun setOnTouchListener (p0: View.OnTouchListener ) setOutlineAmbientShadowColor [androidJvm] open fun setOutlineAmbientShadowColor (p0: Int ) setOutlineProvider [androidJvm] open fun setOutlineProvider (p0: ViewOutlineProvider ) setOutlineSpotShadowColor [androidJvm] open fun setOutlineSpotShadowColor (p0: Int ) setOverScrollMode [androidJvm] open fun setOverScrollMode (p0: Int ) setPadding [androidJvm] open fun setPadding (p0: Int , p1: Int , p2: Int , p3: Int ) setPaddingRelative [androidJvm] open fun setPaddingRelative (p0: Int , p1: Int , p2: Int , p3: Int ) setPivotX [androidJvm] open fun setPivotX (p0: Float ) setPivotY [androidJvm] open fun setPivotY (p0: Float ) setPointerIcon [androidJvm] open fun setPointerIcon (p0: PointerIcon ) setPressed [androidJvm] open fun setPressed (p0: Boolean ) setRenderEffect [androidJvm] open fun setRenderEffect (p0: RenderEffect ?) setRevealOnFocusHint [androidJvm] fun setRevealOnFocusHint (p0: Boolean ) setRight [androidJvm] fun setRight (p0: Int ) setRotation [androidJvm] open fun setRotation (p0: Float ) setRotationX [androidJvm] open fun setRotationX (p0: Float ) setRotationY [androidJvm] open fun setRotationY (p0: Float ) setSaveEnabled [androidJvm] open fun setSaveEnabled (p0: Boolean ) setSaveFromParentEnabled [androidJvm] open fun setSaveFromParentEnabled (p0: Boolean ) setScaleX [androidJvm] open fun setScaleX (p0: Float ) setScaleY [androidJvm] open fun setScaleY (p0: Float ) setScreenReaderFocusable [androidJvm] open fun setScreenReaderFocusable (p0: Boolean ) setScrollBarDefaultDelayBeforeFade [androidJvm] open fun setScrollBarDefaultDelayBeforeFade (p0: Int ) setScrollBarFadeDuration [androidJvm] open fun setScrollBarFadeDuration (p0: Int ) setScrollbarFadingEnabled [androidJvm] open fun setScrollbarFadingEnabled (p0: Boolean ) setScrollBarSize [androidJvm] open fun setScrollBarSize (p0: Int ) setScrollBarStyle [androidJvm] open fun setScrollBarStyle (p0: Int ) setScrollCaptureCallback [androidJvm] fun setScrollCaptureCallback (p0: ScrollCaptureCallback ?) setScrollCaptureHint [androidJvm] open fun setScrollCaptureHint (p0: Int ) setScrollContainer [androidJvm] open fun setScrollContainer (p0: Boolean ) setScrollIndicators [androidJvm] open fun setScrollIndicators (p0: Int ) open fun setScrollIndicators (p0: Int , p1: Int ) setScrollX [androidJvm] open fun setScrollX (p0: Int ) setScrollY [androidJvm] open fun setScrollY (p0: Int ) setSelected [androidJvm] open fun setSelected (p0: Boolean ) setSoundEffectsEnabled [androidJvm] open fun setSoundEffectsEnabled (p0: Boolean ) setStateDescription [androidJvm] open fun setStateDescription (p0: CharSequence ?) setStateListAnimator [androidJvm] open fun setStateListAnimator (p0: StateListAnimator ) setStaticTransformationsEnabled [androidJvm] open fun setStaticTransformationsEnabled (p0: Boolean ) setSystemGestureExclusionRects [androidJvm] open fun setSystemGestureExclusionRects (p0: MutableList < Rect >) setTag [androidJvm] open fun setTag (p0: Any ) open fun setTag (p0: Int , p1: Any ) setTextAlignment [androidJvm] open fun setTextAlignment (p0: Int ) setTextDirection [androidJvm] open fun setTextDirection (p0: Int ) setTooltipText [androidJvm] open fun setTooltipText (p0: CharSequence ?) setTop [androidJvm] fun setTop (p0: Int ) setTouchDelegate [androidJvm] open fun setTouchDelegate (p0: TouchDelegate ) setTouchscreenBlocksFocus [androidJvm] open fun setTouchscreenBlocksFocus (p0: Boolean ) setTransitionAlpha [androidJvm] open fun setTransitionAlpha (p0: Float ) setTransitionGroup [androidJvm] open fun setTransitionGroup (p0: Boolean ) setTransitionName [androidJvm] fun setTransitionName (p0: String ) setTransitionVisibility [androidJvm] open fun setTransitionVisibility (p0: Int ) setTranslationX [androidJvm] open fun setTranslationX (p0: Float ) setTranslationY [androidJvm] open fun setTranslationY (p0: Float ) setTranslationZ [androidJvm] open fun setTranslationZ (p0: Float ) setVerticalFadingEdgeEnabled [androidJvm] open fun setVerticalFadingEdgeEnabled (p0: Boolean ) setVerticalScrollBarEnabled [androidJvm] open fun setVerticalScrollBarEnabled (p0: Boolean ) setVerticalScrollbarPosition [androidJvm] open fun setVerticalScrollbarPosition (p0: Int ) setVerticalScrollbarThumbDrawable [androidJvm] open fun setVerticalScrollbarThumbDrawable (p0: Drawable ?) setVerticalScrollbarTrackDrawable [androidJvm] open fun setVerticalScrollbarTrackDrawable (p0: Drawable ?) setViewTranslationCallback [androidJvm] open fun setViewTranslationCallback (p0: ViewTranslationCallback ) setVisibility [androidJvm] open fun setVisibility (p0: Int ) setWillNotDraw [androidJvm] open fun setWillNotDraw (p0: Boolean ) setWindowInsetsAnimationCallback [androidJvm] open override fun setWindowInsetsAnimationCallback (p0: WindowInsetsAnimation.Callback ?) setX [androidJvm] open fun setX (p0: Float ) setY [androidJvm] open fun setY (p0: Float ) setZ [androidJvm] open fun setZ (p0: Float ) shouldDelayChildPressedState [androidJvm] open override fun shouldDelayChildPressedState (): Boolean showContextMenu [androidJvm] open fun showContextMenu (): Boolean open fun showContextMenu (p0: Float , p1: Float ): Boolean showContextMenuForChild [androidJvm] open override fun showContextMenuForChild (p0: View ): Boolean open override fun showContextMenuForChild (p0: View , p1: Float , p2: Float ): Boolean startActionMode [androidJvm] open fun startActionMode (p0: ActionMode.Callback ): ActionMode open fun startActionMode (p0: ActionMode.Callback , p1: Int ): ActionMode startActionModeForChild [androidJvm] open override fun startActionModeForChild (p0: View , p1: ActionMode.Callback ): ActionMode open override fun startActionModeForChild (p0: View , p1: ActionMode.Callback , p2: Int ): ActionMode startAnimation [androidJvm] open fun startAnimation (p0: Animation ) startDragAndDrop [androidJvm] fun startDragAndDrop (p0: ClipData , p1: View.DragShadowBuilder , p2: Any , p3: Int ): Boolean startLayoutAnimation [androidJvm] open fun startLayoutAnimation () startNestedScroll [androidJvm] open fun startNestedScroll (p0: Int ): Boolean startViewTransition [androidJvm] open fun startViewTransition (p0: View ) stopNestedScroll [androidJvm] open fun stopNestedScroll () suppressLayout [androidJvm] open fun suppressLayout (p0: Boolean ) toString [androidJvm] open override fun toString (): String transformMatrixToGlobal [androidJvm] open fun transformMatrixToGlobal (p0: Matrix ) transformMatrixToLocal [androidJvm] open fun transformMatrixToLocal (p0: Matrix ) unscheduleDrawable [androidJvm] open fun unscheduleDrawable (p0: Drawable ) open override fun unscheduleDrawable (p0: Drawable , p1: Runnable ) updateDragShadow [androidJvm] fun updateDragShadow (p0: View.DragShadowBuilder ) updateViewLayout [androidJvm] open override fun updateViewLayout (p0: View , p1: ViewGroup.LayoutParams ) verifyDrawable [androidJvm] open fun verifyDrawable (p0: Drawable ): Boolean willNotDraw [androidJvm] open fun willNotDraw (): Boolean","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-back-stack-container/#backstackcontainer","text":"[androidJvm]\\ @WorkflowUiExperimentalApi open class BackStackContainer @ JvmOverloads constructor(context: Context , attributeSet: AttributeSet ?, defStyle: Int , defStyleRes: Int ) : FrameLayout A container view that can display a stream of BackStackScreen instances. This container supports saving and restoring the view state of each of its subviews corresponding to the renderings in its BackStackScreen. It supports two distinct state mechanisms: Classic view hierarchy state ([View.onSaveInstanceState](../../com.squareup.workflow1.ui/-workflow-view-stub/index.md#1773232604%2FFunctions%2F576965167)/[View.onRestoreInstanceState](../../com.squareup.workflow1.ui/-workflow-view-stub/index.md#-648840093%2FFunctions%2F576965167)) AndroidX [SavedStateRegistry](https://developer.android.com/reference/kotlin/androidx/savedstate/SavedStateRegistry.html) via [ViewTreeSavedStateRegistryOwner](https://developer.android.com/reference/kotlin/androidx/savedstate/ViewTreeSavedStateRegistryOwner.html).","title":"BackStackContainer"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-back-stack-container/#a-note-about-savedstateregistry-support","text":"The SavedStateRegistry API involves defining string keys to associate with state bundles. These keys must be unique relative to the instance of the registry they are saved in. To support this requirement, BackStackContainer tries to generate a best-effort unique key by combining its fully-qualified class name with both its view ID and the compatibility key of its rendering. This method isn\u2019t guaranteed to give a unique registry key, but it should be good enough: If you need to nest multiple BackStackContainer s under the same SavedStateRegistry, just wrap each BackStackScreen with a Named, or give each BackStackContainer a unique view ID. There\u2019s a potential issue here where if our ID is changed to something else, then another BackStackContainer is added with our old ID, that container will overwrite our state. Since they\u2019d both be using the same key, SavedStateRegistry would throw an exception. As long as this container is detached before its ID is changed, it shouldn\u2019t be a problem.","title":"A note about SavedStateRegistry support."},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-back-stack-container/#constructors","text":"BackStackContainer [androidJvm] @ JvmOverloads fun BackStackContainer (context: Context , attributeSet: AttributeSet ? = null, defStyle: Int = 0, defStyleRes: Int = 0)","title":"Constructors"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-back-stack-container/#types","text":"Name Summary Companion [androidJvm] object Companion : ViewFactory <BackStackScreen<*>>","title":"Types"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-back-stack-container/#functions","text":"Name Summary addChildrenForAccessibility [androidJvm] open override fun addChildrenForAccessibility (p0: ArrayList < View >) addExtraDataToAccessibilityNodeInfo [androidJvm] open override fun addExtraDataToAccessibilityNodeInfo (p0: AccessibilityNodeInfo , p1: String , p2: Bundle ?) addFocusables [androidJvm] open fun addFocusables (p0: ArrayList < View >, p1: Int ) open override fun addFocusables (p0: ArrayList < View >, p1: Int , p2: Int ) addKeyboardNavigationClusters [androidJvm] open override fun addKeyboardNavigationClusters (p0: MutableCollection < View >, p1: Int ) addOnAttachStateChangeListener [androidJvm] open fun addOnAttachStateChangeListener (p0: View.OnAttachStateChangeListener ) addOnLayoutChangeListener [androidJvm] open fun addOnLayoutChangeListener (p0: View.OnLayoutChangeListener ) addOnUnhandledKeyEventListener [androidJvm] open fun addOnUnhandledKeyEventListener (p0: View.OnUnhandledKeyEventListener ) addStatesFromChildren [androidJvm] open fun addStatesFromChildren (): Boolean addTouchables [androidJvm] open override fun addTouchables (p0: ArrayList < View >) addView [androidJvm] open fun addView (p0: View ) open override fun addView (p0: View , p1: ViewGroup.LayoutParams ) open fun addView (p0: View , p1: Int ) open fun addView (p0: View , p1: Int , p2: ViewGroup.LayoutParams ) open fun addView (p0: View , p1: Int , p2: Int ) addViewInLayout [androidJvm] open fun addViewInLayout (p0: View , p1: Int , p2: ViewGroup.LayoutParams ): Boolean open fun addViewInLayout (p0: View , p1: Int , p2: ViewGroup.LayoutParams , p3: Boolean ): Boolean animate [androidJvm] open fun animate (): ViewPropertyAnimator announceForAccessibility [androidJvm] open fun announceForAccessibility (p0: CharSequence ) attachLayoutAnimationParameters [androidJvm] open fun attachLayoutAnimationParameters (p0: View , p1: ViewGroup.LayoutParams , p2: Int , p3: Int ) attachViewToParent [androidJvm] open fun attachViewToParent (p0: View , p1: Int , p2: ViewGroup.LayoutParams ) autofill [androidJvm] open fun autofill (p0: SparseArray < AutofillValue >) open fun autofill (p0: AutofillValue ) awakenScrollBars [androidJvm] open fun awakenScrollBars (): Boolean open fun awakenScrollBars (p0: Int ): Boolean open fun awakenScrollBars (p0: Int , p1: Boolean ): Boolean bringChildToFront [androidJvm] open override fun bringChildToFront (p0: View ) bringToFront [androidJvm] open fun bringToFront () buildLayer [androidJvm] open fun buildLayer () callOnClick [androidJvm] open fun callOnClick (): Boolean canAnimate [androidJvm] open fun canAnimate (): Boolean cancelDragAndDrop [androidJvm] fun cancelDragAndDrop () cancelLongPress [androidJvm] open fun cancelLongPress () cancelPendingInputEvents [androidJvm] fun cancelPendingInputEvents () canResolveLayoutDirection [androidJvm] open fun canResolveLayoutDirection (): Boolean canResolveTextAlignment [androidJvm] open fun canResolveTextAlignment (): Boolean canResolveTextDirection [androidJvm] open fun canResolveTextDirection (): Boolean canScrollHorizontally [androidJvm] open fun canScrollHorizontally (p0: Int ): Boolean canScrollVertically [androidJvm] open fun canScrollVertically (p0: Int ): Boolean checkInputConnectionProxy [androidJvm] open fun checkInputConnectionProxy (p0: View ): Boolean checkLayoutParams [androidJvm] open override fun checkLayoutParams (p0: ViewGroup.LayoutParams ): Boolean childDrawableStateChanged [androidJvm] open override fun childDrawableStateChanged (p0: View ) childHasTransientStateChanged [androidJvm] open override fun childHasTransientStateChanged (p0: View , p1: Boolean ) cleanupLayoutState [androidJvm] open fun cleanupLayoutState (p0: View ) clearAnimation [androidJvm] open fun clearAnimation () clearChildFocus [androidJvm] open override fun clearChildFocus (p0: View ) clearDisappearingChildren [androidJvm] open fun clearDisappearingChildren () clearFocus [androidJvm] open override fun clearFocus () clearViewTranslationCallback [androidJvm] open fun clearViewTranslationCallback () computeHorizontalScrollExtent [androidJvm] open fun computeHorizontalScrollExtent (): Int computeHorizontalScrollOffset [androidJvm] open fun computeHorizontalScrollOffset (): Int computeHorizontalScrollRange [androidJvm] open fun computeHorizontalScrollRange (): Int computeScroll [androidJvm] open fun computeScroll () computeSystemWindowInsets [androidJvm] open fun computeSystemWindowInsets (p0: WindowInsets , p1: Rect ): WindowInsets computeVerticalScrollExtent [androidJvm] open fun computeVerticalScrollExtent (): Int computeVerticalScrollOffset [androidJvm] open fun computeVerticalScrollOffset (): Int computeVerticalScrollRange [androidJvm] open fun computeVerticalScrollRange (): Int createAccessibilityNodeInfo [androidJvm] open fun createAccessibilityNodeInfo (): AccessibilityNodeInfo createContextMenu [androidJvm] open fun createContextMenu (p0: ContextMenu ) debug [androidJvm] open fun debug (p0: Int ) detachAllViewsFromParent [androidJvm] open fun detachAllViewsFromParent () detachViewFromParent [androidJvm] open fun detachViewFromParent (p0: View ) open fun detachViewFromParent (p0: Int ) detachViewsFromParent [androidJvm] open fun detachViewsFromParent (p0: Int , p1: Int ) dispatchApplyWindowInsets [androidJvm] open override fun dispatchApplyWindowInsets (p0: WindowInsets ): WindowInsets dispatchCapturedPointerEvent [androidJvm] open override fun dispatchCapturedPointerEvent (p0: MotionEvent ): Boolean dispatchConfigurationChanged [androidJvm] open override fun dispatchConfigurationChanged (p0: Configuration ) dispatchCreateViewTranslationRequest [androidJvm] open override fun dispatchCreateViewTranslationRequest (p0: MutableMap < AutofillId , LongArray >, p1: IntArray , p2: TranslationCapability , p3: MutableList < ViewTranslationRequest >) dispatchDisplayHint [androidJvm] open override fun dispatchDisplayHint (p0: Int ) dispatchDragEvent [androidJvm] open override fun dispatchDragEvent (p0: DragEvent ): Boolean dispatchDraw [androidJvm] open override fun dispatchDraw (p0: Canvas ) dispatchDrawableHotspotChanged [androidJvm] open override fun dispatchDrawableHotspotChanged (p0: Float , p1: Float ) dispatchFinishTemporaryDetach [androidJvm] open override fun dispatchFinishTemporaryDetach () dispatchFreezeSelfOnly [androidJvm] open fun dispatchFreezeSelfOnly (p0: SparseArray < Parcelable >) dispatchGenericFocusedEvent [androidJvm] open override fun dispatchGenericFocusedEvent (p0: MotionEvent ): Boolean dispatchGenericMotionEvent [androidJvm] open fun dispatchGenericMotionEvent (p0: MotionEvent ): Boolean dispatchGenericPointerEvent [androidJvm] open override fun dispatchGenericPointerEvent (p0: MotionEvent ): Boolean dispatchHoverEvent [androidJvm] open override fun dispatchHoverEvent (p0: MotionEvent ): Boolean dispatchKeyEvent [androidJvm] open override fun dispatchKeyEvent (p0: KeyEvent ): Boolean dispatchKeyEventPreIme [androidJvm] open override fun dispatchKeyEventPreIme (p0: KeyEvent ): Boolean dispatchKeyShortcutEvent [androidJvm] open override fun dispatchKeyShortcutEvent (p0: KeyEvent ): Boolean dispatchNestedFling [androidJvm] open fun dispatchNestedFling (p0: Float , p1: Float , p2: Boolean ): Boolean dispatchNestedPreFling [androidJvm] open fun dispatchNestedPreFling (p0: Float , p1: Float ): Boolean dispatchNestedPrePerformAccessibilityAction [androidJvm] open fun dispatchNestedPrePerformAccessibilityAction (p0: Int , p1: Bundle ): Boolean dispatchNestedPreScroll [androidJvm] open fun dispatchNestedPreScroll (p0: Int , p1: Int , p2: IntArray ?, p3: IntArray ?): Boolean dispatchNestedScroll [androidJvm] open fun dispatchNestedScroll (p0: Int , p1: Int , p2: Int , p3: Int , p4: IntArray ?): Boolean dispatchPointerCaptureChanged [androidJvm] open override fun dispatchPointerCaptureChanged (p0: Boolean ) dispatchPopulateAccessibilityEvent [androidJvm] open fun dispatchPopulateAccessibilityEvent (p0: AccessibilityEvent ): Boolean dispatchProvideAutofillStructure [androidJvm] open override fun dispatchProvideAutofillStructure (p0: ViewStructure , p1: Int ) dispatchProvideStructure [androidJvm] open override fun dispatchProvideStructure (p0: ViewStructure ) dispatchRestoreInstanceState [androidJvm] open override fun dispatchRestoreInstanceState (p0: SparseArray < Parcelable >) dispatchSaveInstanceState [androidJvm] open override fun dispatchSaveInstanceState (p0: SparseArray < Parcelable >) dispatchScrollCaptureSearch [androidJvm] open override fun dispatchScrollCaptureSearch (p0: Rect , p1: Point , p2: Consumer < ScrollCaptureTarget >) dispatchSetActivated [androidJvm] open override fun dispatchSetActivated (p0: Boolean ) dispatchSetPressed [androidJvm] open override fun dispatchSetPressed (p0: Boolean ) dispatchSetSelected [androidJvm] open override fun dispatchSetSelected (p0: Boolean ) dispatchStartTemporaryDetach [androidJvm] open override fun dispatchStartTemporaryDetach () dispatchThawSelfOnly [androidJvm] open fun dispatchThawSelfOnly (p0: SparseArray < Parcelable >) dispatchTouchEvent [androidJvm] open override fun dispatchTouchEvent (p0: MotionEvent ): Boolean dispatchTrackballEvent [androidJvm] open override fun dispatchTrackballEvent (p0: MotionEvent ): Boolean dispatchUnhandledMove [androidJvm] open override fun dispatchUnhandledMove (p0: View , p1: Int ): Boolean dispatchVisibilityChanged [androidJvm] open override fun dispatchVisibilityChanged (p0: View , p1: Int ) dispatchWindowFocusChanged [androidJvm] open override fun dispatchWindowFocusChanged (p0: Boolean ) dispatchWindowInsetsAnimationEnd [androidJvm] open override fun dispatchWindowInsetsAnimationEnd (p0: WindowInsetsAnimation ) dispatchWindowInsetsAnimationPrepare [androidJvm] open override fun dispatchWindowInsetsAnimationPrepare (p0: WindowInsetsAnimation ) dispatchWindowInsetsAnimationProgress [androidJvm] open override fun dispatchWindowInsetsAnimationProgress (p0: WindowInsets , p1: MutableList < WindowInsetsAnimation >): WindowInsets dispatchWindowInsetsAnimationStart [androidJvm] open override fun dispatchWindowInsetsAnimationStart (p0: WindowInsetsAnimation , p1: WindowInsetsAnimation.Bounds ): WindowInsetsAnimation.Bounds dispatchWindowVisibilityChanged [androidJvm] open override fun dispatchWindowVisibilityChanged (p0: Int ) draw [androidJvm] open fun draw (p0: Canvas ) drawableHotspotChanged [androidJvm] open fun drawableHotspotChanged (p0: Float , p1: Float ) drawableStateChanged [androidJvm] open override fun drawableStateChanged () drawChild [androidJvm] open fun drawChild (p0: Canvas , p1: View , p2: Long ): Boolean endViewTransition [androidJvm] open fun endViewTransition (p0: View ) findFocus [androidJvm] open override fun findFocus (): View findViewById [androidJvm] fun < T : View > findViewById (p0: Int ): T findViewsWithText [androidJvm] open override fun findViewsWithText (p0: ArrayList < View >, p1: CharSequence , p2: Int ) findViewWithTag [androidJvm] fun < T : View > findViewWithTag (p0: Any ): T focusableViewAvailable [androidJvm] open override fun focusableViewAvailable (p0: View ) focusSearch [androidJvm] open fun focusSearch (p0: Int ): View open override fun focusSearch (p0: View , p1: Int ): View forceHasOverlappingRendering [androidJvm] open fun forceHasOverlappingRendering (p0: Boolean ) forceLayout [androidJvm] open fun forceLayout () gatherTransparentRegion [androidJvm] open override fun gatherTransparentRegion (p0: Region ?): Boolean generateDefaultLayoutParams [androidJvm] open override fun generateDefaultLayoutParams (): FrameLayout.LayoutParams generateDisplayHash [androidJvm] open fun generateDisplayHash (p0: String , p1: Rect ?, p2: Executor , p3: DisplayHashResultCallback ) generateLayoutParams [androidJvm] open override fun generateLayoutParams (p0: AttributeSet ): FrameLayout.LayoutParams open override fun generateLayoutParams (p0: ViewGroup.LayoutParams ): ViewGroup.LayoutParams getAccessibilityClassName [androidJvm] open override fun getAccessibilityClassName (): CharSequence getAccessibilityDelegate [androidJvm] open fun getAccessibilityDelegate (): View.AccessibilityDelegate getAccessibilityLiveRegion [androidJvm] open fun getAccessibilityLiveRegion (): Int getAccessibilityNodeProvider [androidJvm] open fun getAccessibilityNodeProvider (): AccessibilityNodeProvider getAccessibilityPaneTitle [androidJvm] open fun getAccessibilityPaneTitle (): CharSequence ? getAccessibilityTraversalAfter [androidJvm] open fun getAccessibilityTraversalAfter (): Int getAccessibilityTraversalBefore [androidJvm] open fun getAccessibilityTraversalBefore (): Int getAlpha [androidJvm] open fun getAlpha (): Float getAnimation [androidJvm] open fun getAnimation (): Animation getAnimationMatrix [androidJvm] open fun getAnimationMatrix (): Matrix ? getApplicationWindowToken [androidJvm] open fun getApplicationWindowToken (): IBinder getAttributeResolutionStack [androidJvm] open fun getAttributeResolutionStack (p0: Int ): IntArray getAttributeSourceResourceMap [androidJvm] open fun getAttributeSourceResourceMap (): MutableMap < Int , Int > getAutofillHints [androidJvm] open fun getAutofillHints (): Array < String >? getAutofillId [androidJvm] fun getAutofillId (): AutofillId getAutofillType [androidJvm] open fun getAutofillType (): Int getAutofillValue [androidJvm] open fun getAutofillValue (): AutofillValue ? getBackground [androidJvm] open fun getBackground (): Drawable getBackgroundTintBlendMode [androidJvm] open fun getBackgroundTintBlendMode (): BlendMode ? getBackgroundTintList [androidJvm] open fun getBackgroundTintList (): ColorStateList ? getBackgroundTintMode [androidJvm] open fun getBackgroundTintMode (): PorterDuff.Mode ? getBaseline [androidJvm] open fun getBaseline (): Int getBottom [androidJvm] fun getBottom (): Int getBottomFadingEdgeStrength [androidJvm] open fun getBottomFadingEdgeStrength (): Float getBottomPaddingOffset [androidJvm] open fun getBottomPaddingOffset (): Int getCameraDistance [androidJvm] open fun getCameraDistance (): Float getChildAt [androidJvm] open fun getChildAt (p0: Int ): View getChildCount [androidJvm] open fun getChildCount (): Int getChildDrawingOrder [androidJvm] fun getChildDrawingOrder (p0: Int ): Int open fun getChildDrawingOrder (p0: Int , p1: Int ): Int getChildStaticTransformation [androidJvm] open fun getChildStaticTransformation (p0: View , p1: Transformation ): Boolean getChildVisibleRect [androidJvm] open override fun getChildVisibleRect (p0: View , p1: Rect , p2: Point ): Boolean getClipBounds [androidJvm] open fun getClipBounds (): Rect open fun getClipBounds (p0: Rect ): Boolean getClipChildren [androidJvm] open fun getClipChildren (): Boolean getClipToOutline [androidJvm] fun getClipToOutline (): Boolean getClipToPadding [androidJvm] open fun getClipToPadding (): Boolean getContentCaptureSession [androidJvm] fun getContentCaptureSession (): ContentCaptureSession ? getContentDescription [androidJvm] open fun getContentDescription (): CharSequence getContext [androidJvm] fun getContext (): Context getContextMenuInfo [androidJvm] open fun getContextMenuInfo (): ContextMenu.ContextMenuInfo getDefaultFocusHighlightEnabled [androidJvm] fun getDefaultFocusHighlightEnabled (): Boolean getDescendantFocusability [androidJvm] open fun getDescendantFocusability (): Int getDisplay [androidJvm] open fun getDisplay (): Display getDrawableState [androidJvm] fun getDrawableState (): IntArray getDrawingRect [androidJvm] open fun getDrawingRect (p0: Rect ) getDrawingTime [androidJvm] open fun getDrawingTime (): Long getElevation [androidJvm] open fun getElevation (): Float getExplicitStyle [androidJvm] open fun getExplicitStyle (): Int getFilterTouchesWhenObscured [androidJvm] open fun getFilterTouchesWhenObscured (): Boolean getFitsSystemWindows [androidJvm] open fun getFitsSystemWindows (): Boolean getFocusable [androidJvm] open fun getFocusable (): Int getFocusables [androidJvm] open fun getFocusables (p0: Int ): ArrayList < View > getFocusedChild [androidJvm] open fun getFocusedChild (): View getFocusedRect [androidJvm] open fun getFocusedRect (p0: Rect ) getForeground [androidJvm] open fun getForeground (): Drawable getForegroundGravity [androidJvm] open fun getForegroundGravity (): Int getForegroundTintBlendMode [androidJvm] open fun getForegroundTintBlendMode (): BlendMode ? getForegroundTintList [androidJvm] open fun getForegroundTintList (): ColorStateList ? getForegroundTintMode [androidJvm] open fun getForegroundTintMode (): PorterDuff.Mode ? getGlobalVisibleRect [androidJvm] fun getGlobalVisibleRect (p0: Rect ): Boolean open fun getGlobalVisibleRect (p0: Rect , p1: Point ): Boolean getHandler [androidJvm] open fun getHandler (): Handler getHasOverlappingRendering [androidJvm] fun getHasOverlappingRendering (): Boolean getHeight [androidJvm] fun getHeight (): Int getHitRect [androidJvm] open fun getHitRect (p0: Rect ) getHorizontalFadingEdgeLength [androidJvm] open fun getHorizontalFadingEdgeLength (): Int getHorizontalScrollbarHeight [androidJvm] open fun getHorizontalScrollbarHeight (): Int getHorizontalScrollbarThumbDrawable [androidJvm] open fun getHorizontalScrollbarThumbDrawable (): Drawable ? getHorizontalScrollbarTrackDrawable [androidJvm] open fun getHorizontalScrollbarTrackDrawable (): Drawable ? getId [androidJvm] open fun getId (): Int getImportantForAccessibility [androidJvm] open fun getImportantForAccessibility (): Int getImportantForAutofill [androidJvm] open fun getImportantForAutofill (): Int getImportantForContentCapture [androidJvm] open fun getImportantForContentCapture (): Int getKeepScreenOn [androidJvm] open fun getKeepScreenOn (): Boolean getKeyDispatcherState [androidJvm] open fun getKeyDispatcherState (): KeyEvent.DispatcherState getLabelFor [androidJvm] open fun getLabelFor (): Int getLayerType [androidJvm] open fun getLayerType (): Int getLayoutAnimation [androidJvm] open fun getLayoutAnimation (): LayoutAnimationController getLayoutAnimationListener [androidJvm] open fun getLayoutAnimationListener (): Animation.AnimationListener getLayoutDirection [androidJvm] open fun getLayoutDirection (): Int getLayoutMode [androidJvm] open fun getLayoutMode (): Int getLayoutParams [androidJvm] open fun getLayoutParams (): ViewGroup.LayoutParams getLayoutTransition [androidJvm] open fun getLayoutTransition (): LayoutTransition getLeft [androidJvm] fun getLeft (): Int getLeftFadingEdgeStrength [androidJvm] open fun getLeftFadingEdgeStrength (): Float getLeftPaddingOffset [androidJvm] open fun getLeftPaddingOffset (): Int getLocalVisibleRect [androidJvm] fun getLocalVisibleRect (p0: Rect ): Boolean getLocationInSurface [androidJvm] open fun getLocationInSurface (p0: IntArray ) getLocationInWindow [androidJvm] open fun getLocationInWindow (p0: IntArray ) getLocationOnScreen [androidJvm] open fun getLocationOnScreen (p0: IntArray ) getMatrix [androidJvm] open fun getMatrix (): Matrix getMeasureAllChildren [androidJvm] open fun getMeasureAllChildren (): Boolean getMeasuredHeight [androidJvm] fun getMeasuredHeight (): Int getMeasuredHeightAndState [androidJvm] fun getMeasuredHeightAndState (): Int getMeasuredState [androidJvm] fun getMeasuredState (): Int getMeasuredWidth [androidJvm] fun getMeasuredWidth (): Int getMeasuredWidthAndState [androidJvm] fun getMeasuredWidthAndState (): Int getMinimumHeight [androidJvm] open fun getMinimumHeight (): Int getMinimumWidth [androidJvm] open fun getMinimumWidth (): Int getNestedScrollAxes [androidJvm] open fun getNestedScrollAxes (): Int getNextClusterForwardId [androidJvm] open fun getNextClusterForwardId (): Int getNextFocusDownId [androidJvm] open fun getNextFocusDownId (): Int getNextFocusForwardId [androidJvm] open fun getNextFocusForwardId (): Int getNextFocusLeftId [androidJvm] open fun getNextFocusLeftId (): Int getNextFocusRightId [androidJvm] open fun getNextFocusRightId (): Int getNextFocusUpId [androidJvm] open fun getNextFocusUpId (): Int getOnFocusChangeListener [androidJvm] open fun getOnFocusChangeListener (): View.OnFocusChangeListener getOutlineAmbientShadowColor [androidJvm] open fun getOutlineAmbientShadowColor (): Int getOutlineProvider [androidJvm] open fun getOutlineProvider (): ViewOutlineProvider getOutlineSpotShadowColor [androidJvm] open fun getOutlineSpotShadowColor (): Int getOverlay [androidJvm] open override fun getOverlay (): ViewGroupOverlay getOverScrollMode [androidJvm] open fun getOverScrollMode (): Int getPaddingBottom [androidJvm] open fun getPaddingBottom (): Int getPaddingEnd [androidJvm] open fun getPaddingEnd (): Int getPaddingLeft [androidJvm] open fun getPaddingLeft (): Int getPaddingRight [androidJvm] open fun getPaddingRight (): Int getPaddingStart [androidJvm] open fun getPaddingStart (): Int getPaddingTop [androidJvm] open fun getPaddingTop (): Int getParent [androidJvm] fun getParent (): ViewParent getParentForAccessibility [androidJvm] open fun getParentForAccessibility (): ViewParent getPivotX [androidJvm] open fun getPivotX (): Float getPivotY [androidJvm] open fun getPivotY (): Float getPointerIcon [androidJvm] open fun getPointerIcon (): PointerIcon getReceiveContentMimeTypes [androidJvm] open fun getReceiveContentMimeTypes (): Array < String >? getResources [androidJvm] open fun getResources (): Resources getRevealOnFocusHint [androidJvm] fun getRevealOnFocusHint (): Boolean getRight [androidJvm] fun getRight (): Int getRightFadingEdgeStrength [androidJvm] open fun getRightFadingEdgeStrength (): Float getRightPaddingOffset [androidJvm] open fun getRightPaddingOffset (): Int getRootSurfaceControl [androidJvm] open fun getRootSurfaceControl (): AttachedSurfaceControl ? getRootView [androidJvm] open fun getRootView (): View getRootWindowInsets [androidJvm] open fun getRootWindowInsets (): WindowInsets getRotation [androidJvm] open fun getRotation (): Float getRotationX [androidJvm] open fun getRotationX (): Float getRotationY [androidJvm] open fun getRotationY (): Float getScaleX [androidJvm] open fun getScaleX (): Float getScaleY [androidJvm] open fun getScaleY (): Float getScrollBarDefaultDelayBeforeFade [androidJvm] open fun getScrollBarDefaultDelayBeforeFade (): Int getScrollBarFadeDuration [androidJvm] open fun getScrollBarFadeDuration (): Int getScrollBarSize [androidJvm] open fun getScrollBarSize (): Int getScrollBarStyle [androidJvm] open fun getScrollBarStyle (): Int getScrollCaptureHint [androidJvm] open fun getScrollCaptureHint (): Int getScrollIndicators [androidJvm] open fun getScrollIndicators (): Int getScrollX [androidJvm] fun getScrollX (): Int getScrollY [androidJvm] fun getScrollY (): Int getSolidColor [androidJvm] open fun getSolidColor (): Int getSourceLayoutResId [androidJvm] open fun getSourceLayoutResId (): Int getStateDescription [androidJvm] fun getStateDescription (): CharSequence ? getStateListAnimator [androidJvm] open fun getStateListAnimator (): StateListAnimator getSuggestedMinimumHeight [androidJvm] open fun getSuggestedMinimumHeight (): Int getSuggestedMinimumWidth [androidJvm] open fun getSuggestedMinimumWidth (): Int getSystemGestureExclusionRects [androidJvm] open fun getSystemGestureExclusionRects (): MutableList < Rect > getTag [androidJvm] open fun getTag (): Any open fun getTag (p0: Int ): Any getTextAlignment [androidJvm] open fun getTextAlignment (): Int getTextDirection [androidJvm] open fun getTextDirection (): Int getTooltipText [androidJvm] open fun getTooltipText (): CharSequence ? getTop [androidJvm] fun getTop (): Int getTopFadingEdgeStrength [androidJvm] open fun getTopFadingEdgeStrength (): Float getTopPaddingOffset [androidJvm] open fun getTopPaddingOffset (): Int getTouchables [androidJvm] open fun getTouchables (): ArrayList < View > getTouchDelegate [androidJvm] open fun getTouchDelegate (): TouchDelegate getTouchscreenBlocksFocus [androidJvm] open fun getTouchscreenBlocksFocus (): Boolean getTransitionAlpha [androidJvm] open fun getTransitionAlpha (): Float getTransitionName [androidJvm] open fun getTransitionName (): String getTranslationX [androidJvm] open fun getTranslationX (): Float getTranslationY [androidJvm] open fun getTranslationY (): Float getTranslationZ [androidJvm] open fun getTranslationZ (): Float getUniqueDrawingId [androidJvm] open fun getUniqueDrawingId (): Long getVerticalFadingEdgeLength [androidJvm] open fun getVerticalFadingEdgeLength (): Int getVerticalScrollbarPosition [androidJvm] open fun getVerticalScrollbarPosition (): Int getVerticalScrollbarThumbDrawable [androidJvm] open fun getVerticalScrollbarThumbDrawable (): Drawable ? getVerticalScrollbarTrackDrawable [androidJvm] open fun getVerticalScrollbarTrackDrawable (): Drawable ? getVerticalScrollbarWidth [androidJvm] open fun getVerticalScrollbarWidth (): Int getViewTranslationResponse [androidJvm] open fun getViewTranslationResponse (): ViewTranslationResponse ? getViewTreeObserver [androidJvm] open fun getViewTreeObserver (): ViewTreeObserver getVisibility [androidJvm] open fun getVisibility (): Int getWidth [androidJvm] fun getWidth (): Int getWindowAttachCount [androidJvm] open fun getWindowAttachCount (): Int getWindowId [androidJvm] open fun getWindowId (): WindowId getWindowInsetsController [androidJvm] open fun getWindowInsetsController (): WindowInsetsController ? getWindowToken [androidJvm] open fun getWindowToken (): IBinder getWindowVisibility [androidJvm] open fun getWindowVisibility (): Int getWindowVisibleDisplayFrame [androidJvm] open fun getWindowVisibleDisplayFrame (p0: Rect ) getX [androidJvm] open fun getX (): Float getY [androidJvm] open fun getY (): Float getZ [androidJvm] open fun getZ (): Float hasExplicitFocusable [androidJvm] open fun hasExplicitFocusable (): Boolean hasFocus [androidJvm] open override fun hasFocus (): Boolean hasFocusable [androidJvm] open fun hasFocusable (): Boolean hasNestedScrollingParent [androidJvm] open fun hasNestedScrollingParent (): Boolean hasOnClickListeners [androidJvm] open fun hasOnClickListeners (): Boolean hasOnLongClickListeners [androidJvm] open fun hasOnLongClickListeners (): Boolean hasOverlappingRendering [androidJvm] open fun hasOverlappingRendering (): Boolean hasPointerCapture [androidJvm] open fun hasPointerCapture (): Boolean hasTransientState [androidJvm] open override fun hasTransientState (): Boolean hasWindowFocus [androidJvm] open fun hasWindowFocus (): Boolean indexOfChild [androidJvm] open fun indexOfChild (p0: View ): Int invalidate [androidJvm] open fun invalidate () invalidateDrawable [androidJvm] open override fun invalidateDrawable (p0: Drawable ) invalidateOutline [androidJvm] open fun invalidateOutline () isAccessibilityFocused [androidJvm] open fun isAccessibilityFocused (): Boolean isAccessibilityHeading [androidJvm] open fun isAccessibilityHeading (): Boolean isActivated [androidJvm] open fun isActivated (): Boolean isAttachedToWindow [androidJvm] open fun isAttachedToWindow (): Boolean isChildrenDrawingOrderEnabled [androidJvm] open fun isChildrenDrawingOrderEnabled (): Boolean isClickable [androidJvm] open fun isClickable (): Boolean isContextClickable [androidJvm] open fun isContextClickable (): Boolean isDirty [androidJvm] open fun isDirty (): Boolean isDuplicateParentStateEnabled [androidJvm] open fun isDuplicateParentStateEnabled (): Boolean isEnabled [androidJvm] open fun isEnabled (): Boolean isFocusable [androidJvm] fun isFocusable (): Boolean isFocusableInTouchMode [androidJvm] fun isFocusableInTouchMode (): Boolean isFocused [androidJvm] open fun isFocused (): Boolean isFocusedByDefault [androidJvm] fun isFocusedByDefault (): Boolean isForceDarkAllowed [androidJvm] open fun isForceDarkAllowed (): Boolean isHapticFeedbackEnabled [androidJvm] open fun isHapticFeedbackEnabled (): Boolean isHardwareAccelerated [androidJvm] open fun isHardwareAccelerated (): Boolean isHorizontalFadingEdgeEnabled [androidJvm] open fun isHorizontalFadingEdgeEnabled (): Boolean isHorizontalScrollBarEnabled [androidJvm] open fun isHorizontalScrollBarEnabled (): Boolean isHovered [androidJvm] open fun isHovered (): Boolean isImportantForAccessibility [androidJvm] open fun isImportantForAccessibility (): Boolean isImportantForAutofill [androidJvm] fun isImportantForAutofill (): Boolean isImportantForContentCapture [androidJvm] fun isImportantForContentCapture (): Boolean isInEditMode [androidJvm] open fun isInEditMode (): Boolean isInLayout [androidJvm] open fun isInLayout (): Boolean isInTouchMode [androidJvm] open fun isInTouchMode (): Boolean isKeyboardNavigationCluster [androidJvm] fun isKeyboardNavigationCluster (): Boolean isLaidOut [androidJvm] open fun isLaidOut (): Boolean isLayoutDirectionResolved [androidJvm] open fun isLayoutDirectionResolved (): Boolean isLayoutRequested [androidJvm] open fun isLayoutRequested (): Boolean isLayoutSuppressed [androidJvm] open fun isLayoutSuppressed (): Boolean isLongClickable [androidJvm] open fun isLongClickable (): Boolean isMotionEventSplittingEnabled [androidJvm] open fun isMotionEventSplittingEnabled (): Boolean isNestedScrollingEnabled [androidJvm] open fun isNestedScrollingEnabled (): Boolean isOpaque [androidJvm] open fun isOpaque (): Boolean isPaddingOffsetRequired [androidJvm] open fun isPaddingOffsetRequired (): Boolean isPaddingRelative [androidJvm] open fun isPaddingRelative (): Boolean isPivotSet [androidJvm] open fun isPivotSet (): Boolean isPressed [androidJvm] open fun isPressed (): Boolean isSaveEnabled [androidJvm] open fun isSaveEnabled (): Boolean isSaveFromParentEnabled [androidJvm] open fun isSaveFromParentEnabled (): Boolean isScreenReaderFocusable [androidJvm] open fun isScreenReaderFocusable (): Boolean isScrollbarFadingEnabled [androidJvm] open fun isScrollbarFadingEnabled (): Boolean isScrollContainer [androidJvm] open fun isScrollContainer (): Boolean isSelected [androidJvm] open fun isSelected (): Boolean isShowingLayoutBounds [androidJvm] fun isShowingLayoutBounds (): Boolean isShown [androidJvm] open fun isShown (): Boolean isSoundEffectsEnabled [androidJvm] open fun isSoundEffectsEnabled (): Boolean isTemporarilyDetached [androidJvm] fun isTemporarilyDetached (): Boolean isTextAlignmentResolved [androidJvm] open fun isTextAlignmentResolved (): Boolean isTextDirectionResolved [androidJvm] open fun isTextDirectionResolved (): Boolean isTransitionGroup [androidJvm] open fun isTransitionGroup (): Boolean isVerticalFadingEdgeEnabled [androidJvm] open fun isVerticalFadingEdgeEnabled (): Boolean isVerticalScrollBarEnabled [androidJvm] open fun isVerticalScrollBarEnabled (): Boolean isVisibleToUserForAutofill [androidJvm] open fun isVisibleToUserForAutofill (p0: Int ): Boolean jumpDrawablesToCurrentState [androidJvm] open override fun jumpDrawablesToCurrentState () keyboardNavigationClusterSearch [androidJvm] open fun keyboardNavigationClusterSearch (p0: View , p1: Int ): View layout [androidJvm] override fun layout (p0: Int , p1: Int , p2: Int , p3: Int ) measure [androidJvm] fun measure (p0: Int , p1: Int ) measureChild [androidJvm] open fun measureChild (p0: View , p1: Int , p2: Int ) measureChildren [androidJvm] open fun measureChildren (p0: Int , p1: Int ) measureChildWithMargins [androidJvm] open fun measureChildWithMargins (p0: View , p1: Int , p2: Int , p3: Int , p4: Int ) notifySubtreeAccessibilityStateChanged [androidJvm] open override fun notifySubtreeAccessibilityStateChanged (p0: View , p1: View , p2: Int ) offsetDescendantRectToMyCoords [androidJvm] fun offsetDescendantRectToMyCoords (p0: View , p1: Rect ) offsetLeftAndRight [androidJvm] open fun offsetLeftAndRight (p0: Int ) offsetRectIntoDescendantCoords [androidJvm] fun offsetRectIntoDescendantCoords (p0: View , p1: Rect ) offsetTopAndBottom [androidJvm] open fun offsetTopAndBottom (p0: Int ) onAnimationEnd [androidJvm] open fun onAnimationEnd () onAnimationStart [androidJvm] open fun onAnimationStart () onApplyWindowInsets [androidJvm] open fun onApplyWindowInsets (p0: WindowInsets ): WindowInsets onCancelPendingInputEvents [androidJvm] open fun onCancelPendingInputEvents () onCapturedPointerEvent [androidJvm] open fun onCapturedPointerEvent (p0: MotionEvent ): Boolean onCheckIsTextEditor [androidJvm] open fun onCheckIsTextEditor (): Boolean onConfigurationChanged [androidJvm] open fun onConfigurationChanged (p0: Configuration ) onCreateContextMenu [androidJvm] open fun onCreateContextMenu (p0: ContextMenu ) onCreateDrawableState [androidJvm] open override fun onCreateDrawableState (p0: Int ): IntArray onCreateInputConnection [androidJvm] open fun onCreateInputConnection (p0: EditorInfo ): InputConnection onCreateViewTranslationRequest [androidJvm] open fun onCreateViewTranslationRequest (p0: IntArray , p1: Consumer < ViewTranslationRequest >) onCreateVirtualViewTranslationRequests [androidJvm] open fun onCreateVirtualViewTranslationRequests (p0: LongArray , p1: IntArray , p2: Consumer < ViewTranslationRequest >) onDescendantInvalidated [androidJvm] open override fun onDescendantInvalidated (p0: View , p1: View ) onDisplayHint [androidJvm] open fun onDisplayHint (p0: Int ) onDragEvent [androidJvm] open fun onDragEvent (p0: DragEvent ): Boolean onDraw [androidJvm] open fun onDraw (p0: Canvas ) onDrawForeground [androidJvm] open fun onDrawForeground (p0: Canvas ) onDrawScrollBars [androidJvm] fun onDrawScrollBars (p0: Canvas ) onFilterTouchEventForSecurity [androidJvm] open fun onFilterTouchEventForSecurity (p0: MotionEvent ): Boolean onFinishInflate [androidJvm] open fun onFinishInflate () onFinishTemporaryDetach [androidJvm] open fun onFinishTemporaryDetach () onFocusChanged [androidJvm] open fun onFocusChanged (p0: Boolean , p1: Int , p2: Rect ?) onGenericMotionEvent [androidJvm] open fun onGenericMotionEvent (p0: MotionEvent ): Boolean onHoverChanged [androidJvm] open fun onHoverChanged (p0: Boolean ) onHoverEvent [androidJvm] open fun onHoverEvent (p0: MotionEvent ): Boolean onInitializeAccessibilityEvent [androidJvm] open fun onInitializeAccessibilityEvent (p0: AccessibilityEvent ) onInitializeAccessibilityNodeInfo [androidJvm] open fun onInitializeAccessibilityNodeInfo (p0: AccessibilityNodeInfo ) onInterceptHoverEvent [androidJvm] open fun onInterceptHoverEvent (p0: MotionEvent ): Boolean onInterceptTouchEvent [androidJvm] open fun onInterceptTouchEvent (p0: MotionEvent ): Boolean onKeyDown [androidJvm] open override fun onKeyDown (p0: Int , p1: KeyEvent ): Boolean onKeyLongPress [androidJvm] open override fun onKeyLongPress (p0: Int , p1: KeyEvent ): Boolean onKeyMultiple [androidJvm] open override fun onKeyMultiple (p0: Int , p1: Int , p2: KeyEvent ): Boolean onKeyPreIme [androidJvm] open fun onKeyPreIme (p0: Int , p1: KeyEvent ): Boolean onKeyShortcut [androidJvm] open fun onKeyShortcut (p0: Int , p1: KeyEvent ): Boolean onKeyUp [androidJvm] open override fun onKeyUp (p0: Int , p1: KeyEvent ): Boolean onLayout [androidJvm] open override fun onLayout (p0: Boolean , p1: Int , p2: Int , p3: Int , p4: Int ) onMeasure [androidJvm] open override fun onMeasure (p0: Int , p1: Int ) onNestedFling [androidJvm] open override fun onNestedFling (p0: View , p1: Float , p2: Float , p3: Boolean ): Boolean onNestedPreFling [androidJvm] open override fun onNestedPreFling (p0: View , p1: Float , p2: Float ): Boolean onNestedPrePerformAccessibilityAction [androidJvm] open override fun onNestedPrePerformAccessibilityAction (p0: View , p1: Int , p2: Bundle ): Boolean onNestedPreScroll [androidJvm] open override fun onNestedPreScroll (p0: View , p1: Int , p2: Int , p3: IntArray ) onNestedScroll [androidJvm] open override fun onNestedScroll (p0: View , p1: Int , p2: Int , p3: Int , p4: Int ) onNestedScrollAccepted [androidJvm] open override fun onNestedScrollAccepted (p0: View , p1: View , p2: Int ) onOverScrolled [androidJvm] open fun onOverScrolled (p0: Int , p1: Int , p2: Boolean , p3: Boolean ) onPointerCaptureChange [androidJvm] open fun onPointerCaptureChange (p0: Boolean ) onPopulateAccessibilityEvent [androidJvm] open fun onPopulateAccessibilityEvent (p0: AccessibilityEvent ) onProvideAutofillStructure [androidJvm] open fun onProvideAutofillStructure (p0: ViewStructure , p1: Int ) onProvideAutofillVirtualStructure [androidJvm] open fun onProvideAutofillVirtualStructure (p0: ViewStructure , p1: Int ) onProvideContentCaptureStructure [androidJvm] open fun onProvideContentCaptureStructure (p0: ViewStructure , p1: Int ) onProvideStructure [androidJvm] open fun onProvideStructure (p0: ViewStructure ) onProvideVirtualStructure [androidJvm] open fun onProvideVirtualStructure (p0: ViewStructure ) onReceiveContent [androidJvm] open fun onReceiveContent (p0: ContentInfo ): ContentInfo ? onRequestFocusInDescendants [androidJvm] open fun onRequestFocusInDescendants (p0: Int , p1: Rect ): Boolean onRequestSendAccessibilityEvent [androidJvm] open fun onRequestSendAccessibilityEvent (p0: View , p1: AccessibilityEvent ): Boolean onResolvePointerIcon [androidJvm] open override fun onResolvePointerIcon (p0: MotionEvent , p1: Int ): PointerIcon onRtlPropertiesChanged [androidJvm] open fun onRtlPropertiesChanged (p0: Int ) onScreenStateChanged [androidJvm] open fun onScreenStateChanged (p0: Int ) onScrollCaptureSearch [androidJvm] open fun onScrollCaptureSearch (p0: Rect , p1: Point , p2: Consumer < ScrollCaptureTarget >) onScrollChanged [androidJvm] open fun onScrollChanged (p0: Int , p1: Int , p2: Int , p3: Int ) onSetAlpha [androidJvm] open fun onSetAlpha (p0: Int ): Boolean onSizeChanged [androidJvm] open fun onSizeChanged (p0: Int , p1: Int , p2: Int , p3: Int ) onStartNestedScroll [androidJvm] open override fun onStartNestedScroll (p0: View , p1: View , p2: Int ): Boolean onStartTemporaryDetach [androidJvm] open fun onStartTemporaryDetach () onStopNestedScroll [androidJvm] open override fun onStopNestedScroll (p0: View ) onTouchEvent [androidJvm] open fun onTouchEvent (p0: MotionEvent ): Boolean onTrackballEvent [androidJvm] open fun onTrackballEvent (p0: MotionEvent ): Boolean onViewAdded [androidJvm] open fun onViewAdded (p0: View ) onViewRemoved [androidJvm] open fun onViewRemoved (p0: View ) onViewTranslationResponse [androidJvm] open fun onViewTranslationResponse (p0: ViewTranslationResponse ) onVirtualViewTranslationResponses [androidJvm] open fun onVirtualViewTranslationResponses (p0: LongSparseArray < ViewTranslationResponse >) onVisibilityAggregated [androidJvm] open fun onVisibilityAggregated (p0: Boolean ) onVisibilityChanged [androidJvm] open fun onVisibilityChanged (p0: View , p1: Int ) onWindowFocusChanged [androidJvm] open fun onWindowFocusChanged (p0: Boolean ) onWindowVisibilityChanged [androidJvm] open fun onWindowVisibilityChanged (p0: Int ) overScrollBy [androidJvm] open fun overScrollBy (p0: Int , p1: Int , p2: Int , p3: Int , p4: Int , p5: Int , p6: Int , p7: Int , p8: Boolean ): Boolean performAccessibilityAction [androidJvm] open fun performAccessibilityAction (p0: Int , p1: Bundle ): Boolean performClick [androidJvm] open fun performClick (): Boolean performContextClick [androidJvm] open fun performContextClick (): Boolean open fun performContextClick (p0: Float , p1: Float ): Boolean performHapticFeedback [androidJvm] open fun performHapticFeedback (p0: Int ): Boolean open fun performHapticFeedback (p0: Int , p1: Int ): Boolean performLongClick [androidJvm] open fun performLongClick (): Boolean open fun performLongClick (p0: Float , p1: Float ): Boolean performReceiveContent [androidJvm] open fun performReceiveContent (p0: ContentInfo ): ContentInfo ? playSoundEffect [androidJvm] open fun playSoundEffect (p0: Int ) post [androidJvm] open fun post (p0: Runnable ): Boolean postDelayed [androidJvm] open fun postDelayed (p0: Runnable , p1: Long ): Boolean postInvalidate [androidJvm] open fun postInvalidate () open fun postInvalidate (p0: Int , p1: Int , p2: Int , p3: Int ) postInvalidateDelayed [androidJvm] open fun postInvalidateDelayed (p0: Long ) open fun postInvalidateDelayed (p0: Long , p1: Int , p2: Int , p3: Int , p4: Int ) postInvalidateOnAnimation [androidJvm] open fun postInvalidateOnAnimation () open fun postInvalidateOnAnimation (p0: Int , p1: Int , p2: Int , p3: Int ) postOnAnimation [androidJvm] open fun postOnAnimation (p0: Runnable ) postOnAnimationDelayed [androidJvm] open fun postOnAnimationDelayed (p0: Runnable , p1: Long ) recomputeViewAttributes [androidJvm] open override fun recomputeViewAttributes (p0: View ) refreshDrawableState [androidJvm] open fun refreshDrawableState () releasePointerCapture [androidJvm] open fun releasePointerCapture () removeAllViews [androidJvm] open fun removeAllViews () removeAllViewsInLayout [androidJvm] open fun removeAllViewsInLayout () removeCallbacks [androidJvm] open fun removeCallbacks (p0: Runnable ): Boolean removeDetachedView [androidJvm] open fun removeDetachedView (p0: View , p1: Boolean ) removeOnAttachStateChangeListener [androidJvm] open fun removeOnAttachStateChangeListener (p0: View.OnAttachStateChangeListener ) removeOnLayoutChangeListener [androidJvm] open fun removeOnLayoutChangeListener (p0: View.OnLayoutChangeListener ) removeOnUnhandledKeyEventListener [androidJvm] open fun removeOnUnhandledKeyEventListener (p0: View.OnUnhandledKeyEventListener ) removeView [androidJvm] open override fun removeView (p0: View ) removeViewAt [androidJvm] open fun removeViewAt (p0: Int ) removeViewInLayout [androidJvm] open fun removeViewInLayout (p0: View ) removeViews [androidJvm] open fun removeViews (p0: Int , p1: Int ) removeViewsInLayout [androidJvm] open fun removeViewsInLayout (p0: Int , p1: Int ) requestApplyInsets [androidJvm] open fun requestApplyInsets () requestChildFocus [androidJvm] open override fun requestChildFocus (p0: View , p1: View ) requestChildRectangleOnScreen [androidJvm] open override fun requestChildRectangleOnScreen (p0: View , p1: Rect , p2: Boolean ): Boolean requestDisallowInterceptTouchEvent [androidJvm] open override fun requestDisallowInterceptTouchEvent (p0: Boolean ) requestFocus [androidJvm] fun requestFocus (): Boolean fun requestFocus (p0: Int ): Boolean open override fun requestFocus (p0: Int , p1: Rect ): Boolean requestFocusFromTouch [androidJvm] fun requestFocusFromTouch (): Boolean requestLayout [androidJvm] open fun requestLayout () requestPointerCapture [androidJvm] open fun requestPointerCapture () requestRectangleOnScreen [androidJvm] open fun requestRectangleOnScreen (p0: Rect ): Boolean open fun requestRectangleOnScreen (p0: Rect , p1: Boolean ): Boolean requestSendAccessibilityEvent [androidJvm] open override fun requestSendAccessibilityEvent (p0: View , p1: AccessibilityEvent ): Boolean requestTransparentRegion [androidJvm] open override fun requestTransparentRegion (p0: View ) requestUnbufferedDispatch [androidJvm] fun requestUnbufferedDispatch (p0: MotionEvent ) fun requestUnbufferedDispatch (p0: Int ) requireViewById [androidJvm] fun < T : View > requireViewById (p0: Int ): T resetPivot [androidJvm] open fun resetPivot () restoreDefaultFocus [androidJvm] open override fun restoreDefaultFocus (): Boolean restoreHierarchyState [androidJvm] open fun restoreHierarchyState (p0: SparseArray < Parcelable >) saveAttributeDataForStyleable [androidJvm] fun saveAttributeDataForStyleable (p0: Context , p1: IntArray , p2: AttributeSet ?, p3: TypedArray , p4: Int , p5: Int ) saveHierarchyState [androidJvm] open fun saveHierarchyState (p0: SparseArray < Parcelable >) scheduleDrawable [androidJvm] open override fun scheduleDrawable (p0: Drawable , p1: Runnable , p2: Long ) scheduleLayoutAnimation [androidJvm] open fun scheduleLayoutAnimation () scrollBy [androidJvm] open fun scrollBy (p0: Int , p1: Int ) scrollTo [androidJvm] open fun scrollTo (p0: Int , p1: Int ) sendAccessibilityEvent [androidJvm] open override fun sendAccessibilityEvent (p0: Int ) sendAccessibilityEventUnchecked [androidJvm] open override fun sendAccessibilityEventUnchecked (p0: AccessibilityEvent ) setAccessibilityDelegate [androidJvm] open fun setAccessibilityDelegate (p0: View.AccessibilityDelegate ?) setAccessibilityHeading [androidJvm] open fun setAccessibilityHeading (p0: Boolean ) setAccessibilityLiveRegion [androidJvm] open fun setAccessibilityLiveRegion (p0: Int ) setAccessibilityPaneTitle [androidJvm] open fun setAccessibilityPaneTitle (p0: CharSequence ?) setAccessibilityTraversalAfter [androidJvm] open fun setAccessibilityTraversalAfter (p0: Int ) setAccessibilityTraversalBefore [androidJvm] open fun setAccessibilityTraversalBefore (p0: Int ) setActivated [androidJvm] open fun setActivated (p0: Boolean ) setAddStatesFromChildren [androidJvm] open fun setAddStatesFromChildren (p0: Boolean ) setAllowClickWhenDisabled [androidJvm] open fun setAllowClickWhenDisabled (p0: Boolean ) setAlpha [androidJvm] open fun setAlpha (p0: Float ) setAnimation [androidJvm] open fun setAnimation (p0: Animation ) setAnimationMatrix [androidJvm] open fun setAnimationMatrix (p0: Matrix ?) setAutofillHints [androidJvm] open fun setAutofillHints (vararg p0: String ) setAutofillId [androidJvm] open fun setAutofillId (p0: AutofillId ?) setBackground [androidJvm] open fun setBackground (p0: Drawable ) setBackgroundColor [androidJvm] open fun setBackgroundColor (p0: Int ) setBackgroundResource [androidJvm] open fun setBackgroundResource (p0: Int ) setBackgroundTintBlendMode [androidJvm] open fun setBackgroundTintBlendMode (p0: BlendMode ?) setBackgroundTintList [androidJvm] open fun setBackgroundTintList (p0: ColorStateList ?) setBackgroundTintMode [androidJvm] open fun setBackgroundTintMode (p0: PorterDuff.Mode ?) setBottom [androidJvm] fun setBottom (p0: Int ) setCameraDistance [androidJvm] open fun setCameraDistance (p0: Float ) setChildrenDrawingOrderEnabled [androidJvm] open fun setChildrenDrawingOrderEnabled (p0: Boolean ) setClickable [androidJvm] open fun setClickable (p0: Boolean ) setClipBounds [androidJvm] open fun setClipBounds (p0: Rect ) setClipChildren [androidJvm] open fun setClipChildren (p0: Boolean ) setClipToOutline [androidJvm] open fun setClipToOutline (p0: Boolean ) setClipToPadding [androidJvm] open fun setClipToPadding (p0: Boolean ) setContentCaptureSession [androidJvm] open fun setContentCaptureSession (p0: ContentCaptureSession ?) setContentDescription [androidJvm] open fun setContentDescription (p0: CharSequence ) setContextClickable [androidJvm] open fun setContextClickable (p0: Boolean ) setDefaultFocusHighlightEnabled [androidJvm] open fun setDefaultFocusHighlightEnabled (p0: Boolean ) setDescendantFocusability [androidJvm] open fun setDescendantFocusability (p0: Int ) setDuplicateParentStateEnabled [androidJvm] open fun setDuplicateParentStateEnabled (p0: Boolean ) setElevation [androidJvm] open fun setElevation (p0: Float ) setEnabled [androidJvm] open fun setEnabled (p0: Boolean ) setFadingEdgeLength [androidJvm] open fun setFadingEdgeLength (p0: Int ) setFilterTouchesWhenObscured [androidJvm] open fun setFilterTouchesWhenObscured (p0: Boolean ) setFitsSystemWindows [androidJvm] open fun setFitsSystemWindows (p0: Boolean ) setFocusable [androidJvm] open fun setFocusable (p0: Boolean ) open fun setFocusable (p0: Int ) setFocusableInTouchMode [androidJvm] open fun setFocusableInTouchMode (p0: Boolean ) setFocusedByDefault [androidJvm] open fun setFocusedByDefault (p0: Boolean ) setForceDarkAllowed [androidJvm] open fun setForceDarkAllowed (p0: Boolean ) setForeground [androidJvm] open fun setForeground (p0: Drawable ) setForegroundGravity [androidJvm] open override fun setForegroundGravity (p0: Int ) setForegroundTintBlendMode [androidJvm] open fun setForegroundTintBlendMode (p0: BlendMode ?) setForegroundTintList [androidJvm] open fun setForegroundTintList (p0: ColorStateList ?) setForegroundTintMode [androidJvm] open fun setForegroundTintMode (p0: PorterDuff.Mode ?) setHapticFeedbackEnabled [androidJvm] open fun setHapticFeedbackEnabled (p0: Boolean ) setHasTransientState [androidJvm] open fun setHasTransientState (p0: Boolean ) setHorizontalFadingEdgeEnabled [androidJvm] open fun setHorizontalFadingEdgeEnabled (p0: Boolean ) setHorizontalScrollBarEnabled [androidJvm] open fun setHorizontalScrollBarEnabled (p0: Boolean ) setHorizontalScrollbarThumbDrawable [androidJvm] open fun setHorizontalScrollbarThumbDrawable (p0: Drawable ?) setHorizontalScrollbarTrackDrawable [androidJvm] open fun setHorizontalScrollbarTrackDrawable (p0: Drawable ?) setHovered [androidJvm] open fun setHovered (p0: Boolean ) setId [androidJvm] open fun setId (p0: Int ) setImportantForAccessibility [androidJvm] open fun setImportantForAccessibility (p0: Int ) setImportantForAutofill [androidJvm] open fun setImportantForAutofill (p0: Int ) setImportantForContentCapture [androidJvm] open fun setImportantForContentCapture (p0: Int ) setKeepScreenOn [androidJvm] open fun setKeepScreenOn (p0: Boolean ) setKeyboardNavigationCluster [androidJvm] open fun setKeyboardNavigationCluster (p0: Boolean ) setLabelFor [androidJvm] open fun setLabelFor (p0: Int ) setLayerPaint [androidJvm] open fun setLayerPaint (p0: Paint ?) setLayerType [androidJvm] open fun setLayerType (p0: Int , p1: Paint ?) setLayoutAnimation [androidJvm] open fun setLayoutAnimation (p0: LayoutAnimationController ) setLayoutAnimationListener [androidJvm] open fun setLayoutAnimationListener (p0: Animation.AnimationListener ) setLayoutDirection [androidJvm] open fun setLayoutDirection (p0: Int ) setLayoutMode [androidJvm] open fun setLayoutMode (p0: Int ) setLayoutParams [androidJvm] open fun setLayoutParams (p0: ViewGroup.LayoutParams ) setLayoutTransition [androidJvm] open fun setLayoutTransition (p0: LayoutTransition ) setLeft [androidJvm] fun setLeft (p0: Int ) setLeftTopRightBottom [androidJvm] fun setLeftTopRightBottom (p0: Int , p1: Int , p2: Int , p3: Int ) setLongClickable [androidJvm] open fun setLongClickable (p0: Boolean ) setMeasureAllChildren [androidJvm] open fun setMeasureAllChildren (p0: Boolean ) setMeasuredDimension [androidJvm] fun setMeasuredDimension (p0: Int , p1: Int ) setMinimumHeight [androidJvm] open fun setMinimumHeight (p0: Int ) setMinimumWidth [androidJvm] open fun setMinimumWidth (p0: Int ) setMotionEventSplittingEnabled [androidJvm] open fun setMotionEventSplittingEnabled (p0: Boolean ) setNestedScrollingEnabled [androidJvm] open fun setNestedScrollingEnabled (p0: Boolean ) setNextClusterForwardId [androidJvm] open fun setNextClusterForwardId (p0: Int ) setNextFocusDownId [androidJvm] open fun setNextFocusDownId (p0: Int ) setNextFocusForwardId [androidJvm] open fun setNextFocusForwardId (p0: Int ) setNextFocusLeftId [androidJvm] open fun setNextFocusLeftId (p0: Int ) setNextFocusRightId [androidJvm] open fun setNextFocusRightId (p0: Int ) setNextFocusUpId [androidJvm] open fun setNextFocusUpId (p0: Int ) setOnApplyWindowInsetsListener [androidJvm] open fun setOnApplyWindowInsetsListener (p0: View.OnApplyWindowInsetsListener ) setOnCapturedPointerListener [androidJvm] open fun setOnCapturedPointerListener (p0: View.OnCapturedPointerListener ) setOnClickListener [androidJvm] open fun setOnClickListener (p0: View.OnClickListener ?) setOnContextClickListener [androidJvm] open fun setOnContextClickListener (p0: View.OnContextClickListener ?) setOnCreateContextMenuListener [androidJvm] open fun setOnCreateContextMenuListener (p0: View.OnCreateContextMenuListener ) setOnDragListener [androidJvm] open fun setOnDragListener (p0: View.OnDragListener ) setOnFocusChangeListener [androidJvm] open fun setOnFocusChangeListener (p0: View.OnFocusChangeListener ) setOnGenericMotionListener [androidJvm] open fun setOnGenericMotionListener (p0: View.OnGenericMotionListener ) setOnHierarchyChangeListener [androidJvm] open fun setOnHierarchyChangeListener (p0: ViewGroup.OnHierarchyChangeListener ) setOnHoverListener [androidJvm] open fun setOnHoverListener (p0: View.OnHoverListener ) setOnKeyListener [androidJvm] open fun setOnKeyListener (p0: View.OnKeyListener ) setOnLongClickListener [androidJvm] open fun setOnLongClickListener (p0: View.OnLongClickListener ?) setOnReceiveContentListener [androidJvm] open fun setOnReceiveContentListener (p0: Array < String >?, p1: OnReceiveContentListener ?) setOnScrollChangeListener [androidJvm] open fun setOnScrollChangeListener (p0: View.OnScrollChangeListener ) setOnTouchListener [androidJvm] open fun setOnTouchListener (p0: View.OnTouchListener ) setOutlineAmbientShadowColor [androidJvm] open fun setOutlineAmbientShadowColor (p0: Int ) setOutlineProvider [androidJvm] open fun setOutlineProvider (p0: ViewOutlineProvider ) setOutlineSpotShadowColor [androidJvm] open fun setOutlineSpotShadowColor (p0: Int ) setOverScrollMode [androidJvm] open fun setOverScrollMode (p0: Int ) setPadding [androidJvm] open fun setPadding (p0: Int , p1: Int , p2: Int , p3: Int ) setPaddingRelative [androidJvm] open fun setPaddingRelative (p0: Int , p1: Int , p2: Int , p3: Int ) setPivotX [androidJvm] open fun setPivotX (p0: Float ) setPivotY [androidJvm] open fun setPivotY (p0: Float ) setPointerIcon [androidJvm] open fun setPointerIcon (p0: PointerIcon ) setPressed [androidJvm] open fun setPressed (p0: Boolean ) setRenderEffect [androidJvm] open fun setRenderEffect (p0: RenderEffect ?) setRevealOnFocusHint [androidJvm] fun setRevealOnFocusHint (p0: Boolean ) setRight [androidJvm] fun setRight (p0: Int ) setRotation [androidJvm] open fun setRotation (p0: Float ) setRotationX [androidJvm] open fun setRotationX (p0: Float ) setRotationY [androidJvm] open fun setRotationY (p0: Float ) setSaveEnabled [androidJvm] open fun setSaveEnabled (p0: Boolean ) setSaveFromParentEnabled [androidJvm] open fun setSaveFromParentEnabled (p0: Boolean ) setScaleX [androidJvm] open fun setScaleX (p0: Float ) setScaleY [androidJvm] open fun setScaleY (p0: Float ) setScreenReaderFocusable [androidJvm] open fun setScreenReaderFocusable (p0: Boolean ) setScrollBarDefaultDelayBeforeFade [androidJvm] open fun setScrollBarDefaultDelayBeforeFade (p0: Int ) setScrollBarFadeDuration [androidJvm] open fun setScrollBarFadeDuration (p0: Int ) setScrollbarFadingEnabled [androidJvm] open fun setScrollbarFadingEnabled (p0: Boolean ) setScrollBarSize [androidJvm] open fun setScrollBarSize (p0: Int ) setScrollBarStyle [androidJvm] open fun setScrollBarStyle (p0: Int ) setScrollCaptureCallback [androidJvm] fun setScrollCaptureCallback (p0: ScrollCaptureCallback ?) setScrollCaptureHint [androidJvm] open fun setScrollCaptureHint (p0: Int ) setScrollContainer [androidJvm] open fun setScrollContainer (p0: Boolean ) setScrollIndicators [androidJvm] open fun setScrollIndicators (p0: Int ) open fun setScrollIndicators (p0: Int , p1: Int ) setScrollX [androidJvm] open fun setScrollX (p0: Int ) setScrollY [androidJvm] open fun setScrollY (p0: Int ) setSelected [androidJvm] open fun setSelected (p0: Boolean ) setSoundEffectsEnabled [androidJvm] open fun setSoundEffectsEnabled (p0: Boolean ) setStateDescription [androidJvm] open fun setStateDescription (p0: CharSequence ?) setStateListAnimator [androidJvm] open fun setStateListAnimator (p0: StateListAnimator ) setStaticTransformationsEnabled [androidJvm] open fun setStaticTransformationsEnabled (p0: Boolean ) setSystemGestureExclusionRects [androidJvm] open fun setSystemGestureExclusionRects (p0: MutableList < Rect >) setTag [androidJvm] open fun setTag (p0: Any ) open fun setTag (p0: Int , p1: Any ) setTextAlignment [androidJvm] open fun setTextAlignment (p0: Int ) setTextDirection [androidJvm] open fun setTextDirection (p0: Int ) setTooltipText [androidJvm] open fun setTooltipText (p0: CharSequence ?) setTop [androidJvm] fun setTop (p0: Int ) setTouchDelegate [androidJvm] open fun setTouchDelegate (p0: TouchDelegate ) setTouchscreenBlocksFocus [androidJvm] open fun setTouchscreenBlocksFocus (p0: Boolean ) setTransitionAlpha [androidJvm] open fun setTransitionAlpha (p0: Float ) setTransitionGroup [androidJvm] open fun setTransitionGroup (p0: Boolean ) setTransitionName [androidJvm] fun setTransitionName (p0: String ) setTransitionVisibility [androidJvm] open fun setTransitionVisibility (p0: Int ) setTranslationX [androidJvm] open fun setTranslationX (p0: Float ) setTranslationY [androidJvm] open fun setTranslationY (p0: Float ) setTranslationZ [androidJvm] open fun setTranslationZ (p0: Float ) setVerticalFadingEdgeEnabled [androidJvm] open fun setVerticalFadingEdgeEnabled (p0: Boolean ) setVerticalScrollBarEnabled [androidJvm] open fun setVerticalScrollBarEnabled (p0: Boolean ) setVerticalScrollbarPosition [androidJvm] open fun setVerticalScrollbarPosition (p0: Int ) setVerticalScrollbarThumbDrawable [androidJvm] open fun setVerticalScrollbarThumbDrawable (p0: Drawable ?) setVerticalScrollbarTrackDrawable [androidJvm] open fun setVerticalScrollbarTrackDrawable (p0: Drawable ?) setViewTranslationCallback [androidJvm] open fun setViewTranslationCallback (p0: ViewTranslationCallback ) setVisibility [androidJvm] open fun setVisibility (p0: Int ) setWillNotDraw [androidJvm] open fun setWillNotDraw (p0: Boolean ) setWindowInsetsAnimationCallback [androidJvm] open override fun setWindowInsetsAnimationCallback (p0: WindowInsetsAnimation.Callback ?) setX [androidJvm] open fun setX (p0: Float ) setY [androidJvm] open fun setY (p0: Float ) setZ [androidJvm] open fun setZ (p0: Float ) shouldDelayChildPressedState [androidJvm] open override fun shouldDelayChildPressedState (): Boolean showContextMenu [androidJvm] open fun showContextMenu (): Boolean open fun showContextMenu (p0: Float , p1: Float ): Boolean showContextMenuForChild [androidJvm] open override fun showContextMenuForChild (p0: View ): Boolean open override fun showContextMenuForChild (p0: View , p1: Float , p2: Float ): Boolean startActionMode [androidJvm] open fun startActionMode (p0: ActionMode.Callback ): ActionMode open fun startActionMode (p0: ActionMode.Callback , p1: Int ): ActionMode startActionModeForChild [androidJvm] open override fun startActionModeForChild (p0: View , p1: ActionMode.Callback ): ActionMode open override fun startActionModeForChild (p0: View , p1: ActionMode.Callback , p2: Int ): ActionMode startAnimation [androidJvm] open fun startAnimation (p0: Animation ) startDragAndDrop [androidJvm] fun startDragAndDrop (p0: ClipData , p1: View.DragShadowBuilder , p2: Any , p3: Int ): Boolean startLayoutAnimation [androidJvm] open fun startLayoutAnimation () startNestedScroll [androidJvm] open fun startNestedScroll (p0: Int ): Boolean startViewTransition [androidJvm] open fun startViewTransition (p0: View ) stopNestedScroll [androidJvm] open fun stopNestedScroll () suppressLayout [androidJvm] open fun suppressLayout (p0: Boolean ) toString [androidJvm] open override fun toString (): String transformMatrixToGlobal [androidJvm] open fun transformMatrixToGlobal (p0: Matrix ) transformMatrixToLocal [androidJvm] open fun transformMatrixToLocal (p0: Matrix ) unscheduleDrawable [androidJvm] open fun unscheduleDrawable (p0: Drawable ) open override fun unscheduleDrawable (p0: Drawable , p1: Runnable ) updateDragShadow [androidJvm] fun updateDragShadow (p0: View.DragShadowBuilder ) updateViewLayout [androidJvm] open override fun updateViewLayout (p0: View , p1: ViewGroup.LayoutParams ) verifyDrawable [androidJvm] open fun verifyDrawable (p0: Drawable ): Boolean willNotDraw [androidJvm] open fun willNotDraw (): Boolean","title":"Functions"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-back-stack-container/-back-stack-container/","text":"// workflow / com.squareup.workflow1.ui.backstack / BackStackContainer / BackStackContainer BackStackContainer \u00b6 [androidJvm]\\ @ JvmOverloads fun BackStackContainer (context: Context , attributeSet: AttributeSet ? = null, defStyle: Int = 0, defStyleRes: Int = 0)","title":" back stack container"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-back-stack-container/-back-stack-container/#backstackcontainer","text":"[androidJvm]\\ @ JvmOverloads fun BackStackContainer (context: Context , attributeSet: AttributeSet ? = null, defStyle: Int = 0, defStyleRes: Int = 0)","title":"BackStackContainer"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-back-stack-container/-companion/","text":"// workflow / com.squareup.workflow1.ui.backstack / BackStackContainer / Companion Companion \u00b6 [androidJvm]\\ object Companion : ViewFactory <BackStackScreen<*>> Functions \u00b6 Name Summary buildView [androidJvm] open override fun buildView (initialRendering: BackStackScreen<*>, initialViewEnvironment: ViewEnvironment , contextForNewView: Context , container: ViewGroup ?): View Properties \u00b6 Name Summary type [androidJvm] open override val type : KClass <in BackStackScreen<*>>","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-back-stack-container/-companion/#companion","text":"[androidJvm]\\ object Companion : ViewFactory <BackStackScreen<*>>","title":"Companion"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-back-stack-container/-companion/#functions","text":"Name Summary buildView [androidJvm] open override fun buildView (initialRendering: BackStackScreen<*>, initialViewEnvironment: ViewEnvironment , contextForNewView: Context , container: ViewGroup ?): View","title":"Functions"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-back-stack-container/-companion/#properties","text":"Name Summary type [androidJvm] open override val type : KClass <in BackStackScreen<*>>","title":"Properties"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-back-stack-screen/","text":"// workflow / com.squareup.workflow1.ui.backstack / BackStackScreen BackStackScreen \u00b6 [jvm]\\ @ WorkflowUiExperimentalApi class BackStackScreen < StackedT : Any >(bottom: StackedT , rest: List < StackedT >) Represents an active screen ( top ), and a set of previously visited screens to which we may return ( backStack ). By rendering the entire history we allow the UI to do things like maintain cached view state, implement drag-back gestures without waiting for the workflow, etc. Effectively a list that can never be empty. If multiple BackStackScreen s are used as sibling renderings within the same parent navigation container (either the root activity or another BackStackScreen ), then the siblings must be distinguished by wrapping them in Named renderings in order to correctly support AndroidX SavedStateRegistry. Parameters \u00b6 jvm bottom the bottom-most entry in the stack rest the rest of the stack, empty by default Constructors \u00b6 BackStackScreen [jvm] fun < StackedT : Any > BackStackScreen (bottom: StackedT , vararg rest: StackedT ) Creates a screen with elements listed from the bottom to the top. BackStackScreen [jvm] fun < StackedT : Any > BackStackScreen (bottom: StackedT , rest: List < StackedT >) Functions \u00b6 Name Summary equals [jvm] open operator override fun equals (other: Any ?): Boolean get [jvm] operator fun get (index: Int ): StackedT hashCode [jvm] open override fun hashCode (): Int map [jvm] fun < R : Any > map (transform: ( StackedT ) -> R ): BackStackScreen < R > mapIndexed [jvm] fun < R : Any > mapIndexed (transform: (index: Int , StackedT ) -> R ): BackStackScreen < R > plus [jvm] operator fun plus (other: BackStackScreen < StackedT >?): BackStackScreen < StackedT > toString [jvm] open override fun toString (): String Properties \u00b6 Name Summary backStack [jvm] val backStack : List < StackedT > Screens to which we may return. frames [jvm] val frames : List < StackedT > top [jvm] val top : StackedT The active screen.","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-back-stack-screen/#backstackscreen","text":"[jvm]\\ @ WorkflowUiExperimentalApi class BackStackScreen < StackedT : Any >(bottom: StackedT , rest: List < StackedT >) Represents an active screen ( top ), and a set of previously visited screens to which we may return ( backStack ). By rendering the entire history we allow the UI to do things like maintain cached view state, implement drag-back gestures without waiting for the workflow, etc. Effectively a list that can never be empty. If multiple BackStackScreen s are used as sibling renderings within the same parent navigation container (either the root activity or another BackStackScreen ), then the siblings must be distinguished by wrapping them in Named renderings in order to correctly support AndroidX SavedStateRegistry.","title":"BackStackScreen"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-back-stack-screen/#parameters","text":"jvm bottom the bottom-most entry in the stack rest the rest of the stack, empty by default","title":"Parameters"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-back-stack-screen/#constructors","text":"BackStackScreen [jvm] fun < StackedT : Any > BackStackScreen (bottom: StackedT , vararg rest: StackedT ) Creates a screen with elements listed from the bottom to the top. BackStackScreen [jvm] fun < StackedT : Any > BackStackScreen (bottom: StackedT , rest: List < StackedT >)","title":"Constructors"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-back-stack-screen/#functions","text":"Name Summary equals [jvm] open operator override fun equals (other: Any ?): Boolean get [jvm] operator fun get (index: Int ): StackedT hashCode [jvm] open override fun hashCode (): Int map [jvm] fun < R : Any > map (transform: ( StackedT ) -> R ): BackStackScreen < R > mapIndexed [jvm] fun < R : Any > mapIndexed (transform: (index: Int , StackedT ) -> R ): BackStackScreen < R > plus [jvm] operator fun plus (other: BackStackScreen < StackedT >?): BackStackScreen < StackedT > toString [jvm] open override fun toString (): String","title":"Functions"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-back-stack-screen/#properties","text":"Name Summary backStack [jvm] val backStack : List < StackedT > Screens to which we may return. frames [jvm] val frames : List < StackedT > top [jvm] val top : StackedT The active screen.","title":"Properties"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-back-stack-screen/-back-stack-screen/","text":"// workflow / com.squareup.workflow1.ui.backstack / BackStackScreen / BackStackScreen BackStackScreen \u00b6 [jvm]\\ fun < StackedT : Any > BackStackScreen (bottom: StackedT , vararg rest: StackedT ) Creates a screen with elements listed from the bottom to the top. [jvm]\\ fun < StackedT : Any > BackStackScreen (bottom: StackedT , rest: List < StackedT >) Parameters \u00b6 jvm bottom the bottom-most entry in the stack rest the rest of the stack, empty by default","title":" back stack screen"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-back-stack-screen/-back-stack-screen/#backstackscreen","text":"[jvm]\\ fun < StackedT : Any > BackStackScreen (bottom: StackedT , vararg rest: StackedT ) Creates a screen with elements listed from the bottom to the top. [jvm]\\ fun < StackedT : Any > BackStackScreen (bottom: StackedT , rest: List < StackedT >)","title":"BackStackScreen"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-back-stack-screen/-back-stack-screen/#parameters","text":"jvm bottom the bottom-most entry in the stack rest the rest of the stack, empty by default","title":"Parameters"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-back-stack-screen/back-stack/","text":"// workflow / com.squareup.workflow1.ui.backstack / BackStackScreen / backStack backStack \u00b6 [jvm]\\ val backStack : List < StackedT > Screens to which we may return.","title":"Back stack"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-back-stack-screen/back-stack/#backstack","text":"[jvm]\\ val backStack : List < StackedT > Screens to which we may return.","title":"backStack"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-back-stack-screen/equals/","text":"// workflow / com.squareup.workflow1.ui.backstack / BackStackScreen / equals equals \u00b6 [jvm]\\ open operator override fun equals (other: Any ?): Boolean","title":"Equals"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-back-stack-screen/equals/#equals","text":"[jvm]\\ open operator override fun equals (other: Any ?): Boolean","title":"equals"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-back-stack-screen/frames/","text":"// workflow / com.squareup.workflow1.ui.backstack / BackStackScreen / frames frames \u00b6 [jvm]\\ val frames : List < StackedT >","title":"Frames"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-back-stack-screen/frames/#frames","text":"[jvm]\\ val frames : List < StackedT >","title":"frames"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-back-stack-screen/get/","text":"// workflow / com.squareup.workflow1.ui.backstack / BackStackScreen / get get \u00b6 [jvm]\\ operator fun get (index: Int ): StackedT","title":"Get"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-back-stack-screen/get/#get","text":"[jvm]\\ operator fun get (index: Int ): StackedT","title":"get"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-back-stack-screen/hash-code/","text":"// workflow / com.squareup.workflow1.ui.backstack / BackStackScreen / hashCode hashCode \u00b6 [jvm]\\ open override fun hashCode (): Int","title":"Hash code"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-back-stack-screen/hash-code/#hashcode","text":"[jvm]\\ open override fun hashCode (): Int","title":"hashCode"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-back-stack-screen/map-indexed/","text":"// workflow / com.squareup.workflow1.ui.backstack / BackStackScreen / mapIndexed mapIndexed \u00b6 [jvm]\\ fun < R : Any > mapIndexed (transform: (index: Int , StackedT ) -> R ): BackStackScreen < R >","title":"Map indexed"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-back-stack-screen/map-indexed/#mapindexed","text":"[jvm]\\ fun < R : Any > mapIndexed (transform: (index: Int , StackedT ) -> R ): BackStackScreen < R >","title":"mapIndexed"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-back-stack-screen/map/","text":"// workflow / com.squareup.workflow1.ui.backstack / BackStackScreen / map map \u00b6 [jvm]\\ fun < R : Any > map (transform: ( StackedT ) -> R ): BackStackScreen < R >","title":"Map"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-back-stack-screen/map/#map","text":"[jvm]\\ fun < R : Any > map (transform: ( StackedT ) -> R ): BackStackScreen < R >","title":"map"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-back-stack-screen/plus/","text":"// workflow / com.squareup.workflow1.ui.backstack / BackStackScreen / plus plus \u00b6 [jvm]\\ operator fun plus (other: BackStackScreen < StackedT >?): BackStackScreen < StackedT >","title":"Plus"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-back-stack-screen/plus/#plus","text":"[jvm]\\ operator fun plus (other: BackStackScreen < StackedT >?): BackStackScreen < StackedT >","title":"plus"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-back-stack-screen/to-string/","text":"// workflow / com.squareup.workflow1.ui.backstack / BackStackScreen / toString toString \u00b6 [jvm]\\ open override fun toString (): String","title":"To string"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-back-stack-screen/to-string/#tostring","text":"[jvm]\\ open override fun toString (): String","title":"toString"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-back-stack-screen/top/","text":"// workflow / com.squareup.workflow1.ui.backstack / BackStackScreen / top top \u00b6 [jvm]\\ val top : StackedT The active screen.","title":"Top"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-back-stack-screen/top/#top","text":"[jvm]\\ val top : StackedT The active screen.","title":"top"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-view-state-cache/","text":"// workflow / com.squareup.workflow1.ui.backstack / ViewStateCache ViewStateCache \u00b6 [androidJvm]\\ @WorkflowUiExperimentalApi class ViewStateCache : Parcelable Handles persistence chores for container views that manage a set of Named renderings, showing a view for one at a time \u2013 think back stacks or tab sets. This class implements Parcelable so that it can be preserved from a container view\u2019s own View.saveHierarchyState method. A simple container can return SavedState from that method rather than creating its own persistence class. Container views using this class must call attachToParentRegistry and detachFromParentRegistry when they are attached and detached , respectively. Constructors \u00b6 ViewStateCache [androidJvm] fun ViewStateCache () Types \u00b6 Name Summary CREATOR [androidJvm] object CREATOR : Parcelable.Creator < ViewStateCache > SavedState [androidJvm] class SavedState : View.BaseSavedState Convenience for use in View.onSaveInstanceState and View.onRestoreInstanceState methods of container views that have no other state of their own to save. Functions \u00b6 Name Summary attachToParentRegistry [androidJvm] fun attachToParentRegistry (key: String , parentOwner: SavedStateRegistryOwner ) Must be called whenever the owning view is attached to a window . Must eventually be matched with a call to detachFromParentRegistry . describeContents [androidJvm] open override fun describeContents (): Int detachFromParentRegistry [androidJvm] fun detachFromParentRegistry () Must be called whenever the owning view is detached from a window . Must be matched with a call to attachToParentRegistry . prune [androidJvm] fun prune (retaining: Collection <Named<*>>) To be called when the set of hidden views changes but the visible view remains the same. Any cached view state held for renderings that are not compatible those in retaining will be dropped. restore [androidJvm] fun restore (from: ViewStateCache ) Replaces the state of the receiver with that of from . Typical usage is to call this from a container view\u2019s View.onRestoreInstanceState . update [androidJvm] fun update (retainedRenderings: Collection <Named<*>>, oldViewMaybe: View ?, newView: View ) writeToParcel [androidJvm] open override fun writeToParcel (parcel: Parcel , flags: Int )","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-view-state-cache/#viewstatecache","text":"[androidJvm]\\ @WorkflowUiExperimentalApi class ViewStateCache : Parcelable Handles persistence chores for container views that manage a set of Named renderings, showing a view for one at a time \u2013 think back stacks or tab sets. This class implements Parcelable so that it can be preserved from a container view\u2019s own View.saveHierarchyState method. A simple container can return SavedState from that method rather than creating its own persistence class. Container views using this class must call attachToParentRegistry and detachFromParentRegistry when they are attached and detached , respectively.","title":"ViewStateCache"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-view-state-cache/#constructors","text":"ViewStateCache [androidJvm] fun ViewStateCache ()","title":"Constructors"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-view-state-cache/#types","text":"Name Summary CREATOR [androidJvm] object CREATOR : Parcelable.Creator < ViewStateCache > SavedState [androidJvm] class SavedState : View.BaseSavedState Convenience for use in View.onSaveInstanceState and View.onRestoreInstanceState methods of container views that have no other state of their own to save.","title":"Types"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-view-state-cache/#functions","text":"Name Summary attachToParentRegistry [androidJvm] fun attachToParentRegistry (key: String , parentOwner: SavedStateRegistryOwner ) Must be called whenever the owning view is attached to a window . Must eventually be matched with a call to detachFromParentRegistry . describeContents [androidJvm] open override fun describeContents (): Int detachFromParentRegistry [androidJvm] fun detachFromParentRegistry () Must be called whenever the owning view is detached from a window . Must be matched with a call to attachToParentRegistry . prune [androidJvm] fun prune (retaining: Collection <Named<*>>) To be called when the set of hidden views changes but the visible view remains the same. Any cached view state held for renderings that are not compatible those in retaining will be dropped. restore [androidJvm] fun restore (from: ViewStateCache ) Replaces the state of the receiver with that of from . Typical usage is to call this from a container view\u2019s View.onRestoreInstanceState . update [androidJvm] fun update (retainedRenderings: Collection <Named<*>>, oldViewMaybe: View ?, newView: View ) writeToParcel [androidJvm] open override fun writeToParcel (parcel: Parcel , flags: Int )","title":"Functions"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-view-state-cache/-view-state-cache/","text":"// workflow / com.squareup.workflow1.ui.backstack / ViewStateCache / ViewStateCache ViewStateCache \u00b6 [androidJvm]\\ fun ViewStateCache ()","title":" view state cache"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-view-state-cache/-view-state-cache/#viewstatecache","text":"[androidJvm]\\ fun ViewStateCache ()","title":"ViewStateCache"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-view-state-cache/attach-to-parent-registry/","text":"// workflow / com.squareup.workflow1.ui.backstack / ViewStateCache / attachToParentRegistry attachToParentRegistry \u00b6 [androidJvm]\\ fun attachToParentRegistry (key: String , parentOwner: SavedStateRegistryOwner ) Must be called whenever the owning view is attached to a window . Must eventually be matched with a call to detachFromParentRegistry . Calls StateRegistryAggregator.attachToParentRegistry \u2013 see that method for more information.","title":"Attach to parent registry"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-view-state-cache/attach-to-parent-registry/#attachtoparentregistry","text":"[androidJvm]\\ fun attachToParentRegistry (key: String , parentOwner: SavedStateRegistryOwner ) Must be called whenever the owning view is attached to a window . Must eventually be matched with a call to detachFromParentRegistry . Calls StateRegistryAggregator.attachToParentRegistry \u2013 see that method for more information.","title":"attachToParentRegistry"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-view-state-cache/describe-contents/","text":"// workflow / com.squareup.workflow1.ui.backstack / ViewStateCache / describeContents describeContents \u00b6 [androidJvm]\\ open override fun describeContents (): Int","title":"Describe contents"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-view-state-cache/describe-contents/#describecontents","text":"[androidJvm]\\ open override fun describeContents (): Int","title":"describeContents"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-view-state-cache/detach-from-parent-registry/","text":"// workflow / com.squareup.workflow1.ui.backstack / ViewStateCache / detachFromParentRegistry detachFromParentRegistry \u00b6 [androidJvm]\\ fun detachFromParentRegistry () Must be called whenever the owning view is detached from a window . Must be matched with a call to attachToParentRegistry . Calls StateRegistryAggregator.detachFromParentRegistry \u2013 see that method for more information.","title":"Detach from parent registry"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-view-state-cache/detach-from-parent-registry/#detachfromparentregistry","text":"[androidJvm]\\ fun detachFromParentRegistry () Must be called whenever the owning view is detached from a window . Must be matched with a call to attachToParentRegistry . Calls StateRegistryAggregator.detachFromParentRegistry \u2013 see that method for more information.","title":"detachFromParentRegistry"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-view-state-cache/prune/","text":"// workflow / com.squareup.workflow1.ui.backstack / ViewStateCache / prune prune \u00b6 [androidJvm]\\ fun prune (retaining: Collection <Named<*>>) To be called when the set of hidden views changes but the visible view remains the same. Any cached view state held for renderings that are not compatible those in retaining will be dropped.","title":"Prune"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-view-state-cache/prune/#prune","text":"[androidJvm]\\ fun prune (retaining: Collection <Named<*>>) To be called when the set of hidden views changes but the visible view remains the same. Any cached view state held for renderings that are not compatible those in retaining will be dropped.","title":"prune"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-view-state-cache/restore/","text":"// workflow / com.squareup.workflow1.ui.backstack / ViewStateCache / restore restore \u00b6 [androidJvm]\\ fun restore (from: ViewStateCache ) Replaces the state of the receiver with that of from . Typical usage is to call this from a container view\u2019s View.onRestoreInstanceState .","title":"Restore"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-view-state-cache/restore/#restore","text":"[androidJvm]\\ fun restore (from: ViewStateCache ) Replaces the state of the receiver with that of from . Typical usage is to call this from a container view\u2019s View.onRestoreInstanceState .","title":"restore"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-view-state-cache/update/","text":"// workflow / com.squareup.workflow1.ui.backstack / ViewStateCache / update update \u00b6 [androidJvm]\\ fun update (retainedRenderings: Collection <Named<*>>, oldViewMaybe: View ?, newView: View ) Return \u00b6 true if newView has been restored. Parameters \u00b6 androidJvm retainedRenderings the renderings to be considered hidden after this update. Any associated view state will be retained in the cache, possibly to be restored to newView on a succeeding call to his method. Any other cached view state will be dropped. oldViewMaybe the view that is being removed, if any, which is expected to be showing a Named rendering. If that rendering is compatible with a member of retainedRenderings , its state will be saved . newView the view that is about to be displayed, which must be showing a Named rendering. If compatible view state is found in the cache, it is restored .","title":"Update"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-view-state-cache/update/#update","text":"[androidJvm]\\ fun update (retainedRenderings: Collection <Named<*>>, oldViewMaybe: View ?, newView: View )","title":"update"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-view-state-cache/update/#return","text":"true if newView has been restored.","title":"Return"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-view-state-cache/update/#parameters","text":"androidJvm retainedRenderings the renderings to be considered hidden after this update. Any associated view state will be retained in the cache, possibly to be restored to newView on a succeeding call to his method. Any other cached view state will be dropped. oldViewMaybe the view that is being removed, if any, which is expected to be showing a Named rendering. If that rendering is compatible with a member of retainedRenderings , its state will be saved . newView the view that is about to be displayed, which must be showing a Named rendering. If compatible view state is found in the cache, it is restored .","title":"Parameters"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-view-state-cache/write-to-parcel/","text":"// workflow / com.squareup.workflow1.ui.backstack / ViewStateCache / writeToParcel writeToParcel \u00b6 [androidJvm]\\ open override fun writeToParcel (parcel: Parcel , flags: Int )","title":"Write to parcel"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-view-state-cache/write-to-parcel/#writetoparcel","text":"[androidJvm]\\ open override fun writeToParcel (parcel: Parcel , flags: Int )","title":"writeToParcel"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-view-state-cache/-c-r-e-a-t-o-r/","text":"// workflow / com.squareup.workflow1.ui.backstack / ViewStateCache / CREATOR CREATOR \u00b6 [androidJvm]\\ object CREATOR : Parcelable.Creator < ViewStateCache > Functions \u00b6 Name Summary createFromParcel [androidJvm] open override fun createFromParcel (parcel: Parcel ): ViewStateCache newArray [androidJvm] open override fun newArray (size: Int ): Array < ViewStateCache ?>","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-view-state-cache/-c-r-e-a-t-o-r/#creator","text":"[androidJvm]\\ object CREATOR : Parcelable.Creator < ViewStateCache >","title":"CREATOR"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-view-state-cache/-c-r-e-a-t-o-r/#functions","text":"Name Summary createFromParcel [androidJvm] open override fun createFromParcel (parcel: Parcel ): ViewStateCache newArray [androidJvm] open override fun newArray (size: Int ): Array < ViewStateCache ?>","title":"Functions"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-view-state-cache/-c-r-e-a-t-o-r/create-from-parcel/","text":"// workflow / com.squareup.workflow1.ui.backstack / ViewStateCache / CREATOR / createFromParcel createFromParcel \u00b6 [androidJvm]\\ open override fun createFromParcel (parcel: Parcel ): ViewStateCache","title":"Create from parcel"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-view-state-cache/-c-r-e-a-t-o-r/create-from-parcel/#createfromparcel","text":"[androidJvm]\\ open override fun createFromParcel (parcel: Parcel ): ViewStateCache","title":"createFromParcel"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-view-state-cache/-c-r-e-a-t-o-r/new-array/","text":"// workflow / com.squareup.workflow1.ui.backstack / ViewStateCache / CREATOR / newArray newArray \u00b6 [androidJvm]\\ open override fun newArray (size: Int ): Array < ViewStateCache ?>","title":"New array"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-view-state-cache/-c-r-e-a-t-o-r/new-array/#newarray","text":"[androidJvm]\\ open override fun newArray (size: Int ): Array < ViewStateCache ?>","title":"newArray"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-view-state-cache/-saved-state/","text":"// workflow / com.squareup.workflow1.ui.backstack / ViewStateCache / SavedState SavedState \u00b6 [androidJvm]\\ class SavedState : View.BaseSavedState Convenience for use in View.onSaveInstanceState and View.onRestoreInstanceState methods of container views that have no other state of their own to save. More interesting containers should create their own subclass of BaseSavedState rather than trying to extend this one. Constructors \u00b6 SavedState [androidJvm] fun SavedState (superState: Parcelable ?, viewStateCache: ViewStateCache ) SavedState [androidJvm] fun SavedState (source: Parcel ) Types \u00b6 Name Summary CREATOR [androidJvm] object CREATOR : Parcelable.Creator < ViewStateCache.SavedState > Functions \u00b6 Name Summary describeContents [androidJvm] open override fun describeContents (): Int getSuperState [androidJvm] fun getSuperState (): Parcelable writeToParcel [androidJvm] open override fun writeToParcel (out: Parcel , flags: Int ) Properties \u00b6 Name Summary viewStateCache [androidJvm] val viewStateCache : ViewStateCache","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-view-state-cache/-saved-state/#savedstate","text":"[androidJvm]\\ class SavedState : View.BaseSavedState Convenience for use in View.onSaveInstanceState and View.onRestoreInstanceState methods of container views that have no other state of their own to save. More interesting containers should create their own subclass of BaseSavedState rather than trying to extend this one.","title":"SavedState"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-view-state-cache/-saved-state/#constructors","text":"SavedState [androidJvm] fun SavedState (superState: Parcelable ?, viewStateCache: ViewStateCache ) SavedState [androidJvm] fun SavedState (source: Parcel )","title":"Constructors"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-view-state-cache/-saved-state/#types","text":"Name Summary CREATOR [androidJvm] object CREATOR : Parcelable.Creator < ViewStateCache.SavedState >","title":"Types"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-view-state-cache/-saved-state/#functions","text":"Name Summary describeContents [androidJvm] open override fun describeContents (): Int getSuperState [androidJvm] fun getSuperState (): Parcelable writeToParcel [androidJvm] open override fun writeToParcel (out: Parcel , flags: Int )","title":"Functions"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-view-state-cache/-saved-state/#properties","text":"Name Summary viewStateCache [androidJvm] val viewStateCache : ViewStateCache","title":"Properties"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-view-state-cache/-saved-state/-saved-state/","text":"// workflow / com.squareup.workflow1.ui.backstack / ViewStateCache / SavedState / SavedState SavedState \u00b6 [androidJvm]\\ fun SavedState (superState: Parcelable ?, viewStateCache: ViewStateCache ) fun SavedState (source: Parcel )","title":" saved state"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-view-state-cache/-saved-state/-saved-state/#savedstate","text":"[androidJvm]\\ fun SavedState (superState: Parcelable ?, viewStateCache: ViewStateCache ) fun SavedState (source: Parcel )","title":"SavedState"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-view-state-cache/-saved-state/view-state-cache/","text":"// workflow / com.squareup.workflow1.ui.backstack / ViewStateCache / SavedState / viewStateCache viewStateCache \u00b6 [androidJvm]\\ val viewStateCache : ViewStateCache","title":"View state cache"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-view-state-cache/-saved-state/view-state-cache/#viewstatecache","text":"[androidJvm]\\ val viewStateCache : ViewStateCache","title":"viewStateCache"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-view-state-cache/-saved-state/write-to-parcel/","text":"// workflow / com.squareup.workflow1.ui.backstack / ViewStateCache / SavedState / writeToParcel writeToParcel \u00b6 [androidJvm]\\ open override fun writeToParcel (out: Parcel , flags: Int )","title":"Write to parcel"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-view-state-cache/-saved-state/write-to-parcel/#writetoparcel","text":"[androidJvm]\\ open override fun writeToParcel (out: Parcel , flags: Int )","title":"writeToParcel"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-view-state-cache/-saved-state/-c-r-e-a-t-o-r/","text":"// workflow / com.squareup.workflow1.ui.backstack / ViewStateCache / SavedState / CREATOR CREATOR \u00b6 [androidJvm]\\ object CREATOR : Parcelable.Creator < ViewStateCache.SavedState > Functions \u00b6 Name Summary createFromParcel [androidJvm] open override fun createFromParcel (source: Parcel ): ViewStateCache.SavedState newArray [androidJvm] open override fun newArray (size: Int ): Array < ViewStateCache.SavedState ?>","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-view-state-cache/-saved-state/-c-r-e-a-t-o-r/#creator","text":"[androidJvm]\\ object CREATOR : Parcelable.Creator < ViewStateCache.SavedState >","title":"CREATOR"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-view-state-cache/-saved-state/-c-r-e-a-t-o-r/#functions","text":"Name Summary createFromParcel [androidJvm] open override fun createFromParcel (source: Parcel ): ViewStateCache.SavedState newArray [androidJvm] open override fun newArray (size: Int ): Array < ViewStateCache.SavedState ?>","title":"Functions"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-view-state-cache/-saved-state/-c-r-e-a-t-o-r/create-from-parcel/","text":"// workflow / com.squareup.workflow1.ui.backstack / ViewStateCache / SavedState / CREATOR / createFromParcel createFromParcel \u00b6 [androidJvm]\\ open override fun createFromParcel (source: Parcel ): ViewStateCache.SavedState","title":"Create from parcel"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-view-state-cache/-saved-state/-c-r-e-a-t-o-r/create-from-parcel/#createfromparcel","text":"[androidJvm]\\ open override fun createFromParcel (source: Parcel ): ViewStateCache.SavedState","title":"createFromParcel"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-view-state-cache/-saved-state/-c-r-e-a-t-o-r/new-array/","text":"// workflow / com.squareup.workflow1.ui.backstack / ViewStateCache / SavedState / CREATOR / newArray newArray \u00b6 [androidJvm]\\ open override fun newArray (size: Int ): Array < ViewStateCache.SavedState ?>","title":"New array"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.backstack/-view-state-cache/-saved-state/-c-r-e-a-t-o-r/new-array/#newarray","text":"[androidJvm]\\ open override fun newArray (size: Int ): Array < ViewStateCache.SavedState ?>","title":"newArray"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.compose/","text":"// workflow / com.squareup.workflow1.ui.compose Package com.squareup.workflow1.ui.compose \u00b6 Types \u00b6 Name Summary ComposeRendering [androidJvm] @WorkflowUiExperimentalApi interface ComposeRendering : AndroidViewRendering < Nothing > Interface implemented by a rendering class to allow it to drive a composable UI via an appropriate ComposeViewFactory implementation, by simply overriding the Content method. This is the compose analog to AndroidViewRendering . ComposeViewFactory [androidJvm] @WorkflowUiExperimentalApi abstract class ComposeViewFactory < RenderingT : Any > : ViewFactory < RenderingT > A ViewFactory that uses a Composable function to display the rendering. It is the Compose-based analogue of LayoutRunner . CompositionRoot [androidJvm] typealias CompositionRoot = @Composable(@Composablecontent: () -> Unit ) -> Unit A composable function that will be used to wrap the first (highest-level) composeViewFactory view factory in a composition. This can be used to setup any composition locals that all composeViewFactory factories need access to, such as UI themes. This function will called once, to wrap the highest-level composeViewFactory in the tree. However, composition locals are propagated down to child composeViewFactory compositions, so any locals provided here will be available in all composeViewFactory compositions. Functions \u00b6 Name Summary asMutableState [androidJvm] @Composable fun TextController . asMutableState (): MutableState< String > Exposes the textValue of a TextController as a remembered MutableState, suitable for use from @Composable functions. ComposeRendering [androidJvm] @WorkflowUiExperimentalApi inline fun ComposeRendering (crossinline content: @Composable( ViewEnvironment ) -> Unit ): ComposeRendering Convenience function for creating anonymous ComposeRendering s since composable fun interfaces aren\u2019t supported. See the ComposeRendering class for more information. composeViewFactory [androidJvm] @WorkflowUiExperimentalApi inline fun < RenderingT : Any > composeViewFactory (noinline content: @Composable( RenderingT , environment: ViewEnvironment ) -> Unit ): ViewFactory < RenderingT > Creates a ViewFactory that uses a Composable function to display the rendering. renderAsState [androidJvm] @Composable fun < PropsT , OutputT : Any , RenderingT > Workflow < PropsT , OutputT , RenderingT >. renderAsState (props: PropsT , interceptors: List <WorkflowInterceptor> = emptyList(), scope: CoroutineScope = rememberCoroutineScope(), onOutput: suspend ( OutputT ) -> Unit ): State< RenderingT > Runs this Workflow as long as this composable is part of the composition, and returns a State object that will be updated whenever the runtime emits a new RenderingT . Note that here, and in the rest of the documentation for this class, the \u201cState\u201d type refers to Compose\u2019s snapshot State type, not the concept of the StateT type in a particular workflow. withCompositionRoot [androidJvm] @WorkflowUiExperimentalApi fun ViewEnvironment . withCompositionRoot (root: CompositionRoot ): ViewEnvironment Convenience function for applying a CompositionRoot to this ViewEnvironment \u2018s ViewRegistry . See ViewRegistry.withCompositionRoot . [androidJvm] @WorkflowUiExperimentalApi fun ViewRegistry . withCompositionRoot (root: CompositionRoot ): ViewRegistry Returns a ViewRegistry that ensures that any composeViewFactory factories registered in this registry will be wrapped exactly once with a CompositionRoot wrapper. See CompositionRoot for more information. WorkflowRendering [androidJvm] @WorkflowUiExperimentalApi @Composable fun WorkflowRendering (rendering: Any , viewEnvironment: ViewEnvironment , modifier: Modifier = Modifier) Renders rendering into the composition using this ViewEnvironment \u2018s ViewRegistry to generate the view.","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.compose/#package-comsquareupworkflow1uicompose","text":"","title":"Package com.squareup.workflow1.ui.compose"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.compose/#types","text":"Name Summary ComposeRendering [androidJvm] @WorkflowUiExperimentalApi interface ComposeRendering : AndroidViewRendering < Nothing > Interface implemented by a rendering class to allow it to drive a composable UI via an appropriate ComposeViewFactory implementation, by simply overriding the Content method. This is the compose analog to AndroidViewRendering . ComposeViewFactory [androidJvm] @WorkflowUiExperimentalApi abstract class ComposeViewFactory < RenderingT : Any > : ViewFactory < RenderingT > A ViewFactory that uses a Composable function to display the rendering. It is the Compose-based analogue of LayoutRunner . CompositionRoot [androidJvm] typealias CompositionRoot = @Composable(@Composablecontent: () -> Unit ) -> Unit A composable function that will be used to wrap the first (highest-level) composeViewFactory view factory in a composition. This can be used to setup any composition locals that all composeViewFactory factories need access to, such as UI themes. This function will called once, to wrap the highest-level composeViewFactory in the tree. However, composition locals are propagated down to child composeViewFactory compositions, so any locals provided here will be available in all composeViewFactory compositions.","title":"Types"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.compose/#functions","text":"Name Summary asMutableState [androidJvm] @Composable fun TextController . asMutableState (): MutableState< String > Exposes the textValue of a TextController as a remembered MutableState, suitable for use from @Composable functions. ComposeRendering [androidJvm] @WorkflowUiExperimentalApi inline fun ComposeRendering (crossinline content: @Composable( ViewEnvironment ) -> Unit ): ComposeRendering Convenience function for creating anonymous ComposeRendering s since composable fun interfaces aren\u2019t supported. See the ComposeRendering class for more information. composeViewFactory [androidJvm] @WorkflowUiExperimentalApi inline fun < RenderingT : Any > composeViewFactory (noinline content: @Composable( RenderingT , environment: ViewEnvironment ) -> Unit ): ViewFactory < RenderingT > Creates a ViewFactory that uses a Composable function to display the rendering. renderAsState [androidJvm] @Composable fun < PropsT , OutputT : Any , RenderingT > Workflow < PropsT , OutputT , RenderingT >. renderAsState (props: PropsT , interceptors: List <WorkflowInterceptor> = emptyList(), scope: CoroutineScope = rememberCoroutineScope(), onOutput: suspend ( OutputT ) -> Unit ): State< RenderingT > Runs this Workflow as long as this composable is part of the composition, and returns a State object that will be updated whenever the runtime emits a new RenderingT . Note that here, and in the rest of the documentation for this class, the \u201cState\u201d type refers to Compose\u2019s snapshot State type, not the concept of the StateT type in a particular workflow. withCompositionRoot [androidJvm] @WorkflowUiExperimentalApi fun ViewEnvironment . withCompositionRoot (root: CompositionRoot ): ViewEnvironment Convenience function for applying a CompositionRoot to this ViewEnvironment \u2018s ViewRegistry . See ViewRegistry.withCompositionRoot . [androidJvm] @WorkflowUiExperimentalApi fun ViewRegistry . withCompositionRoot (root: CompositionRoot ): ViewRegistry Returns a ViewRegistry that ensures that any composeViewFactory factories registered in this registry will be wrapped exactly once with a CompositionRoot wrapper. See CompositionRoot for more information. WorkflowRendering [androidJvm] @WorkflowUiExperimentalApi @Composable fun WorkflowRendering (rendering: Any , viewEnvironment: ViewEnvironment , modifier: Modifier = Modifier) Renders rendering into the composition using this ViewEnvironment \u2018s ViewRegistry to generate the view.","title":"Functions"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.compose/-compose-rendering/","text":"// workflow / com.squareup.workflow1.ui.compose / ComposeRendering ComposeRendering \u00b6 [androidJvm]\\ @WorkflowUiExperimentalApi inline fun ComposeRendering (crossinline content: @Composable( ViewEnvironment ) -> Unit ): ComposeRendering Convenience function for creating anonymous ComposeRendering s since composable fun interfaces aren\u2019t supported. See the ComposeRendering class for more information.","title":" compose rendering"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.compose/-compose-rendering/#composerendering","text":"[androidJvm]\\ @WorkflowUiExperimentalApi inline fun ComposeRendering (crossinline content: @Composable( ViewEnvironment ) -> Unit ): ComposeRendering Convenience function for creating anonymous ComposeRendering s since composable fun interfaces aren\u2019t supported. See the ComposeRendering class for more information.","title":"ComposeRendering"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.compose/-workflow-rendering/","text":"// workflow / com.squareup.workflow1.ui.compose / WorkflowRendering WorkflowRendering \u00b6 [androidJvm]\\ @WorkflowUiExperimentalApi @Composable fun WorkflowRendering (rendering: Any , viewEnvironment: ViewEnvironment , modifier: Modifier = Modifier) Renders rendering into the composition using this ViewEnvironment \u2018s ViewRegistry to generate the view. This function fulfills a similar role as WorkflowViewStub , but is much more convenient to use from Composable functions. Note, however, that just like WorkflowViewStub , it doesn\u2019t matter whether the factory registered for the rendering is using classic Android views or Compose. Example \u00b6 data class FramedRendering<R : Any>(\\ val borderColor: Color,\\ val child: R\\ ) : ComposeRendering {\\ \\ @Composable override fun Content(viewEnvironment: ViewEnvironment) {\\ Surface(border = Border(borderColor, 8.dp)) {\\ WorkflowRendering(child, viewEnvironment)\\ }\\ }\\ } Parameters \u00b6 androidJvm rendering The workflow rendering to display. May be of any type for which a ViewFactory has been registered in viewEnvironment \u2018s ViewRegistry . modifier A Modifier that will be applied to composable used to show rendering . Throws \u00b6 kotlin.IllegalArgumentException if no factory can be found for rendering \u2018s type.","title":" workflow rendering"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.compose/-workflow-rendering/#workflowrendering","text":"[androidJvm]\\ @WorkflowUiExperimentalApi @Composable fun WorkflowRendering (rendering: Any , viewEnvironment: ViewEnvironment , modifier: Modifier = Modifier) Renders rendering into the composition using this ViewEnvironment \u2018s ViewRegistry to generate the view. This function fulfills a similar role as WorkflowViewStub , but is much more convenient to use from Composable functions. Note, however, that just like WorkflowViewStub , it doesn\u2019t matter whether the factory registered for the rendering is using classic Android views or Compose.","title":"WorkflowRendering"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.compose/-workflow-rendering/#example","text":"data class FramedRendering<R : Any>(\\ val borderColor: Color,\\ val child: R\\ ) : ComposeRendering {\\ \\ @Composable override fun Content(viewEnvironment: ViewEnvironment) {\\ Surface(border = Border(borderColor, 8.dp)) {\\ WorkflowRendering(child, viewEnvironment)\\ }\\ }\\ }","title":"Example"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.compose/-workflow-rendering/#parameters","text":"androidJvm rendering The workflow rendering to display. May be of any type for which a ViewFactory has been registered in viewEnvironment \u2018s ViewRegistry . modifier A Modifier that will be applied to composable used to show rendering .","title":"Parameters"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.compose/-workflow-rendering/#throws","text":"kotlin.IllegalArgumentException if no factory can be found for rendering \u2018s type.","title":"Throws"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.compose/as-mutable-state/","text":"// workflow / com.squareup.workflow1.ui.compose / asMutableState asMutableState \u00b6 [androidJvm]\\ @Composable fun TextController . asMutableState (): MutableState< String > Exposes the textValue of a TextController as a remembered MutableState, suitable for use from @Composable functions. Usage: 1 2 3 4 5 6 7 8 var text by rendering.textController.asMutableState() OutlinedTextField( label = {}, placeholder = { Text(\"Enter some text\") }, value = text, onValueChange = { text = it } )","title":"As mutable state"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.compose/as-mutable-state/#asmutablestate","text":"[androidJvm]\\ @Composable fun TextController . asMutableState (): MutableState< String > Exposes the textValue of a TextController as a remembered MutableState, suitable for use from @Composable functions. Usage: 1 2 3 4 5 6 7 8 var text by rendering.textController.asMutableState() OutlinedTextField( label = {}, placeholder = { Text(\"Enter some text\") }, value = text, onValueChange = { text = it } )","title":"asMutableState"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.compose/compose-view-factory/","text":"// workflow / com.squareup.workflow1.ui.compose / composeViewFactory composeViewFactory \u00b6 [androidJvm]\\ @WorkflowUiExperimentalApi inline fun < RenderingT : Any > composeViewFactory (noinline content: @Composable( RenderingT , environment: ViewEnvironment ) -> Unit ): ViewFactory < RenderingT > Creates a ViewFactory that uses a Composable function to display the rendering. Simple usage: val FooViewFactory = composeViewFactory { rendering, _ ->\\ Text(rendering.message)\\ }\\ \\ \u2026\\ \\ val viewRegistry = ViewRegistry(FooViewFactory, \u2026) If you need to write a class instead of a function, for example to support dependency injection, see ComposeViewFactory . For more details about how to write composable view factories, see ComposeViewFactory .","title":"Compose view factory"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.compose/compose-view-factory/#composeviewfactory","text":"[androidJvm]\\ @WorkflowUiExperimentalApi inline fun < RenderingT : Any > composeViewFactory (noinline content: @Composable( RenderingT , environment: ViewEnvironment ) -> Unit ): ViewFactory < RenderingT > Creates a ViewFactory that uses a Composable function to display the rendering. Simple usage: val FooViewFactory = composeViewFactory { rendering, _ ->\\ Text(rendering.message)\\ }\\ \\ \u2026\\ \\ val viewRegistry = ViewRegistry(FooViewFactory, \u2026) If you need to write a class instead of a function, for example to support dependency injection, see ComposeViewFactory . For more details about how to write composable view factories, see ComposeViewFactory .","title":"composeViewFactory"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.compose/render-as-state/","text":"// workflow / com.squareup.workflow1.ui.compose / renderAsState renderAsState \u00b6 [androidJvm]\\ @Composable fun < PropsT , OutputT : Any , RenderingT > Workflow < PropsT , OutputT , RenderingT >. renderAsState (props: PropsT , interceptors: List <WorkflowInterceptor> = emptyList(), scope: CoroutineScope = rememberCoroutineScope(), onOutput: suspend ( OutputT ) -> Unit ): State< RenderingT > Runs this Workflow as long as this composable is part of the composition, and returns a State object that will be updated whenever the runtime emits a new RenderingT . Note that here, and in the rest of the documentation for this class, the \u201cState\u201d type refers to Compose\u2019s snapshot State type, not the concept of the StateT type in a particular workflow. The workflow runtime will be started when this function is first added to the composition, and cancelled when it is removed or if the composition fails. The first rendering will be available immediately as soon as this function returns as State.value. Composables that read this value will automatically recompose whenever the runtime emits a new rendering. If you are driving UI from the Workflow tree managed by renderAsState then you will probably want to pass the returned State\u2019s value (which is the Workflow rendering) to the WorkflowRendering composable. Snapshot s from the runtime will automatically be saved and restored using Compose\u2019s rememberSaveable. Example \u00b6 private val appViewRegistry = ViewRegistry(\u2026)\\ \\ @Composable fun App(workflow: Workflow<\u2026>, props: Props) {\\ val scaffoldState = \u2026\\ \\ // Run the workflow in the current composition\u2019s coroutine scope.\\ val rendering by workflow.renderAsState(props, onOutput = { output ->\\ // Note that onOutput is a suspend function, so you can run animations\\ // and call other suspend functions.\\ scaffoldState.snackbarHostState\\ .showSnackbar(output.toString())\\ })\\ val viewEnvironment = remember {\\ ViewEnvironment(mapOf(ViewRegistry to appViewRegistry))\\ }\\ \\ Scaffold(\u2026) { padding ->\\ // Display the root rendering using the view environment\u2019s ViewRegistry.\\ WorkflowRendering(rendering, viewEnvironment, Modifier.padding(padding))\\ }\\ } Caveat on threading and composition \u00b6 Note that the initial render pass will occur on whatever thread this function is called from. That may be a background thread, as Compose supports performing composition on background threads. Well-behaved workflows should have pure initialState and render functions, so this should not be a problem. Any side effects performed by workflows using the runningSideEffect method or Workers will be executed in scope as usual. Also note that composition is an operation that may fail, or be cancelled, and the \u201cresult\u201d of a given composition pass may be thrown away and never used to update UI. When this happens, the composition is said to have failed to commit. If the composition that initializes a workflow runtime using this function fails to commit, the runtime will be started and then immediately cancelled. Since the workflow runtime may perform side effects, this may cause effects that look like they spontaneously occur, or happen more often than they should. Receiver \u00b6 The Workflow to run. If the value of the receiver changes to a different Workflow while this function is in the composition, the runtime will be restarted with the new workflow. Parameters \u00b6 androidJvm props The PropsT for the root Workflow . Changes to this value across different compositions will cause the root workflow to re-render with the new props. interceptors An optional list of WorkflowInterceptors that will wrap every workflow rendered by the runtime. Interceptors will be invoked in 0-to-length order: the interceptor at index 0 will process the workflow first, then the interceptor at index 1, etc. scope The CoroutineScope in which to launch the workflow runtime. If not specified, the value of rememberCoroutineScope will be used. Any exceptions thrown in any workflows, after the initial render pass, will be handled by this scope, and cancelling this scope will cancel the workflow runtime and any running workers. Note that any dispatcher in this scope will not be used to execute the very first render pass. onOutput A function that will be executed whenever the root Workflow emits an output.","title":"Render as state"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.compose/render-as-state/#renderasstate","text":"[androidJvm]\\ @Composable fun < PropsT , OutputT : Any , RenderingT > Workflow < PropsT , OutputT , RenderingT >. renderAsState (props: PropsT , interceptors: List <WorkflowInterceptor> = emptyList(), scope: CoroutineScope = rememberCoroutineScope(), onOutput: suspend ( OutputT ) -> Unit ): State< RenderingT > Runs this Workflow as long as this composable is part of the composition, and returns a State object that will be updated whenever the runtime emits a new RenderingT . Note that here, and in the rest of the documentation for this class, the \u201cState\u201d type refers to Compose\u2019s snapshot State type, not the concept of the StateT type in a particular workflow. The workflow runtime will be started when this function is first added to the composition, and cancelled when it is removed or if the composition fails. The first rendering will be available immediately as soon as this function returns as State.value. Composables that read this value will automatically recompose whenever the runtime emits a new rendering. If you are driving UI from the Workflow tree managed by renderAsState then you will probably want to pass the returned State\u2019s value (which is the Workflow rendering) to the WorkflowRendering composable. Snapshot s from the runtime will automatically be saved and restored using Compose\u2019s rememberSaveable.","title":"renderAsState"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.compose/render-as-state/#example","text":"private val appViewRegistry = ViewRegistry(\u2026)\\ \\ @Composable fun App(workflow: Workflow<\u2026>, props: Props) {\\ val scaffoldState = \u2026\\ \\ // Run the workflow in the current composition\u2019s coroutine scope.\\ val rendering by workflow.renderAsState(props, onOutput = { output ->\\ // Note that onOutput is a suspend function, so you can run animations\\ // and call other suspend functions.\\ scaffoldState.snackbarHostState\\ .showSnackbar(output.toString())\\ })\\ val viewEnvironment = remember {\\ ViewEnvironment(mapOf(ViewRegistry to appViewRegistry))\\ }\\ \\ Scaffold(\u2026) { padding ->\\ // Display the root rendering using the view environment\u2019s ViewRegistry.\\ WorkflowRendering(rendering, viewEnvironment, Modifier.padding(padding))\\ }\\ }","title":"Example"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.compose/render-as-state/#caveat-on-threading-and-composition","text":"Note that the initial render pass will occur on whatever thread this function is called from. That may be a background thread, as Compose supports performing composition on background threads. Well-behaved workflows should have pure initialState and render functions, so this should not be a problem. Any side effects performed by workflows using the runningSideEffect method or Workers will be executed in scope as usual. Also note that composition is an operation that may fail, or be cancelled, and the \u201cresult\u201d of a given composition pass may be thrown away and never used to update UI. When this happens, the composition is said to have failed to commit. If the composition that initializes a workflow runtime using this function fails to commit, the runtime will be started and then immediately cancelled. Since the workflow runtime may perform side effects, this may cause effects that look like they spontaneously occur, or happen more often than they should.","title":"Caveat on threading and composition"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.compose/render-as-state/#receiver","text":"The Workflow to run. If the value of the receiver changes to a different Workflow while this function is in the composition, the runtime will be restarted with the new workflow.","title":"Receiver"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.compose/render-as-state/#parameters","text":"androidJvm props The PropsT for the root Workflow . Changes to this value across different compositions will cause the root workflow to re-render with the new props. interceptors An optional list of WorkflowInterceptors that will wrap every workflow rendered by the runtime. Interceptors will be invoked in 0-to-length order: the interceptor at index 0 will process the workflow first, then the interceptor at index 1, etc. scope The CoroutineScope in which to launch the workflow runtime. If not specified, the value of rememberCoroutineScope will be used. Any exceptions thrown in any workflows, after the initial render pass, will be handled by this scope, and cancelling this scope will cancel the workflow runtime and any running workers. Note that any dispatcher in this scope will not be used to execute the very first render pass. onOutput A function that will be executed whenever the root Workflow emits an output.","title":"Parameters"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.compose/with-composition-root/","text":"// workflow / com.squareup.workflow1.ui.compose / withCompositionRoot withCompositionRoot \u00b6 [androidJvm]\\ @WorkflowUiExperimentalApi fun ViewEnvironment . withCompositionRoot (root: CompositionRoot ): ViewEnvironment Convenience function for applying a CompositionRoot to this ViewEnvironment \u2018s ViewRegistry . See ViewRegistry.withCompositionRoot . [androidJvm]\\ @WorkflowUiExperimentalApi fun ViewRegistry . withCompositionRoot (root: CompositionRoot ): ViewRegistry Returns a ViewRegistry that ensures that any composeViewFactory factories registered in this registry will be wrapped exactly once with a CompositionRoot wrapper. See CompositionRoot for more information.","title":"With composition root"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.compose/with-composition-root/#withcompositionroot","text":"[androidJvm]\\ @WorkflowUiExperimentalApi fun ViewEnvironment . withCompositionRoot (root: CompositionRoot ): ViewEnvironment Convenience function for applying a CompositionRoot to this ViewEnvironment \u2018s ViewRegistry . See ViewRegistry.withCompositionRoot . [androidJvm]\\ @WorkflowUiExperimentalApi fun ViewRegistry . withCompositionRoot (root: CompositionRoot ): ViewRegistry Returns a ViewRegistry that ensures that any composeViewFactory factories registered in this registry will be wrapped exactly once with a CompositionRoot wrapper. See CompositionRoot for more information.","title":"withCompositionRoot"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.compose/-compose-rendering/","text":"// workflow / com.squareup.workflow1.ui.compose / ComposeRendering ComposeRendering \u00b6 [androidJvm]\\ @WorkflowUiExperimentalApi interface ComposeRendering : AndroidViewRendering < Nothing > Interface implemented by a rendering class to allow it to drive a composable UI via an appropriate ComposeViewFactory implementation, by simply overriding the Content method. This is the compose analog to AndroidViewRendering . Note that unlike most workflow view functions, Content does not take the rendering as a parameter. Instead, the rendering is the receiver, i.e. the current value of this. Example: @OptIn(WorkflowUiExperimentalApi::class)\\ data class HelloView(\\ val message: String,\\ val onClick: () -> Unit\\ ) : ComposeRendering {\\ \\ @Composable override fun Content(viewEnvironment: ViewEnvironment) {\\ Button(onClick) {\\ Text(message)\\ }\\ }\\ } This is the simplest way to bridge the gap between your workflows and the UI, but using it requires your workflows code to reside in Android modules, instead of pure Kotlin. If this is a problem, or you need more flexibility for any other reason, you can use ViewRegistry to bind your renderings to ComposeViewFactory implementations at runtime. Functions \u00b6 Name Summary Content [androidJvm] @Composable abstract fun Content (viewEnvironment: ViewEnvironment ) The composable content of this rendering. This method will be called with the current rendering instance as the receiver, any time a new rendering is emitted, or the viewEnvironment changes. Properties \u00b6 Name Summary viewFactory [androidJvm] open override val viewFactory : ViewFactory < Nothing > Don\u2019t override this, override Content instead.","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.compose/-compose-rendering/#composerendering","text":"[androidJvm]\\ @WorkflowUiExperimentalApi interface ComposeRendering : AndroidViewRendering < Nothing > Interface implemented by a rendering class to allow it to drive a composable UI via an appropriate ComposeViewFactory implementation, by simply overriding the Content method. This is the compose analog to AndroidViewRendering . Note that unlike most workflow view functions, Content does not take the rendering as a parameter. Instead, the rendering is the receiver, i.e. the current value of this. Example: @OptIn(WorkflowUiExperimentalApi::class)\\ data class HelloView(\\ val message: String,\\ val onClick: () -> Unit\\ ) : ComposeRendering {\\ \\ @Composable override fun Content(viewEnvironment: ViewEnvironment) {\\ Button(onClick) {\\ Text(message)\\ }\\ }\\ } This is the simplest way to bridge the gap between your workflows and the UI, but using it requires your workflows code to reside in Android modules, instead of pure Kotlin. If this is a problem, or you need more flexibility for any other reason, you can use ViewRegistry to bind your renderings to ComposeViewFactory implementations at runtime.","title":"ComposeRendering"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.compose/-compose-rendering/#functions","text":"Name Summary Content [androidJvm] @Composable abstract fun Content (viewEnvironment: ViewEnvironment ) The composable content of this rendering. This method will be called with the current rendering instance as the receiver, any time a new rendering is emitted, or the viewEnvironment changes.","title":"Functions"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.compose/-compose-rendering/#properties","text":"Name Summary viewFactory [androidJvm] open override val viewFactory : ViewFactory < Nothing > Don\u2019t override this, override Content instead.","title":"Properties"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.compose/-compose-rendering/-content/","text":"// workflow / com.squareup.workflow1.ui.compose / ComposeRendering / Content Content \u00b6 [androidJvm]\\ @Composable abstract fun Content (viewEnvironment: ViewEnvironment ) The composable content of this rendering. This method will be called with the current rendering instance as the receiver, any time a new rendering is emitted, or the viewEnvironment changes.","title":" content"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.compose/-compose-rendering/-content/#content","text":"[androidJvm]\\ @Composable abstract fun Content (viewEnvironment: ViewEnvironment ) The composable content of this rendering. This method will be called with the current rendering instance as the receiver, any time a new rendering is emitted, or the viewEnvironment changes.","title":"Content"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.compose/-compose-rendering/view-factory/","text":"// workflow / com.squareup.workflow1.ui.compose / ComposeRendering / viewFactory viewFactory \u00b6 [androidJvm]\\ open override val viewFactory : ViewFactory < Nothing > Don\u2019t override this, override Content instead.","title":"View factory"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.compose/-compose-rendering/view-factory/#viewfactory","text":"[androidJvm]\\ open override val viewFactory : ViewFactory < Nothing > Don\u2019t override this, override Content instead.","title":"viewFactory"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.compose/-compose-view-factory/","text":"// workflow / com.squareup.workflow1.ui.compose / ComposeViewFactory ComposeViewFactory \u00b6 [androidJvm]\\ @WorkflowUiExperimentalApi abstract class ComposeViewFactory < RenderingT : Any > : ViewFactory < RenderingT > A ViewFactory that uses a Composable function to display the rendering. It is the Compose-based analogue of LayoutRunner . Simple usage: class FooViewFactory : ComposeViewFactory<Foo>() {\\ override val type = Foo::class\\ \\ @Composable override fun Content(\\ rendering: Foo,\\ viewEnvironment: ViewEnvironment\\ ) {\\ Text(rendering.message)\\ }\\ }\\ \\ \u2026\\ \\ val viewRegistry = ViewRegistry(FooViewFactory, \u2026) Nesting child renderings \u00b6 Workflows can render other workflows, and renderings from one workflow can contain renderings from other workflows. These renderings may all be bound to their own ViewFactory s. Regular ViewFactory s and LayoutRunner s use WorkflowViewStub to recursively show nested renderings using the ViewRegistry . View factories defined using this function may also show nested renderings. Doing so is as simple as calling WorkflowRendering and passing in the nested rendering. See the kdoc on that function for an example. Nested renderings will have access to any composition locals defined in outer composable, even if there are legacy views in between them, as long as the ViewEnvironment is propagated continuously between the two factories. Initializing Compose context \u00b6 Often all the composeViewFactory factories in an app need to share some context \u2013 for example, certain composition locals need to be provided, such as MaterialTheme. To configure this shared context, call withCompositionRoot on your top-level ViewEnvironment . The first time a composeViewFactory is used to show a rendering, its Content function will be wrapped with the CompositionRoot . See the documentation on CompositionRoot for more information. Constructors \u00b6 ComposeViewFactory [androidJvm] fun ComposeViewFactory () Functions \u00b6 Name Summary buildView [androidJvm] override fun buildView (initialRendering: RenderingT , initialViewEnvironment: ViewEnvironment , contextForNewView: Context , container: ViewGroup ?): View Content [androidJvm] @Composable abstract fun Content (rendering: RenderingT , viewEnvironment: ViewEnvironment ) The composable content of this ViewFactory . This method will be called any time rendering or viewEnvironment change. It is the Compose-based analogue of LayoutRunner.showRendering . Properties \u00b6 Name Summary type [androidJvm] abstract val type : KClass <in RenderingT >","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.compose/-compose-view-factory/#composeviewfactory","text":"[androidJvm]\\ @WorkflowUiExperimentalApi abstract class ComposeViewFactory < RenderingT : Any > : ViewFactory < RenderingT > A ViewFactory that uses a Composable function to display the rendering. It is the Compose-based analogue of LayoutRunner . Simple usage: class FooViewFactory : ComposeViewFactory<Foo>() {\\ override val type = Foo::class\\ \\ @Composable override fun Content(\\ rendering: Foo,\\ viewEnvironment: ViewEnvironment\\ ) {\\ Text(rendering.message)\\ }\\ }\\ \\ \u2026\\ \\ val viewRegistry = ViewRegistry(FooViewFactory, \u2026)","title":"ComposeViewFactory"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.compose/-compose-view-factory/#nesting-child-renderings","text":"Workflows can render other workflows, and renderings from one workflow can contain renderings from other workflows. These renderings may all be bound to their own ViewFactory s. Regular ViewFactory s and LayoutRunner s use WorkflowViewStub to recursively show nested renderings using the ViewRegistry . View factories defined using this function may also show nested renderings. Doing so is as simple as calling WorkflowRendering and passing in the nested rendering. See the kdoc on that function for an example. Nested renderings will have access to any composition locals defined in outer composable, even if there are legacy views in between them, as long as the ViewEnvironment is propagated continuously between the two factories.","title":"Nesting child renderings"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.compose/-compose-view-factory/#initializing-compose-context","text":"Often all the composeViewFactory factories in an app need to share some context \u2013 for example, certain composition locals need to be provided, such as MaterialTheme. To configure this shared context, call withCompositionRoot on your top-level ViewEnvironment . The first time a composeViewFactory is used to show a rendering, its Content function will be wrapped with the CompositionRoot . See the documentation on CompositionRoot for more information.","title":"Initializing Compose context"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.compose/-compose-view-factory/#constructors","text":"ComposeViewFactory [androidJvm] fun ComposeViewFactory ()","title":"Constructors"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.compose/-compose-view-factory/#functions","text":"Name Summary buildView [androidJvm] override fun buildView (initialRendering: RenderingT , initialViewEnvironment: ViewEnvironment , contextForNewView: Context , container: ViewGroup ?): View Content [androidJvm] @Composable abstract fun Content (rendering: RenderingT , viewEnvironment: ViewEnvironment ) The composable content of this ViewFactory . This method will be called any time rendering or viewEnvironment change. It is the Compose-based analogue of LayoutRunner.showRendering .","title":"Functions"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.compose/-compose-view-factory/#properties","text":"Name Summary type [androidJvm] abstract val type : KClass <in RenderingT >","title":"Properties"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.compose/-compose-view-factory/-compose-view-factory/","text":"// workflow / com.squareup.workflow1.ui.compose / ComposeViewFactory / ComposeViewFactory ComposeViewFactory \u00b6 [androidJvm]\\ fun ComposeViewFactory ()","title":" compose view factory"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.compose/-compose-view-factory/-compose-view-factory/#composeviewfactory","text":"[androidJvm]\\ fun ComposeViewFactory ()","title":"ComposeViewFactory"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.compose/-compose-view-factory/-content/","text":"// workflow / com.squareup.workflow1.ui.compose / ComposeViewFactory / Content Content \u00b6 [androidJvm]\\ @Composable abstract fun Content (rendering: RenderingT , viewEnvironment: ViewEnvironment ) The composable content of this ViewFactory . This method will be called any time rendering or viewEnvironment change. It is the Compose-based analogue of LayoutRunner.showRendering .","title":" content"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.compose/-compose-view-factory/-content/#content","text":"[androidJvm]\\ @Composable abstract fun Content (rendering: RenderingT , viewEnvironment: ViewEnvironment ) The composable content of this ViewFactory . This method will be called any time rendering or viewEnvironment change. It is the Compose-based analogue of LayoutRunner.showRendering .","title":"Content"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.compose/-compose-view-factory/build-view/","text":"// workflow / com.squareup.workflow1.ui.compose / ComposeViewFactory / buildView buildView \u00b6 [androidJvm]\\ override fun buildView (initialRendering: RenderingT , initialViewEnvironment: ViewEnvironment , contextForNewView: Context , container: ViewGroup ?): View","title":"Build view"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.compose/-compose-view-factory/build-view/#buildview","text":"[androidJvm]\\ override fun buildView (initialRendering: RenderingT , initialViewEnvironment: ViewEnvironment , contextForNewView: Context , container: ViewGroup ?): View","title":"buildView"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.compose.tooling/","text":"// workflow / com.squareup.workflow1.ui.compose.tooling Package com.squareup.workflow1.ui.compose.tooling \u00b6 Functions \u00b6 Name Summary Preview [androidJvm] @WorkflowUiExperimentalApi @Composable fun < RenderingT : Any > ViewFactory < RenderingT >. Preview (rendering: RenderingT , modifier: Modifier = Modifier, placeholderModifier: Modifier = Modifier, viewEnvironmentUpdater: ( ViewEnvironment ) -> ViewEnvironment ? = null) Draws this ViewFactory using a special preview ViewRegistry .","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.compose.tooling/#package-comsquareupworkflow1uicomposetooling","text":"","title":"Package com.squareup.workflow1.ui.compose.tooling"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.compose.tooling/#functions","text":"Name Summary Preview [androidJvm] @WorkflowUiExperimentalApi @Composable fun < RenderingT : Any > ViewFactory < RenderingT >. Preview (rendering: RenderingT , modifier: Modifier = Modifier, placeholderModifier: Modifier = Modifier, viewEnvironmentUpdater: ( ViewEnvironment ) -> ViewEnvironment ? = null) Draws this ViewFactory using a special preview ViewRegistry .","title":"Functions"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.compose.tooling/-preview/","text":"// workflow / com.squareup.workflow1.ui.compose.tooling / Preview Preview \u00b6 [androidJvm]\\ @WorkflowUiExperimentalApi @Composable fun < RenderingT : Any > ViewFactory < RenderingT >. Preview (rendering: RenderingT , modifier: Modifier = Modifier, placeholderModifier: Modifier = Modifier, viewEnvironmentUpdater: ( ViewEnvironment ) -> ViewEnvironment ? = null) Draws this ViewFactory using a special preview ViewRegistry . Use inside @Preview Composable functions. Note: rendering must be the same type as this ViewFactory , even though the type system does not enforce this constraint. This is due to a Compose compiler bug tracked here . Parameters \u00b6 androidJvm modifier Modifier that will be applied to this ViewFactory . placeholderModifier Modifier that will be applied to any nested renderings this factory shows. viewEnvironmentUpdater Function that configures the ViewEnvironment passed to this factory.","title":" preview"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.compose.tooling/-preview/#preview","text":"[androidJvm]\\ @WorkflowUiExperimentalApi @Composable fun < RenderingT : Any > ViewFactory < RenderingT >. Preview (rendering: RenderingT , modifier: Modifier = Modifier, placeholderModifier: Modifier = Modifier, viewEnvironmentUpdater: ( ViewEnvironment ) -> ViewEnvironment ? = null) Draws this ViewFactory using a special preview ViewRegistry . Use inside @Preview Composable functions. Note: rendering must be the same type as this ViewFactory , even though the type system does not enforce this constraint. This is due to a Compose compiler bug tracked here .","title":"Preview"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.compose.tooling/-preview/#parameters","text":"androidJvm modifier Modifier that will be applied to this ViewFactory . placeholderModifier Modifier that will be applied to any nested renderings this factory shows. viewEnvironmentUpdater Function that configures the ViewEnvironment passed to this factory.","title":"Parameters"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/","text":"// workflow / com.squareup.workflow1.ui.modal Package com.squareup.workflow1.ui.modal \u00b6 Types \u00b6 Name Summary AlertContainer [androidJvm] @WorkflowUiExperimentalApi class AlertContainer @ JvmOverloads constructor(context: Context , attributeSet: AttributeSet ?, defStyle: Int , defStyleRes: Int , @ StyleRes dialogThemeResId: Int ) : ModalContainer <AlertScreen> Renders the AlertScreens of an AlertContainerScreen as AlertDialog s. AlertContainerScreen [jvm] @ WorkflowUiExperimentalApi data class AlertContainerScreen < B : Any >(beneathModals: B , modals: List < AlertScreen >) : HasModals < B , AlertScreen > May show a stack of AlertScreen over a beneathModals . AlertScreen [jvm] @ WorkflowUiExperimentalApi data class AlertScreen (buttons: Map < AlertScreen.Button , String >, message: String , title: String , cancelable: Boolean , onEvent: ( AlertScreen.Event ) -> Unit ) Models a typical \u201cYou sure about that?\u201d alert box. HasModals [jvm] @ WorkflowUiExperimentalApi interface HasModals <out B : Any , out M : Any > Interface implemented by screen classes that represent a stack of zero or more modal screens above a base screen . ModalContainer [androidJvm] @WorkflowUiExperimentalApi abstract class ModalContainer < ModalRenderingT : Any >@ JvmOverloads constructor(context: Context , attributeSet: AttributeSet ?, defStyle: Int , defStyleRes: Int ) : FrameLayout Base class for containers that show HasModals.modals in Dialog windows. ModalViewContainer [androidJvm] @WorkflowUiExperimentalApi open class ModalViewContainer @ JvmOverloads constructor(context: Context , attributeSet: AttributeSet ?, defStyle: Int , defStyleRes: Int ) : ModalContainer < Any > Container that shows HasModals.modals as arbitrary views in a Dialog window. Provides compatibility with View.backPressedHandler .","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/#package-comsquareupworkflow1uimodal","text":"","title":"Package com.squareup.workflow1.ui.modal"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/#types","text":"Name Summary AlertContainer [androidJvm] @WorkflowUiExperimentalApi class AlertContainer @ JvmOverloads constructor(context: Context , attributeSet: AttributeSet ?, defStyle: Int , defStyleRes: Int , @ StyleRes dialogThemeResId: Int ) : ModalContainer <AlertScreen> Renders the AlertScreens of an AlertContainerScreen as AlertDialog s. AlertContainerScreen [jvm] @ WorkflowUiExperimentalApi data class AlertContainerScreen < B : Any >(beneathModals: B , modals: List < AlertScreen >) : HasModals < B , AlertScreen > May show a stack of AlertScreen over a beneathModals . AlertScreen [jvm] @ WorkflowUiExperimentalApi data class AlertScreen (buttons: Map < AlertScreen.Button , String >, message: String , title: String , cancelable: Boolean , onEvent: ( AlertScreen.Event ) -> Unit ) Models a typical \u201cYou sure about that?\u201d alert box. HasModals [jvm] @ WorkflowUiExperimentalApi interface HasModals <out B : Any , out M : Any > Interface implemented by screen classes that represent a stack of zero or more modal screens above a base screen . ModalContainer [androidJvm] @WorkflowUiExperimentalApi abstract class ModalContainer < ModalRenderingT : Any >@ JvmOverloads constructor(context: Context , attributeSet: AttributeSet ?, defStyle: Int , defStyleRes: Int ) : FrameLayout Base class for containers that show HasModals.modals in Dialog windows. ModalViewContainer [androidJvm] @WorkflowUiExperimentalApi open class ModalViewContainer @ JvmOverloads constructor(context: Context , attributeSet: AttributeSet ?, defStyle: Int , defStyleRes: Int ) : ModalContainer < Any > Container that shows HasModals.modals as arbitrary views in a Dialog window. Provides compatibility with View.backPressedHandler .","title":"Types"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-alert-container/","text":"// workflow / com.squareup.workflow1.ui.modal / AlertContainer AlertContainer \u00b6 [androidJvm]\\ @WorkflowUiExperimentalApi class AlertContainer @ JvmOverloads constructor(context: Context , attributeSet: AttributeSet ?, defStyle: Int , defStyleRes: Int , @ StyleRes dialogThemeResId: Int ) : ModalContainer <AlertScreen> Renders the AlertScreens of an AlertContainerScreen as AlertDialog s. Constructors \u00b6 AlertContainer [androidJvm] @ JvmOverloads fun AlertContainer (context: Context , attributeSet: AttributeSet ? = null, defStyle: Int = 0, defStyleRes: Int = 0, @ StyleRes dialogThemeResId: Int = 0) Types \u00b6 Name Summary Companion [androidJvm] object Companion : ViewFactory <AlertContainerScreen<*>> Functions \u00b6 Name Summary addChildrenForAccessibility [androidJvm] open override fun addChildrenForAccessibility (p0: ArrayList < View >) addExtraDataToAccessibilityNodeInfo [androidJvm] open override fun addExtraDataToAccessibilityNodeInfo (p0: AccessibilityNodeInfo , p1: String , p2: Bundle ?) addFocusables [androidJvm] open fun addFocusables (p0: ArrayList < View >, p1: Int ) open override fun addFocusables (p0: ArrayList < View >, p1: Int , p2: Int ) addKeyboardNavigationClusters [androidJvm] open override fun addKeyboardNavigationClusters (p0: MutableCollection < View >, p1: Int ) addOnAttachStateChangeListener [androidJvm] open fun addOnAttachStateChangeListener (p0: View.OnAttachStateChangeListener ) addOnLayoutChangeListener [androidJvm] open fun addOnLayoutChangeListener (p0: View.OnLayoutChangeListener ) addOnUnhandledKeyEventListener [androidJvm] open fun addOnUnhandledKeyEventListener (p0: View.OnUnhandledKeyEventListener ) addStatesFromChildren [androidJvm] open fun addStatesFromChildren (): Boolean addTouchables [androidJvm] open override fun addTouchables (p0: ArrayList < View >) addView [androidJvm] open fun addView (p0: View ) open override fun addView (p0: View , p1: ViewGroup.LayoutParams ) open fun addView (p0: View , p1: Int ) open fun addView (p0: View , p1: Int , p2: ViewGroup.LayoutParams ) open fun addView (p0: View , p1: Int , p2: Int ) addViewInLayout [androidJvm] open fun addViewInLayout (p0: View , p1: Int , p2: ViewGroup.LayoutParams ): Boolean open fun addViewInLayout (p0: View , p1: Int , p2: ViewGroup.LayoutParams , p3: Boolean ): Boolean animate [androidJvm] open fun animate (): ViewPropertyAnimator announceForAccessibility [androidJvm] open fun announceForAccessibility (p0: CharSequence ) attachLayoutAnimationParameters [androidJvm] open fun attachLayoutAnimationParameters (p0: View , p1: ViewGroup.LayoutParams , p2: Int , p3: Int ) attachViewToParent [androidJvm] open fun attachViewToParent (p0: View , p1: Int , p2: ViewGroup.LayoutParams ) autofill [androidJvm] open fun autofill (p0: SparseArray < AutofillValue >) open fun autofill (p0: AutofillValue ) awakenScrollBars [androidJvm] open fun awakenScrollBars (): Boolean open fun awakenScrollBars (p0: Int ): Boolean open fun awakenScrollBars (p0: Int , p1: Boolean ): Boolean bringChildToFront [androidJvm] open override fun bringChildToFront (p0: View ) bringToFront [androidJvm] open fun bringToFront () buildLayer [androidJvm] open fun buildLayer () callOnClick [androidJvm] open fun callOnClick (): Boolean canAnimate [androidJvm] open fun canAnimate (): Boolean cancelDragAndDrop [androidJvm] fun cancelDragAndDrop () cancelLongPress [androidJvm] open fun cancelLongPress () cancelPendingInputEvents [androidJvm] fun cancelPendingInputEvents () canResolveLayoutDirection [androidJvm] open fun canResolveLayoutDirection (): Boolean canResolveTextAlignment [androidJvm] open fun canResolveTextAlignment (): Boolean canResolveTextDirection [androidJvm] open fun canResolveTextDirection (): Boolean canScrollHorizontally [androidJvm] open fun canScrollHorizontally (p0: Int ): Boolean canScrollVertically [androidJvm] open fun canScrollVertically (p0: Int ): Boolean checkInputConnectionProxy [androidJvm] open fun checkInputConnectionProxy (p0: View ): Boolean checkLayoutParams [androidJvm] open override fun checkLayoutParams (p0: ViewGroup.LayoutParams ): Boolean childDrawableStateChanged [androidJvm] open override fun childDrawableStateChanged (p0: View ) childHasTransientStateChanged [androidJvm] open override fun childHasTransientStateChanged (p0: View , p1: Boolean ) cleanupLayoutState [androidJvm] open fun cleanupLayoutState (p0: View ) clearAnimation [androidJvm] open fun clearAnimation () clearChildFocus [androidJvm] open override fun clearChildFocus (p0: View ) clearDisappearingChildren [androidJvm] open fun clearDisappearingChildren () clearFocus [androidJvm] open override fun clearFocus () clearViewTranslationCallback [androidJvm] open fun clearViewTranslationCallback () computeHorizontalScrollExtent [androidJvm] open fun computeHorizontalScrollExtent (): Int computeHorizontalScrollOffset [androidJvm] open fun computeHorizontalScrollOffset (): Int computeHorizontalScrollRange [androidJvm] open fun computeHorizontalScrollRange (): Int computeScroll [androidJvm] open fun computeScroll () computeSystemWindowInsets [androidJvm] open fun computeSystemWindowInsets (p0: WindowInsets , p1: Rect ): WindowInsets computeVerticalScrollExtent [androidJvm] open fun computeVerticalScrollExtent (): Int computeVerticalScrollOffset [androidJvm] open fun computeVerticalScrollOffset (): Int computeVerticalScrollRange [androidJvm] open fun computeVerticalScrollRange (): Int createAccessibilityNodeInfo [androidJvm] open fun createAccessibilityNodeInfo (): AccessibilityNodeInfo createContextMenu [androidJvm] open fun createContextMenu (p0: ContextMenu ) debug [androidJvm] open fun debug (p0: Int ) detachAllViewsFromParent [androidJvm] open fun detachAllViewsFromParent () detachViewFromParent [androidJvm] open fun detachViewFromParent (p0: View ) open fun detachViewFromParent (p0: Int ) detachViewsFromParent [androidJvm] open fun detachViewsFromParent (p0: Int , p1: Int ) dispatchApplyWindowInsets [androidJvm] open override fun dispatchApplyWindowInsets (p0: WindowInsets ): WindowInsets dispatchCapturedPointerEvent [androidJvm] open override fun dispatchCapturedPointerEvent (p0: MotionEvent ): Boolean dispatchConfigurationChanged [androidJvm] open override fun dispatchConfigurationChanged (p0: Configuration ) dispatchCreateViewTranslationRequest [androidJvm] open override fun dispatchCreateViewTranslationRequest (p0: MutableMap < AutofillId , LongArray >, p1: IntArray , p2: TranslationCapability , p3: MutableList < ViewTranslationRequest >) dispatchDisplayHint [androidJvm] open override fun dispatchDisplayHint (p0: Int ) dispatchDragEvent [androidJvm] open override fun dispatchDragEvent (p0: DragEvent ): Boolean dispatchDraw [androidJvm] open override fun dispatchDraw (p0: Canvas ) dispatchDrawableHotspotChanged [androidJvm] open override fun dispatchDrawableHotspotChanged (p0: Float , p1: Float ) dispatchFinishTemporaryDetach [androidJvm] open override fun dispatchFinishTemporaryDetach () dispatchFreezeSelfOnly [androidJvm] open fun dispatchFreezeSelfOnly (p0: SparseArray < Parcelable >) dispatchGenericFocusedEvent [androidJvm] open override fun dispatchGenericFocusedEvent (p0: MotionEvent ): Boolean dispatchGenericMotionEvent [androidJvm] open fun dispatchGenericMotionEvent (p0: MotionEvent ): Boolean dispatchGenericPointerEvent [androidJvm] open override fun dispatchGenericPointerEvent (p0: MotionEvent ): Boolean dispatchHoverEvent [androidJvm] open override fun dispatchHoverEvent (p0: MotionEvent ): Boolean dispatchKeyEvent [androidJvm] open override fun dispatchKeyEvent (p0: KeyEvent ): Boolean dispatchKeyEventPreIme [androidJvm] open override fun dispatchKeyEventPreIme (p0: KeyEvent ): Boolean dispatchKeyShortcutEvent [androidJvm] open override fun dispatchKeyShortcutEvent (p0: KeyEvent ): Boolean dispatchNestedFling [androidJvm] open fun dispatchNestedFling (p0: Float , p1: Float , p2: Boolean ): Boolean dispatchNestedPreFling [androidJvm] open fun dispatchNestedPreFling (p0: Float , p1: Float ): Boolean dispatchNestedPrePerformAccessibilityAction [androidJvm] open fun dispatchNestedPrePerformAccessibilityAction (p0: Int , p1: Bundle ): Boolean dispatchNestedPreScroll [androidJvm] open fun dispatchNestedPreScroll (p0: Int , p1: Int , p2: IntArray ?, p3: IntArray ?): Boolean dispatchNestedScroll [androidJvm] open fun dispatchNestedScroll (p0: Int , p1: Int , p2: Int , p3: Int , p4: IntArray ?): Boolean dispatchPointerCaptureChanged [androidJvm] open override fun dispatchPointerCaptureChanged (p0: Boolean ) dispatchPopulateAccessibilityEvent [androidJvm] open fun dispatchPopulateAccessibilityEvent (p0: AccessibilityEvent ): Boolean dispatchProvideAutofillStructure [androidJvm] open override fun dispatchProvideAutofillStructure (p0: ViewStructure , p1: Int ) dispatchProvideStructure [androidJvm] open override fun dispatchProvideStructure (p0: ViewStructure ) dispatchRestoreInstanceState [androidJvm] open override fun dispatchRestoreInstanceState (p0: SparseArray < Parcelable >) dispatchSaveInstanceState [androidJvm] open override fun dispatchSaveInstanceState (p0: SparseArray < Parcelable >) dispatchScrollCaptureSearch [androidJvm] open override fun dispatchScrollCaptureSearch (p0: Rect , p1: Point , p2: Consumer < ScrollCaptureTarget >) dispatchSetActivated [androidJvm] open override fun dispatchSetActivated (p0: Boolean ) dispatchSetPressed [androidJvm] open override fun dispatchSetPressed (p0: Boolean ) dispatchSetSelected [androidJvm] open override fun dispatchSetSelected (p0: Boolean ) dispatchStartTemporaryDetach [androidJvm] open override fun dispatchStartTemporaryDetach () dispatchThawSelfOnly [androidJvm] open fun dispatchThawSelfOnly (p0: SparseArray < Parcelable >) dispatchTouchEvent [androidJvm] open override fun dispatchTouchEvent (p0: MotionEvent ): Boolean dispatchTrackballEvent [androidJvm] open override fun dispatchTrackballEvent (p0: MotionEvent ): Boolean dispatchUnhandledMove [androidJvm] open override fun dispatchUnhandledMove (p0: View , p1: Int ): Boolean dispatchVisibilityChanged [androidJvm] open override fun dispatchVisibilityChanged (p0: View , p1: Int ) dispatchWindowFocusChanged [androidJvm] open override fun dispatchWindowFocusChanged (p0: Boolean ) dispatchWindowInsetsAnimationEnd [androidJvm] open override fun dispatchWindowInsetsAnimationEnd (p0: WindowInsetsAnimation ) dispatchWindowInsetsAnimationPrepare [androidJvm] open override fun dispatchWindowInsetsAnimationPrepare (p0: WindowInsetsAnimation ) dispatchWindowInsetsAnimationProgress [androidJvm] open override fun dispatchWindowInsetsAnimationProgress (p0: WindowInsets , p1: MutableList < WindowInsetsAnimation >): WindowInsets dispatchWindowInsetsAnimationStart [androidJvm] open override fun dispatchWindowInsetsAnimationStart (p0: WindowInsetsAnimation , p1: WindowInsetsAnimation.Bounds ): WindowInsetsAnimation.Bounds dispatchWindowVisibilityChanged [androidJvm] open override fun dispatchWindowVisibilityChanged (p0: Int ) draw [androidJvm] open fun draw (p0: Canvas ) drawableHotspotChanged [androidJvm] open fun drawableHotspotChanged (p0: Float , p1: Float ) drawableStateChanged [androidJvm] open override fun drawableStateChanged () drawChild [androidJvm] open fun drawChild (p0: Canvas , p1: View , p2: Long ): Boolean endViewTransition [androidJvm] open fun endViewTransition (p0: View ) findFocus [androidJvm] open override fun findFocus (): View findViewById [androidJvm] fun < T : View > findViewById (p0: Int ): T findViewsWithText [androidJvm] open override fun findViewsWithText (p0: ArrayList < View >, p1: CharSequence , p2: Int ) findViewWithTag [androidJvm] fun < T : View > findViewWithTag (p0: Any ): T focusableViewAvailable [androidJvm] open override fun focusableViewAvailable (p0: View ) focusSearch [androidJvm] open fun focusSearch (p0: Int ): View open override fun focusSearch (p0: View , p1: Int ): View forceHasOverlappingRendering [androidJvm] open fun forceHasOverlappingRendering (p0: Boolean ) forceLayout [androidJvm] open fun forceLayout () gatherTransparentRegion [androidJvm] open override fun gatherTransparentRegion (p0: Region ?): Boolean generateDefaultLayoutParams [androidJvm] open override fun generateDefaultLayoutParams (): FrameLayout.LayoutParams generateDisplayHash [androidJvm] open fun generateDisplayHash (p0: String , p1: Rect ?, p2: Executor , p3: DisplayHashResultCallback ) generateLayoutParams [androidJvm] open override fun generateLayoutParams (p0: AttributeSet ): FrameLayout.LayoutParams open override fun generateLayoutParams (p0: ViewGroup.LayoutParams ): ViewGroup.LayoutParams getAccessibilityClassName [androidJvm] open override fun getAccessibilityClassName (): CharSequence getAccessibilityDelegate [androidJvm] open fun getAccessibilityDelegate (): View.AccessibilityDelegate getAccessibilityLiveRegion [androidJvm] open fun getAccessibilityLiveRegion (): Int getAccessibilityNodeProvider [androidJvm] open fun getAccessibilityNodeProvider (): AccessibilityNodeProvider getAccessibilityPaneTitle [androidJvm] open fun getAccessibilityPaneTitle (): CharSequence ? getAccessibilityTraversalAfter [androidJvm] open fun getAccessibilityTraversalAfter (): Int getAccessibilityTraversalBefore [androidJvm] open fun getAccessibilityTraversalBefore (): Int getAlpha [androidJvm] open fun getAlpha (): Float getAnimation [androidJvm] open fun getAnimation (): Animation getAnimationMatrix [androidJvm] open fun getAnimationMatrix (): Matrix ? getApplicationWindowToken [androidJvm] open fun getApplicationWindowToken (): IBinder getAttributeResolutionStack [androidJvm] open fun getAttributeResolutionStack (p0: Int ): IntArray getAttributeSourceResourceMap [androidJvm] open fun getAttributeSourceResourceMap (): MutableMap < Int , Int > getAutofillHints [androidJvm] open fun getAutofillHints (): Array < String >? getAutofillId [androidJvm] fun getAutofillId (): AutofillId getAutofillType [androidJvm] open fun getAutofillType (): Int getAutofillValue [androidJvm] open fun getAutofillValue (): AutofillValue ? getBackground [androidJvm] open fun getBackground (): Drawable getBackgroundTintBlendMode [androidJvm] open fun getBackgroundTintBlendMode (): BlendMode ? getBackgroundTintList [androidJvm] open fun getBackgroundTintList (): ColorStateList ? getBackgroundTintMode [androidJvm] open fun getBackgroundTintMode (): PorterDuff.Mode ? getBaseline [androidJvm] open fun getBaseline (): Int getBottom [androidJvm] fun getBottom (): Int getBottomFadingEdgeStrength [androidJvm] open fun getBottomFadingEdgeStrength (): Float getBottomPaddingOffset [androidJvm] open fun getBottomPaddingOffset (): Int getCameraDistance [androidJvm] open fun getCameraDistance (): Float getChildAt [androidJvm] open fun getChildAt (p0: Int ): View getChildCount [androidJvm] open fun getChildCount (): Int getChildDrawingOrder [androidJvm] fun getChildDrawingOrder (p0: Int ): Int open fun getChildDrawingOrder (p0: Int , p1: Int ): Int getChildStaticTransformation [androidJvm] open fun getChildStaticTransformation (p0: View , p1: Transformation ): Boolean getChildVisibleRect [androidJvm] open override fun getChildVisibleRect (p0: View , p1: Rect , p2: Point ): Boolean getClipBounds [androidJvm] open fun getClipBounds (): Rect open fun getClipBounds (p0: Rect ): Boolean getClipChildren [androidJvm] open fun getClipChildren (): Boolean getClipToOutline [androidJvm] fun getClipToOutline (): Boolean getClipToPadding [androidJvm] open fun getClipToPadding (): Boolean getContentCaptureSession [androidJvm] fun getContentCaptureSession (): ContentCaptureSession ? getContentDescription [androidJvm] open fun getContentDescription (): CharSequence getContext [androidJvm] fun getContext (): Context getContextMenuInfo [androidJvm] open fun getContextMenuInfo (): ContextMenu.ContextMenuInfo getDefaultFocusHighlightEnabled [androidJvm] fun getDefaultFocusHighlightEnabled (): Boolean getDescendantFocusability [androidJvm] open fun getDescendantFocusability (): Int getDisplay [androidJvm] open fun getDisplay (): Display getDrawableState [androidJvm] fun getDrawableState (): IntArray getDrawingRect [androidJvm] open fun getDrawingRect (p0: Rect ) getDrawingTime [androidJvm] open fun getDrawingTime (): Long getElevation [androidJvm] open fun getElevation (): Float getExplicitStyle [androidJvm] open fun getExplicitStyle (): Int getFilterTouchesWhenObscured [androidJvm] open fun getFilterTouchesWhenObscured (): Boolean getFitsSystemWindows [androidJvm] open fun getFitsSystemWindows (): Boolean getFocusable [androidJvm] open fun getFocusable (): Int getFocusables [androidJvm] open fun getFocusables (p0: Int ): ArrayList < View > getFocusedChild [androidJvm] open fun getFocusedChild (): View getFocusedRect [androidJvm] open fun getFocusedRect (p0: Rect ) getForeground [androidJvm] open fun getForeground (): Drawable getForegroundGravity [androidJvm] open fun getForegroundGravity (): Int getForegroundTintBlendMode [androidJvm] open fun getForegroundTintBlendMode (): BlendMode ? getForegroundTintList [androidJvm] open fun getForegroundTintList (): ColorStateList ? getForegroundTintMode [androidJvm] open fun getForegroundTintMode (): PorterDuff.Mode ? getGlobalVisibleRect [androidJvm] fun getGlobalVisibleRect (p0: Rect ): Boolean open fun getGlobalVisibleRect (p0: Rect , p1: Point ): Boolean getHandler [androidJvm] open fun getHandler (): Handler getHasOverlappingRendering [androidJvm] fun getHasOverlappingRendering (): Boolean getHeight [androidJvm] fun getHeight (): Int getHitRect [androidJvm] open fun getHitRect (p0: Rect ) getHorizontalFadingEdgeLength [androidJvm] open fun getHorizontalFadingEdgeLength (): Int getHorizontalScrollbarHeight [androidJvm] open fun getHorizontalScrollbarHeight (): Int getHorizontalScrollbarThumbDrawable [androidJvm] open fun getHorizontalScrollbarThumbDrawable (): Drawable ? getHorizontalScrollbarTrackDrawable [androidJvm] open fun getHorizontalScrollbarTrackDrawable (): Drawable ? getId [androidJvm] open fun getId (): Int getImportantForAccessibility [androidJvm] open fun getImportantForAccessibility (): Int getImportantForAutofill [androidJvm] open fun getImportantForAutofill (): Int getImportantForContentCapture [androidJvm] open fun getImportantForContentCapture (): Int getKeepScreenOn [androidJvm] open fun getKeepScreenOn (): Boolean getKeyDispatcherState [androidJvm] open fun getKeyDispatcherState (): KeyEvent.DispatcherState getLabelFor [androidJvm] open fun getLabelFor (): Int getLayerType [androidJvm] open fun getLayerType (): Int getLayoutAnimation [androidJvm] open fun getLayoutAnimation (): LayoutAnimationController getLayoutAnimationListener [androidJvm] open fun getLayoutAnimationListener (): Animation.AnimationListener getLayoutDirection [androidJvm] open fun getLayoutDirection (): Int getLayoutMode [androidJvm] open fun getLayoutMode (): Int getLayoutParams [androidJvm] open fun getLayoutParams (): ViewGroup.LayoutParams getLayoutTransition [androidJvm] open fun getLayoutTransition (): LayoutTransition getLeft [androidJvm] fun getLeft (): Int getLeftFadingEdgeStrength [androidJvm] open fun getLeftFadingEdgeStrength (): Float getLeftPaddingOffset [androidJvm] open fun getLeftPaddingOffset (): Int getLocalVisibleRect [androidJvm] fun getLocalVisibleRect (p0: Rect ): Boolean getLocationInSurface [androidJvm] open fun getLocationInSurface (p0: IntArray ) getLocationInWindow [androidJvm] open fun getLocationInWindow (p0: IntArray ) getLocationOnScreen [androidJvm] open fun getLocationOnScreen (p0: IntArray ) getMatrix [androidJvm] open fun getMatrix (): Matrix getMeasureAllChildren [androidJvm] open fun getMeasureAllChildren (): Boolean getMeasuredHeight [androidJvm] fun getMeasuredHeight (): Int getMeasuredHeightAndState [androidJvm] fun getMeasuredHeightAndState (): Int getMeasuredState [androidJvm] fun getMeasuredState (): Int getMeasuredWidth [androidJvm] fun getMeasuredWidth (): Int getMeasuredWidthAndState [androidJvm] fun getMeasuredWidthAndState (): Int getMinimumHeight [androidJvm] open fun getMinimumHeight (): Int getMinimumWidth [androidJvm] open fun getMinimumWidth (): Int getNestedScrollAxes [androidJvm] open fun getNestedScrollAxes (): Int getNextClusterForwardId [androidJvm] open fun getNextClusterForwardId (): Int getNextFocusDownId [androidJvm] open fun getNextFocusDownId (): Int getNextFocusForwardId [androidJvm] open fun getNextFocusForwardId (): Int getNextFocusLeftId [androidJvm] open fun getNextFocusLeftId (): Int getNextFocusRightId [androidJvm] open fun getNextFocusRightId (): Int getNextFocusUpId [androidJvm] open fun getNextFocusUpId (): Int getOnFocusChangeListener [androidJvm] open fun getOnFocusChangeListener (): View.OnFocusChangeListener getOutlineAmbientShadowColor [androidJvm] open fun getOutlineAmbientShadowColor (): Int getOutlineProvider [androidJvm] open fun getOutlineProvider (): ViewOutlineProvider getOutlineSpotShadowColor [androidJvm] open fun getOutlineSpotShadowColor (): Int getOverlay [androidJvm] open override fun getOverlay (): ViewGroupOverlay getOverScrollMode [androidJvm] open fun getOverScrollMode (): Int getPaddingBottom [androidJvm] open fun getPaddingBottom (): Int getPaddingEnd [androidJvm] open fun getPaddingEnd (): Int getPaddingLeft [androidJvm] open fun getPaddingLeft (): Int getPaddingRight [androidJvm] open fun getPaddingRight (): Int getPaddingStart [androidJvm] open fun getPaddingStart (): Int getPaddingTop [androidJvm] open fun getPaddingTop (): Int getParent [androidJvm] fun getParent (): ViewParent getParentForAccessibility [androidJvm] open fun getParentForAccessibility (): ViewParent getPivotX [androidJvm] open fun getPivotX (): Float getPivotY [androidJvm] open fun getPivotY (): Float getPointerIcon [androidJvm] open fun getPointerIcon (): PointerIcon getReceiveContentMimeTypes [androidJvm] open fun getReceiveContentMimeTypes (): Array < String >? getResources [androidJvm] open fun getResources (): Resources getRevealOnFocusHint [androidJvm] fun getRevealOnFocusHint (): Boolean getRight [androidJvm] fun getRight (): Int getRightFadingEdgeStrength [androidJvm] open fun getRightFadingEdgeStrength (): Float getRightPaddingOffset [androidJvm] open fun getRightPaddingOffset (): Int getRootSurfaceControl [androidJvm] open fun getRootSurfaceControl (): AttachedSurfaceControl ? getRootView [androidJvm] open fun getRootView (): View getRootWindowInsets [androidJvm] open fun getRootWindowInsets (): WindowInsets getRotation [androidJvm] open fun getRotation (): Float getRotationX [androidJvm] open fun getRotationX (): Float getRotationY [androidJvm] open fun getRotationY (): Float getScaleX [androidJvm] open fun getScaleX (): Float getScaleY [androidJvm] open fun getScaleY (): Float getScrollBarDefaultDelayBeforeFade [androidJvm] open fun getScrollBarDefaultDelayBeforeFade (): Int getScrollBarFadeDuration [androidJvm] open fun getScrollBarFadeDuration (): Int getScrollBarSize [androidJvm] open fun getScrollBarSize (): Int getScrollBarStyle [androidJvm] open fun getScrollBarStyle (): Int getScrollCaptureHint [androidJvm] open fun getScrollCaptureHint (): Int getScrollIndicators [androidJvm] open fun getScrollIndicators (): Int getScrollX [androidJvm] fun getScrollX (): Int getScrollY [androidJvm] fun getScrollY (): Int getSolidColor [androidJvm] open fun getSolidColor (): Int getSourceLayoutResId [androidJvm] open fun getSourceLayoutResId (): Int getStateDescription [androidJvm] fun getStateDescription (): CharSequence ? getStateListAnimator [androidJvm] open fun getStateListAnimator (): StateListAnimator getSuggestedMinimumHeight [androidJvm] open fun getSuggestedMinimumHeight (): Int getSuggestedMinimumWidth [androidJvm] open fun getSuggestedMinimumWidth (): Int getSystemGestureExclusionRects [androidJvm] open fun getSystemGestureExclusionRects (): MutableList < Rect > getTag [androidJvm] open fun getTag (): Any open fun getTag (p0: Int ): Any getTextAlignment [androidJvm] open fun getTextAlignment (): Int getTextDirection [androidJvm] open fun getTextDirection (): Int getTooltipText [androidJvm] open fun getTooltipText (): CharSequence ? getTop [androidJvm] fun getTop (): Int getTopFadingEdgeStrength [androidJvm] open fun getTopFadingEdgeStrength (): Float getTopPaddingOffset [androidJvm] open fun getTopPaddingOffset (): Int getTouchables [androidJvm] open fun getTouchables (): ArrayList < View > getTouchDelegate [androidJvm] open fun getTouchDelegate (): TouchDelegate getTouchscreenBlocksFocus [androidJvm] open fun getTouchscreenBlocksFocus (): Boolean getTransitionAlpha [androidJvm] open fun getTransitionAlpha (): Float getTransitionName [androidJvm] open fun getTransitionName (): String getTranslationX [androidJvm] open fun getTranslationX (): Float getTranslationY [androidJvm] open fun getTranslationY (): Float getTranslationZ [androidJvm] open fun getTranslationZ (): Float getUniqueDrawingId [androidJvm] open fun getUniqueDrawingId (): Long getVerticalFadingEdgeLength [androidJvm] open fun getVerticalFadingEdgeLength (): Int getVerticalScrollbarPosition [androidJvm] open fun getVerticalScrollbarPosition (): Int getVerticalScrollbarThumbDrawable [androidJvm] open fun getVerticalScrollbarThumbDrawable (): Drawable ? getVerticalScrollbarTrackDrawable [androidJvm] open fun getVerticalScrollbarTrackDrawable (): Drawable ? getVerticalScrollbarWidth [androidJvm] open fun getVerticalScrollbarWidth (): Int getViewTranslationResponse [androidJvm] open fun getViewTranslationResponse (): ViewTranslationResponse ? getViewTreeObserver [androidJvm] open fun getViewTreeObserver (): ViewTreeObserver getVisibility [androidJvm] open fun getVisibility (): Int getWidth [androidJvm] fun getWidth (): Int getWindowAttachCount [androidJvm] open fun getWindowAttachCount (): Int getWindowId [androidJvm] open fun getWindowId (): WindowId getWindowInsetsController [androidJvm] open fun getWindowInsetsController (): WindowInsetsController ? getWindowToken [androidJvm] open fun getWindowToken (): IBinder getWindowVisibility [androidJvm] open fun getWindowVisibility (): Int getWindowVisibleDisplayFrame [androidJvm] open fun getWindowVisibleDisplayFrame (p0: Rect ) getX [androidJvm] open fun getX (): Float getY [androidJvm] open fun getY (): Float getZ [androidJvm] open fun getZ (): Float hasExplicitFocusable [androidJvm] open fun hasExplicitFocusable (): Boolean hasFocus [androidJvm] open override fun hasFocus (): Boolean hasFocusable [androidJvm] open fun hasFocusable (): Boolean hasNestedScrollingParent [androidJvm] open fun hasNestedScrollingParent (): Boolean hasOnClickListeners [androidJvm] open fun hasOnClickListeners (): Boolean hasOnLongClickListeners [androidJvm] open fun hasOnLongClickListeners (): Boolean hasOverlappingRendering [androidJvm] open fun hasOverlappingRendering (): Boolean hasPointerCapture [androidJvm] open fun hasPointerCapture (): Boolean hasTransientState [androidJvm] open override fun hasTransientState (): Boolean hasWindowFocus [androidJvm] open fun hasWindowFocus (): Boolean indexOfChild [androidJvm] open fun indexOfChild (p0: View ): Int invalidate [androidJvm] open fun invalidate () invalidateDrawable [androidJvm] open override fun invalidateDrawable (p0: Drawable ) invalidateOutline [androidJvm] open fun invalidateOutline () isAccessibilityFocused [androidJvm] open fun isAccessibilityFocused (): Boolean isAccessibilityHeading [androidJvm] open fun isAccessibilityHeading (): Boolean isActivated [androidJvm] open fun isActivated (): Boolean isAttachedToWindow [androidJvm] open fun isAttachedToWindow (): Boolean isChildrenDrawingOrderEnabled [androidJvm] open fun isChildrenDrawingOrderEnabled (): Boolean isClickable [androidJvm] open fun isClickable (): Boolean isContextClickable [androidJvm] open fun isContextClickable (): Boolean isDirty [androidJvm] open fun isDirty (): Boolean isDuplicateParentStateEnabled [androidJvm] open fun isDuplicateParentStateEnabled (): Boolean isEnabled [androidJvm] open fun isEnabled (): Boolean isFocusable [androidJvm] fun isFocusable (): Boolean isFocusableInTouchMode [androidJvm] fun isFocusableInTouchMode (): Boolean isFocused [androidJvm] open fun isFocused (): Boolean isFocusedByDefault [androidJvm] fun isFocusedByDefault (): Boolean isForceDarkAllowed [androidJvm] open fun isForceDarkAllowed (): Boolean isHapticFeedbackEnabled [androidJvm] open fun isHapticFeedbackEnabled (): Boolean isHardwareAccelerated [androidJvm] open fun isHardwareAccelerated (): Boolean isHorizontalFadingEdgeEnabled [androidJvm] open fun isHorizontalFadingEdgeEnabled (): Boolean isHorizontalScrollBarEnabled [androidJvm] open fun isHorizontalScrollBarEnabled (): Boolean isHovered [androidJvm] open fun isHovered (): Boolean isImportantForAccessibility [androidJvm] open fun isImportantForAccessibility (): Boolean isImportantForAutofill [androidJvm] fun isImportantForAutofill (): Boolean isImportantForContentCapture [androidJvm] fun isImportantForContentCapture (): Boolean isInEditMode [androidJvm] open fun isInEditMode (): Boolean isInLayout [androidJvm] open fun isInLayout (): Boolean isInTouchMode [androidJvm] open fun isInTouchMode (): Boolean isKeyboardNavigationCluster [androidJvm] fun isKeyboardNavigationCluster (): Boolean isLaidOut [androidJvm] open fun isLaidOut (): Boolean isLayoutDirectionResolved [androidJvm] open fun isLayoutDirectionResolved (): Boolean isLayoutRequested [androidJvm] open fun isLayoutRequested (): Boolean isLayoutSuppressed [androidJvm] open fun isLayoutSuppressed (): Boolean isLongClickable [androidJvm] open fun isLongClickable (): Boolean isMotionEventSplittingEnabled [androidJvm] open fun isMotionEventSplittingEnabled (): Boolean isNestedScrollingEnabled [androidJvm] open fun isNestedScrollingEnabled (): Boolean isOpaque [androidJvm] open fun isOpaque (): Boolean isPaddingOffsetRequired [androidJvm] open fun isPaddingOffsetRequired (): Boolean isPaddingRelative [androidJvm] open fun isPaddingRelative (): Boolean isPivotSet [androidJvm] open fun isPivotSet (): Boolean isPressed [androidJvm] open fun isPressed (): Boolean isSaveEnabled [androidJvm] open fun isSaveEnabled (): Boolean isSaveFromParentEnabled [androidJvm] open fun isSaveFromParentEnabled (): Boolean isScreenReaderFocusable [androidJvm] open fun isScreenReaderFocusable (): Boolean isScrollbarFadingEnabled [androidJvm] open fun isScrollbarFadingEnabled (): Boolean isScrollContainer [androidJvm] open fun isScrollContainer (): Boolean isSelected [androidJvm] open fun isSelected (): Boolean isShowingLayoutBounds [androidJvm] fun isShowingLayoutBounds (): Boolean isShown [androidJvm] open fun isShown (): Boolean isSoundEffectsEnabled [androidJvm] open fun isSoundEffectsEnabled (): Boolean isTemporarilyDetached [androidJvm] fun isTemporarilyDetached (): Boolean isTextAlignmentResolved [androidJvm] open fun isTextAlignmentResolved (): Boolean isTextDirectionResolved [androidJvm] open fun isTextDirectionResolved (): Boolean isTransitionGroup [androidJvm] open fun isTransitionGroup (): Boolean isVerticalFadingEdgeEnabled [androidJvm] open fun isVerticalFadingEdgeEnabled (): Boolean isVerticalScrollBarEnabled [androidJvm] open fun isVerticalScrollBarEnabled (): Boolean isVisibleToUserForAutofill [androidJvm] open fun isVisibleToUserForAutofill (p0: Int ): Boolean jumpDrawablesToCurrentState [androidJvm] open override fun jumpDrawablesToCurrentState () keyboardNavigationClusterSearch [androidJvm] open fun keyboardNavigationClusterSearch (p0: View , p1: Int ): View layout [androidJvm] override fun layout (p0: Int , p1: Int , p2: Int , p3: Int ) measure [androidJvm] fun measure (p0: Int , p1: Int ) measureChild [androidJvm] open fun measureChild (p0: View , p1: Int , p2: Int ) measureChildren [androidJvm] open fun measureChildren (p0: Int , p1: Int ) measureChildWithMargins [androidJvm] open fun measureChildWithMargins (p0: View , p1: Int , p2: Int , p3: Int , p4: Int ) notifySubtreeAccessibilityStateChanged [androidJvm] open override fun notifySubtreeAccessibilityStateChanged (p0: View , p1: View , p2: Int ) offsetDescendantRectToMyCoords [androidJvm] fun offsetDescendantRectToMyCoords (p0: View , p1: Rect ) offsetLeftAndRight [androidJvm] open fun offsetLeftAndRight (p0: Int ) offsetRectIntoDescendantCoords [androidJvm] fun offsetRectIntoDescendantCoords (p0: View , p1: Rect ) offsetTopAndBottom [androidJvm] open fun offsetTopAndBottom (p0: Int ) onAnimationEnd [androidJvm] open fun onAnimationEnd () onAnimationStart [androidJvm] open fun onAnimationStart () onApplyWindowInsets [androidJvm] open fun onApplyWindowInsets (p0: WindowInsets ): WindowInsets onAttachedToWindow [androidJvm] open override fun onAttachedToWindow () onCancelPendingInputEvents [androidJvm] open fun onCancelPendingInputEvents () onCapturedPointerEvent [androidJvm] open fun onCapturedPointerEvent (p0: MotionEvent ): Boolean onCheckIsTextEditor [androidJvm] open fun onCheckIsTextEditor (): Boolean onConfigurationChanged [androidJvm] open fun onConfigurationChanged (p0: Configuration ) onCreateContextMenu [androidJvm] open fun onCreateContextMenu (p0: ContextMenu ) onCreateDrawableState [androidJvm] open override fun onCreateDrawableState (p0: Int ): IntArray onCreateInputConnection [androidJvm] open fun onCreateInputConnection (p0: EditorInfo ): InputConnection onCreateViewTranslationRequest [androidJvm] open fun onCreateViewTranslationRequest (p0: IntArray , p1: Consumer < ViewTranslationRequest >) onCreateVirtualViewTranslationRequests [androidJvm] open fun onCreateVirtualViewTranslationRequests (p0: LongArray , p1: IntArray , p2: Consumer < ViewTranslationRequest >) onDescendantInvalidated [androidJvm] open override fun onDescendantInvalidated (p0: View , p1: View ) onDetachedFromWindow [androidJvm] open override fun onDetachedFromWindow () onDisplayHint [androidJvm] open fun onDisplayHint (p0: Int ) onDragEvent [androidJvm] open fun onDragEvent (p0: DragEvent ): Boolean onDraw [androidJvm] open fun onDraw (p0: Canvas ) onDrawForeground [androidJvm] open fun onDrawForeground (p0: Canvas ) onDrawScrollBars [androidJvm] fun onDrawScrollBars (p0: Canvas ) onFilterTouchEventForSecurity [androidJvm] open fun onFilterTouchEventForSecurity (p0: MotionEvent ): Boolean onFinishInflate [androidJvm] open fun onFinishInflate () onFinishTemporaryDetach [androidJvm] open fun onFinishTemporaryDetach () onFocusChanged [androidJvm] open fun onFocusChanged (p0: Boolean , p1: Int , p2: Rect ?) onGenericMotionEvent [androidJvm] open fun onGenericMotionEvent (p0: MotionEvent ): Boolean onHoverChanged [androidJvm] open fun onHoverChanged (p0: Boolean ) onHoverEvent [androidJvm] open fun onHoverEvent (p0: MotionEvent ): Boolean onInitializeAccessibilityEvent [androidJvm] open fun onInitializeAccessibilityEvent (p0: AccessibilityEvent ) onInitializeAccessibilityNodeInfo [androidJvm] open fun onInitializeAccessibilityNodeInfo (p0: AccessibilityNodeInfo ) onInterceptHoverEvent [androidJvm] open fun onInterceptHoverEvent (p0: MotionEvent ): Boolean onInterceptTouchEvent [androidJvm] open fun onInterceptTouchEvent (p0: MotionEvent ): Boolean onKeyDown [androidJvm] open override fun onKeyDown (p0: Int , p1: KeyEvent ): Boolean onKeyLongPress [androidJvm] open override fun onKeyLongPress (p0: Int , p1: KeyEvent ): Boolean onKeyMultiple [androidJvm] open override fun onKeyMultiple (p0: Int , p1: Int , p2: KeyEvent ): Boolean onKeyPreIme [androidJvm] open fun onKeyPreIme (p0: Int , p1: KeyEvent ): Boolean onKeyShortcut [androidJvm] open fun onKeyShortcut (p0: Int , p1: KeyEvent ): Boolean onKeyUp [androidJvm] open override fun onKeyUp (p0: Int , p1: KeyEvent ): Boolean onLayout [androidJvm] open override fun onLayout (p0: Boolean , p1: Int , p2: Int , p3: Int , p4: Int ) onMeasure [androidJvm] open override fun onMeasure (p0: Int , p1: Int ) onNestedFling [androidJvm] open override fun onNestedFling (p0: View , p1: Float , p2: Float , p3: Boolean ): Boolean onNestedPreFling [androidJvm] open override fun onNestedPreFling (p0: View , p1: Float , p2: Float ): Boolean onNestedPrePerformAccessibilityAction [androidJvm] open override fun onNestedPrePerformAccessibilityAction (p0: View , p1: Int , p2: Bundle ): Boolean onNestedPreScroll [androidJvm] open override fun onNestedPreScroll (p0: View , p1: Int , p2: Int , p3: IntArray ) onNestedScroll [androidJvm] open override fun onNestedScroll (p0: View , p1: Int , p2: Int , p3: Int , p4: Int ) onNestedScrollAccepted [androidJvm] open override fun onNestedScrollAccepted (p0: View , p1: View , p2: Int ) onOverScrolled [androidJvm] open fun onOverScrolled (p0: Int , p1: Int , p2: Boolean , p3: Boolean ) onPointerCaptureChange [androidJvm] open fun onPointerCaptureChange (p0: Boolean ) onPopulateAccessibilityEvent [androidJvm] open fun onPopulateAccessibilityEvent (p0: AccessibilityEvent ) onProvideAutofillStructure [androidJvm] open fun onProvideAutofillStructure (p0: ViewStructure , p1: Int ) onProvideAutofillVirtualStructure [androidJvm] open fun onProvideAutofillVirtualStructure (p0: ViewStructure , p1: Int ) onProvideContentCaptureStructure [androidJvm] open fun onProvideContentCaptureStructure (p0: ViewStructure , p1: Int ) onProvideStructure [androidJvm] open fun onProvideStructure (p0: ViewStructure ) onProvideVirtualStructure [androidJvm] open fun onProvideVirtualStructure (p0: ViewStructure ) onReceiveContent [androidJvm] open fun onReceiveContent (p0: ContentInfo ): ContentInfo ? onRequestFocusInDescendants [androidJvm] open fun onRequestFocusInDescendants (p0: Int , p1: Rect ): Boolean onRequestSendAccessibilityEvent [androidJvm] open fun onRequestSendAccessibilityEvent (p0: View , p1: AccessibilityEvent ): Boolean onResolvePointerIcon [androidJvm] open override fun onResolvePointerIcon (p0: MotionEvent , p1: Int ): PointerIcon onRtlPropertiesChanged [androidJvm] open fun onRtlPropertiesChanged (p0: Int ) onScreenStateChanged [androidJvm] open fun onScreenStateChanged (p0: Int ) onScrollCaptureSearch [androidJvm] open fun onScrollCaptureSearch (p0: Rect , p1: Point , p2: Consumer < ScrollCaptureTarget >) onScrollChanged [androidJvm] open fun onScrollChanged (p0: Int , p1: Int , p2: Int , p3: Int ) onSetAlpha [androidJvm] open fun onSetAlpha (p0: Int ): Boolean onSizeChanged [androidJvm] open fun onSizeChanged (p0: Int , p1: Int , p2: Int , p3: Int ) onStartNestedScroll [androidJvm] open override fun onStartNestedScroll (p0: View , p1: View , p2: Int ): Boolean onStartTemporaryDetach [androidJvm] open fun onStartTemporaryDetach () onStopNestedScroll [androidJvm] open override fun onStopNestedScroll (p0: View ) onTouchEvent [androidJvm] open fun onTouchEvent (p0: MotionEvent ): Boolean onTrackballEvent [androidJvm] open fun onTrackballEvent (p0: MotionEvent ): Boolean onViewAdded [androidJvm] open fun onViewAdded (p0: View ) onViewRemoved [androidJvm] open fun onViewRemoved (p0: View ) onViewTranslationResponse [androidJvm] open fun onViewTranslationResponse (p0: ViewTranslationResponse ) onVirtualViewTranslationResponses [androidJvm] open fun onVirtualViewTranslationResponses (p0: LongSparseArray < ViewTranslationResponse >) onVisibilityAggregated [androidJvm] open fun onVisibilityAggregated (p0: Boolean ) onVisibilityChanged [androidJvm] open fun onVisibilityChanged (p0: View , p1: Int ) onWindowFocusChanged [androidJvm] open fun onWindowFocusChanged (p0: Boolean ) onWindowVisibilityChanged [androidJvm] open fun onWindowVisibilityChanged (p0: Int ) overScrollBy [androidJvm] open fun overScrollBy (p0: Int , p1: Int , p2: Int , p3: Int , p4: Int , p5: Int , p6: Int , p7: Int , p8: Boolean ): Boolean performAccessibilityAction [androidJvm] open fun performAccessibilityAction (p0: Int , p1: Bundle ): Boolean performClick [androidJvm] open fun performClick (): Boolean performContextClick [androidJvm] open fun performContextClick (): Boolean open fun performContextClick (p0: Float , p1: Float ): Boolean performHapticFeedback [androidJvm] open fun performHapticFeedback (p0: Int ): Boolean open fun performHapticFeedback (p0: Int , p1: Int ): Boolean performLongClick [androidJvm] open fun performLongClick (): Boolean open fun performLongClick (p0: Float , p1: Float ): Boolean performReceiveContent [androidJvm] open fun performReceiveContent (p0: ContentInfo ): ContentInfo ? playSoundEffect [androidJvm] open fun playSoundEffect (p0: Int ) post [androidJvm] open fun post (p0: Runnable ): Boolean postDelayed [androidJvm] open fun postDelayed (p0: Runnable , p1: Long ): Boolean postInvalidate [androidJvm] open fun postInvalidate () open fun postInvalidate (p0: Int , p1: Int , p2: Int , p3: Int ) postInvalidateDelayed [androidJvm] open fun postInvalidateDelayed (p0: Long ) open fun postInvalidateDelayed (p0: Long , p1: Int , p2: Int , p3: Int , p4: Int ) postInvalidateOnAnimation [androidJvm] open fun postInvalidateOnAnimation () open fun postInvalidateOnAnimation (p0: Int , p1: Int , p2: Int , p3: Int ) postOnAnimation [androidJvm] open fun postOnAnimation (p0: Runnable ) postOnAnimationDelayed [androidJvm] open fun postOnAnimationDelayed (p0: Runnable , p1: Long ) recomputeViewAttributes [androidJvm] open override fun recomputeViewAttributes (p0: View ) refreshDrawableState [androidJvm] open fun refreshDrawableState () releasePointerCapture [androidJvm] open fun releasePointerCapture () removeAllViews [androidJvm] open fun removeAllViews () removeAllViewsInLayout [androidJvm] open fun removeAllViewsInLayout () removeCallbacks [androidJvm] open fun removeCallbacks (p0: Runnable ): Boolean removeDetachedView [androidJvm] open fun removeDetachedView (p0: View , p1: Boolean ) removeOnAttachStateChangeListener [androidJvm] open fun removeOnAttachStateChangeListener (p0: View.OnAttachStateChangeListener ) removeOnLayoutChangeListener [androidJvm] open fun removeOnLayoutChangeListener (p0: View.OnLayoutChangeListener ) removeOnUnhandledKeyEventListener [androidJvm] open fun removeOnUnhandledKeyEventListener (p0: View.OnUnhandledKeyEventListener ) removeView [androidJvm] open override fun removeView (p0: View ) removeViewAt [androidJvm] open fun removeViewAt (p0: Int ) removeViewInLayout [androidJvm] open fun removeViewInLayout (p0: View ) removeViews [androidJvm] open fun removeViews (p0: Int , p1: Int ) removeViewsInLayout [androidJvm] open fun removeViewsInLayout (p0: Int , p1: Int ) requestApplyInsets [androidJvm] open fun requestApplyInsets () requestChildFocus [androidJvm] open override fun requestChildFocus (p0: View , p1: View ) requestChildRectangleOnScreen [androidJvm] open override fun requestChildRectangleOnScreen (p0: View , p1: Rect , p2: Boolean ): Boolean requestDisallowInterceptTouchEvent [androidJvm] open override fun requestDisallowInterceptTouchEvent (p0: Boolean ) requestFocus [androidJvm] fun requestFocus (): Boolean fun requestFocus (p0: Int ): Boolean open override fun requestFocus (p0: Int , p1: Rect ): Boolean requestFocusFromTouch [androidJvm] fun requestFocusFromTouch (): Boolean requestLayout [androidJvm] open fun requestLayout () requestPointerCapture [androidJvm] open fun requestPointerCapture () requestRectangleOnScreen [androidJvm] open fun requestRectangleOnScreen (p0: Rect ): Boolean open fun requestRectangleOnScreen (p0: Rect , p1: Boolean ): Boolean requestSendAccessibilityEvent [androidJvm] open override fun requestSendAccessibilityEvent (p0: View , p1: AccessibilityEvent ): Boolean requestTransparentRegion [androidJvm] open override fun requestTransparentRegion (p0: View ) requestUnbufferedDispatch [androidJvm] fun requestUnbufferedDispatch (p0: MotionEvent ) fun requestUnbufferedDispatch (p0: Int ) requireViewById [androidJvm] fun < T : View > requireViewById (p0: Int ): T resetPivot [androidJvm] open fun resetPivot () restoreDefaultFocus [androidJvm] open override fun restoreDefaultFocus (): Boolean restoreHierarchyState [androidJvm] open fun restoreHierarchyState (p0: SparseArray < Parcelable >) saveAttributeDataForStyleable [androidJvm] fun saveAttributeDataForStyleable (p0: Context , p1: IntArray , p2: AttributeSet ?, p3: TypedArray , p4: Int , p5: Int ) saveHierarchyState [androidJvm] open fun saveHierarchyState (p0: SparseArray < Parcelable >) scheduleDrawable [androidJvm] open override fun scheduleDrawable (p0: Drawable , p1: Runnable , p2: Long ) scheduleLayoutAnimation [androidJvm] open fun scheduleLayoutAnimation () scrollBy [androidJvm] open fun scrollBy (p0: Int , p1: Int ) scrollTo [androidJvm] open fun scrollTo (p0: Int , p1: Int ) sendAccessibilityEvent [androidJvm] open override fun sendAccessibilityEvent (p0: Int ) sendAccessibilityEventUnchecked [androidJvm] open override fun sendAccessibilityEventUnchecked (p0: AccessibilityEvent ) setAccessibilityDelegate [androidJvm] open fun setAccessibilityDelegate (p0: View.AccessibilityDelegate ?) setAccessibilityHeading [androidJvm] open fun setAccessibilityHeading (p0: Boolean ) setAccessibilityLiveRegion [androidJvm] open fun setAccessibilityLiveRegion (p0: Int ) setAccessibilityPaneTitle [androidJvm] open fun setAccessibilityPaneTitle (p0: CharSequence ?) setAccessibilityTraversalAfter [androidJvm] open fun setAccessibilityTraversalAfter (p0: Int ) setAccessibilityTraversalBefore [androidJvm] open fun setAccessibilityTraversalBefore (p0: Int ) setActivated [androidJvm] open fun setActivated (p0: Boolean ) setAddStatesFromChildren [androidJvm] open fun setAddStatesFromChildren (p0: Boolean ) setAllowClickWhenDisabled [androidJvm] open fun setAllowClickWhenDisabled (p0: Boolean ) setAlpha [androidJvm] open fun setAlpha (p0: Float ) setAnimation [androidJvm] open fun setAnimation (p0: Animation ) setAnimationMatrix [androidJvm] open fun setAnimationMatrix (p0: Matrix ?) setAutofillHints [androidJvm] open fun setAutofillHints (vararg p0: String ) setAutofillId [androidJvm] open fun setAutofillId (p0: AutofillId ?) setBackground [androidJvm] open fun setBackground (p0: Drawable ) setBackgroundColor [androidJvm] open fun setBackgroundColor (p0: Int ) setBackgroundResource [androidJvm] open fun setBackgroundResource (p0: Int ) setBackgroundTintBlendMode [androidJvm] open fun setBackgroundTintBlendMode (p0: BlendMode ?) setBackgroundTintList [androidJvm] open fun setBackgroundTintList (p0: ColorStateList ?) setBackgroundTintMode [androidJvm] open fun setBackgroundTintMode (p0: PorterDuff.Mode ?) setBottom [androidJvm] fun setBottom (p0: Int ) setCameraDistance [androidJvm] open fun setCameraDistance (p0: Float ) setChildrenDrawingOrderEnabled [androidJvm] open fun setChildrenDrawingOrderEnabled (p0: Boolean ) setClickable [androidJvm] open fun setClickable (p0: Boolean ) setClipBounds [androidJvm] open fun setClipBounds (p0: Rect ) setClipChildren [androidJvm] open fun setClipChildren (p0: Boolean ) setClipToOutline [androidJvm] open fun setClipToOutline (p0: Boolean ) setClipToPadding [androidJvm] open fun setClipToPadding (p0: Boolean ) setContentCaptureSession [androidJvm] open fun setContentCaptureSession (p0: ContentCaptureSession ?) setContentDescription [androidJvm] open fun setContentDescription (p0: CharSequence ) setContextClickable [androidJvm] open fun setContextClickable (p0: Boolean ) setDefaultFocusHighlightEnabled [androidJvm] open fun setDefaultFocusHighlightEnabled (p0: Boolean ) setDescendantFocusability [androidJvm] open fun setDescendantFocusability (p0: Int ) setDuplicateParentStateEnabled [androidJvm] open fun setDuplicateParentStateEnabled (p0: Boolean ) setElevation [androidJvm] open fun setElevation (p0: Float ) setEnabled [androidJvm] open fun setEnabled (p0: Boolean ) setFadingEdgeLength [androidJvm] open fun setFadingEdgeLength (p0: Int ) setFilterTouchesWhenObscured [androidJvm] open fun setFilterTouchesWhenObscured (p0: Boolean ) setFitsSystemWindows [androidJvm] open fun setFitsSystemWindows (p0: Boolean ) setFocusable [androidJvm] open fun setFocusable (p0: Boolean ) open fun setFocusable (p0: Int ) setFocusableInTouchMode [androidJvm] open fun setFocusableInTouchMode (p0: Boolean ) setFocusedByDefault [androidJvm] open fun setFocusedByDefault (p0: Boolean ) setForceDarkAllowed [androidJvm] open fun setForceDarkAllowed (p0: Boolean ) setForeground [androidJvm] open fun setForeground (p0: Drawable ) setForegroundGravity [androidJvm] open override fun setForegroundGravity (p0: Int ) setForegroundTintBlendMode [androidJvm] open fun setForegroundTintBlendMode (p0: BlendMode ?) setForegroundTintList [androidJvm] open fun setForegroundTintList (p0: ColorStateList ?) setForegroundTintMode [androidJvm] open fun setForegroundTintMode (p0: PorterDuff.Mode ?) setHapticFeedbackEnabled [androidJvm] open fun setHapticFeedbackEnabled (p0: Boolean ) setHasTransientState [androidJvm] open fun setHasTransientState (p0: Boolean ) setHorizontalFadingEdgeEnabled [androidJvm] open fun setHorizontalFadingEdgeEnabled (p0: Boolean ) setHorizontalScrollBarEnabled [androidJvm] open fun setHorizontalScrollBarEnabled (p0: Boolean ) setHorizontalScrollbarThumbDrawable [androidJvm] open fun setHorizontalScrollbarThumbDrawable (p0: Drawable ?) setHorizontalScrollbarTrackDrawable [androidJvm] open fun setHorizontalScrollbarTrackDrawable (p0: Drawable ?) setHovered [androidJvm] open fun setHovered (p0: Boolean ) setId [androidJvm] open fun setId (p0: Int ) setImportantForAccessibility [androidJvm] open fun setImportantForAccessibility (p0: Int ) setImportantForAutofill [androidJvm] open fun setImportantForAutofill (p0: Int ) setImportantForContentCapture [androidJvm] open fun setImportantForContentCapture (p0: Int ) setKeepScreenOn [androidJvm] open fun setKeepScreenOn (p0: Boolean ) setKeyboardNavigationCluster [androidJvm] open fun setKeyboardNavigationCluster (p0: Boolean ) setLabelFor [androidJvm] open fun setLabelFor (p0: Int ) setLayerPaint [androidJvm] open fun setLayerPaint (p0: Paint ?) setLayerType [androidJvm] open fun setLayerType (p0: Int , p1: Paint ?) setLayoutAnimation [androidJvm] open fun setLayoutAnimation (p0: LayoutAnimationController ) setLayoutAnimationListener [androidJvm] open fun setLayoutAnimationListener (p0: Animation.AnimationListener ) setLayoutDirection [androidJvm] open fun setLayoutDirection (p0: Int ) setLayoutMode [androidJvm] open fun setLayoutMode (p0: Int ) setLayoutParams [androidJvm] open fun setLayoutParams (p0: ViewGroup.LayoutParams ) setLayoutTransition [androidJvm] open fun setLayoutTransition (p0: LayoutTransition ) setLeft [androidJvm] fun setLeft (p0: Int ) setLeftTopRightBottom [androidJvm] fun setLeftTopRightBottom (p0: Int , p1: Int , p2: Int , p3: Int ) setLongClickable [androidJvm] open fun setLongClickable (p0: Boolean ) setMeasureAllChildren [androidJvm] open fun setMeasureAllChildren (p0: Boolean ) setMeasuredDimension [androidJvm] fun setMeasuredDimension (p0: Int , p1: Int ) setMinimumHeight [androidJvm] open fun setMinimumHeight (p0: Int ) setMinimumWidth [androidJvm] open fun setMinimumWidth (p0: Int ) setMotionEventSplittingEnabled [androidJvm] open fun setMotionEventSplittingEnabled (p0: Boolean ) setNestedScrollingEnabled [androidJvm] open fun setNestedScrollingEnabled (p0: Boolean ) setNextClusterForwardId [androidJvm] open fun setNextClusterForwardId (p0: Int ) setNextFocusDownId [androidJvm] open fun setNextFocusDownId (p0: Int ) setNextFocusForwardId [androidJvm] open fun setNextFocusForwardId (p0: Int ) setNextFocusLeftId [androidJvm] open fun setNextFocusLeftId (p0: Int ) setNextFocusRightId [androidJvm] open fun setNextFocusRightId (p0: Int ) setNextFocusUpId [androidJvm] open fun setNextFocusUpId (p0: Int ) setOnApplyWindowInsetsListener [androidJvm] open fun setOnApplyWindowInsetsListener (p0: View.OnApplyWindowInsetsListener ) setOnCapturedPointerListener [androidJvm] open fun setOnCapturedPointerListener (p0: View.OnCapturedPointerListener ) setOnClickListener [androidJvm] open fun setOnClickListener (p0: View.OnClickListener ?) setOnContextClickListener [androidJvm] open fun setOnContextClickListener (p0: View.OnContextClickListener ?) setOnCreateContextMenuListener [androidJvm] open fun setOnCreateContextMenuListener (p0: View.OnCreateContextMenuListener ) setOnDragListener [androidJvm] open fun setOnDragListener (p0: View.OnDragListener ) setOnFocusChangeListener [androidJvm] open fun setOnFocusChangeListener (p0: View.OnFocusChangeListener ) setOnGenericMotionListener [androidJvm] open fun setOnGenericMotionListener (p0: View.OnGenericMotionListener ) setOnHierarchyChangeListener [androidJvm] open fun setOnHierarchyChangeListener (p0: ViewGroup.OnHierarchyChangeListener ) setOnHoverListener [androidJvm] open fun setOnHoverListener (p0: View.OnHoverListener ) setOnKeyListener [androidJvm] open fun setOnKeyListener (p0: View.OnKeyListener ) setOnLongClickListener [androidJvm] open fun setOnLongClickListener (p0: View.OnLongClickListener ?) setOnReceiveContentListener [androidJvm] open fun setOnReceiveContentListener (p0: Array < String >?, p1: OnReceiveContentListener ?) setOnScrollChangeListener [androidJvm] open fun setOnScrollChangeListener (p0: View.OnScrollChangeListener ) setOnTouchListener [androidJvm] open fun setOnTouchListener (p0: View.OnTouchListener ) setOutlineAmbientShadowColor [androidJvm] open fun setOutlineAmbientShadowColor (p0: Int ) setOutlineProvider [androidJvm] open fun setOutlineProvider (p0: ViewOutlineProvider ) setOutlineSpotShadowColor [androidJvm] open fun setOutlineSpotShadowColor (p0: Int ) setOverScrollMode [androidJvm] open fun setOverScrollMode (p0: Int ) setPadding [androidJvm] open fun setPadding (p0: Int , p1: Int , p2: Int , p3: Int ) setPaddingRelative [androidJvm] open fun setPaddingRelative (p0: Int , p1: Int , p2: Int , p3: Int ) setPivotX [androidJvm] open fun setPivotX (p0: Float ) setPivotY [androidJvm] open fun setPivotY (p0: Float ) setPointerIcon [androidJvm] open fun setPointerIcon (p0: PointerIcon ) setPressed [androidJvm] open fun setPressed (p0: Boolean ) setRenderEffect [androidJvm] open fun setRenderEffect (p0: RenderEffect ?) setRevealOnFocusHint [androidJvm] fun setRevealOnFocusHint (p0: Boolean ) setRight [androidJvm] fun setRight (p0: Int ) setRotation [androidJvm] open fun setRotation (p0: Float ) setRotationX [androidJvm] open fun setRotationX (p0: Float ) setRotationY [androidJvm] open fun setRotationY (p0: Float ) setSaveEnabled [androidJvm] open fun setSaveEnabled (p0: Boolean ) setSaveFromParentEnabled [androidJvm] open fun setSaveFromParentEnabled (p0: Boolean ) setScaleX [androidJvm] open fun setScaleX (p0: Float ) setScaleY [androidJvm] open fun setScaleY (p0: Float ) setScreenReaderFocusable [androidJvm] open fun setScreenReaderFocusable (p0: Boolean ) setScrollBarDefaultDelayBeforeFade [androidJvm] open fun setScrollBarDefaultDelayBeforeFade (p0: Int ) setScrollBarFadeDuration [androidJvm] open fun setScrollBarFadeDuration (p0: Int ) setScrollbarFadingEnabled [androidJvm] open fun setScrollbarFadingEnabled (p0: Boolean ) setScrollBarSize [androidJvm] open fun setScrollBarSize (p0: Int ) setScrollBarStyle [androidJvm] open fun setScrollBarStyle (p0: Int ) setScrollCaptureCallback [androidJvm] fun setScrollCaptureCallback (p0: ScrollCaptureCallback ?) setScrollCaptureHint [androidJvm] open fun setScrollCaptureHint (p0: Int ) setScrollContainer [androidJvm] open fun setScrollContainer (p0: Boolean ) setScrollIndicators [androidJvm] open fun setScrollIndicators (p0: Int ) open fun setScrollIndicators (p0: Int , p1: Int ) setScrollX [androidJvm] open fun setScrollX (p0: Int ) setScrollY [androidJvm] open fun setScrollY (p0: Int ) setSelected [androidJvm] open fun setSelected (p0: Boolean ) setSoundEffectsEnabled [androidJvm] open fun setSoundEffectsEnabled (p0: Boolean ) setStateDescription [androidJvm] open fun setStateDescription (p0: CharSequence ?) setStateListAnimator [androidJvm] open fun setStateListAnimator (p0: StateListAnimator ) setStaticTransformationsEnabled [androidJvm] open fun setStaticTransformationsEnabled (p0: Boolean ) setSystemGestureExclusionRects [androidJvm] open fun setSystemGestureExclusionRects (p0: MutableList < Rect >) setTag [androidJvm] open fun setTag (p0: Any ) open fun setTag (p0: Int , p1: Any ) setTextAlignment [androidJvm] open fun setTextAlignment (p0: Int ) setTextDirection [androidJvm] open fun setTextDirection (p0: Int ) setTooltipText [androidJvm] open fun setTooltipText (p0: CharSequence ?) setTop [androidJvm] fun setTop (p0: Int ) setTouchDelegate [androidJvm] open fun setTouchDelegate (p0: TouchDelegate ) setTouchscreenBlocksFocus [androidJvm] open fun setTouchscreenBlocksFocus (p0: Boolean ) setTransitionAlpha [androidJvm] open fun setTransitionAlpha (p0: Float ) setTransitionGroup [androidJvm] open fun setTransitionGroup (p0: Boolean ) setTransitionName [androidJvm] fun setTransitionName (p0: String ) setTransitionVisibility [androidJvm] open fun setTransitionVisibility (p0: Int ) setTranslationX [androidJvm] open fun setTranslationX (p0: Float ) setTranslationY [androidJvm] open fun setTranslationY (p0: Float ) setTranslationZ [androidJvm] open fun setTranslationZ (p0: Float ) setVerticalFadingEdgeEnabled [androidJvm] open fun setVerticalFadingEdgeEnabled (p0: Boolean ) setVerticalScrollBarEnabled [androidJvm] open fun setVerticalScrollBarEnabled (p0: Boolean ) setVerticalScrollbarPosition [androidJvm] open fun setVerticalScrollbarPosition (p0: Int ) setVerticalScrollbarThumbDrawable [androidJvm] open fun setVerticalScrollbarThumbDrawable (p0: Drawable ?) setVerticalScrollbarTrackDrawable [androidJvm] open fun setVerticalScrollbarTrackDrawable (p0: Drawable ?) setViewTranslationCallback [androidJvm] open fun setViewTranslationCallback (p0: ViewTranslationCallback ) setVisibility [androidJvm] open fun setVisibility (p0: Int ) setWillNotDraw [androidJvm] open fun setWillNotDraw (p0: Boolean ) setWindowInsetsAnimationCallback [androidJvm] open override fun setWindowInsetsAnimationCallback (p0: WindowInsetsAnimation.Callback ?) setX [androidJvm] open fun setX (p0: Float ) setY [androidJvm] open fun setY (p0: Float ) setZ [androidJvm] open fun setZ (p0: Float ) shouldDelayChildPressedState [androidJvm] open override fun shouldDelayChildPressedState (): Boolean showContextMenu [androidJvm] open fun showContextMenu (): Boolean open fun showContextMenu (p0: Float , p1: Float ): Boolean showContextMenuForChild [androidJvm] open override fun showContextMenuForChild (p0: View ): Boolean open override fun showContextMenuForChild (p0: View , p1: Float , p2: Float ): Boolean startActionMode [androidJvm] open fun startActionMode (p0: ActionMode.Callback ): ActionMode open fun startActionMode (p0: ActionMode.Callback , p1: Int ): ActionMode startActionModeForChild [androidJvm] open override fun startActionModeForChild (p0: View , p1: ActionMode.Callback ): ActionMode open override fun startActionModeForChild (p0: View , p1: ActionMode.Callback , p2: Int ): ActionMode startAnimation [androidJvm] open fun startAnimation (p0: Animation ) startDragAndDrop [androidJvm] fun startDragAndDrop (p0: ClipData , p1: View.DragShadowBuilder , p2: Any , p3: Int ): Boolean startLayoutAnimation [androidJvm] open fun startLayoutAnimation () startNestedScroll [androidJvm] open fun startNestedScroll (p0: Int ): Boolean startViewTransition [androidJvm] open fun startViewTransition (p0: View ) stopNestedScroll [androidJvm] open fun stopNestedScroll () suppressLayout [androidJvm] open fun suppressLayout (p0: Boolean ) toString [androidJvm] open override fun toString (): String transformMatrixToGlobal [androidJvm] open fun transformMatrixToGlobal (p0: Matrix ) transformMatrixToLocal [androidJvm] open fun transformMatrixToLocal (p0: Matrix ) unscheduleDrawable [androidJvm] open fun unscheduleDrawable (p0: Drawable ) open override fun unscheduleDrawable (p0: Drawable , p1: Runnable ) updateDragShadow [androidJvm] fun updateDragShadow (p0: View.DragShadowBuilder ) updateViewLayout [androidJvm] open override fun updateViewLayout (p0: View , p1: ViewGroup.LayoutParams ) verifyDrawable [androidJvm] open fun verifyDrawable (p0: Drawable ): Boolean willNotDraw [androidJvm] open fun willNotDraw (): Boolean","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-alert-container/#alertcontainer","text":"[androidJvm]\\ @WorkflowUiExperimentalApi class AlertContainer @ JvmOverloads constructor(context: Context , attributeSet: AttributeSet ?, defStyle: Int , defStyleRes: Int , @ StyleRes dialogThemeResId: Int ) : ModalContainer <AlertScreen> Renders the AlertScreens of an AlertContainerScreen as AlertDialog s.","title":"AlertContainer"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-alert-container/#constructors","text":"AlertContainer [androidJvm] @ JvmOverloads fun AlertContainer (context: Context , attributeSet: AttributeSet ? = null, defStyle: Int = 0, defStyleRes: Int = 0, @ StyleRes dialogThemeResId: Int = 0)","title":"Constructors"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-alert-container/#types","text":"Name Summary Companion [androidJvm] object Companion : ViewFactory <AlertContainerScreen<*>>","title":"Types"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-alert-container/#functions","text":"Name Summary addChildrenForAccessibility [androidJvm] open override fun addChildrenForAccessibility (p0: ArrayList < View >) addExtraDataToAccessibilityNodeInfo [androidJvm] open override fun addExtraDataToAccessibilityNodeInfo (p0: AccessibilityNodeInfo , p1: String , p2: Bundle ?) addFocusables [androidJvm] open fun addFocusables (p0: ArrayList < View >, p1: Int ) open override fun addFocusables (p0: ArrayList < View >, p1: Int , p2: Int ) addKeyboardNavigationClusters [androidJvm] open override fun addKeyboardNavigationClusters (p0: MutableCollection < View >, p1: Int ) addOnAttachStateChangeListener [androidJvm] open fun addOnAttachStateChangeListener (p0: View.OnAttachStateChangeListener ) addOnLayoutChangeListener [androidJvm] open fun addOnLayoutChangeListener (p0: View.OnLayoutChangeListener ) addOnUnhandledKeyEventListener [androidJvm] open fun addOnUnhandledKeyEventListener (p0: View.OnUnhandledKeyEventListener ) addStatesFromChildren [androidJvm] open fun addStatesFromChildren (): Boolean addTouchables [androidJvm] open override fun addTouchables (p0: ArrayList < View >) addView [androidJvm] open fun addView (p0: View ) open override fun addView (p0: View , p1: ViewGroup.LayoutParams ) open fun addView (p0: View , p1: Int ) open fun addView (p0: View , p1: Int , p2: ViewGroup.LayoutParams ) open fun addView (p0: View , p1: Int , p2: Int ) addViewInLayout [androidJvm] open fun addViewInLayout (p0: View , p1: Int , p2: ViewGroup.LayoutParams ): Boolean open fun addViewInLayout (p0: View , p1: Int , p2: ViewGroup.LayoutParams , p3: Boolean ): Boolean animate [androidJvm] open fun animate (): ViewPropertyAnimator announceForAccessibility [androidJvm] open fun announceForAccessibility (p0: CharSequence ) attachLayoutAnimationParameters [androidJvm] open fun attachLayoutAnimationParameters (p0: View , p1: ViewGroup.LayoutParams , p2: Int , p3: Int ) attachViewToParent [androidJvm] open fun attachViewToParent (p0: View , p1: Int , p2: ViewGroup.LayoutParams ) autofill [androidJvm] open fun autofill (p0: SparseArray < AutofillValue >) open fun autofill (p0: AutofillValue ) awakenScrollBars [androidJvm] open fun awakenScrollBars (): Boolean open fun awakenScrollBars (p0: Int ): Boolean open fun awakenScrollBars (p0: Int , p1: Boolean ): Boolean bringChildToFront [androidJvm] open override fun bringChildToFront (p0: View ) bringToFront [androidJvm] open fun bringToFront () buildLayer [androidJvm] open fun buildLayer () callOnClick [androidJvm] open fun callOnClick (): Boolean canAnimate [androidJvm] open fun canAnimate (): Boolean cancelDragAndDrop [androidJvm] fun cancelDragAndDrop () cancelLongPress [androidJvm] open fun cancelLongPress () cancelPendingInputEvents [androidJvm] fun cancelPendingInputEvents () canResolveLayoutDirection [androidJvm] open fun canResolveLayoutDirection (): Boolean canResolveTextAlignment [androidJvm] open fun canResolveTextAlignment (): Boolean canResolveTextDirection [androidJvm] open fun canResolveTextDirection (): Boolean canScrollHorizontally [androidJvm] open fun canScrollHorizontally (p0: Int ): Boolean canScrollVertically [androidJvm] open fun canScrollVertically (p0: Int ): Boolean checkInputConnectionProxy [androidJvm] open fun checkInputConnectionProxy (p0: View ): Boolean checkLayoutParams [androidJvm] open override fun checkLayoutParams (p0: ViewGroup.LayoutParams ): Boolean childDrawableStateChanged [androidJvm] open override fun childDrawableStateChanged (p0: View ) childHasTransientStateChanged [androidJvm] open override fun childHasTransientStateChanged (p0: View , p1: Boolean ) cleanupLayoutState [androidJvm] open fun cleanupLayoutState (p0: View ) clearAnimation [androidJvm] open fun clearAnimation () clearChildFocus [androidJvm] open override fun clearChildFocus (p0: View ) clearDisappearingChildren [androidJvm] open fun clearDisappearingChildren () clearFocus [androidJvm] open override fun clearFocus () clearViewTranslationCallback [androidJvm] open fun clearViewTranslationCallback () computeHorizontalScrollExtent [androidJvm] open fun computeHorizontalScrollExtent (): Int computeHorizontalScrollOffset [androidJvm] open fun computeHorizontalScrollOffset (): Int computeHorizontalScrollRange [androidJvm] open fun computeHorizontalScrollRange (): Int computeScroll [androidJvm] open fun computeScroll () computeSystemWindowInsets [androidJvm] open fun computeSystemWindowInsets (p0: WindowInsets , p1: Rect ): WindowInsets computeVerticalScrollExtent [androidJvm] open fun computeVerticalScrollExtent (): Int computeVerticalScrollOffset [androidJvm] open fun computeVerticalScrollOffset (): Int computeVerticalScrollRange [androidJvm] open fun computeVerticalScrollRange (): Int createAccessibilityNodeInfo [androidJvm] open fun createAccessibilityNodeInfo (): AccessibilityNodeInfo createContextMenu [androidJvm] open fun createContextMenu (p0: ContextMenu ) debug [androidJvm] open fun debug (p0: Int ) detachAllViewsFromParent [androidJvm] open fun detachAllViewsFromParent () detachViewFromParent [androidJvm] open fun detachViewFromParent (p0: View ) open fun detachViewFromParent (p0: Int ) detachViewsFromParent [androidJvm] open fun detachViewsFromParent (p0: Int , p1: Int ) dispatchApplyWindowInsets [androidJvm] open override fun dispatchApplyWindowInsets (p0: WindowInsets ): WindowInsets dispatchCapturedPointerEvent [androidJvm] open override fun dispatchCapturedPointerEvent (p0: MotionEvent ): Boolean dispatchConfigurationChanged [androidJvm] open override fun dispatchConfigurationChanged (p0: Configuration ) dispatchCreateViewTranslationRequest [androidJvm] open override fun dispatchCreateViewTranslationRequest (p0: MutableMap < AutofillId , LongArray >, p1: IntArray , p2: TranslationCapability , p3: MutableList < ViewTranslationRequest >) dispatchDisplayHint [androidJvm] open override fun dispatchDisplayHint (p0: Int ) dispatchDragEvent [androidJvm] open override fun dispatchDragEvent (p0: DragEvent ): Boolean dispatchDraw [androidJvm] open override fun dispatchDraw (p0: Canvas ) dispatchDrawableHotspotChanged [androidJvm] open override fun dispatchDrawableHotspotChanged (p0: Float , p1: Float ) dispatchFinishTemporaryDetach [androidJvm] open override fun dispatchFinishTemporaryDetach () dispatchFreezeSelfOnly [androidJvm] open fun dispatchFreezeSelfOnly (p0: SparseArray < Parcelable >) dispatchGenericFocusedEvent [androidJvm] open override fun dispatchGenericFocusedEvent (p0: MotionEvent ): Boolean dispatchGenericMotionEvent [androidJvm] open fun dispatchGenericMotionEvent (p0: MotionEvent ): Boolean dispatchGenericPointerEvent [androidJvm] open override fun dispatchGenericPointerEvent (p0: MotionEvent ): Boolean dispatchHoverEvent [androidJvm] open override fun dispatchHoverEvent (p0: MotionEvent ): Boolean dispatchKeyEvent [androidJvm] open override fun dispatchKeyEvent (p0: KeyEvent ): Boolean dispatchKeyEventPreIme [androidJvm] open override fun dispatchKeyEventPreIme (p0: KeyEvent ): Boolean dispatchKeyShortcutEvent [androidJvm] open override fun dispatchKeyShortcutEvent (p0: KeyEvent ): Boolean dispatchNestedFling [androidJvm] open fun dispatchNestedFling (p0: Float , p1: Float , p2: Boolean ): Boolean dispatchNestedPreFling [androidJvm] open fun dispatchNestedPreFling (p0: Float , p1: Float ): Boolean dispatchNestedPrePerformAccessibilityAction [androidJvm] open fun dispatchNestedPrePerformAccessibilityAction (p0: Int , p1: Bundle ): Boolean dispatchNestedPreScroll [androidJvm] open fun dispatchNestedPreScroll (p0: Int , p1: Int , p2: IntArray ?, p3: IntArray ?): Boolean dispatchNestedScroll [androidJvm] open fun dispatchNestedScroll (p0: Int , p1: Int , p2: Int , p3: Int , p4: IntArray ?): Boolean dispatchPointerCaptureChanged [androidJvm] open override fun dispatchPointerCaptureChanged (p0: Boolean ) dispatchPopulateAccessibilityEvent [androidJvm] open fun dispatchPopulateAccessibilityEvent (p0: AccessibilityEvent ): Boolean dispatchProvideAutofillStructure [androidJvm] open override fun dispatchProvideAutofillStructure (p0: ViewStructure , p1: Int ) dispatchProvideStructure [androidJvm] open override fun dispatchProvideStructure (p0: ViewStructure ) dispatchRestoreInstanceState [androidJvm] open override fun dispatchRestoreInstanceState (p0: SparseArray < Parcelable >) dispatchSaveInstanceState [androidJvm] open override fun dispatchSaveInstanceState (p0: SparseArray < Parcelable >) dispatchScrollCaptureSearch [androidJvm] open override fun dispatchScrollCaptureSearch (p0: Rect , p1: Point , p2: Consumer < ScrollCaptureTarget >) dispatchSetActivated [androidJvm] open override fun dispatchSetActivated (p0: Boolean ) dispatchSetPressed [androidJvm] open override fun dispatchSetPressed (p0: Boolean ) dispatchSetSelected [androidJvm] open override fun dispatchSetSelected (p0: Boolean ) dispatchStartTemporaryDetach [androidJvm] open override fun dispatchStartTemporaryDetach () dispatchThawSelfOnly [androidJvm] open fun dispatchThawSelfOnly (p0: SparseArray < Parcelable >) dispatchTouchEvent [androidJvm] open override fun dispatchTouchEvent (p0: MotionEvent ): Boolean dispatchTrackballEvent [androidJvm] open override fun dispatchTrackballEvent (p0: MotionEvent ): Boolean dispatchUnhandledMove [androidJvm] open override fun dispatchUnhandledMove (p0: View , p1: Int ): Boolean dispatchVisibilityChanged [androidJvm] open override fun dispatchVisibilityChanged (p0: View , p1: Int ) dispatchWindowFocusChanged [androidJvm] open override fun dispatchWindowFocusChanged (p0: Boolean ) dispatchWindowInsetsAnimationEnd [androidJvm] open override fun dispatchWindowInsetsAnimationEnd (p0: WindowInsetsAnimation ) dispatchWindowInsetsAnimationPrepare [androidJvm] open override fun dispatchWindowInsetsAnimationPrepare (p0: WindowInsetsAnimation ) dispatchWindowInsetsAnimationProgress [androidJvm] open override fun dispatchWindowInsetsAnimationProgress (p0: WindowInsets , p1: MutableList < WindowInsetsAnimation >): WindowInsets dispatchWindowInsetsAnimationStart [androidJvm] open override fun dispatchWindowInsetsAnimationStart (p0: WindowInsetsAnimation , p1: WindowInsetsAnimation.Bounds ): WindowInsetsAnimation.Bounds dispatchWindowVisibilityChanged [androidJvm] open override fun dispatchWindowVisibilityChanged (p0: Int ) draw [androidJvm] open fun draw (p0: Canvas ) drawableHotspotChanged [androidJvm] open fun drawableHotspotChanged (p0: Float , p1: Float ) drawableStateChanged [androidJvm] open override fun drawableStateChanged () drawChild [androidJvm] open fun drawChild (p0: Canvas , p1: View , p2: Long ): Boolean endViewTransition [androidJvm] open fun endViewTransition (p0: View ) findFocus [androidJvm] open override fun findFocus (): View findViewById [androidJvm] fun < T : View > findViewById (p0: Int ): T findViewsWithText [androidJvm] open override fun findViewsWithText (p0: ArrayList < View >, p1: CharSequence , p2: Int ) findViewWithTag [androidJvm] fun < T : View > findViewWithTag (p0: Any ): T focusableViewAvailable [androidJvm] open override fun focusableViewAvailable (p0: View ) focusSearch [androidJvm] open fun focusSearch (p0: Int ): View open override fun focusSearch (p0: View , p1: Int ): View forceHasOverlappingRendering [androidJvm] open fun forceHasOverlappingRendering (p0: Boolean ) forceLayout [androidJvm] open fun forceLayout () gatherTransparentRegion [androidJvm] open override fun gatherTransparentRegion (p0: Region ?): Boolean generateDefaultLayoutParams [androidJvm] open override fun generateDefaultLayoutParams (): FrameLayout.LayoutParams generateDisplayHash [androidJvm] open fun generateDisplayHash (p0: String , p1: Rect ?, p2: Executor , p3: DisplayHashResultCallback ) generateLayoutParams [androidJvm] open override fun generateLayoutParams (p0: AttributeSet ): FrameLayout.LayoutParams open override fun generateLayoutParams (p0: ViewGroup.LayoutParams ): ViewGroup.LayoutParams getAccessibilityClassName [androidJvm] open override fun getAccessibilityClassName (): CharSequence getAccessibilityDelegate [androidJvm] open fun getAccessibilityDelegate (): View.AccessibilityDelegate getAccessibilityLiveRegion [androidJvm] open fun getAccessibilityLiveRegion (): Int getAccessibilityNodeProvider [androidJvm] open fun getAccessibilityNodeProvider (): AccessibilityNodeProvider getAccessibilityPaneTitle [androidJvm] open fun getAccessibilityPaneTitle (): CharSequence ? getAccessibilityTraversalAfter [androidJvm] open fun getAccessibilityTraversalAfter (): Int getAccessibilityTraversalBefore [androidJvm] open fun getAccessibilityTraversalBefore (): Int getAlpha [androidJvm] open fun getAlpha (): Float getAnimation [androidJvm] open fun getAnimation (): Animation getAnimationMatrix [androidJvm] open fun getAnimationMatrix (): Matrix ? getApplicationWindowToken [androidJvm] open fun getApplicationWindowToken (): IBinder getAttributeResolutionStack [androidJvm] open fun getAttributeResolutionStack (p0: Int ): IntArray getAttributeSourceResourceMap [androidJvm] open fun getAttributeSourceResourceMap (): MutableMap < Int , Int > getAutofillHints [androidJvm] open fun getAutofillHints (): Array < String >? getAutofillId [androidJvm] fun getAutofillId (): AutofillId getAutofillType [androidJvm] open fun getAutofillType (): Int getAutofillValue [androidJvm] open fun getAutofillValue (): AutofillValue ? getBackground [androidJvm] open fun getBackground (): Drawable getBackgroundTintBlendMode [androidJvm] open fun getBackgroundTintBlendMode (): BlendMode ? getBackgroundTintList [androidJvm] open fun getBackgroundTintList (): ColorStateList ? getBackgroundTintMode [androidJvm] open fun getBackgroundTintMode (): PorterDuff.Mode ? getBaseline [androidJvm] open fun getBaseline (): Int getBottom [androidJvm] fun getBottom (): Int getBottomFadingEdgeStrength [androidJvm] open fun getBottomFadingEdgeStrength (): Float getBottomPaddingOffset [androidJvm] open fun getBottomPaddingOffset (): Int getCameraDistance [androidJvm] open fun getCameraDistance (): Float getChildAt [androidJvm] open fun getChildAt (p0: Int ): View getChildCount [androidJvm] open fun getChildCount (): Int getChildDrawingOrder [androidJvm] fun getChildDrawingOrder (p0: Int ): Int open fun getChildDrawingOrder (p0: Int , p1: Int ): Int getChildStaticTransformation [androidJvm] open fun getChildStaticTransformation (p0: View , p1: Transformation ): Boolean getChildVisibleRect [androidJvm] open override fun getChildVisibleRect (p0: View , p1: Rect , p2: Point ): Boolean getClipBounds [androidJvm] open fun getClipBounds (): Rect open fun getClipBounds (p0: Rect ): Boolean getClipChildren [androidJvm] open fun getClipChildren (): Boolean getClipToOutline [androidJvm] fun getClipToOutline (): Boolean getClipToPadding [androidJvm] open fun getClipToPadding (): Boolean getContentCaptureSession [androidJvm] fun getContentCaptureSession (): ContentCaptureSession ? getContentDescription [androidJvm] open fun getContentDescription (): CharSequence getContext [androidJvm] fun getContext (): Context getContextMenuInfo [androidJvm] open fun getContextMenuInfo (): ContextMenu.ContextMenuInfo getDefaultFocusHighlightEnabled [androidJvm] fun getDefaultFocusHighlightEnabled (): Boolean getDescendantFocusability [androidJvm] open fun getDescendantFocusability (): Int getDisplay [androidJvm] open fun getDisplay (): Display getDrawableState [androidJvm] fun getDrawableState (): IntArray getDrawingRect [androidJvm] open fun getDrawingRect (p0: Rect ) getDrawingTime [androidJvm] open fun getDrawingTime (): Long getElevation [androidJvm] open fun getElevation (): Float getExplicitStyle [androidJvm] open fun getExplicitStyle (): Int getFilterTouchesWhenObscured [androidJvm] open fun getFilterTouchesWhenObscured (): Boolean getFitsSystemWindows [androidJvm] open fun getFitsSystemWindows (): Boolean getFocusable [androidJvm] open fun getFocusable (): Int getFocusables [androidJvm] open fun getFocusables (p0: Int ): ArrayList < View > getFocusedChild [androidJvm] open fun getFocusedChild (): View getFocusedRect [androidJvm] open fun getFocusedRect (p0: Rect ) getForeground [androidJvm] open fun getForeground (): Drawable getForegroundGravity [androidJvm] open fun getForegroundGravity (): Int getForegroundTintBlendMode [androidJvm] open fun getForegroundTintBlendMode (): BlendMode ? getForegroundTintList [androidJvm] open fun getForegroundTintList (): ColorStateList ? getForegroundTintMode [androidJvm] open fun getForegroundTintMode (): PorterDuff.Mode ? getGlobalVisibleRect [androidJvm] fun getGlobalVisibleRect (p0: Rect ): Boolean open fun getGlobalVisibleRect (p0: Rect , p1: Point ): Boolean getHandler [androidJvm] open fun getHandler (): Handler getHasOverlappingRendering [androidJvm] fun getHasOverlappingRendering (): Boolean getHeight [androidJvm] fun getHeight (): Int getHitRect [androidJvm] open fun getHitRect (p0: Rect ) getHorizontalFadingEdgeLength [androidJvm] open fun getHorizontalFadingEdgeLength (): Int getHorizontalScrollbarHeight [androidJvm] open fun getHorizontalScrollbarHeight (): Int getHorizontalScrollbarThumbDrawable [androidJvm] open fun getHorizontalScrollbarThumbDrawable (): Drawable ? getHorizontalScrollbarTrackDrawable [androidJvm] open fun getHorizontalScrollbarTrackDrawable (): Drawable ? getId [androidJvm] open fun getId (): Int getImportantForAccessibility [androidJvm] open fun getImportantForAccessibility (): Int getImportantForAutofill [androidJvm] open fun getImportantForAutofill (): Int getImportantForContentCapture [androidJvm] open fun getImportantForContentCapture (): Int getKeepScreenOn [androidJvm] open fun getKeepScreenOn (): Boolean getKeyDispatcherState [androidJvm] open fun getKeyDispatcherState (): KeyEvent.DispatcherState getLabelFor [androidJvm] open fun getLabelFor (): Int getLayerType [androidJvm] open fun getLayerType (): Int getLayoutAnimation [androidJvm] open fun getLayoutAnimation (): LayoutAnimationController getLayoutAnimationListener [androidJvm] open fun getLayoutAnimationListener (): Animation.AnimationListener getLayoutDirection [androidJvm] open fun getLayoutDirection (): Int getLayoutMode [androidJvm] open fun getLayoutMode (): Int getLayoutParams [androidJvm] open fun getLayoutParams (): ViewGroup.LayoutParams getLayoutTransition [androidJvm] open fun getLayoutTransition (): LayoutTransition getLeft [androidJvm] fun getLeft (): Int getLeftFadingEdgeStrength [androidJvm] open fun getLeftFadingEdgeStrength (): Float getLeftPaddingOffset [androidJvm] open fun getLeftPaddingOffset (): Int getLocalVisibleRect [androidJvm] fun getLocalVisibleRect (p0: Rect ): Boolean getLocationInSurface [androidJvm] open fun getLocationInSurface (p0: IntArray ) getLocationInWindow [androidJvm] open fun getLocationInWindow (p0: IntArray ) getLocationOnScreen [androidJvm] open fun getLocationOnScreen (p0: IntArray ) getMatrix [androidJvm] open fun getMatrix (): Matrix getMeasureAllChildren [androidJvm] open fun getMeasureAllChildren (): Boolean getMeasuredHeight [androidJvm] fun getMeasuredHeight (): Int getMeasuredHeightAndState [androidJvm] fun getMeasuredHeightAndState (): Int getMeasuredState [androidJvm] fun getMeasuredState (): Int getMeasuredWidth [androidJvm] fun getMeasuredWidth (): Int getMeasuredWidthAndState [androidJvm] fun getMeasuredWidthAndState (): Int getMinimumHeight [androidJvm] open fun getMinimumHeight (): Int getMinimumWidth [androidJvm] open fun getMinimumWidth (): Int getNestedScrollAxes [androidJvm] open fun getNestedScrollAxes (): Int getNextClusterForwardId [androidJvm] open fun getNextClusterForwardId (): Int getNextFocusDownId [androidJvm] open fun getNextFocusDownId (): Int getNextFocusForwardId [androidJvm] open fun getNextFocusForwardId (): Int getNextFocusLeftId [androidJvm] open fun getNextFocusLeftId (): Int getNextFocusRightId [androidJvm] open fun getNextFocusRightId (): Int getNextFocusUpId [androidJvm] open fun getNextFocusUpId (): Int getOnFocusChangeListener [androidJvm] open fun getOnFocusChangeListener (): View.OnFocusChangeListener getOutlineAmbientShadowColor [androidJvm] open fun getOutlineAmbientShadowColor (): Int getOutlineProvider [androidJvm] open fun getOutlineProvider (): ViewOutlineProvider getOutlineSpotShadowColor [androidJvm] open fun getOutlineSpotShadowColor (): Int getOverlay [androidJvm] open override fun getOverlay (): ViewGroupOverlay getOverScrollMode [androidJvm] open fun getOverScrollMode (): Int getPaddingBottom [androidJvm] open fun getPaddingBottom (): Int getPaddingEnd [androidJvm] open fun getPaddingEnd (): Int getPaddingLeft [androidJvm] open fun getPaddingLeft (): Int getPaddingRight [androidJvm] open fun getPaddingRight (): Int getPaddingStart [androidJvm] open fun getPaddingStart (): Int getPaddingTop [androidJvm] open fun getPaddingTop (): Int getParent [androidJvm] fun getParent (): ViewParent getParentForAccessibility [androidJvm] open fun getParentForAccessibility (): ViewParent getPivotX [androidJvm] open fun getPivotX (): Float getPivotY [androidJvm] open fun getPivotY (): Float getPointerIcon [androidJvm] open fun getPointerIcon (): PointerIcon getReceiveContentMimeTypes [androidJvm] open fun getReceiveContentMimeTypes (): Array < String >? getResources [androidJvm] open fun getResources (): Resources getRevealOnFocusHint [androidJvm] fun getRevealOnFocusHint (): Boolean getRight [androidJvm] fun getRight (): Int getRightFadingEdgeStrength [androidJvm] open fun getRightFadingEdgeStrength (): Float getRightPaddingOffset [androidJvm] open fun getRightPaddingOffset (): Int getRootSurfaceControl [androidJvm] open fun getRootSurfaceControl (): AttachedSurfaceControl ? getRootView [androidJvm] open fun getRootView (): View getRootWindowInsets [androidJvm] open fun getRootWindowInsets (): WindowInsets getRotation [androidJvm] open fun getRotation (): Float getRotationX [androidJvm] open fun getRotationX (): Float getRotationY [androidJvm] open fun getRotationY (): Float getScaleX [androidJvm] open fun getScaleX (): Float getScaleY [androidJvm] open fun getScaleY (): Float getScrollBarDefaultDelayBeforeFade [androidJvm] open fun getScrollBarDefaultDelayBeforeFade (): Int getScrollBarFadeDuration [androidJvm] open fun getScrollBarFadeDuration (): Int getScrollBarSize [androidJvm] open fun getScrollBarSize (): Int getScrollBarStyle [androidJvm] open fun getScrollBarStyle (): Int getScrollCaptureHint [androidJvm] open fun getScrollCaptureHint (): Int getScrollIndicators [androidJvm] open fun getScrollIndicators (): Int getScrollX [androidJvm] fun getScrollX (): Int getScrollY [androidJvm] fun getScrollY (): Int getSolidColor [androidJvm] open fun getSolidColor (): Int getSourceLayoutResId [androidJvm] open fun getSourceLayoutResId (): Int getStateDescription [androidJvm] fun getStateDescription (): CharSequence ? getStateListAnimator [androidJvm] open fun getStateListAnimator (): StateListAnimator getSuggestedMinimumHeight [androidJvm] open fun getSuggestedMinimumHeight (): Int getSuggestedMinimumWidth [androidJvm] open fun getSuggestedMinimumWidth (): Int getSystemGestureExclusionRects [androidJvm] open fun getSystemGestureExclusionRects (): MutableList < Rect > getTag [androidJvm] open fun getTag (): Any open fun getTag (p0: Int ): Any getTextAlignment [androidJvm] open fun getTextAlignment (): Int getTextDirection [androidJvm] open fun getTextDirection (): Int getTooltipText [androidJvm] open fun getTooltipText (): CharSequence ? getTop [androidJvm] fun getTop (): Int getTopFadingEdgeStrength [androidJvm] open fun getTopFadingEdgeStrength (): Float getTopPaddingOffset [androidJvm] open fun getTopPaddingOffset (): Int getTouchables [androidJvm] open fun getTouchables (): ArrayList < View > getTouchDelegate [androidJvm] open fun getTouchDelegate (): TouchDelegate getTouchscreenBlocksFocus [androidJvm] open fun getTouchscreenBlocksFocus (): Boolean getTransitionAlpha [androidJvm] open fun getTransitionAlpha (): Float getTransitionName [androidJvm] open fun getTransitionName (): String getTranslationX [androidJvm] open fun getTranslationX (): Float getTranslationY [androidJvm] open fun getTranslationY (): Float getTranslationZ [androidJvm] open fun getTranslationZ (): Float getUniqueDrawingId [androidJvm] open fun getUniqueDrawingId (): Long getVerticalFadingEdgeLength [androidJvm] open fun getVerticalFadingEdgeLength (): Int getVerticalScrollbarPosition [androidJvm] open fun getVerticalScrollbarPosition (): Int getVerticalScrollbarThumbDrawable [androidJvm] open fun getVerticalScrollbarThumbDrawable (): Drawable ? getVerticalScrollbarTrackDrawable [androidJvm] open fun getVerticalScrollbarTrackDrawable (): Drawable ? getVerticalScrollbarWidth [androidJvm] open fun getVerticalScrollbarWidth (): Int getViewTranslationResponse [androidJvm] open fun getViewTranslationResponse (): ViewTranslationResponse ? getViewTreeObserver [androidJvm] open fun getViewTreeObserver (): ViewTreeObserver getVisibility [androidJvm] open fun getVisibility (): Int getWidth [androidJvm] fun getWidth (): Int getWindowAttachCount [androidJvm] open fun getWindowAttachCount (): Int getWindowId [androidJvm] open fun getWindowId (): WindowId getWindowInsetsController [androidJvm] open fun getWindowInsetsController (): WindowInsetsController ? getWindowToken [androidJvm] open fun getWindowToken (): IBinder getWindowVisibility [androidJvm] open fun getWindowVisibility (): Int getWindowVisibleDisplayFrame [androidJvm] open fun getWindowVisibleDisplayFrame (p0: Rect ) getX [androidJvm] open fun getX (): Float getY [androidJvm] open fun getY (): Float getZ [androidJvm] open fun getZ (): Float hasExplicitFocusable [androidJvm] open fun hasExplicitFocusable (): Boolean hasFocus [androidJvm] open override fun hasFocus (): Boolean hasFocusable [androidJvm] open fun hasFocusable (): Boolean hasNestedScrollingParent [androidJvm] open fun hasNestedScrollingParent (): Boolean hasOnClickListeners [androidJvm] open fun hasOnClickListeners (): Boolean hasOnLongClickListeners [androidJvm] open fun hasOnLongClickListeners (): Boolean hasOverlappingRendering [androidJvm] open fun hasOverlappingRendering (): Boolean hasPointerCapture [androidJvm] open fun hasPointerCapture (): Boolean hasTransientState [androidJvm] open override fun hasTransientState (): Boolean hasWindowFocus [androidJvm] open fun hasWindowFocus (): Boolean indexOfChild [androidJvm] open fun indexOfChild (p0: View ): Int invalidate [androidJvm] open fun invalidate () invalidateDrawable [androidJvm] open override fun invalidateDrawable (p0: Drawable ) invalidateOutline [androidJvm] open fun invalidateOutline () isAccessibilityFocused [androidJvm] open fun isAccessibilityFocused (): Boolean isAccessibilityHeading [androidJvm] open fun isAccessibilityHeading (): Boolean isActivated [androidJvm] open fun isActivated (): Boolean isAttachedToWindow [androidJvm] open fun isAttachedToWindow (): Boolean isChildrenDrawingOrderEnabled [androidJvm] open fun isChildrenDrawingOrderEnabled (): Boolean isClickable [androidJvm] open fun isClickable (): Boolean isContextClickable [androidJvm] open fun isContextClickable (): Boolean isDirty [androidJvm] open fun isDirty (): Boolean isDuplicateParentStateEnabled [androidJvm] open fun isDuplicateParentStateEnabled (): Boolean isEnabled [androidJvm] open fun isEnabled (): Boolean isFocusable [androidJvm] fun isFocusable (): Boolean isFocusableInTouchMode [androidJvm] fun isFocusableInTouchMode (): Boolean isFocused [androidJvm] open fun isFocused (): Boolean isFocusedByDefault [androidJvm] fun isFocusedByDefault (): Boolean isForceDarkAllowed [androidJvm] open fun isForceDarkAllowed (): Boolean isHapticFeedbackEnabled [androidJvm] open fun isHapticFeedbackEnabled (): Boolean isHardwareAccelerated [androidJvm] open fun isHardwareAccelerated (): Boolean isHorizontalFadingEdgeEnabled [androidJvm] open fun isHorizontalFadingEdgeEnabled (): Boolean isHorizontalScrollBarEnabled [androidJvm] open fun isHorizontalScrollBarEnabled (): Boolean isHovered [androidJvm] open fun isHovered (): Boolean isImportantForAccessibility [androidJvm] open fun isImportantForAccessibility (): Boolean isImportantForAutofill [androidJvm] fun isImportantForAutofill (): Boolean isImportantForContentCapture [androidJvm] fun isImportantForContentCapture (): Boolean isInEditMode [androidJvm] open fun isInEditMode (): Boolean isInLayout [androidJvm] open fun isInLayout (): Boolean isInTouchMode [androidJvm] open fun isInTouchMode (): Boolean isKeyboardNavigationCluster [androidJvm] fun isKeyboardNavigationCluster (): Boolean isLaidOut [androidJvm] open fun isLaidOut (): Boolean isLayoutDirectionResolved [androidJvm] open fun isLayoutDirectionResolved (): Boolean isLayoutRequested [androidJvm] open fun isLayoutRequested (): Boolean isLayoutSuppressed [androidJvm] open fun isLayoutSuppressed (): Boolean isLongClickable [androidJvm] open fun isLongClickable (): Boolean isMotionEventSplittingEnabled [androidJvm] open fun isMotionEventSplittingEnabled (): Boolean isNestedScrollingEnabled [androidJvm] open fun isNestedScrollingEnabled (): Boolean isOpaque [androidJvm] open fun isOpaque (): Boolean isPaddingOffsetRequired [androidJvm] open fun isPaddingOffsetRequired (): Boolean isPaddingRelative [androidJvm] open fun isPaddingRelative (): Boolean isPivotSet [androidJvm] open fun isPivotSet (): Boolean isPressed [androidJvm] open fun isPressed (): Boolean isSaveEnabled [androidJvm] open fun isSaveEnabled (): Boolean isSaveFromParentEnabled [androidJvm] open fun isSaveFromParentEnabled (): Boolean isScreenReaderFocusable [androidJvm] open fun isScreenReaderFocusable (): Boolean isScrollbarFadingEnabled [androidJvm] open fun isScrollbarFadingEnabled (): Boolean isScrollContainer [androidJvm] open fun isScrollContainer (): Boolean isSelected [androidJvm] open fun isSelected (): Boolean isShowingLayoutBounds [androidJvm] fun isShowingLayoutBounds (): Boolean isShown [androidJvm] open fun isShown (): Boolean isSoundEffectsEnabled [androidJvm] open fun isSoundEffectsEnabled (): Boolean isTemporarilyDetached [androidJvm] fun isTemporarilyDetached (): Boolean isTextAlignmentResolved [androidJvm] open fun isTextAlignmentResolved (): Boolean isTextDirectionResolved [androidJvm] open fun isTextDirectionResolved (): Boolean isTransitionGroup [androidJvm] open fun isTransitionGroup (): Boolean isVerticalFadingEdgeEnabled [androidJvm] open fun isVerticalFadingEdgeEnabled (): Boolean isVerticalScrollBarEnabled [androidJvm] open fun isVerticalScrollBarEnabled (): Boolean isVisibleToUserForAutofill [androidJvm] open fun isVisibleToUserForAutofill (p0: Int ): Boolean jumpDrawablesToCurrentState [androidJvm] open override fun jumpDrawablesToCurrentState () keyboardNavigationClusterSearch [androidJvm] open fun keyboardNavigationClusterSearch (p0: View , p1: Int ): View layout [androidJvm] override fun layout (p0: Int , p1: Int , p2: Int , p3: Int ) measure [androidJvm] fun measure (p0: Int , p1: Int ) measureChild [androidJvm] open fun measureChild (p0: View , p1: Int , p2: Int ) measureChildren [androidJvm] open fun measureChildren (p0: Int , p1: Int ) measureChildWithMargins [androidJvm] open fun measureChildWithMargins (p0: View , p1: Int , p2: Int , p3: Int , p4: Int ) notifySubtreeAccessibilityStateChanged [androidJvm] open override fun notifySubtreeAccessibilityStateChanged (p0: View , p1: View , p2: Int ) offsetDescendantRectToMyCoords [androidJvm] fun offsetDescendantRectToMyCoords (p0: View , p1: Rect ) offsetLeftAndRight [androidJvm] open fun offsetLeftAndRight (p0: Int ) offsetRectIntoDescendantCoords [androidJvm] fun offsetRectIntoDescendantCoords (p0: View , p1: Rect ) offsetTopAndBottom [androidJvm] open fun offsetTopAndBottom (p0: Int ) onAnimationEnd [androidJvm] open fun onAnimationEnd () onAnimationStart [androidJvm] open fun onAnimationStart () onApplyWindowInsets [androidJvm] open fun onApplyWindowInsets (p0: WindowInsets ): WindowInsets onAttachedToWindow [androidJvm] open override fun onAttachedToWindow () onCancelPendingInputEvents [androidJvm] open fun onCancelPendingInputEvents () onCapturedPointerEvent [androidJvm] open fun onCapturedPointerEvent (p0: MotionEvent ): Boolean onCheckIsTextEditor [androidJvm] open fun onCheckIsTextEditor (): Boolean onConfigurationChanged [androidJvm] open fun onConfigurationChanged (p0: Configuration ) onCreateContextMenu [androidJvm] open fun onCreateContextMenu (p0: ContextMenu ) onCreateDrawableState [androidJvm] open override fun onCreateDrawableState (p0: Int ): IntArray onCreateInputConnection [androidJvm] open fun onCreateInputConnection (p0: EditorInfo ): InputConnection onCreateViewTranslationRequest [androidJvm] open fun onCreateViewTranslationRequest (p0: IntArray , p1: Consumer < ViewTranslationRequest >) onCreateVirtualViewTranslationRequests [androidJvm] open fun onCreateVirtualViewTranslationRequests (p0: LongArray , p1: IntArray , p2: Consumer < ViewTranslationRequest >) onDescendantInvalidated [androidJvm] open override fun onDescendantInvalidated (p0: View , p1: View ) onDetachedFromWindow [androidJvm] open override fun onDetachedFromWindow () onDisplayHint [androidJvm] open fun onDisplayHint (p0: Int ) onDragEvent [androidJvm] open fun onDragEvent (p0: DragEvent ): Boolean onDraw [androidJvm] open fun onDraw (p0: Canvas ) onDrawForeground [androidJvm] open fun onDrawForeground (p0: Canvas ) onDrawScrollBars [androidJvm] fun onDrawScrollBars (p0: Canvas ) onFilterTouchEventForSecurity [androidJvm] open fun onFilterTouchEventForSecurity (p0: MotionEvent ): Boolean onFinishInflate [androidJvm] open fun onFinishInflate () onFinishTemporaryDetach [androidJvm] open fun onFinishTemporaryDetach () onFocusChanged [androidJvm] open fun onFocusChanged (p0: Boolean , p1: Int , p2: Rect ?) onGenericMotionEvent [androidJvm] open fun onGenericMotionEvent (p0: MotionEvent ): Boolean onHoverChanged [androidJvm] open fun onHoverChanged (p0: Boolean ) onHoverEvent [androidJvm] open fun onHoverEvent (p0: MotionEvent ): Boolean onInitializeAccessibilityEvent [androidJvm] open fun onInitializeAccessibilityEvent (p0: AccessibilityEvent ) onInitializeAccessibilityNodeInfo [androidJvm] open fun onInitializeAccessibilityNodeInfo (p0: AccessibilityNodeInfo ) onInterceptHoverEvent [androidJvm] open fun onInterceptHoverEvent (p0: MotionEvent ): Boolean onInterceptTouchEvent [androidJvm] open fun onInterceptTouchEvent (p0: MotionEvent ): Boolean onKeyDown [androidJvm] open override fun onKeyDown (p0: Int , p1: KeyEvent ): Boolean onKeyLongPress [androidJvm] open override fun onKeyLongPress (p0: Int , p1: KeyEvent ): Boolean onKeyMultiple [androidJvm] open override fun onKeyMultiple (p0: Int , p1: Int , p2: KeyEvent ): Boolean onKeyPreIme [androidJvm] open fun onKeyPreIme (p0: Int , p1: KeyEvent ): Boolean onKeyShortcut [androidJvm] open fun onKeyShortcut (p0: Int , p1: KeyEvent ): Boolean onKeyUp [androidJvm] open override fun onKeyUp (p0: Int , p1: KeyEvent ): Boolean onLayout [androidJvm] open override fun onLayout (p0: Boolean , p1: Int , p2: Int , p3: Int , p4: Int ) onMeasure [androidJvm] open override fun onMeasure (p0: Int , p1: Int ) onNestedFling [androidJvm] open override fun onNestedFling (p0: View , p1: Float , p2: Float , p3: Boolean ): Boolean onNestedPreFling [androidJvm] open override fun onNestedPreFling (p0: View , p1: Float , p2: Float ): Boolean onNestedPrePerformAccessibilityAction [androidJvm] open override fun onNestedPrePerformAccessibilityAction (p0: View , p1: Int , p2: Bundle ): Boolean onNestedPreScroll [androidJvm] open override fun onNestedPreScroll (p0: View , p1: Int , p2: Int , p3: IntArray ) onNestedScroll [androidJvm] open override fun onNestedScroll (p0: View , p1: Int , p2: Int , p3: Int , p4: Int ) onNestedScrollAccepted [androidJvm] open override fun onNestedScrollAccepted (p0: View , p1: View , p2: Int ) onOverScrolled [androidJvm] open fun onOverScrolled (p0: Int , p1: Int , p2: Boolean , p3: Boolean ) onPointerCaptureChange [androidJvm] open fun onPointerCaptureChange (p0: Boolean ) onPopulateAccessibilityEvent [androidJvm] open fun onPopulateAccessibilityEvent (p0: AccessibilityEvent ) onProvideAutofillStructure [androidJvm] open fun onProvideAutofillStructure (p0: ViewStructure , p1: Int ) onProvideAutofillVirtualStructure [androidJvm] open fun onProvideAutofillVirtualStructure (p0: ViewStructure , p1: Int ) onProvideContentCaptureStructure [androidJvm] open fun onProvideContentCaptureStructure (p0: ViewStructure , p1: Int ) onProvideStructure [androidJvm] open fun onProvideStructure (p0: ViewStructure ) onProvideVirtualStructure [androidJvm] open fun onProvideVirtualStructure (p0: ViewStructure ) onReceiveContent [androidJvm] open fun onReceiveContent (p0: ContentInfo ): ContentInfo ? onRequestFocusInDescendants [androidJvm] open fun onRequestFocusInDescendants (p0: Int , p1: Rect ): Boolean onRequestSendAccessibilityEvent [androidJvm] open fun onRequestSendAccessibilityEvent (p0: View , p1: AccessibilityEvent ): Boolean onResolvePointerIcon [androidJvm] open override fun onResolvePointerIcon (p0: MotionEvent , p1: Int ): PointerIcon onRtlPropertiesChanged [androidJvm] open fun onRtlPropertiesChanged (p0: Int ) onScreenStateChanged [androidJvm] open fun onScreenStateChanged (p0: Int ) onScrollCaptureSearch [androidJvm] open fun onScrollCaptureSearch (p0: Rect , p1: Point , p2: Consumer < ScrollCaptureTarget >) onScrollChanged [androidJvm] open fun onScrollChanged (p0: Int , p1: Int , p2: Int , p3: Int ) onSetAlpha [androidJvm] open fun onSetAlpha (p0: Int ): Boolean onSizeChanged [androidJvm] open fun onSizeChanged (p0: Int , p1: Int , p2: Int , p3: Int ) onStartNestedScroll [androidJvm] open override fun onStartNestedScroll (p0: View , p1: View , p2: Int ): Boolean onStartTemporaryDetach [androidJvm] open fun onStartTemporaryDetach () onStopNestedScroll [androidJvm] open override fun onStopNestedScroll (p0: View ) onTouchEvent [androidJvm] open fun onTouchEvent (p0: MotionEvent ): Boolean onTrackballEvent [androidJvm] open fun onTrackballEvent (p0: MotionEvent ): Boolean onViewAdded [androidJvm] open fun onViewAdded (p0: View ) onViewRemoved [androidJvm] open fun onViewRemoved (p0: View ) onViewTranslationResponse [androidJvm] open fun onViewTranslationResponse (p0: ViewTranslationResponse ) onVirtualViewTranslationResponses [androidJvm] open fun onVirtualViewTranslationResponses (p0: LongSparseArray < ViewTranslationResponse >) onVisibilityAggregated [androidJvm] open fun onVisibilityAggregated (p0: Boolean ) onVisibilityChanged [androidJvm] open fun onVisibilityChanged (p0: View , p1: Int ) onWindowFocusChanged [androidJvm] open fun onWindowFocusChanged (p0: Boolean ) onWindowVisibilityChanged [androidJvm] open fun onWindowVisibilityChanged (p0: Int ) overScrollBy [androidJvm] open fun overScrollBy (p0: Int , p1: Int , p2: Int , p3: Int , p4: Int , p5: Int , p6: Int , p7: Int , p8: Boolean ): Boolean performAccessibilityAction [androidJvm] open fun performAccessibilityAction (p0: Int , p1: Bundle ): Boolean performClick [androidJvm] open fun performClick (): Boolean performContextClick [androidJvm] open fun performContextClick (): Boolean open fun performContextClick (p0: Float , p1: Float ): Boolean performHapticFeedback [androidJvm] open fun performHapticFeedback (p0: Int ): Boolean open fun performHapticFeedback (p0: Int , p1: Int ): Boolean performLongClick [androidJvm] open fun performLongClick (): Boolean open fun performLongClick (p0: Float , p1: Float ): Boolean performReceiveContent [androidJvm] open fun performReceiveContent (p0: ContentInfo ): ContentInfo ? playSoundEffect [androidJvm] open fun playSoundEffect (p0: Int ) post [androidJvm] open fun post (p0: Runnable ): Boolean postDelayed [androidJvm] open fun postDelayed (p0: Runnable , p1: Long ): Boolean postInvalidate [androidJvm] open fun postInvalidate () open fun postInvalidate (p0: Int , p1: Int , p2: Int , p3: Int ) postInvalidateDelayed [androidJvm] open fun postInvalidateDelayed (p0: Long ) open fun postInvalidateDelayed (p0: Long , p1: Int , p2: Int , p3: Int , p4: Int ) postInvalidateOnAnimation [androidJvm] open fun postInvalidateOnAnimation () open fun postInvalidateOnAnimation (p0: Int , p1: Int , p2: Int , p3: Int ) postOnAnimation [androidJvm] open fun postOnAnimation (p0: Runnable ) postOnAnimationDelayed [androidJvm] open fun postOnAnimationDelayed (p0: Runnable , p1: Long ) recomputeViewAttributes [androidJvm] open override fun recomputeViewAttributes (p0: View ) refreshDrawableState [androidJvm] open fun refreshDrawableState () releasePointerCapture [androidJvm] open fun releasePointerCapture () removeAllViews [androidJvm] open fun removeAllViews () removeAllViewsInLayout [androidJvm] open fun removeAllViewsInLayout () removeCallbacks [androidJvm] open fun removeCallbacks (p0: Runnable ): Boolean removeDetachedView [androidJvm] open fun removeDetachedView (p0: View , p1: Boolean ) removeOnAttachStateChangeListener [androidJvm] open fun removeOnAttachStateChangeListener (p0: View.OnAttachStateChangeListener ) removeOnLayoutChangeListener [androidJvm] open fun removeOnLayoutChangeListener (p0: View.OnLayoutChangeListener ) removeOnUnhandledKeyEventListener [androidJvm] open fun removeOnUnhandledKeyEventListener (p0: View.OnUnhandledKeyEventListener ) removeView [androidJvm] open override fun removeView (p0: View ) removeViewAt [androidJvm] open fun removeViewAt (p0: Int ) removeViewInLayout [androidJvm] open fun removeViewInLayout (p0: View ) removeViews [androidJvm] open fun removeViews (p0: Int , p1: Int ) removeViewsInLayout [androidJvm] open fun removeViewsInLayout (p0: Int , p1: Int ) requestApplyInsets [androidJvm] open fun requestApplyInsets () requestChildFocus [androidJvm] open override fun requestChildFocus (p0: View , p1: View ) requestChildRectangleOnScreen [androidJvm] open override fun requestChildRectangleOnScreen (p0: View , p1: Rect , p2: Boolean ): Boolean requestDisallowInterceptTouchEvent [androidJvm] open override fun requestDisallowInterceptTouchEvent (p0: Boolean ) requestFocus [androidJvm] fun requestFocus (): Boolean fun requestFocus (p0: Int ): Boolean open override fun requestFocus (p0: Int , p1: Rect ): Boolean requestFocusFromTouch [androidJvm] fun requestFocusFromTouch (): Boolean requestLayout [androidJvm] open fun requestLayout () requestPointerCapture [androidJvm] open fun requestPointerCapture () requestRectangleOnScreen [androidJvm] open fun requestRectangleOnScreen (p0: Rect ): Boolean open fun requestRectangleOnScreen (p0: Rect , p1: Boolean ): Boolean requestSendAccessibilityEvent [androidJvm] open override fun requestSendAccessibilityEvent (p0: View , p1: AccessibilityEvent ): Boolean requestTransparentRegion [androidJvm] open override fun requestTransparentRegion (p0: View ) requestUnbufferedDispatch [androidJvm] fun requestUnbufferedDispatch (p0: MotionEvent ) fun requestUnbufferedDispatch (p0: Int ) requireViewById [androidJvm] fun < T : View > requireViewById (p0: Int ): T resetPivot [androidJvm] open fun resetPivot () restoreDefaultFocus [androidJvm] open override fun restoreDefaultFocus (): Boolean restoreHierarchyState [androidJvm] open fun restoreHierarchyState (p0: SparseArray < Parcelable >) saveAttributeDataForStyleable [androidJvm] fun saveAttributeDataForStyleable (p0: Context , p1: IntArray , p2: AttributeSet ?, p3: TypedArray , p4: Int , p5: Int ) saveHierarchyState [androidJvm] open fun saveHierarchyState (p0: SparseArray < Parcelable >) scheduleDrawable [androidJvm] open override fun scheduleDrawable (p0: Drawable , p1: Runnable , p2: Long ) scheduleLayoutAnimation [androidJvm] open fun scheduleLayoutAnimation () scrollBy [androidJvm] open fun scrollBy (p0: Int , p1: Int ) scrollTo [androidJvm] open fun scrollTo (p0: Int , p1: Int ) sendAccessibilityEvent [androidJvm] open override fun sendAccessibilityEvent (p0: Int ) sendAccessibilityEventUnchecked [androidJvm] open override fun sendAccessibilityEventUnchecked (p0: AccessibilityEvent ) setAccessibilityDelegate [androidJvm] open fun setAccessibilityDelegate (p0: View.AccessibilityDelegate ?) setAccessibilityHeading [androidJvm] open fun setAccessibilityHeading (p0: Boolean ) setAccessibilityLiveRegion [androidJvm] open fun setAccessibilityLiveRegion (p0: Int ) setAccessibilityPaneTitle [androidJvm] open fun setAccessibilityPaneTitle (p0: CharSequence ?) setAccessibilityTraversalAfter [androidJvm] open fun setAccessibilityTraversalAfter (p0: Int ) setAccessibilityTraversalBefore [androidJvm] open fun setAccessibilityTraversalBefore (p0: Int ) setActivated [androidJvm] open fun setActivated (p0: Boolean ) setAddStatesFromChildren [androidJvm] open fun setAddStatesFromChildren (p0: Boolean ) setAllowClickWhenDisabled [androidJvm] open fun setAllowClickWhenDisabled (p0: Boolean ) setAlpha [androidJvm] open fun setAlpha (p0: Float ) setAnimation [androidJvm] open fun setAnimation (p0: Animation ) setAnimationMatrix [androidJvm] open fun setAnimationMatrix (p0: Matrix ?) setAutofillHints [androidJvm] open fun setAutofillHints (vararg p0: String ) setAutofillId [androidJvm] open fun setAutofillId (p0: AutofillId ?) setBackground [androidJvm] open fun setBackground (p0: Drawable ) setBackgroundColor [androidJvm] open fun setBackgroundColor (p0: Int ) setBackgroundResource [androidJvm] open fun setBackgroundResource (p0: Int ) setBackgroundTintBlendMode [androidJvm] open fun setBackgroundTintBlendMode (p0: BlendMode ?) setBackgroundTintList [androidJvm] open fun setBackgroundTintList (p0: ColorStateList ?) setBackgroundTintMode [androidJvm] open fun setBackgroundTintMode (p0: PorterDuff.Mode ?) setBottom [androidJvm] fun setBottom (p0: Int ) setCameraDistance [androidJvm] open fun setCameraDistance (p0: Float ) setChildrenDrawingOrderEnabled [androidJvm] open fun setChildrenDrawingOrderEnabled (p0: Boolean ) setClickable [androidJvm] open fun setClickable (p0: Boolean ) setClipBounds [androidJvm] open fun setClipBounds (p0: Rect ) setClipChildren [androidJvm] open fun setClipChildren (p0: Boolean ) setClipToOutline [androidJvm] open fun setClipToOutline (p0: Boolean ) setClipToPadding [androidJvm] open fun setClipToPadding (p0: Boolean ) setContentCaptureSession [androidJvm] open fun setContentCaptureSession (p0: ContentCaptureSession ?) setContentDescription [androidJvm] open fun setContentDescription (p0: CharSequence ) setContextClickable [androidJvm] open fun setContextClickable (p0: Boolean ) setDefaultFocusHighlightEnabled [androidJvm] open fun setDefaultFocusHighlightEnabled (p0: Boolean ) setDescendantFocusability [androidJvm] open fun setDescendantFocusability (p0: Int ) setDuplicateParentStateEnabled [androidJvm] open fun setDuplicateParentStateEnabled (p0: Boolean ) setElevation [androidJvm] open fun setElevation (p0: Float ) setEnabled [androidJvm] open fun setEnabled (p0: Boolean ) setFadingEdgeLength [androidJvm] open fun setFadingEdgeLength (p0: Int ) setFilterTouchesWhenObscured [androidJvm] open fun setFilterTouchesWhenObscured (p0: Boolean ) setFitsSystemWindows [androidJvm] open fun setFitsSystemWindows (p0: Boolean ) setFocusable [androidJvm] open fun setFocusable (p0: Boolean ) open fun setFocusable (p0: Int ) setFocusableInTouchMode [androidJvm] open fun setFocusableInTouchMode (p0: Boolean ) setFocusedByDefault [androidJvm] open fun setFocusedByDefault (p0: Boolean ) setForceDarkAllowed [androidJvm] open fun setForceDarkAllowed (p0: Boolean ) setForeground [androidJvm] open fun setForeground (p0: Drawable ) setForegroundGravity [androidJvm] open override fun setForegroundGravity (p0: Int ) setForegroundTintBlendMode [androidJvm] open fun setForegroundTintBlendMode (p0: BlendMode ?) setForegroundTintList [androidJvm] open fun setForegroundTintList (p0: ColorStateList ?) setForegroundTintMode [androidJvm] open fun setForegroundTintMode (p0: PorterDuff.Mode ?) setHapticFeedbackEnabled [androidJvm] open fun setHapticFeedbackEnabled (p0: Boolean ) setHasTransientState [androidJvm] open fun setHasTransientState (p0: Boolean ) setHorizontalFadingEdgeEnabled [androidJvm] open fun setHorizontalFadingEdgeEnabled (p0: Boolean ) setHorizontalScrollBarEnabled [androidJvm] open fun setHorizontalScrollBarEnabled (p0: Boolean ) setHorizontalScrollbarThumbDrawable [androidJvm] open fun setHorizontalScrollbarThumbDrawable (p0: Drawable ?) setHorizontalScrollbarTrackDrawable [androidJvm] open fun setHorizontalScrollbarTrackDrawable (p0: Drawable ?) setHovered [androidJvm] open fun setHovered (p0: Boolean ) setId [androidJvm] open fun setId (p0: Int ) setImportantForAccessibility [androidJvm] open fun setImportantForAccessibility (p0: Int ) setImportantForAutofill [androidJvm] open fun setImportantForAutofill (p0: Int ) setImportantForContentCapture [androidJvm] open fun setImportantForContentCapture (p0: Int ) setKeepScreenOn [androidJvm] open fun setKeepScreenOn (p0: Boolean ) setKeyboardNavigationCluster [androidJvm] open fun setKeyboardNavigationCluster (p0: Boolean ) setLabelFor [androidJvm] open fun setLabelFor (p0: Int ) setLayerPaint [androidJvm] open fun setLayerPaint (p0: Paint ?) setLayerType [androidJvm] open fun setLayerType (p0: Int , p1: Paint ?) setLayoutAnimation [androidJvm] open fun setLayoutAnimation (p0: LayoutAnimationController ) setLayoutAnimationListener [androidJvm] open fun setLayoutAnimationListener (p0: Animation.AnimationListener ) setLayoutDirection [androidJvm] open fun setLayoutDirection (p0: Int ) setLayoutMode [androidJvm] open fun setLayoutMode (p0: Int ) setLayoutParams [androidJvm] open fun setLayoutParams (p0: ViewGroup.LayoutParams ) setLayoutTransition [androidJvm] open fun setLayoutTransition (p0: LayoutTransition ) setLeft [androidJvm] fun setLeft (p0: Int ) setLeftTopRightBottom [androidJvm] fun setLeftTopRightBottom (p0: Int , p1: Int , p2: Int , p3: Int ) setLongClickable [androidJvm] open fun setLongClickable (p0: Boolean ) setMeasureAllChildren [androidJvm] open fun setMeasureAllChildren (p0: Boolean ) setMeasuredDimension [androidJvm] fun setMeasuredDimension (p0: Int , p1: Int ) setMinimumHeight [androidJvm] open fun setMinimumHeight (p0: Int ) setMinimumWidth [androidJvm] open fun setMinimumWidth (p0: Int ) setMotionEventSplittingEnabled [androidJvm] open fun setMotionEventSplittingEnabled (p0: Boolean ) setNestedScrollingEnabled [androidJvm] open fun setNestedScrollingEnabled (p0: Boolean ) setNextClusterForwardId [androidJvm] open fun setNextClusterForwardId (p0: Int ) setNextFocusDownId [androidJvm] open fun setNextFocusDownId (p0: Int ) setNextFocusForwardId [androidJvm] open fun setNextFocusForwardId (p0: Int ) setNextFocusLeftId [androidJvm] open fun setNextFocusLeftId (p0: Int ) setNextFocusRightId [androidJvm] open fun setNextFocusRightId (p0: Int ) setNextFocusUpId [androidJvm] open fun setNextFocusUpId (p0: Int ) setOnApplyWindowInsetsListener [androidJvm] open fun setOnApplyWindowInsetsListener (p0: View.OnApplyWindowInsetsListener ) setOnCapturedPointerListener [androidJvm] open fun setOnCapturedPointerListener (p0: View.OnCapturedPointerListener ) setOnClickListener [androidJvm] open fun setOnClickListener (p0: View.OnClickListener ?) setOnContextClickListener [androidJvm] open fun setOnContextClickListener (p0: View.OnContextClickListener ?) setOnCreateContextMenuListener [androidJvm] open fun setOnCreateContextMenuListener (p0: View.OnCreateContextMenuListener ) setOnDragListener [androidJvm] open fun setOnDragListener (p0: View.OnDragListener ) setOnFocusChangeListener [androidJvm] open fun setOnFocusChangeListener (p0: View.OnFocusChangeListener ) setOnGenericMotionListener [androidJvm] open fun setOnGenericMotionListener (p0: View.OnGenericMotionListener ) setOnHierarchyChangeListener [androidJvm] open fun setOnHierarchyChangeListener (p0: ViewGroup.OnHierarchyChangeListener ) setOnHoverListener [androidJvm] open fun setOnHoverListener (p0: View.OnHoverListener ) setOnKeyListener [androidJvm] open fun setOnKeyListener (p0: View.OnKeyListener ) setOnLongClickListener [androidJvm] open fun setOnLongClickListener (p0: View.OnLongClickListener ?) setOnReceiveContentListener [androidJvm] open fun setOnReceiveContentListener (p0: Array < String >?, p1: OnReceiveContentListener ?) setOnScrollChangeListener [androidJvm] open fun setOnScrollChangeListener (p0: View.OnScrollChangeListener ) setOnTouchListener [androidJvm] open fun setOnTouchListener (p0: View.OnTouchListener ) setOutlineAmbientShadowColor [androidJvm] open fun setOutlineAmbientShadowColor (p0: Int ) setOutlineProvider [androidJvm] open fun setOutlineProvider (p0: ViewOutlineProvider ) setOutlineSpotShadowColor [androidJvm] open fun setOutlineSpotShadowColor (p0: Int ) setOverScrollMode [androidJvm] open fun setOverScrollMode (p0: Int ) setPadding [androidJvm] open fun setPadding (p0: Int , p1: Int , p2: Int , p3: Int ) setPaddingRelative [androidJvm] open fun setPaddingRelative (p0: Int , p1: Int , p2: Int , p3: Int ) setPivotX [androidJvm] open fun setPivotX (p0: Float ) setPivotY [androidJvm] open fun setPivotY (p0: Float ) setPointerIcon [androidJvm] open fun setPointerIcon (p0: PointerIcon ) setPressed [androidJvm] open fun setPressed (p0: Boolean ) setRenderEffect [androidJvm] open fun setRenderEffect (p0: RenderEffect ?) setRevealOnFocusHint [androidJvm] fun setRevealOnFocusHint (p0: Boolean ) setRight [androidJvm] fun setRight (p0: Int ) setRotation [androidJvm] open fun setRotation (p0: Float ) setRotationX [androidJvm] open fun setRotationX (p0: Float ) setRotationY [androidJvm] open fun setRotationY (p0: Float ) setSaveEnabled [androidJvm] open fun setSaveEnabled (p0: Boolean ) setSaveFromParentEnabled [androidJvm] open fun setSaveFromParentEnabled (p0: Boolean ) setScaleX [androidJvm] open fun setScaleX (p0: Float ) setScaleY [androidJvm] open fun setScaleY (p0: Float ) setScreenReaderFocusable [androidJvm] open fun setScreenReaderFocusable (p0: Boolean ) setScrollBarDefaultDelayBeforeFade [androidJvm] open fun setScrollBarDefaultDelayBeforeFade (p0: Int ) setScrollBarFadeDuration [androidJvm] open fun setScrollBarFadeDuration (p0: Int ) setScrollbarFadingEnabled [androidJvm] open fun setScrollbarFadingEnabled (p0: Boolean ) setScrollBarSize [androidJvm] open fun setScrollBarSize (p0: Int ) setScrollBarStyle [androidJvm] open fun setScrollBarStyle (p0: Int ) setScrollCaptureCallback [androidJvm] fun setScrollCaptureCallback (p0: ScrollCaptureCallback ?) setScrollCaptureHint [androidJvm] open fun setScrollCaptureHint (p0: Int ) setScrollContainer [androidJvm] open fun setScrollContainer (p0: Boolean ) setScrollIndicators [androidJvm] open fun setScrollIndicators (p0: Int ) open fun setScrollIndicators (p0: Int , p1: Int ) setScrollX [androidJvm] open fun setScrollX (p0: Int ) setScrollY [androidJvm] open fun setScrollY (p0: Int ) setSelected [androidJvm] open fun setSelected (p0: Boolean ) setSoundEffectsEnabled [androidJvm] open fun setSoundEffectsEnabled (p0: Boolean ) setStateDescription [androidJvm] open fun setStateDescription (p0: CharSequence ?) setStateListAnimator [androidJvm] open fun setStateListAnimator (p0: StateListAnimator ) setStaticTransformationsEnabled [androidJvm] open fun setStaticTransformationsEnabled (p0: Boolean ) setSystemGestureExclusionRects [androidJvm] open fun setSystemGestureExclusionRects (p0: MutableList < Rect >) setTag [androidJvm] open fun setTag (p0: Any ) open fun setTag (p0: Int , p1: Any ) setTextAlignment [androidJvm] open fun setTextAlignment (p0: Int ) setTextDirection [androidJvm] open fun setTextDirection (p0: Int ) setTooltipText [androidJvm] open fun setTooltipText (p0: CharSequence ?) setTop [androidJvm] fun setTop (p0: Int ) setTouchDelegate [androidJvm] open fun setTouchDelegate (p0: TouchDelegate ) setTouchscreenBlocksFocus [androidJvm] open fun setTouchscreenBlocksFocus (p0: Boolean ) setTransitionAlpha [androidJvm] open fun setTransitionAlpha (p0: Float ) setTransitionGroup [androidJvm] open fun setTransitionGroup (p0: Boolean ) setTransitionName [androidJvm] fun setTransitionName (p0: String ) setTransitionVisibility [androidJvm] open fun setTransitionVisibility (p0: Int ) setTranslationX [androidJvm] open fun setTranslationX (p0: Float ) setTranslationY [androidJvm] open fun setTranslationY (p0: Float ) setTranslationZ [androidJvm] open fun setTranslationZ (p0: Float ) setVerticalFadingEdgeEnabled [androidJvm] open fun setVerticalFadingEdgeEnabled (p0: Boolean ) setVerticalScrollBarEnabled [androidJvm] open fun setVerticalScrollBarEnabled (p0: Boolean ) setVerticalScrollbarPosition [androidJvm] open fun setVerticalScrollbarPosition (p0: Int ) setVerticalScrollbarThumbDrawable [androidJvm] open fun setVerticalScrollbarThumbDrawable (p0: Drawable ?) setVerticalScrollbarTrackDrawable [androidJvm] open fun setVerticalScrollbarTrackDrawable (p0: Drawable ?) setViewTranslationCallback [androidJvm] open fun setViewTranslationCallback (p0: ViewTranslationCallback ) setVisibility [androidJvm] open fun setVisibility (p0: Int ) setWillNotDraw [androidJvm] open fun setWillNotDraw (p0: Boolean ) setWindowInsetsAnimationCallback [androidJvm] open override fun setWindowInsetsAnimationCallback (p0: WindowInsetsAnimation.Callback ?) setX [androidJvm] open fun setX (p0: Float ) setY [androidJvm] open fun setY (p0: Float ) setZ [androidJvm] open fun setZ (p0: Float ) shouldDelayChildPressedState [androidJvm] open override fun shouldDelayChildPressedState (): Boolean showContextMenu [androidJvm] open fun showContextMenu (): Boolean open fun showContextMenu (p0: Float , p1: Float ): Boolean showContextMenuForChild [androidJvm] open override fun showContextMenuForChild (p0: View ): Boolean open override fun showContextMenuForChild (p0: View , p1: Float , p2: Float ): Boolean startActionMode [androidJvm] open fun startActionMode (p0: ActionMode.Callback ): ActionMode open fun startActionMode (p0: ActionMode.Callback , p1: Int ): ActionMode startActionModeForChild [androidJvm] open override fun startActionModeForChild (p0: View , p1: ActionMode.Callback ): ActionMode open override fun startActionModeForChild (p0: View , p1: ActionMode.Callback , p2: Int ): ActionMode startAnimation [androidJvm] open fun startAnimation (p0: Animation ) startDragAndDrop [androidJvm] fun startDragAndDrop (p0: ClipData , p1: View.DragShadowBuilder , p2: Any , p3: Int ): Boolean startLayoutAnimation [androidJvm] open fun startLayoutAnimation () startNestedScroll [androidJvm] open fun startNestedScroll (p0: Int ): Boolean startViewTransition [androidJvm] open fun startViewTransition (p0: View ) stopNestedScroll [androidJvm] open fun stopNestedScroll () suppressLayout [androidJvm] open fun suppressLayout (p0: Boolean ) toString [androidJvm] open override fun toString (): String transformMatrixToGlobal [androidJvm] open fun transformMatrixToGlobal (p0: Matrix ) transformMatrixToLocal [androidJvm] open fun transformMatrixToLocal (p0: Matrix ) unscheduleDrawable [androidJvm] open fun unscheduleDrawable (p0: Drawable ) open override fun unscheduleDrawable (p0: Drawable , p1: Runnable ) updateDragShadow [androidJvm] fun updateDragShadow (p0: View.DragShadowBuilder ) updateViewLayout [androidJvm] open override fun updateViewLayout (p0: View , p1: ViewGroup.LayoutParams ) verifyDrawable [androidJvm] open fun verifyDrawable (p0: Drawable ): Boolean willNotDraw [androidJvm] open fun willNotDraw (): Boolean","title":"Functions"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-alert-container/-alert-container/","text":"// workflow / com.squareup.workflow1.ui.modal / AlertContainer / AlertContainer AlertContainer \u00b6 [androidJvm]\\ @ JvmOverloads fun AlertContainer (context: Context , attributeSet: AttributeSet ? = null, defStyle: Int = 0, defStyleRes: Int = 0, @ StyleRes dialogThemeResId: Int = 0)","title":" alert container"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-alert-container/-alert-container/#alertcontainer","text":"[androidJvm]\\ @ JvmOverloads fun AlertContainer (context: Context , attributeSet: AttributeSet ? = null, defStyle: Int = 0, defStyleRes: Int = 0, @ StyleRes dialogThemeResId: Int = 0)","title":"AlertContainer"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-alert-container/-companion/","text":"// workflow / com.squareup.workflow1.ui.modal / AlertContainer / Companion Companion \u00b6 [androidJvm]\\ object Companion : ViewFactory <AlertContainerScreen<*>> Functions \u00b6 Name Summary buildView [androidJvm] open override fun buildView (initialRendering: AlertContainerScreen<*>, initialViewEnvironment: ViewEnvironment , contextForNewView: Context , container: ViewGroup ?): View customThemeBinding [androidJvm] fun customThemeBinding (@ StyleRes dialogThemeResId: Int = 0): ViewFactory <AlertContainerScreen<*>> Creates a ViewFactory to show the AlertScreens of an AlertContainerScreen as Android AlertDialogs. Properties \u00b6 Name Summary type [androidJvm] open override val type : KClass <in AlertContainerScreen<*>>","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-alert-container/-companion/#companion","text":"[androidJvm]\\ object Companion : ViewFactory <AlertContainerScreen<*>>","title":"Companion"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-alert-container/-companion/#functions","text":"Name Summary buildView [androidJvm] open override fun buildView (initialRendering: AlertContainerScreen<*>, initialViewEnvironment: ViewEnvironment , contextForNewView: Context , container: ViewGroup ?): View customThemeBinding [androidJvm] fun customThemeBinding (@ StyleRes dialogThemeResId: Int = 0): ViewFactory <AlertContainerScreen<*>> Creates a ViewFactory to show the AlertScreens of an AlertContainerScreen as Android AlertDialogs.","title":"Functions"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-alert-container/-companion/#properties","text":"Name Summary type [androidJvm] open override val type : KClass <in AlertContainerScreen<*>>","title":"Properties"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-alert-container/-companion/custom-theme-binding/","text":"// workflow / com.squareup.workflow1.ui.modal / AlertContainer / Companion / customThemeBinding customThemeBinding \u00b6 [androidJvm]\\ fun customThemeBinding (@ StyleRes dialogThemeResId: Int = 0): ViewFactory <AlertContainerScreen<*>> Creates a ViewFactory to show the AlertScreens of an AlertContainerScreen as Android AlertDialogs. Parameters \u00b6 androidJvm dialogThemeResId the resource ID of the theme against which to inflate dialogs. Defaults to 0 to use the parent context\u2019s default alert dialog theme.","title":"Custom theme binding"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-alert-container/-companion/custom-theme-binding/#customthemebinding","text":"[androidJvm]\\ fun customThemeBinding (@ StyleRes dialogThemeResId: Int = 0): ViewFactory <AlertContainerScreen<*>> Creates a ViewFactory to show the AlertScreens of an AlertContainerScreen as Android AlertDialogs.","title":"customThemeBinding"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-alert-container/-companion/custom-theme-binding/#parameters","text":"androidJvm dialogThemeResId the resource ID of the theme against which to inflate dialogs. Defaults to 0 to use the parent context\u2019s default alert dialog theme.","title":"Parameters"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-alert-container-screen/","text":"// workflow / com.squareup.workflow1.ui.modal / AlertContainerScreen AlertContainerScreen \u00b6 [jvm]\\ @ WorkflowUiExperimentalApi data class AlertContainerScreen < B : Any >(beneathModals: B , modals: List < AlertScreen >) : HasModals < B , AlertScreen > May show a stack of AlertScreen over a beneathModals . Parameters \u00b6 jvm B the type of beneathModals Constructors \u00b6 AlertContainerScreen [jvm] fun < B : Any > AlertContainerScreen (baseScreen: B , alert: AlertScreen ) AlertContainerScreen [jvm] fun < B : Any > AlertContainerScreen (baseScreen: B , vararg alerts: AlertScreen ) AlertContainerScreen [jvm] fun < B : Any > AlertContainerScreen (beneathModals: B , modals: List < AlertScreen > = emptyList()) Properties \u00b6 Name Summary beneathModals [jvm] open override val beneathModals : B modals [jvm] open override val modals : List < AlertScreen >","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-alert-container-screen/#alertcontainerscreen","text":"[jvm]\\ @ WorkflowUiExperimentalApi data class AlertContainerScreen < B : Any >(beneathModals: B , modals: List < AlertScreen >) : HasModals < B , AlertScreen > May show a stack of AlertScreen over a beneathModals .","title":"AlertContainerScreen"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-alert-container-screen/#parameters","text":"jvm B the type of beneathModals","title":"Parameters"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-alert-container-screen/#constructors","text":"AlertContainerScreen [jvm] fun < B : Any > AlertContainerScreen (baseScreen: B , alert: AlertScreen ) AlertContainerScreen [jvm] fun < B : Any > AlertContainerScreen (baseScreen: B , vararg alerts: AlertScreen ) AlertContainerScreen [jvm] fun < B : Any > AlertContainerScreen (beneathModals: B , modals: List < AlertScreen > = emptyList())","title":"Constructors"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-alert-container-screen/#properties","text":"Name Summary beneathModals [jvm] open override val beneathModals : B modals [jvm] open override val modals : List < AlertScreen >","title":"Properties"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-alert-container-screen/-alert-container-screen/","text":"// workflow / com.squareup.workflow1.ui.modal / AlertContainerScreen / AlertContainerScreen AlertContainerScreen \u00b6 [jvm]\\ fun < B : Any > AlertContainerScreen (baseScreen: B , alert: AlertScreen ) fun < B : Any > AlertContainerScreen (baseScreen: B , vararg alerts: AlertScreen ) [jvm]\\ fun < B : Any > AlertContainerScreen (beneathModals: B , modals: List < AlertScreen > = emptyList()) Parameters \u00b6 jvm B the type of beneathModals","title":" alert container screen"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-alert-container-screen/-alert-container-screen/#alertcontainerscreen","text":"[jvm]\\ fun < B : Any > AlertContainerScreen (baseScreen: B , alert: AlertScreen ) fun < B : Any > AlertContainerScreen (baseScreen: B , vararg alerts: AlertScreen ) [jvm]\\ fun < B : Any > AlertContainerScreen (beneathModals: B , modals: List < AlertScreen > = emptyList())","title":"AlertContainerScreen"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-alert-container-screen/-alert-container-screen/#parameters","text":"jvm B the type of beneathModals","title":"Parameters"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-alert-container-screen/beneath-modals/","text":"// workflow / com.squareup.workflow1.ui.modal / AlertContainerScreen / beneathModals beneathModals \u00b6 [jvm]\\ open override val beneathModals : B","title":"Beneath modals"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-alert-container-screen/beneath-modals/#beneathmodals","text":"[jvm]\\ open override val beneathModals : B","title":"beneathModals"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-alert-container-screen/modals/","text":"// workflow / com.squareup.workflow1.ui.modal / AlertContainerScreen / modals modals \u00b6 [jvm]\\ open override val modals : List < AlertScreen >","title":"Modals"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-alert-container-screen/modals/#modals","text":"[jvm]\\ open override val modals : List < AlertScreen >","title":"modals"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-alert-screen/","text":"// workflow / com.squareup.workflow1.ui.modal / AlertScreen AlertScreen \u00b6 [jvm]\\ @ WorkflowUiExperimentalApi data class AlertScreen (buttons: Map < AlertScreen.Button , String >, message: String , title: String , cancelable: Boolean , onEvent: ( AlertScreen.Event ) -> Unit ) Models a typical \u201cYou sure about that?\u201d alert box. Constructors \u00b6 AlertScreen [jvm] fun AlertScreen (buttons: Map < AlertScreen.Button , String > = emptyMap(), message: String = \u201c\u201d, title: String = \u201c\u201d, cancelable: Boolean = true, onEvent: ( AlertScreen.Event ) -> Unit ) Types \u00b6 Name Summary Button [jvm] enum Button : Enum < AlertScreen.Button > Event [jvm] sealed class Event Functions \u00b6 Name Summary equals [jvm] open operator override fun equals (other: Any ?): Boolean hashCode [jvm] open override fun hashCode (): Int Properties \u00b6 Name Summary buttons [jvm] val buttons : Map < AlertScreen.Button , String > cancelable [jvm] val cancelable : Boolean = true message [jvm] val message : String onEvent [jvm] val onEvent : ( AlertScreen.Event ) -> Unit title [jvm] val title : String","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-alert-screen/#alertscreen","text":"[jvm]\\ @ WorkflowUiExperimentalApi data class AlertScreen (buttons: Map < AlertScreen.Button , String >, message: String , title: String , cancelable: Boolean , onEvent: ( AlertScreen.Event ) -> Unit ) Models a typical \u201cYou sure about that?\u201d alert box.","title":"AlertScreen"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-alert-screen/#constructors","text":"AlertScreen [jvm] fun AlertScreen (buttons: Map < AlertScreen.Button , String > = emptyMap(), message: String = \u201c\u201d, title: String = \u201c\u201d, cancelable: Boolean = true, onEvent: ( AlertScreen.Event ) -> Unit )","title":"Constructors"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-alert-screen/#types","text":"Name Summary Button [jvm] enum Button : Enum < AlertScreen.Button > Event [jvm] sealed class Event","title":"Types"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-alert-screen/#functions","text":"Name Summary equals [jvm] open operator override fun equals (other: Any ?): Boolean hashCode [jvm] open override fun hashCode (): Int","title":"Functions"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-alert-screen/#properties","text":"Name Summary buttons [jvm] val buttons : Map < AlertScreen.Button , String > cancelable [jvm] val cancelable : Boolean = true message [jvm] val message : String onEvent [jvm] val onEvent : ( AlertScreen.Event ) -> Unit title [jvm] val title : String","title":"Properties"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-alert-screen/-alert-screen/","text":"// workflow / com.squareup.workflow1.ui.modal / AlertScreen / AlertScreen AlertScreen \u00b6 [jvm]\\ fun AlertScreen (buttons: Map < AlertScreen.Button , String > = emptyMap(), message: String = \u201c\u201d, title: String = \u201c\u201d, cancelable: Boolean = true, onEvent: ( AlertScreen.Event ) -> Unit )","title":" alert screen"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-alert-screen/-alert-screen/#alertscreen","text":"[jvm]\\ fun AlertScreen (buttons: Map < AlertScreen.Button , String > = emptyMap(), message: String = \u201c\u201d, title: String = \u201c\u201d, cancelable: Boolean = true, onEvent: ( AlertScreen.Event ) -> Unit )","title":"AlertScreen"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-alert-screen/buttons/","text":"// workflow / com.squareup.workflow1.ui.modal / AlertScreen / buttons buttons \u00b6 [jvm]\\ val buttons : Map < AlertScreen.Button , String >","title":"Buttons"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-alert-screen/buttons/#buttons","text":"[jvm]\\ val buttons : Map < AlertScreen.Button , String >","title":"buttons"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-alert-screen/cancelable/","text":"// workflow / com.squareup.workflow1.ui.modal / AlertScreen / cancelable cancelable \u00b6 [jvm]\\ val cancelable : Boolean = true","title":"Cancelable"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-alert-screen/cancelable/#cancelable","text":"[jvm]\\ val cancelable : Boolean = true","title":"cancelable"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-alert-screen/equals/","text":"// workflow / com.squareup.workflow1.ui.modal / AlertScreen / equals equals \u00b6 [jvm]\\ open operator override fun equals (other: Any ?): Boolean","title":"Equals"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-alert-screen/equals/#equals","text":"[jvm]\\ open operator override fun equals (other: Any ?): Boolean","title":"equals"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-alert-screen/hash-code/","text":"// workflow / com.squareup.workflow1.ui.modal / AlertScreen / hashCode hashCode \u00b6 [jvm]\\ open override fun hashCode (): Int","title":"Hash code"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-alert-screen/hash-code/#hashcode","text":"[jvm]\\ open override fun hashCode (): Int","title":"hashCode"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-alert-screen/message/","text":"// workflow / com.squareup.workflow1.ui.modal / AlertScreen / message message \u00b6 [jvm]\\ val message : String","title":"Message"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-alert-screen/message/#message","text":"[jvm]\\ val message : String","title":"message"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-alert-screen/on-event/","text":"// workflow / com.squareup.workflow1.ui.modal / AlertScreen / onEvent onEvent \u00b6 [jvm]\\ val onEvent : ( AlertScreen.Event ) -> Unit","title":"On event"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-alert-screen/on-event/#onevent","text":"[jvm]\\ val onEvent : ( AlertScreen.Event ) -> Unit","title":"onEvent"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-alert-screen/title/","text":"// workflow / com.squareup.workflow1.ui.modal / AlertScreen / title title \u00b6 [jvm]\\ val title : String","title":"Title"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-alert-screen/title/#title","text":"[jvm]\\ val title : String","title":"title"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-alert-screen/-button/","text":"// workflow / com.squareup.workflow1.ui.modal / AlertScreen / Button Button \u00b6 [jvm]\\ enum Button : Enum < AlertScreen.Button > Entries \u00b6 NEUTRAL [jvm] NEUTRAL () NEGATIVE [jvm] NEGATIVE () POSITIVE [jvm] POSITIVE () Properties \u00b6 Name Summary name [jvm] val name : String ordinal [jvm] val ordinal : Int","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-alert-screen/-button/#button","text":"[jvm]\\ enum Button : Enum < AlertScreen.Button >","title":"Button"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-alert-screen/-button/#entries","text":"NEUTRAL [jvm] NEUTRAL () NEGATIVE [jvm] NEGATIVE () POSITIVE [jvm] POSITIVE ()","title":"Entries"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-alert-screen/-button/#properties","text":"Name Summary name [jvm] val name : String ordinal [jvm] val ordinal : Int","title":"Properties"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-alert-screen/-button/-n-e-g-a-t-i-v-e/","text":"// workflow / com.squareup.workflow1.ui.modal / AlertScreen / Button / NEGATIVE NEGATIVE \u00b6 [jvm]\\ NEGATIVE () Properties \u00b6 Name Summary name [jvm] val name : String ordinal [jvm] val ordinal : Int","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-alert-screen/-button/-n-e-g-a-t-i-v-e/#negative","text":"[jvm]\\ NEGATIVE ()","title":"NEGATIVE"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-alert-screen/-button/-n-e-g-a-t-i-v-e/#properties","text":"Name Summary name [jvm] val name : String ordinal [jvm] val ordinal : Int","title":"Properties"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-alert-screen/-button/-n-e-u-t-r-a-l/","text":"// workflow / com.squareup.workflow1.ui.modal / AlertScreen / Button / NEUTRAL NEUTRAL \u00b6 [jvm]\\ NEUTRAL () Properties \u00b6 Name Summary name [jvm] val name : String ordinal [jvm] val ordinal : Int","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-alert-screen/-button/-n-e-u-t-r-a-l/#neutral","text":"[jvm]\\ NEUTRAL ()","title":"NEUTRAL"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-alert-screen/-button/-n-e-u-t-r-a-l/#properties","text":"Name Summary name [jvm] val name : String ordinal [jvm] val ordinal : Int","title":"Properties"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-alert-screen/-button/-p-o-s-i-t-i-v-e/","text":"// workflow / com.squareup.workflow1.ui.modal / AlertScreen / Button / POSITIVE POSITIVE \u00b6 [jvm]\\ POSITIVE () Properties \u00b6 Name Summary name [jvm] val name : String ordinal [jvm] val ordinal : Int","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-alert-screen/-button/-p-o-s-i-t-i-v-e/#positive","text":"[jvm]\\ POSITIVE ()","title":"POSITIVE"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-alert-screen/-button/-p-o-s-i-t-i-v-e/#properties","text":"Name Summary name [jvm] val name : String ordinal [jvm] val ordinal : Int","title":"Properties"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-alert-screen/-event/","text":"// workflow / com.squareup.workflow1.ui.modal / AlertScreen / Event Event \u00b6 [jvm]\\ sealed class Event Types \u00b6 Name Summary ButtonClicked [jvm] data class ButtonClicked (button: AlertScreen.Button ) : AlertScreen.Event Canceled [jvm] object Canceled : AlertScreen.Event Inheritors \u00b6 Name AlertScreen.Event AlertScreen.Event","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-alert-screen/-event/#event","text":"[jvm]\\ sealed class Event","title":"Event"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-alert-screen/-event/#types","text":"Name Summary ButtonClicked [jvm] data class ButtonClicked (button: AlertScreen.Button ) : AlertScreen.Event Canceled [jvm] object Canceled : AlertScreen.Event","title":"Types"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-alert-screen/-event/#inheritors","text":"Name AlertScreen.Event AlertScreen.Event","title":"Inheritors"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-alert-screen/-event/-button-clicked/","text":"// workflow / com.squareup.workflow1.ui.modal / AlertScreen / Event / ButtonClicked ButtonClicked \u00b6 [jvm]\\ data class ButtonClicked (button: AlertScreen.Button ) : AlertScreen.Event Properties \u00b6 Name Summary button [jvm] val button : AlertScreen.Button","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-alert-screen/-event/-button-clicked/#buttonclicked","text":"[jvm]\\ data class ButtonClicked (button: AlertScreen.Button ) : AlertScreen.Event","title":"ButtonClicked"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-alert-screen/-event/-button-clicked/#properties","text":"Name Summary button [jvm] val button : AlertScreen.Button","title":"Properties"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-alert-screen/-event/-button-clicked/-button-clicked/","text":"// workflow / com.squareup.workflow1.ui.modal / AlertScreen / Event / ButtonClicked / ButtonClicked ButtonClicked \u00b6 [jvm]\\ fun ButtonClicked (button: AlertScreen.Button )","title":" button clicked"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-alert-screen/-event/-button-clicked/-button-clicked/#buttonclicked","text":"[jvm]\\ fun ButtonClicked (button: AlertScreen.Button )","title":"ButtonClicked"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-alert-screen/-event/-button-clicked/button/","text":"// workflow / com.squareup.workflow1.ui.modal / AlertScreen / Event / ButtonClicked / button button \u00b6 [jvm]\\ val button : AlertScreen.Button","title":"Button"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-alert-screen/-event/-button-clicked/button/#button","text":"[jvm]\\ val button : AlertScreen.Button","title":"button"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-alert-screen/-event/-canceled/","text":"// workflow / com.squareup.workflow1.ui.modal / AlertScreen / Event / Canceled Canceled \u00b6 [jvm]\\ object Canceled : AlertScreen.Event","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-alert-screen/-event/-canceled/#canceled","text":"[jvm]\\ object Canceled : AlertScreen.Event","title":"Canceled"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-has-modals/","text":"// workflow / com.squareup.workflow1.ui.modal / HasModals HasModals \u00b6 [jvm]\\ @ WorkflowUiExperimentalApi interface HasModals <out B : Any , out M : Any > Interface implemented by screen classes that represent a stack of zero or more modal screens above a base screen . Use of this interface allows platform specific containers to share base classes, like ModalContainer in the workflow-ui:core-android module. Properties \u00b6 Name Summary beneathModals [jvm] abstract val beneathModals : B modals [jvm] abstract val modals : List < M > Inheritors \u00b6 Name AlertContainerScreen","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-has-modals/#hasmodals","text":"[jvm]\\ @ WorkflowUiExperimentalApi interface HasModals <out B : Any , out M : Any > Interface implemented by screen classes that represent a stack of zero or more modal screens above a base screen . Use of this interface allows platform specific containers to share base classes, like ModalContainer in the workflow-ui:core-android module.","title":"HasModals"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-has-modals/#properties","text":"Name Summary beneathModals [jvm] abstract val beneathModals : B modals [jvm] abstract val modals : List < M >","title":"Properties"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-has-modals/#inheritors","text":"Name AlertContainerScreen","title":"Inheritors"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-has-modals/beneath-modals/","text":"// workflow / com.squareup.workflow1.ui.modal / HasModals / beneathModals beneathModals \u00b6 [jvm]\\ abstract val beneathModals : B","title":"Beneath modals"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-has-modals/beneath-modals/#beneathmodals","text":"[jvm]\\ abstract val beneathModals : B","title":"beneathModals"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-has-modals/modals/","text":"// workflow / com.squareup.workflow1.ui.modal / HasModals / modals modals \u00b6 [jvm]\\ abstract val modals : List < M >","title":"Modals"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-has-modals/modals/#modals","text":"[jvm]\\ abstract val modals : List < M >","title":"modals"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-modal-container/","text":"// workflow / com.squareup.workflow1.ui.modal / ModalContainer ModalContainer \u00b6 [androidJvm]\\ @WorkflowUiExperimentalApi abstract class ModalContainer < ModalRenderingT : Any >@ JvmOverloads constructor(context: Context , attributeSet: AttributeSet ?, defStyle: Int , defStyleRes: Int ) : FrameLayout Base class for containers that show HasModals.modals in Dialog windows. It is not currently supported to make a ModalContainer the immediate child of a BackStackContainer. See https://github.com/square/workflow-kotlin/issues/470 . Parameters \u00b6 androidJvm ModalRenderingT the type of the nested renderings to be shown in a dialog window. Constructors \u00b6 ModalContainer [androidJvm] @ JvmOverloads fun ModalContainer (context: Context , attributeSet: AttributeSet ? = null, defStyle: Int = 0, defStyleRes: Int = 0) Functions \u00b6 Name Summary addChildrenForAccessibility [androidJvm] open override fun addChildrenForAccessibility (p0: ArrayList < View >) addExtraDataToAccessibilityNodeInfo [androidJvm] open override fun addExtraDataToAccessibilityNodeInfo (p0: AccessibilityNodeInfo , p1: String , p2: Bundle ?) addFocusables [androidJvm] open fun addFocusables (p0: ArrayList < View >, p1: Int ) open override fun addFocusables (p0: ArrayList < View >, p1: Int , p2: Int ) addKeyboardNavigationClusters [androidJvm] open override fun addKeyboardNavigationClusters (p0: MutableCollection < View >, p1: Int ) addOnAttachStateChangeListener [androidJvm] open fun addOnAttachStateChangeListener (p0: View.OnAttachStateChangeListener ) addOnLayoutChangeListener [androidJvm] open fun addOnLayoutChangeListener (p0: View.OnLayoutChangeListener ) addOnUnhandledKeyEventListener [androidJvm] open fun addOnUnhandledKeyEventListener (p0: View.OnUnhandledKeyEventListener ) addStatesFromChildren [androidJvm] open fun addStatesFromChildren (): Boolean addTouchables [androidJvm] open override fun addTouchables (p0: ArrayList < View >) addView [androidJvm] open fun addView (p0: View ) open override fun addView (p0: View , p1: ViewGroup.LayoutParams ) open fun addView (p0: View , p1: Int ) open fun addView (p0: View , p1: Int , p2: ViewGroup.LayoutParams ) open fun addView (p0: View , p1: Int , p2: Int ) addViewInLayout [androidJvm] open fun addViewInLayout (p0: View , p1: Int , p2: ViewGroup.LayoutParams ): Boolean open fun addViewInLayout (p0: View , p1: Int , p2: ViewGroup.LayoutParams , p3: Boolean ): Boolean animate [androidJvm] open fun animate (): ViewPropertyAnimator announceForAccessibility [androidJvm] open fun announceForAccessibility (p0: CharSequence ) attachLayoutAnimationParameters [androidJvm] open fun attachLayoutAnimationParameters (p0: View , p1: ViewGroup.LayoutParams , p2: Int , p3: Int ) attachViewToParent [androidJvm] open fun attachViewToParent (p0: View , p1: Int , p2: ViewGroup.LayoutParams ) autofill [androidJvm] open fun autofill (p0: SparseArray < AutofillValue >) open fun autofill (p0: AutofillValue ) awakenScrollBars [androidJvm] open fun awakenScrollBars (): Boolean open fun awakenScrollBars (p0: Int ): Boolean open fun awakenScrollBars (p0: Int , p1: Boolean ): Boolean bringChildToFront [androidJvm] open override fun bringChildToFront (p0: View ) bringToFront [androidJvm] open fun bringToFront () buildLayer [androidJvm] open fun buildLayer () callOnClick [androidJvm] open fun callOnClick (): Boolean canAnimate [androidJvm] open fun canAnimate (): Boolean cancelDragAndDrop [androidJvm] fun cancelDragAndDrop () cancelLongPress [androidJvm] open fun cancelLongPress () cancelPendingInputEvents [androidJvm] fun cancelPendingInputEvents () canResolveLayoutDirection [androidJvm] open fun canResolveLayoutDirection (): Boolean canResolveTextAlignment [androidJvm] open fun canResolveTextAlignment (): Boolean canResolveTextDirection [androidJvm] open fun canResolveTextDirection (): Boolean canScrollHorizontally [androidJvm] open fun canScrollHorizontally (p0: Int ): Boolean canScrollVertically [androidJvm] open fun canScrollVertically (p0: Int ): Boolean checkInputConnectionProxy [androidJvm] open fun checkInputConnectionProxy (p0: View ): Boolean checkLayoutParams [androidJvm] open override fun checkLayoutParams (p0: ViewGroup.LayoutParams ): Boolean childDrawableStateChanged [androidJvm] open override fun childDrawableStateChanged (p0: View ) childHasTransientStateChanged [androidJvm] open override fun childHasTransientStateChanged (p0: View , p1: Boolean ) cleanupLayoutState [androidJvm] open fun cleanupLayoutState (p0: View ) clearAnimation [androidJvm] open fun clearAnimation () clearChildFocus [androidJvm] open override fun clearChildFocus (p0: View ) clearDisappearingChildren [androidJvm] open fun clearDisappearingChildren () clearFocus [androidJvm] open override fun clearFocus () clearViewTranslationCallback [androidJvm] open fun clearViewTranslationCallback () computeHorizontalScrollExtent [androidJvm] open fun computeHorizontalScrollExtent (): Int computeHorizontalScrollOffset [androidJvm] open fun computeHorizontalScrollOffset (): Int computeHorizontalScrollRange [androidJvm] open fun computeHorizontalScrollRange (): Int computeScroll [androidJvm] open fun computeScroll () computeSystemWindowInsets [androidJvm] open fun computeSystemWindowInsets (p0: WindowInsets , p1: Rect ): WindowInsets computeVerticalScrollExtent [androidJvm] open fun computeVerticalScrollExtent (): Int computeVerticalScrollOffset [androidJvm] open fun computeVerticalScrollOffset (): Int computeVerticalScrollRange [androidJvm] open fun computeVerticalScrollRange (): Int createAccessibilityNodeInfo [androidJvm] open fun createAccessibilityNodeInfo (): AccessibilityNodeInfo createContextMenu [androidJvm] open fun createContextMenu (p0: ContextMenu ) debug [androidJvm] open fun debug (p0: Int ) detachAllViewsFromParent [androidJvm] open fun detachAllViewsFromParent () detachViewFromParent [androidJvm] open fun detachViewFromParent (p0: View ) open fun detachViewFromParent (p0: Int ) detachViewsFromParent [androidJvm] open fun detachViewsFromParent (p0: Int , p1: Int ) dispatchApplyWindowInsets [androidJvm] open override fun dispatchApplyWindowInsets (p0: WindowInsets ): WindowInsets dispatchCapturedPointerEvent [androidJvm] open override fun dispatchCapturedPointerEvent (p0: MotionEvent ): Boolean dispatchConfigurationChanged [androidJvm] open override fun dispatchConfigurationChanged (p0: Configuration ) dispatchCreateViewTranslationRequest [androidJvm] open override fun dispatchCreateViewTranslationRequest (p0: MutableMap < AutofillId , LongArray >, p1: IntArray , p2: TranslationCapability , p3: MutableList < ViewTranslationRequest >) dispatchDisplayHint [androidJvm] open override fun dispatchDisplayHint (p0: Int ) dispatchDragEvent [androidJvm] open override fun dispatchDragEvent (p0: DragEvent ): Boolean dispatchDraw [androidJvm] open override fun dispatchDraw (p0: Canvas ) dispatchDrawableHotspotChanged [androidJvm] open override fun dispatchDrawableHotspotChanged (p0: Float , p1: Float ) dispatchFinishTemporaryDetach [androidJvm] open override fun dispatchFinishTemporaryDetach () dispatchFreezeSelfOnly [androidJvm] open fun dispatchFreezeSelfOnly (p0: SparseArray < Parcelable >) dispatchGenericFocusedEvent [androidJvm] open override fun dispatchGenericFocusedEvent (p0: MotionEvent ): Boolean dispatchGenericMotionEvent [androidJvm] open fun dispatchGenericMotionEvent (p0: MotionEvent ): Boolean dispatchGenericPointerEvent [androidJvm] open override fun dispatchGenericPointerEvent (p0: MotionEvent ): Boolean dispatchHoverEvent [androidJvm] open override fun dispatchHoverEvent (p0: MotionEvent ): Boolean dispatchKeyEvent [androidJvm] open override fun dispatchKeyEvent (p0: KeyEvent ): Boolean dispatchKeyEventPreIme [androidJvm] open override fun dispatchKeyEventPreIme (p0: KeyEvent ): Boolean dispatchKeyShortcutEvent [androidJvm] open override fun dispatchKeyShortcutEvent (p0: KeyEvent ): Boolean dispatchNestedFling [androidJvm] open fun dispatchNestedFling (p0: Float , p1: Float , p2: Boolean ): Boolean dispatchNestedPreFling [androidJvm] open fun dispatchNestedPreFling (p0: Float , p1: Float ): Boolean dispatchNestedPrePerformAccessibilityAction [androidJvm] open fun dispatchNestedPrePerformAccessibilityAction (p0: Int , p1: Bundle ): Boolean dispatchNestedPreScroll [androidJvm] open fun dispatchNestedPreScroll (p0: Int , p1: Int , p2: IntArray ?, p3: IntArray ?): Boolean dispatchNestedScroll [androidJvm] open fun dispatchNestedScroll (p0: Int , p1: Int , p2: Int , p3: Int , p4: IntArray ?): Boolean dispatchPointerCaptureChanged [androidJvm] open override fun dispatchPointerCaptureChanged (p0: Boolean ) dispatchPopulateAccessibilityEvent [androidJvm] open fun dispatchPopulateAccessibilityEvent (p0: AccessibilityEvent ): Boolean dispatchProvideAutofillStructure [androidJvm] open override fun dispatchProvideAutofillStructure (p0: ViewStructure , p1: Int ) dispatchProvideStructure [androidJvm] open override fun dispatchProvideStructure (p0: ViewStructure ) dispatchRestoreInstanceState [androidJvm] open override fun dispatchRestoreInstanceState (p0: SparseArray < Parcelable >) dispatchSaveInstanceState [androidJvm] open override fun dispatchSaveInstanceState (p0: SparseArray < Parcelable >) dispatchScrollCaptureSearch [androidJvm] open override fun dispatchScrollCaptureSearch (p0: Rect , p1: Point , p2: Consumer < ScrollCaptureTarget >) dispatchSetActivated [androidJvm] open override fun dispatchSetActivated (p0: Boolean ) dispatchSetPressed [androidJvm] open override fun dispatchSetPressed (p0: Boolean ) dispatchSetSelected [androidJvm] open override fun dispatchSetSelected (p0: Boolean ) dispatchStartTemporaryDetach [androidJvm] open override fun dispatchStartTemporaryDetach () dispatchThawSelfOnly [androidJvm] open fun dispatchThawSelfOnly (p0: SparseArray < Parcelable >) dispatchTouchEvent [androidJvm] open override fun dispatchTouchEvent (p0: MotionEvent ): Boolean dispatchTrackballEvent [androidJvm] open override fun dispatchTrackballEvent (p0: MotionEvent ): Boolean dispatchUnhandledMove [androidJvm] open override fun dispatchUnhandledMove (p0: View , p1: Int ): Boolean dispatchVisibilityChanged [androidJvm] open override fun dispatchVisibilityChanged (p0: View , p1: Int ) dispatchWindowFocusChanged [androidJvm] open override fun dispatchWindowFocusChanged (p0: Boolean ) dispatchWindowInsetsAnimationEnd [androidJvm] open override fun dispatchWindowInsetsAnimationEnd (p0: WindowInsetsAnimation ) dispatchWindowInsetsAnimationPrepare [androidJvm] open override fun dispatchWindowInsetsAnimationPrepare (p0: WindowInsetsAnimation ) dispatchWindowInsetsAnimationProgress [androidJvm] open override fun dispatchWindowInsetsAnimationProgress (p0: WindowInsets , p1: MutableList < WindowInsetsAnimation >): WindowInsets dispatchWindowInsetsAnimationStart [androidJvm] open override fun dispatchWindowInsetsAnimationStart (p0: WindowInsetsAnimation , p1: WindowInsetsAnimation.Bounds ): WindowInsetsAnimation.Bounds dispatchWindowVisibilityChanged [androidJvm] open override fun dispatchWindowVisibilityChanged (p0: Int ) draw [androidJvm] open fun draw (p0: Canvas ) drawableHotspotChanged [androidJvm] open fun drawableHotspotChanged (p0: Float , p1: Float ) drawableStateChanged [androidJvm] open override fun drawableStateChanged () drawChild [androidJvm] open fun drawChild (p0: Canvas , p1: View , p2: Long ): Boolean endViewTransition [androidJvm] open fun endViewTransition (p0: View ) findFocus [androidJvm] open override fun findFocus (): View findViewById [androidJvm] fun < T : View > findViewById (p0: Int ): T findViewsWithText [androidJvm] open override fun findViewsWithText (p0: ArrayList < View >, p1: CharSequence , p2: Int ) findViewWithTag [androidJvm] fun < T : View > findViewWithTag (p0: Any ): T focusableViewAvailable [androidJvm] open override fun focusableViewAvailable (p0: View ) focusSearch [androidJvm] open fun focusSearch (p0: Int ): View open override fun focusSearch (p0: View , p1: Int ): View forceHasOverlappingRendering [androidJvm] open fun forceHasOverlappingRendering (p0: Boolean ) forceLayout [androidJvm] open fun forceLayout () gatherTransparentRegion [androidJvm] open override fun gatherTransparentRegion (p0: Region ?): Boolean generateDefaultLayoutParams [androidJvm] open override fun generateDefaultLayoutParams (): FrameLayout.LayoutParams generateDisplayHash [androidJvm] open fun generateDisplayHash (p0: String , p1: Rect ?, p2: Executor , p3: DisplayHashResultCallback ) generateLayoutParams [androidJvm] open override fun generateLayoutParams (p0: AttributeSet ): FrameLayout.LayoutParams open override fun generateLayoutParams (p0: ViewGroup.LayoutParams ): ViewGroup.LayoutParams getAccessibilityClassName [androidJvm] open override fun getAccessibilityClassName (): CharSequence getAccessibilityDelegate [androidJvm] open fun getAccessibilityDelegate (): View.AccessibilityDelegate getAccessibilityLiveRegion [androidJvm] open fun getAccessibilityLiveRegion (): Int getAccessibilityNodeProvider [androidJvm] open fun getAccessibilityNodeProvider (): AccessibilityNodeProvider getAccessibilityPaneTitle [androidJvm] open fun getAccessibilityPaneTitle (): CharSequence ? getAccessibilityTraversalAfter [androidJvm] open fun getAccessibilityTraversalAfter (): Int getAccessibilityTraversalBefore [androidJvm] open fun getAccessibilityTraversalBefore (): Int getAlpha [androidJvm] open fun getAlpha (): Float getAnimation [androidJvm] open fun getAnimation (): Animation getAnimationMatrix [androidJvm] open fun getAnimationMatrix (): Matrix ? getApplicationWindowToken [androidJvm] open fun getApplicationWindowToken (): IBinder getAttributeResolutionStack [androidJvm] open fun getAttributeResolutionStack (p0: Int ): IntArray getAttributeSourceResourceMap [androidJvm] open fun getAttributeSourceResourceMap (): MutableMap < Int , Int > getAutofillHints [androidJvm] open fun getAutofillHints (): Array < String >? getAutofillId [androidJvm] fun getAutofillId (): AutofillId getAutofillType [androidJvm] open fun getAutofillType (): Int getAutofillValue [androidJvm] open fun getAutofillValue (): AutofillValue ? getBackground [androidJvm] open fun getBackground (): Drawable getBackgroundTintBlendMode [androidJvm] open fun getBackgroundTintBlendMode (): BlendMode ? getBackgroundTintList [androidJvm] open fun getBackgroundTintList (): ColorStateList ? getBackgroundTintMode [androidJvm] open fun getBackgroundTintMode (): PorterDuff.Mode ? getBaseline [androidJvm] open fun getBaseline (): Int getBottom [androidJvm] fun getBottom (): Int getBottomFadingEdgeStrength [androidJvm] open fun getBottomFadingEdgeStrength (): Float getBottomPaddingOffset [androidJvm] open fun getBottomPaddingOffset (): Int getCameraDistance [androidJvm] open fun getCameraDistance (): Float getChildAt [androidJvm] open fun getChildAt (p0: Int ): View getChildCount [androidJvm] open fun getChildCount (): Int getChildDrawingOrder [androidJvm] fun getChildDrawingOrder (p0: Int ): Int open fun getChildDrawingOrder (p0: Int , p1: Int ): Int getChildStaticTransformation [androidJvm] open fun getChildStaticTransformation (p0: View , p1: Transformation ): Boolean getChildVisibleRect [androidJvm] open override fun getChildVisibleRect (p0: View , p1: Rect , p2: Point ): Boolean getClipBounds [androidJvm] open fun getClipBounds (): Rect open fun getClipBounds (p0: Rect ): Boolean getClipChildren [androidJvm] open fun getClipChildren (): Boolean getClipToOutline [androidJvm] fun getClipToOutline (): Boolean getClipToPadding [androidJvm] open fun getClipToPadding (): Boolean getContentCaptureSession [androidJvm] fun getContentCaptureSession (): ContentCaptureSession ? getContentDescription [androidJvm] open fun getContentDescription (): CharSequence getContext [androidJvm] fun getContext (): Context getContextMenuInfo [androidJvm] open fun getContextMenuInfo (): ContextMenu.ContextMenuInfo getDefaultFocusHighlightEnabled [androidJvm] fun getDefaultFocusHighlightEnabled (): Boolean getDescendantFocusability [androidJvm] open fun getDescendantFocusability (): Int getDisplay [androidJvm] open fun getDisplay (): Display getDrawableState [androidJvm] fun getDrawableState (): IntArray getDrawingRect [androidJvm] open fun getDrawingRect (p0: Rect ) getDrawingTime [androidJvm] open fun getDrawingTime (): Long getElevation [androidJvm] open fun getElevation (): Float getExplicitStyle [androidJvm] open fun getExplicitStyle (): Int getFilterTouchesWhenObscured [androidJvm] open fun getFilterTouchesWhenObscured (): Boolean getFitsSystemWindows [androidJvm] open fun getFitsSystemWindows (): Boolean getFocusable [androidJvm] open fun getFocusable (): Int getFocusables [androidJvm] open fun getFocusables (p0: Int ): ArrayList < View > getFocusedChild [androidJvm] open fun getFocusedChild (): View getFocusedRect [androidJvm] open fun getFocusedRect (p0: Rect ) getForeground [androidJvm] open fun getForeground (): Drawable getForegroundGravity [androidJvm] open fun getForegroundGravity (): Int getForegroundTintBlendMode [androidJvm] open fun getForegroundTintBlendMode (): BlendMode ? getForegroundTintList [androidJvm] open fun getForegroundTintList (): ColorStateList ? getForegroundTintMode [androidJvm] open fun getForegroundTintMode (): PorterDuff.Mode ? getGlobalVisibleRect [androidJvm] fun getGlobalVisibleRect (p0: Rect ): Boolean open fun getGlobalVisibleRect (p0: Rect , p1: Point ): Boolean getHandler [androidJvm] open fun getHandler (): Handler getHasOverlappingRendering [androidJvm] fun getHasOverlappingRendering (): Boolean getHeight [androidJvm] fun getHeight (): Int getHitRect [androidJvm] open fun getHitRect (p0: Rect ) getHorizontalFadingEdgeLength [androidJvm] open fun getHorizontalFadingEdgeLength (): Int getHorizontalScrollbarHeight [androidJvm] open fun getHorizontalScrollbarHeight (): Int getHorizontalScrollbarThumbDrawable [androidJvm] open fun getHorizontalScrollbarThumbDrawable (): Drawable ? getHorizontalScrollbarTrackDrawable [androidJvm] open fun getHorizontalScrollbarTrackDrawable (): Drawable ? getId [androidJvm] open fun getId (): Int getImportantForAccessibility [androidJvm] open fun getImportantForAccessibility (): Int getImportantForAutofill [androidJvm] open fun getImportantForAutofill (): Int getImportantForContentCapture [androidJvm] open fun getImportantForContentCapture (): Int getKeepScreenOn [androidJvm] open fun getKeepScreenOn (): Boolean getKeyDispatcherState [androidJvm] open fun getKeyDispatcherState (): KeyEvent.DispatcherState getLabelFor [androidJvm] open fun getLabelFor (): Int getLayerType [androidJvm] open fun getLayerType (): Int getLayoutAnimation [androidJvm] open fun getLayoutAnimation (): LayoutAnimationController getLayoutAnimationListener [androidJvm] open fun getLayoutAnimationListener (): Animation.AnimationListener getLayoutDirection [androidJvm] open fun getLayoutDirection (): Int getLayoutMode [androidJvm] open fun getLayoutMode (): Int getLayoutParams [androidJvm] open fun getLayoutParams (): ViewGroup.LayoutParams getLayoutTransition [androidJvm] open fun getLayoutTransition (): LayoutTransition getLeft [androidJvm] fun getLeft (): Int getLeftFadingEdgeStrength [androidJvm] open fun getLeftFadingEdgeStrength (): Float getLeftPaddingOffset [androidJvm] open fun getLeftPaddingOffset (): Int getLocalVisibleRect [androidJvm] fun getLocalVisibleRect (p0: Rect ): Boolean getLocationInSurface [androidJvm] open fun getLocationInSurface (p0: IntArray ) getLocationInWindow [androidJvm] open fun getLocationInWindow (p0: IntArray ) getLocationOnScreen [androidJvm] open fun getLocationOnScreen (p0: IntArray ) getMatrix [androidJvm] open fun getMatrix (): Matrix getMeasureAllChildren [androidJvm] open fun getMeasureAllChildren (): Boolean getMeasuredHeight [androidJvm] fun getMeasuredHeight (): Int getMeasuredHeightAndState [androidJvm] fun getMeasuredHeightAndState (): Int getMeasuredState [androidJvm] fun getMeasuredState (): Int getMeasuredWidth [androidJvm] fun getMeasuredWidth (): Int getMeasuredWidthAndState [androidJvm] fun getMeasuredWidthAndState (): Int getMinimumHeight [androidJvm] open fun getMinimumHeight (): Int getMinimumWidth [androidJvm] open fun getMinimumWidth (): Int getNestedScrollAxes [androidJvm] open fun getNestedScrollAxes (): Int getNextClusterForwardId [androidJvm] open fun getNextClusterForwardId (): Int getNextFocusDownId [androidJvm] open fun getNextFocusDownId (): Int getNextFocusForwardId [androidJvm] open fun getNextFocusForwardId (): Int getNextFocusLeftId [androidJvm] open fun getNextFocusLeftId (): Int getNextFocusRightId [androidJvm] open fun getNextFocusRightId (): Int getNextFocusUpId [androidJvm] open fun getNextFocusUpId (): Int getOnFocusChangeListener [androidJvm] open fun getOnFocusChangeListener (): View.OnFocusChangeListener getOutlineAmbientShadowColor [androidJvm] open fun getOutlineAmbientShadowColor (): Int getOutlineProvider [androidJvm] open fun getOutlineProvider (): ViewOutlineProvider getOutlineSpotShadowColor [androidJvm] open fun getOutlineSpotShadowColor (): Int getOverlay [androidJvm] open override fun getOverlay (): ViewGroupOverlay getOverScrollMode [androidJvm] open fun getOverScrollMode (): Int getPaddingBottom [androidJvm] open fun getPaddingBottom (): Int getPaddingEnd [androidJvm] open fun getPaddingEnd (): Int getPaddingLeft [androidJvm] open fun getPaddingLeft (): Int getPaddingRight [androidJvm] open fun getPaddingRight (): Int getPaddingStart [androidJvm] open fun getPaddingStart (): Int getPaddingTop [androidJvm] open fun getPaddingTop (): Int getParent [androidJvm] fun getParent (): ViewParent getParentForAccessibility [androidJvm] open fun getParentForAccessibility (): ViewParent getPivotX [androidJvm] open fun getPivotX (): Float getPivotY [androidJvm] open fun getPivotY (): Float getPointerIcon [androidJvm] open fun getPointerIcon (): PointerIcon getReceiveContentMimeTypes [androidJvm] open fun getReceiveContentMimeTypes (): Array < String >? getResources [androidJvm] open fun getResources (): Resources getRevealOnFocusHint [androidJvm] fun getRevealOnFocusHint (): Boolean getRight [androidJvm] fun getRight (): Int getRightFadingEdgeStrength [androidJvm] open fun getRightFadingEdgeStrength (): Float getRightPaddingOffset [androidJvm] open fun getRightPaddingOffset (): Int getRootSurfaceControl [androidJvm] open fun getRootSurfaceControl (): AttachedSurfaceControl ? getRootView [androidJvm] open fun getRootView (): View getRootWindowInsets [androidJvm] open fun getRootWindowInsets (): WindowInsets getRotation [androidJvm] open fun getRotation (): Float getRotationX [androidJvm] open fun getRotationX (): Float getRotationY [androidJvm] open fun getRotationY (): Float getScaleX [androidJvm] open fun getScaleX (): Float getScaleY [androidJvm] open fun getScaleY (): Float getScrollBarDefaultDelayBeforeFade [androidJvm] open fun getScrollBarDefaultDelayBeforeFade (): Int getScrollBarFadeDuration [androidJvm] open fun getScrollBarFadeDuration (): Int getScrollBarSize [androidJvm] open fun getScrollBarSize (): Int getScrollBarStyle [androidJvm] open fun getScrollBarStyle (): Int getScrollCaptureHint [androidJvm] open fun getScrollCaptureHint (): Int getScrollIndicators [androidJvm] open fun getScrollIndicators (): Int getScrollX [androidJvm] fun getScrollX (): Int getScrollY [androidJvm] fun getScrollY (): Int getSolidColor [androidJvm] open fun getSolidColor (): Int getSourceLayoutResId [androidJvm] open fun getSourceLayoutResId (): Int getStateDescription [androidJvm] fun getStateDescription (): CharSequence ? getStateListAnimator [androidJvm] open fun getStateListAnimator (): StateListAnimator getSuggestedMinimumHeight [androidJvm] open fun getSuggestedMinimumHeight (): Int getSuggestedMinimumWidth [androidJvm] open fun getSuggestedMinimumWidth (): Int getSystemGestureExclusionRects [androidJvm] open fun getSystemGestureExclusionRects (): MutableList < Rect > getTag [androidJvm] open fun getTag (): Any open fun getTag (p0: Int ): Any getTextAlignment [androidJvm] open fun getTextAlignment (): Int getTextDirection [androidJvm] open fun getTextDirection (): Int getTooltipText [androidJvm] open fun getTooltipText (): CharSequence ? getTop [androidJvm] fun getTop (): Int getTopFadingEdgeStrength [androidJvm] open fun getTopFadingEdgeStrength (): Float getTopPaddingOffset [androidJvm] open fun getTopPaddingOffset (): Int getTouchables [androidJvm] open fun getTouchables (): ArrayList < View > getTouchDelegate [androidJvm] open fun getTouchDelegate (): TouchDelegate getTouchscreenBlocksFocus [androidJvm] open fun getTouchscreenBlocksFocus (): Boolean getTransitionAlpha [androidJvm] open fun getTransitionAlpha (): Float getTransitionName [androidJvm] open fun getTransitionName (): String getTranslationX [androidJvm] open fun getTranslationX (): Float getTranslationY [androidJvm] open fun getTranslationY (): Float getTranslationZ [androidJvm] open fun getTranslationZ (): Float getUniqueDrawingId [androidJvm] open fun getUniqueDrawingId (): Long getVerticalFadingEdgeLength [androidJvm] open fun getVerticalFadingEdgeLength (): Int getVerticalScrollbarPosition [androidJvm] open fun getVerticalScrollbarPosition (): Int getVerticalScrollbarThumbDrawable [androidJvm] open fun getVerticalScrollbarThumbDrawable (): Drawable ? getVerticalScrollbarTrackDrawable [androidJvm] open fun getVerticalScrollbarTrackDrawable (): Drawable ? getVerticalScrollbarWidth [androidJvm] open fun getVerticalScrollbarWidth (): Int getViewTranslationResponse [androidJvm] open fun getViewTranslationResponse (): ViewTranslationResponse ? getViewTreeObserver [androidJvm] open fun getViewTreeObserver (): ViewTreeObserver getVisibility [androidJvm] open fun getVisibility (): Int getWidth [androidJvm] fun getWidth (): Int getWindowAttachCount [androidJvm] open fun getWindowAttachCount (): Int getWindowId [androidJvm] open fun getWindowId (): WindowId getWindowInsetsController [androidJvm] open fun getWindowInsetsController (): WindowInsetsController ? getWindowToken [androidJvm] open fun getWindowToken (): IBinder getWindowVisibility [androidJvm] open fun getWindowVisibility (): Int getWindowVisibleDisplayFrame [androidJvm] open fun getWindowVisibleDisplayFrame (p0: Rect ) getX [androidJvm] open fun getX (): Float getY [androidJvm] open fun getY (): Float getZ [androidJvm] open fun getZ (): Float hasExplicitFocusable [androidJvm] open fun hasExplicitFocusable (): Boolean hasFocus [androidJvm] open override fun hasFocus (): Boolean hasFocusable [androidJvm] open fun hasFocusable (): Boolean hasNestedScrollingParent [androidJvm] open fun hasNestedScrollingParent (): Boolean hasOnClickListeners [androidJvm] open fun hasOnClickListeners (): Boolean hasOnLongClickListeners [androidJvm] open fun hasOnLongClickListeners (): Boolean hasOverlappingRendering [androidJvm] open fun hasOverlappingRendering (): Boolean hasPointerCapture [androidJvm] open fun hasPointerCapture (): Boolean hasTransientState [androidJvm] open override fun hasTransientState (): Boolean hasWindowFocus [androidJvm] open fun hasWindowFocus (): Boolean indexOfChild [androidJvm] open fun indexOfChild (p0: View ): Int invalidate [androidJvm] open fun invalidate () invalidateDrawable [androidJvm] open override fun invalidateDrawable (p0: Drawable ) invalidateOutline [androidJvm] open fun invalidateOutline () isAccessibilityFocused [androidJvm] open fun isAccessibilityFocused (): Boolean isAccessibilityHeading [androidJvm] open fun isAccessibilityHeading (): Boolean isActivated [androidJvm] open fun isActivated (): Boolean isAttachedToWindow [androidJvm] open fun isAttachedToWindow (): Boolean isChildrenDrawingOrderEnabled [androidJvm] open fun isChildrenDrawingOrderEnabled (): Boolean isClickable [androidJvm] open fun isClickable (): Boolean isContextClickable [androidJvm] open fun isContextClickable (): Boolean isDirty [androidJvm] open fun isDirty (): Boolean isDuplicateParentStateEnabled [androidJvm] open fun isDuplicateParentStateEnabled (): Boolean isEnabled [androidJvm] open fun isEnabled (): Boolean isFocusable [androidJvm] fun isFocusable (): Boolean isFocusableInTouchMode [androidJvm] fun isFocusableInTouchMode (): Boolean isFocused [androidJvm] open fun isFocused (): Boolean isFocusedByDefault [androidJvm] fun isFocusedByDefault (): Boolean isForceDarkAllowed [androidJvm] open fun isForceDarkAllowed (): Boolean isHapticFeedbackEnabled [androidJvm] open fun isHapticFeedbackEnabled (): Boolean isHardwareAccelerated [androidJvm] open fun isHardwareAccelerated (): Boolean isHorizontalFadingEdgeEnabled [androidJvm] open fun isHorizontalFadingEdgeEnabled (): Boolean isHorizontalScrollBarEnabled [androidJvm] open fun isHorizontalScrollBarEnabled (): Boolean isHovered [androidJvm] open fun isHovered (): Boolean isImportantForAccessibility [androidJvm] open fun isImportantForAccessibility (): Boolean isImportantForAutofill [androidJvm] fun isImportantForAutofill (): Boolean isImportantForContentCapture [androidJvm] fun isImportantForContentCapture (): Boolean isInEditMode [androidJvm] open fun isInEditMode (): Boolean isInLayout [androidJvm] open fun isInLayout (): Boolean isInTouchMode [androidJvm] open fun isInTouchMode (): Boolean isKeyboardNavigationCluster [androidJvm] fun isKeyboardNavigationCluster (): Boolean isLaidOut [androidJvm] open fun isLaidOut (): Boolean isLayoutDirectionResolved [androidJvm] open fun isLayoutDirectionResolved (): Boolean isLayoutRequested [androidJvm] open fun isLayoutRequested (): Boolean isLayoutSuppressed [androidJvm] open fun isLayoutSuppressed (): Boolean isLongClickable [androidJvm] open fun isLongClickable (): Boolean isMotionEventSplittingEnabled [androidJvm] open fun isMotionEventSplittingEnabled (): Boolean isNestedScrollingEnabled [androidJvm] open fun isNestedScrollingEnabled (): Boolean isOpaque [androidJvm] open fun isOpaque (): Boolean isPaddingOffsetRequired [androidJvm] open fun isPaddingOffsetRequired (): Boolean isPaddingRelative [androidJvm] open fun isPaddingRelative (): Boolean isPivotSet [androidJvm] open fun isPivotSet (): Boolean isPressed [androidJvm] open fun isPressed (): Boolean isSaveEnabled [androidJvm] open fun isSaveEnabled (): Boolean isSaveFromParentEnabled [androidJvm] open fun isSaveFromParentEnabled (): Boolean isScreenReaderFocusable [androidJvm] open fun isScreenReaderFocusable (): Boolean isScrollbarFadingEnabled [androidJvm] open fun isScrollbarFadingEnabled (): Boolean isScrollContainer [androidJvm] open fun isScrollContainer (): Boolean isSelected [androidJvm] open fun isSelected (): Boolean isShowingLayoutBounds [androidJvm] fun isShowingLayoutBounds (): Boolean isShown [androidJvm] open fun isShown (): Boolean isSoundEffectsEnabled [androidJvm] open fun isSoundEffectsEnabled (): Boolean isTemporarilyDetached [androidJvm] fun isTemporarilyDetached (): Boolean isTextAlignmentResolved [androidJvm] open fun isTextAlignmentResolved (): Boolean isTextDirectionResolved [androidJvm] open fun isTextDirectionResolved (): Boolean isTransitionGroup [androidJvm] open fun isTransitionGroup (): Boolean isVerticalFadingEdgeEnabled [androidJvm] open fun isVerticalFadingEdgeEnabled (): Boolean isVerticalScrollBarEnabled [androidJvm] open fun isVerticalScrollBarEnabled (): Boolean isVisibleToUserForAutofill [androidJvm] open fun isVisibleToUserForAutofill (p0: Int ): Boolean jumpDrawablesToCurrentState [androidJvm] open override fun jumpDrawablesToCurrentState () keyboardNavigationClusterSearch [androidJvm] open fun keyboardNavigationClusterSearch (p0: View , p1: Int ): View layout [androidJvm] override fun layout (p0: Int , p1: Int , p2: Int , p3: Int ) measure [androidJvm] fun measure (p0: Int , p1: Int ) measureChild [androidJvm] open fun measureChild (p0: View , p1: Int , p2: Int ) measureChildren [androidJvm] open fun measureChildren (p0: Int , p1: Int ) measureChildWithMargins [androidJvm] open fun measureChildWithMargins (p0: View , p1: Int , p2: Int , p3: Int , p4: Int ) notifySubtreeAccessibilityStateChanged [androidJvm] open override fun notifySubtreeAccessibilityStateChanged (p0: View , p1: View , p2: Int ) offsetDescendantRectToMyCoords [androidJvm] fun offsetDescendantRectToMyCoords (p0: View , p1: Rect ) offsetLeftAndRight [androidJvm] open fun offsetLeftAndRight (p0: Int ) offsetRectIntoDescendantCoords [androidJvm] fun offsetRectIntoDescendantCoords (p0: View , p1: Rect ) offsetTopAndBottom [androidJvm] open fun offsetTopAndBottom (p0: Int ) onAnimationEnd [androidJvm] open fun onAnimationEnd () onAnimationStart [androidJvm] open fun onAnimationStart () onApplyWindowInsets [androidJvm] open fun onApplyWindowInsets (p0: WindowInsets ): WindowInsets onAttachedToWindow [androidJvm] open override fun onAttachedToWindow () onCancelPendingInputEvents [androidJvm] open fun onCancelPendingInputEvents () onCapturedPointerEvent [androidJvm] open fun onCapturedPointerEvent (p0: MotionEvent ): Boolean onCheckIsTextEditor [androidJvm] open fun onCheckIsTextEditor (): Boolean onConfigurationChanged [androidJvm] open fun onConfigurationChanged (p0: Configuration ) onCreateContextMenu [androidJvm] open fun onCreateContextMenu (p0: ContextMenu ) onCreateDrawableState [androidJvm] open override fun onCreateDrawableState (p0: Int ): IntArray onCreateInputConnection [androidJvm] open fun onCreateInputConnection (p0: EditorInfo ): InputConnection onCreateViewTranslationRequest [androidJvm] open fun onCreateViewTranslationRequest (p0: IntArray , p1: Consumer < ViewTranslationRequest >) onCreateVirtualViewTranslationRequests [androidJvm] open fun onCreateVirtualViewTranslationRequests (p0: LongArray , p1: IntArray , p2: Consumer < ViewTranslationRequest >) onDescendantInvalidated [androidJvm] open override fun onDescendantInvalidated (p0: View , p1: View ) onDetachedFromWindow [androidJvm] open override fun onDetachedFromWindow () onDisplayHint [androidJvm] open fun onDisplayHint (p0: Int ) onDragEvent [androidJvm] open fun onDragEvent (p0: DragEvent ): Boolean onDraw [androidJvm] open fun onDraw (p0: Canvas ) onDrawForeground [androidJvm] open fun onDrawForeground (p0: Canvas ) onDrawScrollBars [androidJvm] fun onDrawScrollBars (p0: Canvas ) onFilterTouchEventForSecurity [androidJvm] open fun onFilterTouchEventForSecurity (p0: MotionEvent ): Boolean onFinishInflate [androidJvm] open fun onFinishInflate () onFinishTemporaryDetach [androidJvm] open fun onFinishTemporaryDetach () onFocusChanged [androidJvm] open fun onFocusChanged (p0: Boolean , p1: Int , p2: Rect ?) onGenericMotionEvent [androidJvm] open fun onGenericMotionEvent (p0: MotionEvent ): Boolean onHoverChanged [androidJvm] open fun onHoverChanged (p0: Boolean ) onHoverEvent [androidJvm] open fun onHoverEvent (p0: MotionEvent ): Boolean onInitializeAccessibilityEvent [androidJvm] open fun onInitializeAccessibilityEvent (p0: AccessibilityEvent ) onInitializeAccessibilityNodeInfo [androidJvm] open fun onInitializeAccessibilityNodeInfo (p0: AccessibilityNodeInfo ) onInterceptHoverEvent [androidJvm] open fun onInterceptHoverEvent (p0: MotionEvent ): Boolean onInterceptTouchEvent [androidJvm] open fun onInterceptTouchEvent (p0: MotionEvent ): Boolean onKeyDown [androidJvm] open override fun onKeyDown (p0: Int , p1: KeyEvent ): Boolean onKeyLongPress [androidJvm] open override fun onKeyLongPress (p0: Int , p1: KeyEvent ): Boolean onKeyMultiple [androidJvm] open override fun onKeyMultiple (p0: Int , p1: Int , p2: KeyEvent ): Boolean onKeyPreIme [androidJvm] open fun onKeyPreIme (p0: Int , p1: KeyEvent ): Boolean onKeyShortcut [androidJvm] open fun onKeyShortcut (p0: Int , p1: KeyEvent ): Boolean onKeyUp [androidJvm] open override fun onKeyUp (p0: Int , p1: KeyEvent ): Boolean onLayout [androidJvm] open override fun onLayout (p0: Boolean , p1: Int , p2: Int , p3: Int , p4: Int ) onMeasure [androidJvm] open override fun onMeasure (p0: Int , p1: Int ) onNestedFling [androidJvm] open override fun onNestedFling (p0: View , p1: Float , p2: Float , p3: Boolean ): Boolean onNestedPreFling [androidJvm] open override fun onNestedPreFling (p0: View , p1: Float , p2: Float ): Boolean onNestedPrePerformAccessibilityAction [androidJvm] open override fun onNestedPrePerformAccessibilityAction (p0: View , p1: Int , p2: Bundle ): Boolean onNestedPreScroll [androidJvm] open override fun onNestedPreScroll (p0: View , p1: Int , p2: Int , p3: IntArray ) onNestedScroll [androidJvm] open override fun onNestedScroll (p0: View , p1: Int , p2: Int , p3: Int , p4: Int ) onNestedScrollAccepted [androidJvm] open override fun onNestedScrollAccepted (p0: View , p1: View , p2: Int ) onOverScrolled [androidJvm] open fun onOverScrolled (p0: Int , p1: Int , p2: Boolean , p3: Boolean ) onPointerCaptureChange [androidJvm] open fun onPointerCaptureChange (p0: Boolean ) onPopulateAccessibilityEvent [androidJvm] open fun onPopulateAccessibilityEvent (p0: AccessibilityEvent ) onProvideAutofillStructure [androidJvm] open fun onProvideAutofillStructure (p0: ViewStructure , p1: Int ) onProvideAutofillVirtualStructure [androidJvm] open fun onProvideAutofillVirtualStructure (p0: ViewStructure , p1: Int ) onProvideContentCaptureStructure [androidJvm] open fun onProvideContentCaptureStructure (p0: ViewStructure , p1: Int ) onProvideStructure [androidJvm] open fun onProvideStructure (p0: ViewStructure ) onProvideVirtualStructure [androidJvm] open fun onProvideVirtualStructure (p0: ViewStructure ) onReceiveContent [androidJvm] open fun onReceiveContent (p0: ContentInfo ): ContentInfo ? onRequestFocusInDescendants [androidJvm] open fun onRequestFocusInDescendants (p0: Int , p1: Rect ): Boolean onRequestSendAccessibilityEvent [androidJvm] open fun onRequestSendAccessibilityEvent (p0: View , p1: AccessibilityEvent ): Boolean onResolvePointerIcon [androidJvm] open override fun onResolvePointerIcon (p0: MotionEvent , p1: Int ): PointerIcon onRtlPropertiesChanged [androidJvm] open fun onRtlPropertiesChanged (p0: Int ) onScreenStateChanged [androidJvm] open fun onScreenStateChanged (p0: Int ) onScrollCaptureSearch [androidJvm] open fun onScrollCaptureSearch (p0: Rect , p1: Point , p2: Consumer < ScrollCaptureTarget >) onScrollChanged [androidJvm] open fun onScrollChanged (p0: Int , p1: Int , p2: Int , p3: Int ) onSetAlpha [androidJvm] open fun onSetAlpha (p0: Int ): Boolean onSizeChanged [androidJvm] open fun onSizeChanged (p0: Int , p1: Int , p2: Int , p3: Int ) onStartNestedScroll [androidJvm] open override fun onStartNestedScroll (p0: View , p1: View , p2: Int ): Boolean onStartTemporaryDetach [androidJvm] open fun onStartTemporaryDetach () onStopNestedScroll [androidJvm] open override fun onStopNestedScroll (p0: View ) onTouchEvent [androidJvm] open fun onTouchEvent (p0: MotionEvent ): Boolean onTrackballEvent [androidJvm] open fun onTrackballEvent (p0: MotionEvent ): Boolean onViewAdded [androidJvm] open fun onViewAdded (p0: View ) onViewRemoved [androidJvm] open fun onViewRemoved (p0: View ) onViewTranslationResponse [androidJvm] open fun onViewTranslationResponse (p0: ViewTranslationResponse ) onVirtualViewTranslationResponses [androidJvm] open fun onVirtualViewTranslationResponses (p0: LongSparseArray < ViewTranslationResponse >) onVisibilityAggregated [androidJvm] open fun onVisibilityAggregated (p0: Boolean ) onVisibilityChanged [androidJvm] open fun onVisibilityChanged (p0: View , p1: Int ) onWindowFocusChanged [androidJvm] open fun onWindowFocusChanged (p0: Boolean ) onWindowVisibilityChanged [androidJvm] open fun onWindowVisibilityChanged (p0: Int ) overScrollBy [androidJvm] open fun overScrollBy (p0: Int , p1: Int , p2: Int , p3: Int , p4: Int , p5: Int , p6: Int , p7: Int , p8: Boolean ): Boolean performAccessibilityAction [androidJvm] open fun performAccessibilityAction (p0: Int , p1: Bundle ): Boolean performClick [androidJvm] open fun performClick (): Boolean performContextClick [androidJvm] open fun performContextClick (): Boolean open fun performContextClick (p0: Float , p1: Float ): Boolean performHapticFeedback [androidJvm] open fun performHapticFeedback (p0: Int ): Boolean open fun performHapticFeedback (p0: Int , p1: Int ): Boolean performLongClick [androidJvm] open fun performLongClick (): Boolean open fun performLongClick (p0: Float , p1: Float ): Boolean performReceiveContent [androidJvm] open fun performReceiveContent (p0: ContentInfo ): ContentInfo ? playSoundEffect [androidJvm] open fun playSoundEffect (p0: Int ) post [androidJvm] open fun post (p0: Runnable ): Boolean postDelayed [androidJvm] open fun postDelayed (p0: Runnable , p1: Long ): Boolean postInvalidate [androidJvm] open fun postInvalidate () open fun postInvalidate (p0: Int , p1: Int , p2: Int , p3: Int ) postInvalidateDelayed [androidJvm] open fun postInvalidateDelayed (p0: Long ) open fun postInvalidateDelayed (p0: Long , p1: Int , p2: Int , p3: Int , p4: Int ) postInvalidateOnAnimation [androidJvm] open fun postInvalidateOnAnimation () open fun postInvalidateOnAnimation (p0: Int , p1: Int , p2: Int , p3: Int ) postOnAnimation [androidJvm] open fun postOnAnimation (p0: Runnable ) postOnAnimationDelayed [androidJvm] open fun postOnAnimationDelayed (p0: Runnable , p1: Long ) recomputeViewAttributes [androidJvm] open override fun recomputeViewAttributes (p0: View ) refreshDrawableState [androidJvm] open fun refreshDrawableState () releasePointerCapture [androidJvm] open fun releasePointerCapture () removeAllViews [androidJvm] open fun removeAllViews () removeAllViewsInLayout [androidJvm] open fun removeAllViewsInLayout () removeCallbacks [androidJvm] open fun removeCallbacks (p0: Runnable ): Boolean removeDetachedView [androidJvm] open fun removeDetachedView (p0: View , p1: Boolean ) removeOnAttachStateChangeListener [androidJvm] open fun removeOnAttachStateChangeListener (p0: View.OnAttachStateChangeListener ) removeOnLayoutChangeListener [androidJvm] open fun removeOnLayoutChangeListener (p0: View.OnLayoutChangeListener ) removeOnUnhandledKeyEventListener [androidJvm] open fun removeOnUnhandledKeyEventListener (p0: View.OnUnhandledKeyEventListener ) removeView [androidJvm] open override fun removeView (p0: View ) removeViewAt [androidJvm] open fun removeViewAt (p0: Int ) removeViewInLayout [androidJvm] open fun removeViewInLayout (p0: View ) removeViews [androidJvm] open fun removeViews (p0: Int , p1: Int ) removeViewsInLayout [androidJvm] open fun removeViewsInLayout (p0: Int , p1: Int ) requestApplyInsets [androidJvm] open fun requestApplyInsets () requestChildFocus [androidJvm] open override fun requestChildFocus (p0: View , p1: View ) requestChildRectangleOnScreen [androidJvm] open override fun requestChildRectangleOnScreen (p0: View , p1: Rect , p2: Boolean ): Boolean requestDisallowInterceptTouchEvent [androidJvm] open override fun requestDisallowInterceptTouchEvent (p0: Boolean ) requestFocus [androidJvm] fun requestFocus (): Boolean fun requestFocus (p0: Int ): Boolean open override fun requestFocus (p0: Int , p1: Rect ): Boolean requestFocusFromTouch [androidJvm] fun requestFocusFromTouch (): Boolean requestLayout [androidJvm] open fun requestLayout () requestPointerCapture [androidJvm] open fun requestPointerCapture () requestRectangleOnScreen [androidJvm] open fun requestRectangleOnScreen (p0: Rect ): Boolean open fun requestRectangleOnScreen (p0: Rect , p1: Boolean ): Boolean requestSendAccessibilityEvent [androidJvm] open override fun requestSendAccessibilityEvent (p0: View , p1: AccessibilityEvent ): Boolean requestTransparentRegion [androidJvm] open override fun requestTransparentRegion (p0: View ) requestUnbufferedDispatch [androidJvm] fun requestUnbufferedDispatch (p0: MotionEvent ) fun requestUnbufferedDispatch (p0: Int ) requireViewById [androidJvm] fun < T : View > requireViewById (p0: Int ): T resetPivot [androidJvm] open fun resetPivot () restoreDefaultFocus [androidJvm] open override fun restoreDefaultFocus (): Boolean restoreHierarchyState [androidJvm] open fun restoreHierarchyState (p0: SparseArray < Parcelable >) saveAttributeDataForStyleable [androidJvm] fun saveAttributeDataForStyleable (p0: Context , p1: IntArray , p2: AttributeSet ?, p3: TypedArray , p4: Int , p5: Int ) saveHierarchyState [androidJvm] open fun saveHierarchyState (p0: SparseArray < Parcelable >) scheduleDrawable [androidJvm] open override fun scheduleDrawable (p0: Drawable , p1: Runnable , p2: Long ) scheduleLayoutAnimation [androidJvm] open fun scheduleLayoutAnimation () scrollBy [androidJvm] open fun scrollBy (p0: Int , p1: Int ) scrollTo [androidJvm] open fun scrollTo (p0: Int , p1: Int ) sendAccessibilityEvent [androidJvm] open override fun sendAccessibilityEvent (p0: Int ) sendAccessibilityEventUnchecked [androidJvm] open override fun sendAccessibilityEventUnchecked (p0: AccessibilityEvent ) setAccessibilityDelegate [androidJvm] open fun setAccessibilityDelegate (p0: View.AccessibilityDelegate ?) setAccessibilityHeading [androidJvm] open fun setAccessibilityHeading (p0: Boolean ) setAccessibilityLiveRegion [androidJvm] open fun setAccessibilityLiveRegion (p0: Int ) setAccessibilityPaneTitle [androidJvm] open fun setAccessibilityPaneTitle (p0: CharSequence ?) setAccessibilityTraversalAfter [androidJvm] open fun setAccessibilityTraversalAfter (p0: Int ) setAccessibilityTraversalBefore [androidJvm] open fun setAccessibilityTraversalBefore (p0: Int ) setActivated [androidJvm] open fun setActivated (p0: Boolean ) setAddStatesFromChildren [androidJvm] open fun setAddStatesFromChildren (p0: Boolean ) setAllowClickWhenDisabled [androidJvm] open fun setAllowClickWhenDisabled (p0: Boolean ) setAlpha [androidJvm] open fun setAlpha (p0: Float ) setAnimation [androidJvm] open fun setAnimation (p0: Animation ) setAnimationMatrix [androidJvm] open fun setAnimationMatrix (p0: Matrix ?) setAutofillHints [androidJvm] open fun setAutofillHints (vararg p0: String ) setAutofillId [androidJvm] open fun setAutofillId (p0: AutofillId ?) setBackground [androidJvm] open fun setBackground (p0: Drawable ) setBackgroundColor [androidJvm] open fun setBackgroundColor (p0: Int ) setBackgroundResource [androidJvm] open fun setBackgroundResource (p0: Int ) setBackgroundTintBlendMode [androidJvm] open fun setBackgroundTintBlendMode (p0: BlendMode ?) setBackgroundTintList [androidJvm] open fun setBackgroundTintList (p0: ColorStateList ?) setBackgroundTintMode [androidJvm] open fun setBackgroundTintMode (p0: PorterDuff.Mode ?) setBottom [androidJvm] fun setBottom (p0: Int ) setCameraDistance [androidJvm] open fun setCameraDistance (p0: Float ) setChildrenDrawingOrderEnabled [androidJvm] open fun setChildrenDrawingOrderEnabled (p0: Boolean ) setClickable [androidJvm] open fun setClickable (p0: Boolean ) setClipBounds [androidJvm] open fun setClipBounds (p0: Rect ) setClipChildren [androidJvm] open fun setClipChildren (p0: Boolean ) setClipToOutline [androidJvm] open fun setClipToOutline (p0: Boolean ) setClipToPadding [androidJvm] open fun setClipToPadding (p0: Boolean ) setContentCaptureSession [androidJvm] open fun setContentCaptureSession (p0: ContentCaptureSession ?) setContentDescription [androidJvm] open fun setContentDescription (p0: CharSequence ) setContextClickable [androidJvm] open fun setContextClickable (p0: Boolean ) setDefaultFocusHighlightEnabled [androidJvm] open fun setDefaultFocusHighlightEnabled (p0: Boolean ) setDescendantFocusability [androidJvm] open fun setDescendantFocusability (p0: Int ) setDuplicateParentStateEnabled [androidJvm] open fun setDuplicateParentStateEnabled (p0: Boolean ) setElevation [androidJvm] open fun setElevation (p0: Float ) setEnabled [androidJvm] open fun setEnabled (p0: Boolean ) setFadingEdgeLength [androidJvm] open fun setFadingEdgeLength (p0: Int ) setFilterTouchesWhenObscured [androidJvm] open fun setFilterTouchesWhenObscured (p0: Boolean ) setFitsSystemWindows [androidJvm] open fun setFitsSystemWindows (p0: Boolean ) setFocusable [androidJvm] open fun setFocusable (p0: Boolean ) open fun setFocusable (p0: Int ) setFocusableInTouchMode [androidJvm] open fun setFocusableInTouchMode (p0: Boolean ) setFocusedByDefault [androidJvm] open fun setFocusedByDefault (p0: Boolean ) setForceDarkAllowed [androidJvm] open fun setForceDarkAllowed (p0: Boolean ) setForeground [androidJvm] open fun setForeground (p0: Drawable ) setForegroundGravity [androidJvm] open override fun setForegroundGravity (p0: Int ) setForegroundTintBlendMode [androidJvm] open fun setForegroundTintBlendMode (p0: BlendMode ?) setForegroundTintList [androidJvm] open fun setForegroundTintList (p0: ColorStateList ?) setForegroundTintMode [androidJvm] open fun setForegroundTintMode (p0: PorterDuff.Mode ?) setHapticFeedbackEnabled [androidJvm] open fun setHapticFeedbackEnabled (p0: Boolean ) setHasTransientState [androidJvm] open fun setHasTransientState (p0: Boolean ) setHorizontalFadingEdgeEnabled [androidJvm] open fun setHorizontalFadingEdgeEnabled (p0: Boolean ) setHorizontalScrollBarEnabled [androidJvm] open fun setHorizontalScrollBarEnabled (p0: Boolean ) setHorizontalScrollbarThumbDrawable [androidJvm] open fun setHorizontalScrollbarThumbDrawable (p0: Drawable ?) setHorizontalScrollbarTrackDrawable [androidJvm] open fun setHorizontalScrollbarTrackDrawable (p0: Drawable ?) setHovered [androidJvm] open fun setHovered (p0: Boolean ) setId [androidJvm] open fun setId (p0: Int ) setImportantForAccessibility [androidJvm] open fun setImportantForAccessibility (p0: Int ) setImportantForAutofill [androidJvm] open fun setImportantForAutofill (p0: Int ) setImportantForContentCapture [androidJvm] open fun setImportantForContentCapture (p0: Int ) setKeepScreenOn [androidJvm] open fun setKeepScreenOn (p0: Boolean ) setKeyboardNavigationCluster [androidJvm] open fun setKeyboardNavigationCluster (p0: Boolean ) setLabelFor [androidJvm] open fun setLabelFor (p0: Int ) setLayerPaint [androidJvm] open fun setLayerPaint (p0: Paint ?) setLayerType [androidJvm] open fun setLayerType (p0: Int , p1: Paint ?) setLayoutAnimation [androidJvm] open fun setLayoutAnimation (p0: LayoutAnimationController ) setLayoutAnimationListener [androidJvm] open fun setLayoutAnimationListener (p0: Animation.AnimationListener ) setLayoutDirection [androidJvm] open fun setLayoutDirection (p0: Int ) setLayoutMode [androidJvm] open fun setLayoutMode (p0: Int ) setLayoutParams [androidJvm] open fun setLayoutParams (p0: ViewGroup.LayoutParams ) setLayoutTransition [androidJvm] open fun setLayoutTransition (p0: LayoutTransition ) setLeft [androidJvm] fun setLeft (p0: Int ) setLeftTopRightBottom [androidJvm] fun setLeftTopRightBottom (p0: Int , p1: Int , p2: Int , p3: Int ) setLongClickable [androidJvm] open fun setLongClickable (p0: Boolean ) setMeasureAllChildren [androidJvm] open fun setMeasureAllChildren (p0: Boolean ) setMeasuredDimension [androidJvm] fun setMeasuredDimension (p0: Int , p1: Int ) setMinimumHeight [androidJvm] open fun setMinimumHeight (p0: Int ) setMinimumWidth [androidJvm] open fun setMinimumWidth (p0: Int ) setMotionEventSplittingEnabled [androidJvm] open fun setMotionEventSplittingEnabled (p0: Boolean ) setNestedScrollingEnabled [androidJvm] open fun setNestedScrollingEnabled (p0: Boolean ) setNextClusterForwardId [androidJvm] open fun setNextClusterForwardId (p0: Int ) setNextFocusDownId [androidJvm] open fun setNextFocusDownId (p0: Int ) setNextFocusForwardId [androidJvm] open fun setNextFocusForwardId (p0: Int ) setNextFocusLeftId [androidJvm] open fun setNextFocusLeftId (p0: Int ) setNextFocusRightId [androidJvm] open fun setNextFocusRightId (p0: Int ) setNextFocusUpId [androidJvm] open fun setNextFocusUpId (p0: Int ) setOnApplyWindowInsetsListener [androidJvm] open fun setOnApplyWindowInsetsListener (p0: View.OnApplyWindowInsetsListener ) setOnCapturedPointerListener [androidJvm] open fun setOnCapturedPointerListener (p0: View.OnCapturedPointerListener ) setOnClickListener [androidJvm] open fun setOnClickListener (p0: View.OnClickListener ?) setOnContextClickListener [androidJvm] open fun setOnContextClickListener (p0: View.OnContextClickListener ?) setOnCreateContextMenuListener [androidJvm] open fun setOnCreateContextMenuListener (p0: View.OnCreateContextMenuListener ) setOnDragListener [androidJvm] open fun setOnDragListener (p0: View.OnDragListener ) setOnFocusChangeListener [androidJvm] open fun setOnFocusChangeListener (p0: View.OnFocusChangeListener ) setOnGenericMotionListener [androidJvm] open fun setOnGenericMotionListener (p0: View.OnGenericMotionListener ) setOnHierarchyChangeListener [androidJvm] open fun setOnHierarchyChangeListener (p0: ViewGroup.OnHierarchyChangeListener ) setOnHoverListener [androidJvm] open fun setOnHoverListener (p0: View.OnHoverListener ) setOnKeyListener [androidJvm] open fun setOnKeyListener (p0: View.OnKeyListener ) setOnLongClickListener [androidJvm] open fun setOnLongClickListener (p0: View.OnLongClickListener ?) setOnReceiveContentListener [androidJvm] open fun setOnReceiveContentListener (p0: Array < String >?, p1: OnReceiveContentListener ?) setOnScrollChangeListener [androidJvm] open fun setOnScrollChangeListener (p0: View.OnScrollChangeListener ) setOnTouchListener [androidJvm] open fun setOnTouchListener (p0: View.OnTouchListener ) setOutlineAmbientShadowColor [androidJvm] open fun setOutlineAmbientShadowColor (p0: Int ) setOutlineProvider [androidJvm] open fun setOutlineProvider (p0: ViewOutlineProvider ) setOutlineSpotShadowColor [androidJvm] open fun setOutlineSpotShadowColor (p0: Int ) setOverScrollMode [androidJvm] open fun setOverScrollMode (p0: Int ) setPadding [androidJvm] open fun setPadding (p0: Int , p1: Int , p2: Int , p3: Int ) setPaddingRelative [androidJvm] open fun setPaddingRelative (p0: Int , p1: Int , p2: Int , p3: Int ) setPivotX [androidJvm] open fun setPivotX (p0: Float ) setPivotY [androidJvm] open fun setPivotY (p0: Float ) setPointerIcon [androidJvm] open fun setPointerIcon (p0: PointerIcon ) setPressed [androidJvm] open fun setPressed (p0: Boolean ) setRenderEffect [androidJvm] open fun setRenderEffect (p0: RenderEffect ?) setRevealOnFocusHint [androidJvm] fun setRevealOnFocusHint (p0: Boolean ) setRight [androidJvm] fun setRight (p0: Int ) setRotation [androidJvm] open fun setRotation (p0: Float ) setRotationX [androidJvm] open fun setRotationX (p0: Float ) setRotationY [androidJvm] open fun setRotationY (p0: Float ) setSaveEnabled [androidJvm] open fun setSaveEnabled (p0: Boolean ) setSaveFromParentEnabled [androidJvm] open fun setSaveFromParentEnabled (p0: Boolean ) setScaleX [androidJvm] open fun setScaleX (p0: Float ) setScaleY [androidJvm] open fun setScaleY (p0: Float ) setScreenReaderFocusable [androidJvm] open fun setScreenReaderFocusable (p0: Boolean ) setScrollBarDefaultDelayBeforeFade [androidJvm] open fun setScrollBarDefaultDelayBeforeFade (p0: Int ) setScrollBarFadeDuration [androidJvm] open fun setScrollBarFadeDuration (p0: Int ) setScrollbarFadingEnabled [androidJvm] open fun setScrollbarFadingEnabled (p0: Boolean ) setScrollBarSize [androidJvm] open fun setScrollBarSize (p0: Int ) setScrollBarStyle [androidJvm] open fun setScrollBarStyle (p0: Int ) setScrollCaptureCallback [androidJvm] fun setScrollCaptureCallback (p0: ScrollCaptureCallback ?) setScrollCaptureHint [androidJvm] open fun setScrollCaptureHint (p0: Int ) setScrollContainer [androidJvm] open fun setScrollContainer (p0: Boolean ) setScrollIndicators [androidJvm] open fun setScrollIndicators (p0: Int ) open fun setScrollIndicators (p0: Int , p1: Int ) setScrollX [androidJvm] open fun setScrollX (p0: Int ) setScrollY [androidJvm] open fun setScrollY (p0: Int ) setSelected [androidJvm] open fun setSelected (p0: Boolean ) setSoundEffectsEnabled [androidJvm] open fun setSoundEffectsEnabled (p0: Boolean ) setStateDescription [androidJvm] open fun setStateDescription (p0: CharSequence ?) setStateListAnimator [androidJvm] open fun setStateListAnimator (p0: StateListAnimator ) setStaticTransformationsEnabled [androidJvm] open fun setStaticTransformationsEnabled (p0: Boolean ) setSystemGestureExclusionRects [androidJvm] open fun setSystemGestureExclusionRects (p0: MutableList < Rect >) setTag [androidJvm] open fun setTag (p0: Any ) open fun setTag (p0: Int , p1: Any ) setTextAlignment [androidJvm] open fun setTextAlignment (p0: Int ) setTextDirection [androidJvm] open fun setTextDirection (p0: Int ) setTooltipText [androidJvm] open fun setTooltipText (p0: CharSequence ?) setTop [androidJvm] fun setTop (p0: Int ) setTouchDelegate [androidJvm] open fun setTouchDelegate (p0: TouchDelegate ) setTouchscreenBlocksFocus [androidJvm] open fun setTouchscreenBlocksFocus (p0: Boolean ) setTransitionAlpha [androidJvm] open fun setTransitionAlpha (p0: Float ) setTransitionGroup [androidJvm] open fun setTransitionGroup (p0: Boolean ) setTransitionName [androidJvm] fun setTransitionName (p0: String ) setTransitionVisibility [androidJvm] open fun setTransitionVisibility (p0: Int ) setTranslationX [androidJvm] open fun setTranslationX (p0: Float ) setTranslationY [androidJvm] open fun setTranslationY (p0: Float ) setTranslationZ [androidJvm] open fun setTranslationZ (p0: Float ) setVerticalFadingEdgeEnabled [androidJvm] open fun setVerticalFadingEdgeEnabled (p0: Boolean ) setVerticalScrollBarEnabled [androidJvm] open fun setVerticalScrollBarEnabled (p0: Boolean ) setVerticalScrollbarPosition [androidJvm] open fun setVerticalScrollbarPosition (p0: Int ) setVerticalScrollbarThumbDrawable [androidJvm] open fun setVerticalScrollbarThumbDrawable (p0: Drawable ?) setVerticalScrollbarTrackDrawable [androidJvm] open fun setVerticalScrollbarTrackDrawable (p0: Drawable ?) setViewTranslationCallback [androidJvm] open fun setViewTranslationCallback (p0: ViewTranslationCallback ) setVisibility [androidJvm] open fun setVisibility (p0: Int ) setWillNotDraw [androidJvm] open fun setWillNotDraw (p0: Boolean ) setWindowInsetsAnimationCallback [androidJvm] open override fun setWindowInsetsAnimationCallback (p0: WindowInsetsAnimation.Callback ?) setX [androidJvm] open fun setX (p0: Float ) setY [androidJvm] open fun setY (p0: Float ) setZ [androidJvm] open fun setZ (p0: Float ) shouldDelayChildPressedState [androidJvm] open override fun shouldDelayChildPressedState (): Boolean showContextMenu [androidJvm] open fun showContextMenu (): Boolean open fun showContextMenu (p0: Float , p1: Float ): Boolean showContextMenuForChild [androidJvm] open override fun showContextMenuForChild (p0: View ): Boolean open override fun showContextMenuForChild (p0: View , p1: Float , p2: Float ): Boolean startActionMode [androidJvm] open fun startActionMode (p0: ActionMode.Callback ): ActionMode open fun startActionMode (p0: ActionMode.Callback , p1: Int ): ActionMode startActionModeForChild [androidJvm] open override fun startActionModeForChild (p0: View , p1: ActionMode.Callback ): ActionMode open override fun startActionModeForChild (p0: View , p1: ActionMode.Callback , p2: Int ): ActionMode startAnimation [androidJvm] open fun startAnimation (p0: Animation ) startDragAndDrop [androidJvm] fun startDragAndDrop (p0: ClipData , p1: View.DragShadowBuilder , p2: Any , p3: Int ): Boolean startLayoutAnimation [androidJvm] open fun startLayoutAnimation () startNestedScroll [androidJvm] open fun startNestedScroll (p0: Int ): Boolean startViewTransition [androidJvm] open fun startViewTransition (p0: View ) stopNestedScroll [androidJvm] open fun stopNestedScroll () suppressLayout [androidJvm] open fun suppressLayout (p0: Boolean ) toString [androidJvm] open override fun toString (): String transformMatrixToGlobal [androidJvm] open fun transformMatrixToGlobal (p0: Matrix ) transformMatrixToLocal [androidJvm] open fun transformMatrixToLocal (p0: Matrix ) unscheduleDrawable [androidJvm] open fun unscheduleDrawable (p0: Drawable ) open override fun unscheduleDrawable (p0: Drawable , p1: Runnable ) updateDragShadow [androidJvm] fun updateDragShadow (p0: View.DragShadowBuilder ) updateViewLayout [androidJvm] open override fun updateViewLayout (p0: View , p1: ViewGroup.LayoutParams ) verifyDrawable [androidJvm] open fun verifyDrawable (p0: Drawable ): Boolean willNotDraw [androidJvm] open fun willNotDraw (): Boolean Inheritors \u00b6 Name AlertContainer ModalViewContainer","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-modal-container/#modalcontainer","text":"[androidJvm]\\ @WorkflowUiExperimentalApi abstract class ModalContainer < ModalRenderingT : Any >@ JvmOverloads constructor(context: Context , attributeSet: AttributeSet ?, defStyle: Int , defStyleRes: Int ) : FrameLayout Base class for containers that show HasModals.modals in Dialog windows. It is not currently supported to make a ModalContainer the immediate child of a BackStackContainer. See https://github.com/square/workflow-kotlin/issues/470 .","title":"ModalContainer"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-modal-container/#parameters","text":"androidJvm ModalRenderingT the type of the nested renderings to be shown in a dialog window.","title":"Parameters"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-modal-container/#constructors","text":"ModalContainer [androidJvm] @ JvmOverloads fun ModalContainer (context: Context , attributeSet: AttributeSet ? = null, defStyle: Int = 0, defStyleRes: Int = 0)","title":"Constructors"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-modal-container/#functions","text":"Name Summary addChildrenForAccessibility [androidJvm] open override fun addChildrenForAccessibility (p0: ArrayList < View >) addExtraDataToAccessibilityNodeInfo [androidJvm] open override fun addExtraDataToAccessibilityNodeInfo (p0: AccessibilityNodeInfo , p1: String , p2: Bundle ?) addFocusables [androidJvm] open fun addFocusables (p0: ArrayList < View >, p1: Int ) open override fun addFocusables (p0: ArrayList < View >, p1: Int , p2: Int ) addKeyboardNavigationClusters [androidJvm] open override fun addKeyboardNavigationClusters (p0: MutableCollection < View >, p1: Int ) addOnAttachStateChangeListener [androidJvm] open fun addOnAttachStateChangeListener (p0: View.OnAttachStateChangeListener ) addOnLayoutChangeListener [androidJvm] open fun addOnLayoutChangeListener (p0: View.OnLayoutChangeListener ) addOnUnhandledKeyEventListener [androidJvm] open fun addOnUnhandledKeyEventListener (p0: View.OnUnhandledKeyEventListener ) addStatesFromChildren [androidJvm] open fun addStatesFromChildren (): Boolean addTouchables [androidJvm] open override fun addTouchables (p0: ArrayList < View >) addView [androidJvm] open fun addView (p0: View ) open override fun addView (p0: View , p1: ViewGroup.LayoutParams ) open fun addView (p0: View , p1: Int ) open fun addView (p0: View , p1: Int , p2: ViewGroup.LayoutParams ) open fun addView (p0: View , p1: Int , p2: Int ) addViewInLayout [androidJvm] open fun addViewInLayout (p0: View , p1: Int , p2: ViewGroup.LayoutParams ): Boolean open fun addViewInLayout (p0: View , p1: Int , p2: ViewGroup.LayoutParams , p3: Boolean ): Boolean animate [androidJvm] open fun animate (): ViewPropertyAnimator announceForAccessibility [androidJvm] open fun announceForAccessibility (p0: CharSequence ) attachLayoutAnimationParameters [androidJvm] open fun attachLayoutAnimationParameters (p0: View , p1: ViewGroup.LayoutParams , p2: Int , p3: Int ) attachViewToParent [androidJvm] open fun attachViewToParent (p0: View , p1: Int , p2: ViewGroup.LayoutParams ) autofill [androidJvm] open fun autofill (p0: SparseArray < AutofillValue >) open fun autofill (p0: AutofillValue ) awakenScrollBars [androidJvm] open fun awakenScrollBars (): Boolean open fun awakenScrollBars (p0: Int ): Boolean open fun awakenScrollBars (p0: Int , p1: Boolean ): Boolean bringChildToFront [androidJvm] open override fun bringChildToFront (p0: View ) bringToFront [androidJvm] open fun bringToFront () buildLayer [androidJvm] open fun buildLayer () callOnClick [androidJvm] open fun callOnClick (): Boolean canAnimate [androidJvm] open fun canAnimate (): Boolean cancelDragAndDrop [androidJvm] fun cancelDragAndDrop () cancelLongPress [androidJvm] open fun cancelLongPress () cancelPendingInputEvents [androidJvm] fun cancelPendingInputEvents () canResolveLayoutDirection [androidJvm] open fun canResolveLayoutDirection (): Boolean canResolveTextAlignment [androidJvm] open fun canResolveTextAlignment (): Boolean canResolveTextDirection [androidJvm] open fun canResolveTextDirection (): Boolean canScrollHorizontally [androidJvm] open fun canScrollHorizontally (p0: Int ): Boolean canScrollVertically [androidJvm] open fun canScrollVertically (p0: Int ): Boolean checkInputConnectionProxy [androidJvm] open fun checkInputConnectionProxy (p0: View ): Boolean checkLayoutParams [androidJvm] open override fun checkLayoutParams (p0: ViewGroup.LayoutParams ): Boolean childDrawableStateChanged [androidJvm] open override fun childDrawableStateChanged (p0: View ) childHasTransientStateChanged [androidJvm] open override fun childHasTransientStateChanged (p0: View , p1: Boolean ) cleanupLayoutState [androidJvm] open fun cleanupLayoutState (p0: View ) clearAnimation [androidJvm] open fun clearAnimation () clearChildFocus [androidJvm] open override fun clearChildFocus (p0: View ) clearDisappearingChildren [androidJvm] open fun clearDisappearingChildren () clearFocus [androidJvm] open override fun clearFocus () clearViewTranslationCallback [androidJvm] open fun clearViewTranslationCallback () computeHorizontalScrollExtent [androidJvm] open fun computeHorizontalScrollExtent (): Int computeHorizontalScrollOffset [androidJvm] open fun computeHorizontalScrollOffset (): Int computeHorizontalScrollRange [androidJvm] open fun computeHorizontalScrollRange (): Int computeScroll [androidJvm] open fun computeScroll () computeSystemWindowInsets [androidJvm] open fun computeSystemWindowInsets (p0: WindowInsets , p1: Rect ): WindowInsets computeVerticalScrollExtent [androidJvm] open fun computeVerticalScrollExtent (): Int computeVerticalScrollOffset [androidJvm] open fun computeVerticalScrollOffset (): Int computeVerticalScrollRange [androidJvm] open fun computeVerticalScrollRange (): Int createAccessibilityNodeInfo [androidJvm] open fun createAccessibilityNodeInfo (): AccessibilityNodeInfo createContextMenu [androidJvm] open fun createContextMenu (p0: ContextMenu ) debug [androidJvm] open fun debug (p0: Int ) detachAllViewsFromParent [androidJvm] open fun detachAllViewsFromParent () detachViewFromParent [androidJvm] open fun detachViewFromParent (p0: View ) open fun detachViewFromParent (p0: Int ) detachViewsFromParent [androidJvm] open fun detachViewsFromParent (p0: Int , p1: Int ) dispatchApplyWindowInsets [androidJvm] open override fun dispatchApplyWindowInsets (p0: WindowInsets ): WindowInsets dispatchCapturedPointerEvent [androidJvm] open override fun dispatchCapturedPointerEvent (p0: MotionEvent ): Boolean dispatchConfigurationChanged [androidJvm] open override fun dispatchConfigurationChanged (p0: Configuration ) dispatchCreateViewTranslationRequest [androidJvm] open override fun dispatchCreateViewTranslationRequest (p0: MutableMap < AutofillId , LongArray >, p1: IntArray , p2: TranslationCapability , p3: MutableList < ViewTranslationRequest >) dispatchDisplayHint [androidJvm] open override fun dispatchDisplayHint (p0: Int ) dispatchDragEvent [androidJvm] open override fun dispatchDragEvent (p0: DragEvent ): Boolean dispatchDraw [androidJvm] open override fun dispatchDraw (p0: Canvas ) dispatchDrawableHotspotChanged [androidJvm] open override fun dispatchDrawableHotspotChanged (p0: Float , p1: Float ) dispatchFinishTemporaryDetach [androidJvm] open override fun dispatchFinishTemporaryDetach () dispatchFreezeSelfOnly [androidJvm] open fun dispatchFreezeSelfOnly (p0: SparseArray < Parcelable >) dispatchGenericFocusedEvent [androidJvm] open override fun dispatchGenericFocusedEvent (p0: MotionEvent ): Boolean dispatchGenericMotionEvent [androidJvm] open fun dispatchGenericMotionEvent (p0: MotionEvent ): Boolean dispatchGenericPointerEvent [androidJvm] open override fun dispatchGenericPointerEvent (p0: MotionEvent ): Boolean dispatchHoverEvent [androidJvm] open override fun dispatchHoverEvent (p0: MotionEvent ): Boolean dispatchKeyEvent [androidJvm] open override fun dispatchKeyEvent (p0: KeyEvent ): Boolean dispatchKeyEventPreIme [androidJvm] open override fun dispatchKeyEventPreIme (p0: KeyEvent ): Boolean dispatchKeyShortcutEvent [androidJvm] open override fun dispatchKeyShortcutEvent (p0: KeyEvent ): Boolean dispatchNestedFling [androidJvm] open fun dispatchNestedFling (p0: Float , p1: Float , p2: Boolean ): Boolean dispatchNestedPreFling [androidJvm] open fun dispatchNestedPreFling (p0: Float , p1: Float ): Boolean dispatchNestedPrePerformAccessibilityAction [androidJvm] open fun dispatchNestedPrePerformAccessibilityAction (p0: Int , p1: Bundle ): Boolean dispatchNestedPreScroll [androidJvm] open fun dispatchNestedPreScroll (p0: Int , p1: Int , p2: IntArray ?, p3: IntArray ?): Boolean dispatchNestedScroll [androidJvm] open fun dispatchNestedScroll (p0: Int , p1: Int , p2: Int , p3: Int , p4: IntArray ?): Boolean dispatchPointerCaptureChanged [androidJvm] open override fun dispatchPointerCaptureChanged (p0: Boolean ) dispatchPopulateAccessibilityEvent [androidJvm] open fun dispatchPopulateAccessibilityEvent (p0: AccessibilityEvent ): Boolean dispatchProvideAutofillStructure [androidJvm] open override fun dispatchProvideAutofillStructure (p0: ViewStructure , p1: Int ) dispatchProvideStructure [androidJvm] open override fun dispatchProvideStructure (p0: ViewStructure ) dispatchRestoreInstanceState [androidJvm] open override fun dispatchRestoreInstanceState (p0: SparseArray < Parcelable >) dispatchSaveInstanceState [androidJvm] open override fun dispatchSaveInstanceState (p0: SparseArray < Parcelable >) dispatchScrollCaptureSearch [androidJvm] open override fun dispatchScrollCaptureSearch (p0: Rect , p1: Point , p2: Consumer < ScrollCaptureTarget >) dispatchSetActivated [androidJvm] open override fun dispatchSetActivated (p0: Boolean ) dispatchSetPressed [androidJvm] open override fun dispatchSetPressed (p0: Boolean ) dispatchSetSelected [androidJvm] open override fun dispatchSetSelected (p0: Boolean ) dispatchStartTemporaryDetach [androidJvm] open override fun dispatchStartTemporaryDetach () dispatchThawSelfOnly [androidJvm] open fun dispatchThawSelfOnly (p0: SparseArray < Parcelable >) dispatchTouchEvent [androidJvm] open override fun dispatchTouchEvent (p0: MotionEvent ): Boolean dispatchTrackballEvent [androidJvm] open override fun dispatchTrackballEvent (p0: MotionEvent ): Boolean dispatchUnhandledMove [androidJvm] open override fun dispatchUnhandledMove (p0: View , p1: Int ): Boolean dispatchVisibilityChanged [androidJvm] open override fun dispatchVisibilityChanged (p0: View , p1: Int ) dispatchWindowFocusChanged [androidJvm] open override fun dispatchWindowFocusChanged (p0: Boolean ) dispatchWindowInsetsAnimationEnd [androidJvm] open override fun dispatchWindowInsetsAnimationEnd (p0: WindowInsetsAnimation ) dispatchWindowInsetsAnimationPrepare [androidJvm] open override fun dispatchWindowInsetsAnimationPrepare (p0: WindowInsetsAnimation ) dispatchWindowInsetsAnimationProgress [androidJvm] open override fun dispatchWindowInsetsAnimationProgress (p0: WindowInsets , p1: MutableList < WindowInsetsAnimation >): WindowInsets dispatchWindowInsetsAnimationStart [androidJvm] open override fun dispatchWindowInsetsAnimationStart (p0: WindowInsetsAnimation , p1: WindowInsetsAnimation.Bounds ): WindowInsetsAnimation.Bounds dispatchWindowVisibilityChanged [androidJvm] open override fun dispatchWindowVisibilityChanged (p0: Int ) draw [androidJvm] open fun draw (p0: Canvas ) drawableHotspotChanged [androidJvm] open fun drawableHotspotChanged (p0: Float , p1: Float ) drawableStateChanged [androidJvm] open override fun drawableStateChanged () drawChild [androidJvm] open fun drawChild (p0: Canvas , p1: View , p2: Long ): Boolean endViewTransition [androidJvm] open fun endViewTransition (p0: View ) findFocus [androidJvm] open override fun findFocus (): View findViewById [androidJvm] fun < T : View > findViewById (p0: Int ): T findViewsWithText [androidJvm] open override fun findViewsWithText (p0: ArrayList < View >, p1: CharSequence , p2: Int ) findViewWithTag [androidJvm] fun < T : View > findViewWithTag (p0: Any ): T focusableViewAvailable [androidJvm] open override fun focusableViewAvailable (p0: View ) focusSearch [androidJvm] open fun focusSearch (p0: Int ): View open override fun focusSearch (p0: View , p1: Int ): View forceHasOverlappingRendering [androidJvm] open fun forceHasOverlappingRendering (p0: Boolean ) forceLayout [androidJvm] open fun forceLayout () gatherTransparentRegion [androidJvm] open override fun gatherTransparentRegion (p0: Region ?): Boolean generateDefaultLayoutParams [androidJvm] open override fun generateDefaultLayoutParams (): FrameLayout.LayoutParams generateDisplayHash [androidJvm] open fun generateDisplayHash (p0: String , p1: Rect ?, p2: Executor , p3: DisplayHashResultCallback ) generateLayoutParams [androidJvm] open override fun generateLayoutParams (p0: AttributeSet ): FrameLayout.LayoutParams open override fun generateLayoutParams (p0: ViewGroup.LayoutParams ): ViewGroup.LayoutParams getAccessibilityClassName [androidJvm] open override fun getAccessibilityClassName (): CharSequence getAccessibilityDelegate [androidJvm] open fun getAccessibilityDelegate (): View.AccessibilityDelegate getAccessibilityLiveRegion [androidJvm] open fun getAccessibilityLiveRegion (): Int getAccessibilityNodeProvider [androidJvm] open fun getAccessibilityNodeProvider (): AccessibilityNodeProvider getAccessibilityPaneTitle [androidJvm] open fun getAccessibilityPaneTitle (): CharSequence ? getAccessibilityTraversalAfter [androidJvm] open fun getAccessibilityTraversalAfter (): Int getAccessibilityTraversalBefore [androidJvm] open fun getAccessibilityTraversalBefore (): Int getAlpha [androidJvm] open fun getAlpha (): Float getAnimation [androidJvm] open fun getAnimation (): Animation getAnimationMatrix [androidJvm] open fun getAnimationMatrix (): Matrix ? getApplicationWindowToken [androidJvm] open fun getApplicationWindowToken (): IBinder getAttributeResolutionStack [androidJvm] open fun getAttributeResolutionStack (p0: Int ): IntArray getAttributeSourceResourceMap [androidJvm] open fun getAttributeSourceResourceMap (): MutableMap < Int , Int > getAutofillHints [androidJvm] open fun getAutofillHints (): Array < String >? getAutofillId [androidJvm] fun getAutofillId (): AutofillId getAutofillType [androidJvm] open fun getAutofillType (): Int getAutofillValue [androidJvm] open fun getAutofillValue (): AutofillValue ? getBackground [androidJvm] open fun getBackground (): Drawable getBackgroundTintBlendMode [androidJvm] open fun getBackgroundTintBlendMode (): BlendMode ? getBackgroundTintList [androidJvm] open fun getBackgroundTintList (): ColorStateList ? getBackgroundTintMode [androidJvm] open fun getBackgroundTintMode (): PorterDuff.Mode ? getBaseline [androidJvm] open fun getBaseline (): Int getBottom [androidJvm] fun getBottom (): Int getBottomFadingEdgeStrength [androidJvm] open fun getBottomFadingEdgeStrength (): Float getBottomPaddingOffset [androidJvm] open fun getBottomPaddingOffset (): Int getCameraDistance [androidJvm] open fun getCameraDistance (): Float getChildAt [androidJvm] open fun getChildAt (p0: Int ): View getChildCount [androidJvm] open fun getChildCount (): Int getChildDrawingOrder [androidJvm] fun getChildDrawingOrder (p0: Int ): Int open fun getChildDrawingOrder (p0: Int , p1: Int ): Int getChildStaticTransformation [androidJvm] open fun getChildStaticTransformation (p0: View , p1: Transformation ): Boolean getChildVisibleRect [androidJvm] open override fun getChildVisibleRect (p0: View , p1: Rect , p2: Point ): Boolean getClipBounds [androidJvm] open fun getClipBounds (): Rect open fun getClipBounds (p0: Rect ): Boolean getClipChildren [androidJvm] open fun getClipChildren (): Boolean getClipToOutline [androidJvm] fun getClipToOutline (): Boolean getClipToPadding [androidJvm] open fun getClipToPadding (): Boolean getContentCaptureSession [androidJvm] fun getContentCaptureSession (): ContentCaptureSession ? getContentDescription [androidJvm] open fun getContentDescription (): CharSequence getContext [androidJvm] fun getContext (): Context getContextMenuInfo [androidJvm] open fun getContextMenuInfo (): ContextMenu.ContextMenuInfo getDefaultFocusHighlightEnabled [androidJvm] fun getDefaultFocusHighlightEnabled (): Boolean getDescendantFocusability [androidJvm] open fun getDescendantFocusability (): Int getDisplay [androidJvm] open fun getDisplay (): Display getDrawableState [androidJvm] fun getDrawableState (): IntArray getDrawingRect [androidJvm] open fun getDrawingRect (p0: Rect ) getDrawingTime [androidJvm] open fun getDrawingTime (): Long getElevation [androidJvm] open fun getElevation (): Float getExplicitStyle [androidJvm] open fun getExplicitStyle (): Int getFilterTouchesWhenObscured [androidJvm] open fun getFilterTouchesWhenObscured (): Boolean getFitsSystemWindows [androidJvm] open fun getFitsSystemWindows (): Boolean getFocusable [androidJvm] open fun getFocusable (): Int getFocusables [androidJvm] open fun getFocusables (p0: Int ): ArrayList < View > getFocusedChild [androidJvm] open fun getFocusedChild (): View getFocusedRect [androidJvm] open fun getFocusedRect (p0: Rect ) getForeground [androidJvm] open fun getForeground (): Drawable getForegroundGravity [androidJvm] open fun getForegroundGravity (): Int getForegroundTintBlendMode [androidJvm] open fun getForegroundTintBlendMode (): BlendMode ? getForegroundTintList [androidJvm] open fun getForegroundTintList (): ColorStateList ? getForegroundTintMode [androidJvm] open fun getForegroundTintMode (): PorterDuff.Mode ? getGlobalVisibleRect [androidJvm] fun getGlobalVisibleRect (p0: Rect ): Boolean open fun getGlobalVisibleRect (p0: Rect , p1: Point ): Boolean getHandler [androidJvm] open fun getHandler (): Handler getHasOverlappingRendering [androidJvm] fun getHasOverlappingRendering (): Boolean getHeight [androidJvm] fun getHeight (): Int getHitRect [androidJvm] open fun getHitRect (p0: Rect ) getHorizontalFadingEdgeLength [androidJvm] open fun getHorizontalFadingEdgeLength (): Int getHorizontalScrollbarHeight [androidJvm] open fun getHorizontalScrollbarHeight (): Int getHorizontalScrollbarThumbDrawable [androidJvm] open fun getHorizontalScrollbarThumbDrawable (): Drawable ? getHorizontalScrollbarTrackDrawable [androidJvm] open fun getHorizontalScrollbarTrackDrawable (): Drawable ? getId [androidJvm] open fun getId (): Int getImportantForAccessibility [androidJvm] open fun getImportantForAccessibility (): Int getImportantForAutofill [androidJvm] open fun getImportantForAutofill (): Int getImportantForContentCapture [androidJvm] open fun getImportantForContentCapture (): Int getKeepScreenOn [androidJvm] open fun getKeepScreenOn (): Boolean getKeyDispatcherState [androidJvm] open fun getKeyDispatcherState (): KeyEvent.DispatcherState getLabelFor [androidJvm] open fun getLabelFor (): Int getLayerType [androidJvm] open fun getLayerType (): Int getLayoutAnimation [androidJvm] open fun getLayoutAnimation (): LayoutAnimationController getLayoutAnimationListener [androidJvm] open fun getLayoutAnimationListener (): Animation.AnimationListener getLayoutDirection [androidJvm] open fun getLayoutDirection (): Int getLayoutMode [androidJvm] open fun getLayoutMode (): Int getLayoutParams [androidJvm] open fun getLayoutParams (): ViewGroup.LayoutParams getLayoutTransition [androidJvm] open fun getLayoutTransition (): LayoutTransition getLeft [androidJvm] fun getLeft (): Int getLeftFadingEdgeStrength [androidJvm] open fun getLeftFadingEdgeStrength (): Float getLeftPaddingOffset [androidJvm] open fun getLeftPaddingOffset (): Int getLocalVisibleRect [androidJvm] fun getLocalVisibleRect (p0: Rect ): Boolean getLocationInSurface [androidJvm] open fun getLocationInSurface (p0: IntArray ) getLocationInWindow [androidJvm] open fun getLocationInWindow (p0: IntArray ) getLocationOnScreen [androidJvm] open fun getLocationOnScreen (p0: IntArray ) getMatrix [androidJvm] open fun getMatrix (): Matrix getMeasureAllChildren [androidJvm] open fun getMeasureAllChildren (): Boolean getMeasuredHeight [androidJvm] fun getMeasuredHeight (): Int getMeasuredHeightAndState [androidJvm] fun getMeasuredHeightAndState (): Int getMeasuredState [androidJvm] fun getMeasuredState (): Int getMeasuredWidth [androidJvm] fun getMeasuredWidth (): Int getMeasuredWidthAndState [androidJvm] fun getMeasuredWidthAndState (): Int getMinimumHeight [androidJvm] open fun getMinimumHeight (): Int getMinimumWidth [androidJvm] open fun getMinimumWidth (): Int getNestedScrollAxes [androidJvm] open fun getNestedScrollAxes (): Int getNextClusterForwardId [androidJvm] open fun getNextClusterForwardId (): Int getNextFocusDownId [androidJvm] open fun getNextFocusDownId (): Int getNextFocusForwardId [androidJvm] open fun getNextFocusForwardId (): Int getNextFocusLeftId [androidJvm] open fun getNextFocusLeftId (): Int getNextFocusRightId [androidJvm] open fun getNextFocusRightId (): Int getNextFocusUpId [androidJvm] open fun getNextFocusUpId (): Int getOnFocusChangeListener [androidJvm] open fun getOnFocusChangeListener (): View.OnFocusChangeListener getOutlineAmbientShadowColor [androidJvm] open fun getOutlineAmbientShadowColor (): Int getOutlineProvider [androidJvm] open fun getOutlineProvider (): ViewOutlineProvider getOutlineSpotShadowColor [androidJvm] open fun getOutlineSpotShadowColor (): Int getOverlay [androidJvm] open override fun getOverlay (): ViewGroupOverlay getOverScrollMode [androidJvm] open fun getOverScrollMode (): Int getPaddingBottom [androidJvm] open fun getPaddingBottom (): Int getPaddingEnd [androidJvm] open fun getPaddingEnd (): Int getPaddingLeft [androidJvm] open fun getPaddingLeft (): Int getPaddingRight [androidJvm] open fun getPaddingRight (): Int getPaddingStart [androidJvm] open fun getPaddingStart (): Int getPaddingTop [androidJvm] open fun getPaddingTop (): Int getParent [androidJvm] fun getParent (): ViewParent getParentForAccessibility [androidJvm] open fun getParentForAccessibility (): ViewParent getPivotX [androidJvm] open fun getPivotX (): Float getPivotY [androidJvm] open fun getPivotY (): Float getPointerIcon [androidJvm] open fun getPointerIcon (): PointerIcon getReceiveContentMimeTypes [androidJvm] open fun getReceiveContentMimeTypes (): Array < String >? getResources [androidJvm] open fun getResources (): Resources getRevealOnFocusHint [androidJvm] fun getRevealOnFocusHint (): Boolean getRight [androidJvm] fun getRight (): Int getRightFadingEdgeStrength [androidJvm] open fun getRightFadingEdgeStrength (): Float getRightPaddingOffset [androidJvm] open fun getRightPaddingOffset (): Int getRootSurfaceControl [androidJvm] open fun getRootSurfaceControl (): AttachedSurfaceControl ? getRootView [androidJvm] open fun getRootView (): View getRootWindowInsets [androidJvm] open fun getRootWindowInsets (): WindowInsets getRotation [androidJvm] open fun getRotation (): Float getRotationX [androidJvm] open fun getRotationX (): Float getRotationY [androidJvm] open fun getRotationY (): Float getScaleX [androidJvm] open fun getScaleX (): Float getScaleY [androidJvm] open fun getScaleY (): Float getScrollBarDefaultDelayBeforeFade [androidJvm] open fun getScrollBarDefaultDelayBeforeFade (): Int getScrollBarFadeDuration [androidJvm] open fun getScrollBarFadeDuration (): Int getScrollBarSize [androidJvm] open fun getScrollBarSize (): Int getScrollBarStyle [androidJvm] open fun getScrollBarStyle (): Int getScrollCaptureHint [androidJvm] open fun getScrollCaptureHint (): Int getScrollIndicators [androidJvm] open fun getScrollIndicators (): Int getScrollX [androidJvm] fun getScrollX (): Int getScrollY [androidJvm] fun getScrollY (): Int getSolidColor [androidJvm] open fun getSolidColor (): Int getSourceLayoutResId [androidJvm] open fun getSourceLayoutResId (): Int getStateDescription [androidJvm] fun getStateDescription (): CharSequence ? getStateListAnimator [androidJvm] open fun getStateListAnimator (): StateListAnimator getSuggestedMinimumHeight [androidJvm] open fun getSuggestedMinimumHeight (): Int getSuggestedMinimumWidth [androidJvm] open fun getSuggestedMinimumWidth (): Int getSystemGestureExclusionRects [androidJvm] open fun getSystemGestureExclusionRects (): MutableList < Rect > getTag [androidJvm] open fun getTag (): Any open fun getTag (p0: Int ): Any getTextAlignment [androidJvm] open fun getTextAlignment (): Int getTextDirection [androidJvm] open fun getTextDirection (): Int getTooltipText [androidJvm] open fun getTooltipText (): CharSequence ? getTop [androidJvm] fun getTop (): Int getTopFadingEdgeStrength [androidJvm] open fun getTopFadingEdgeStrength (): Float getTopPaddingOffset [androidJvm] open fun getTopPaddingOffset (): Int getTouchables [androidJvm] open fun getTouchables (): ArrayList < View > getTouchDelegate [androidJvm] open fun getTouchDelegate (): TouchDelegate getTouchscreenBlocksFocus [androidJvm] open fun getTouchscreenBlocksFocus (): Boolean getTransitionAlpha [androidJvm] open fun getTransitionAlpha (): Float getTransitionName [androidJvm] open fun getTransitionName (): String getTranslationX [androidJvm] open fun getTranslationX (): Float getTranslationY [androidJvm] open fun getTranslationY (): Float getTranslationZ [androidJvm] open fun getTranslationZ (): Float getUniqueDrawingId [androidJvm] open fun getUniqueDrawingId (): Long getVerticalFadingEdgeLength [androidJvm] open fun getVerticalFadingEdgeLength (): Int getVerticalScrollbarPosition [androidJvm] open fun getVerticalScrollbarPosition (): Int getVerticalScrollbarThumbDrawable [androidJvm] open fun getVerticalScrollbarThumbDrawable (): Drawable ? getVerticalScrollbarTrackDrawable [androidJvm] open fun getVerticalScrollbarTrackDrawable (): Drawable ? getVerticalScrollbarWidth [androidJvm] open fun getVerticalScrollbarWidth (): Int getViewTranslationResponse [androidJvm] open fun getViewTranslationResponse (): ViewTranslationResponse ? getViewTreeObserver [androidJvm] open fun getViewTreeObserver (): ViewTreeObserver getVisibility [androidJvm] open fun getVisibility (): Int getWidth [androidJvm] fun getWidth (): Int getWindowAttachCount [androidJvm] open fun getWindowAttachCount (): Int getWindowId [androidJvm] open fun getWindowId (): WindowId getWindowInsetsController [androidJvm] open fun getWindowInsetsController (): WindowInsetsController ? getWindowToken [androidJvm] open fun getWindowToken (): IBinder getWindowVisibility [androidJvm] open fun getWindowVisibility (): Int getWindowVisibleDisplayFrame [androidJvm] open fun getWindowVisibleDisplayFrame (p0: Rect ) getX [androidJvm] open fun getX (): Float getY [androidJvm] open fun getY (): Float getZ [androidJvm] open fun getZ (): Float hasExplicitFocusable [androidJvm] open fun hasExplicitFocusable (): Boolean hasFocus [androidJvm] open override fun hasFocus (): Boolean hasFocusable [androidJvm] open fun hasFocusable (): Boolean hasNestedScrollingParent [androidJvm] open fun hasNestedScrollingParent (): Boolean hasOnClickListeners [androidJvm] open fun hasOnClickListeners (): Boolean hasOnLongClickListeners [androidJvm] open fun hasOnLongClickListeners (): Boolean hasOverlappingRendering [androidJvm] open fun hasOverlappingRendering (): Boolean hasPointerCapture [androidJvm] open fun hasPointerCapture (): Boolean hasTransientState [androidJvm] open override fun hasTransientState (): Boolean hasWindowFocus [androidJvm] open fun hasWindowFocus (): Boolean indexOfChild [androidJvm] open fun indexOfChild (p0: View ): Int invalidate [androidJvm] open fun invalidate () invalidateDrawable [androidJvm] open override fun invalidateDrawable (p0: Drawable ) invalidateOutline [androidJvm] open fun invalidateOutline () isAccessibilityFocused [androidJvm] open fun isAccessibilityFocused (): Boolean isAccessibilityHeading [androidJvm] open fun isAccessibilityHeading (): Boolean isActivated [androidJvm] open fun isActivated (): Boolean isAttachedToWindow [androidJvm] open fun isAttachedToWindow (): Boolean isChildrenDrawingOrderEnabled [androidJvm] open fun isChildrenDrawingOrderEnabled (): Boolean isClickable [androidJvm] open fun isClickable (): Boolean isContextClickable [androidJvm] open fun isContextClickable (): Boolean isDirty [androidJvm] open fun isDirty (): Boolean isDuplicateParentStateEnabled [androidJvm] open fun isDuplicateParentStateEnabled (): Boolean isEnabled [androidJvm] open fun isEnabled (): Boolean isFocusable [androidJvm] fun isFocusable (): Boolean isFocusableInTouchMode [androidJvm] fun isFocusableInTouchMode (): Boolean isFocused [androidJvm] open fun isFocused (): Boolean isFocusedByDefault [androidJvm] fun isFocusedByDefault (): Boolean isForceDarkAllowed [androidJvm] open fun isForceDarkAllowed (): Boolean isHapticFeedbackEnabled [androidJvm] open fun isHapticFeedbackEnabled (): Boolean isHardwareAccelerated [androidJvm] open fun isHardwareAccelerated (): Boolean isHorizontalFadingEdgeEnabled [androidJvm] open fun isHorizontalFadingEdgeEnabled (): Boolean isHorizontalScrollBarEnabled [androidJvm] open fun isHorizontalScrollBarEnabled (): Boolean isHovered [androidJvm] open fun isHovered (): Boolean isImportantForAccessibility [androidJvm] open fun isImportantForAccessibility (): Boolean isImportantForAutofill [androidJvm] fun isImportantForAutofill (): Boolean isImportantForContentCapture [androidJvm] fun isImportantForContentCapture (): Boolean isInEditMode [androidJvm] open fun isInEditMode (): Boolean isInLayout [androidJvm] open fun isInLayout (): Boolean isInTouchMode [androidJvm] open fun isInTouchMode (): Boolean isKeyboardNavigationCluster [androidJvm] fun isKeyboardNavigationCluster (): Boolean isLaidOut [androidJvm] open fun isLaidOut (): Boolean isLayoutDirectionResolved [androidJvm] open fun isLayoutDirectionResolved (): Boolean isLayoutRequested [androidJvm] open fun isLayoutRequested (): Boolean isLayoutSuppressed [androidJvm] open fun isLayoutSuppressed (): Boolean isLongClickable [androidJvm] open fun isLongClickable (): Boolean isMotionEventSplittingEnabled [androidJvm] open fun isMotionEventSplittingEnabled (): Boolean isNestedScrollingEnabled [androidJvm] open fun isNestedScrollingEnabled (): Boolean isOpaque [androidJvm] open fun isOpaque (): Boolean isPaddingOffsetRequired [androidJvm] open fun isPaddingOffsetRequired (): Boolean isPaddingRelative [androidJvm] open fun isPaddingRelative (): Boolean isPivotSet [androidJvm] open fun isPivotSet (): Boolean isPressed [androidJvm] open fun isPressed (): Boolean isSaveEnabled [androidJvm] open fun isSaveEnabled (): Boolean isSaveFromParentEnabled [androidJvm] open fun isSaveFromParentEnabled (): Boolean isScreenReaderFocusable [androidJvm] open fun isScreenReaderFocusable (): Boolean isScrollbarFadingEnabled [androidJvm] open fun isScrollbarFadingEnabled (): Boolean isScrollContainer [androidJvm] open fun isScrollContainer (): Boolean isSelected [androidJvm] open fun isSelected (): Boolean isShowingLayoutBounds [androidJvm] fun isShowingLayoutBounds (): Boolean isShown [androidJvm] open fun isShown (): Boolean isSoundEffectsEnabled [androidJvm] open fun isSoundEffectsEnabled (): Boolean isTemporarilyDetached [androidJvm] fun isTemporarilyDetached (): Boolean isTextAlignmentResolved [androidJvm] open fun isTextAlignmentResolved (): Boolean isTextDirectionResolved [androidJvm] open fun isTextDirectionResolved (): Boolean isTransitionGroup [androidJvm] open fun isTransitionGroup (): Boolean isVerticalFadingEdgeEnabled [androidJvm] open fun isVerticalFadingEdgeEnabled (): Boolean isVerticalScrollBarEnabled [androidJvm] open fun isVerticalScrollBarEnabled (): Boolean isVisibleToUserForAutofill [androidJvm] open fun isVisibleToUserForAutofill (p0: Int ): Boolean jumpDrawablesToCurrentState [androidJvm] open override fun jumpDrawablesToCurrentState () keyboardNavigationClusterSearch [androidJvm] open fun keyboardNavigationClusterSearch (p0: View , p1: Int ): View layout [androidJvm] override fun layout (p0: Int , p1: Int , p2: Int , p3: Int ) measure [androidJvm] fun measure (p0: Int , p1: Int ) measureChild [androidJvm] open fun measureChild (p0: View , p1: Int , p2: Int ) measureChildren [androidJvm] open fun measureChildren (p0: Int , p1: Int ) measureChildWithMargins [androidJvm] open fun measureChildWithMargins (p0: View , p1: Int , p2: Int , p3: Int , p4: Int ) notifySubtreeAccessibilityStateChanged [androidJvm] open override fun notifySubtreeAccessibilityStateChanged (p0: View , p1: View , p2: Int ) offsetDescendantRectToMyCoords [androidJvm] fun offsetDescendantRectToMyCoords (p0: View , p1: Rect ) offsetLeftAndRight [androidJvm] open fun offsetLeftAndRight (p0: Int ) offsetRectIntoDescendantCoords [androidJvm] fun offsetRectIntoDescendantCoords (p0: View , p1: Rect ) offsetTopAndBottom [androidJvm] open fun offsetTopAndBottom (p0: Int ) onAnimationEnd [androidJvm] open fun onAnimationEnd () onAnimationStart [androidJvm] open fun onAnimationStart () onApplyWindowInsets [androidJvm] open fun onApplyWindowInsets (p0: WindowInsets ): WindowInsets onAttachedToWindow [androidJvm] open override fun onAttachedToWindow () onCancelPendingInputEvents [androidJvm] open fun onCancelPendingInputEvents () onCapturedPointerEvent [androidJvm] open fun onCapturedPointerEvent (p0: MotionEvent ): Boolean onCheckIsTextEditor [androidJvm] open fun onCheckIsTextEditor (): Boolean onConfigurationChanged [androidJvm] open fun onConfigurationChanged (p0: Configuration ) onCreateContextMenu [androidJvm] open fun onCreateContextMenu (p0: ContextMenu ) onCreateDrawableState [androidJvm] open override fun onCreateDrawableState (p0: Int ): IntArray onCreateInputConnection [androidJvm] open fun onCreateInputConnection (p0: EditorInfo ): InputConnection onCreateViewTranslationRequest [androidJvm] open fun onCreateViewTranslationRequest (p0: IntArray , p1: Consumer < ViewTranslationRequest >) onCreateVirtualViewTranslationRequests [androidJvm] open fun onCreateVirtualViewTranslationRequests (p0: LongArray , p1: IntArray , p2: Consumer < ViewTranslationRequest >) onDescendantInvalidated [androidJvm] open override fun onDescendantInvalidated (p0: View , p1: View ) onDetachedFromWindow [androidJvm] open override fun onDetachedFromWindow () onDisplayHint [androidJvm] open fun onDisplayHint (p0: Int ) onDragEvent [androidJvm] open fun onDragEvent (p0: DragEvent ): Boolean onDraw [androidJvm] open fun onDraw (p0: Canvas ) onDrawForeground [androidJvm] open fun onDrawForeground (p0: Canvas ) onDrawScrollBars [androidJvm] fun onDrawScrollBars (p0: Canvas ) onFilterTouchEventForSecurity [androidJvm] open fun onFilterTouchEventForSecurity (p0: MotionEvent ): Boolean onFinishInflate [androidJvm] open fun onFinishInflate () onFinishTemporaryDetach [androidJvm] open fun onFinishTemporaryDetach () onFocusChanged [androidJvm] open fun onFocusChanged (p0: Boolean , p1: Int , p2: Rect ?) onGenericMotionEvent [androidJvm] open fun onGenericMotionEvent (p0: MotionEvent ): Boolean onHoverChanged [androidJvm] open fun onHoverChanged (p0: Boolean ) onHoverEvent [androidJvm] open fun onHoverEvent (p0: MotionEvent ): Boolean onInitializeAccessibilityEvent [androidJvm] open fun onInitializeAccessibilityEvent (p0: AccessibilityEvent ) onInitializeAccessibilityNodeInfo [androidJvm] open fun onInitializeAccessibilityNodeInfo (p0: AccessibilityNodeInfo ) onInterceptHoverEvent [androidJvm] open fun onInterceptHoverEvent (p0: MotionEvent ): Boolean onInterceptTouchEvent [androidJvm] open fun onInterceptTouchEvent (p0: MotionEvent ): Boolean onKeyDown [androidJvm] open override fun onKeyDown (p0: Int , p1: KeyEvent ): Boolean onKeyLongPress [androidJvm] open override fun onKeyLongPress (p0: Int , p1: KeyEvent ): Boolean onKeyMultiple [androidJvm] open override fun onKeyMultiple (p0: Int , p1: Int , p2: KeyEvent ): Boolean onKeyPreIme [androidJvm] open fun onKeyPreIme (p0: Int , p1: KeyEvent ): Boolean onKeyShortcut [androidJvm] open fun onKeyShortcut (p0: Int , p1: KeyEvent ): Boolean onKeyUp [androidJvm] open override fun onKeyUp (p0: Int , p1: KeyEvent ): Boolean onLayout [androidJvm] open override fun onLayout (p0: Boolean , p1: Int , p2: Int , p3: Int , p4: Int ) onMeasure [androidJvm] open override fun onMeasure (p0: Int , p1: Int ) onNestedFling [androidJvm] open override fun onNestedFling (p0: View , p1: Float , p2: Float , p3: Boolean ): Boolean onNestedPreFling [androidJvm] open override fun onNestedPreFling (p0: View , p1: Float , p2: Float ): Boolean onNestedPrePerformAccessibilityAction [androidJvm] open override fun onNestedPrePerformAccessibilityAction (p0: View , p1: Int , p2: Bundle ): Boolean onNestedPreScroll [androidJvm] open override fun onNestedPreScroll (p0: View , p1: Int , p2: Int , p3: IntArray ) onNestedScroll [androidJvm] open override fun onNestedScroll (p0: View , p1: Int , p2: Int , p3: Int , p4: Int ) onNestedScrollAccepted [androidJvm] open override fun onNestedScrollAccepted (p0: View , p1: View , p2: Int ) onOverScrolled [androidJvm] open fun onOverScrolled (p0: Int , p1: Int , p2: Boolean , p3: Boolean ) onPointerCaptureChange [androidJvm] open fun onPointerCaptureChange (p0: Boolean ) onPopulateAccessibilityEvent [androidJvm] open fun onPopulateAccessibilityEvent (p0: AccessibilityEvent ) onProvideAutofillStructure [androidJvm] open fun onProvideAutofillStructure (p0: ViewStructure , p1: Int ) onProvideAutofillVirtualStructure [androidJvm] open fun onProvideAutofillVirtualStructure (p0: ViewStructure , p1: Int ) onProvideContentCaptureStructure [androidJvm] open fun onProvideContentCaptureStructure (p0: ViewStructure , p1: Int ) onProvideStructure [androidJvm] open fun onProvideStructure (p0: ViewStructure ) onProvideVirtualStructure [androidJvm] open fun onProvideVirtualStructure (p0: ViewStructure ) onReceiveContent [androidJvm] open fun onReceiveContent (p0: ContentInfo ): ContentInfo ? onRequestFocusInDescendants [androidJvm] open fun onRequestFocusInDescendants (p0: Int , p1: Rect ): Boolean onRequestSendAccessibilityEvent [androidJvm] open fun onRequestSendAccessibilityEvent (p0: View , p1: AccessibilityEvent ): Boolean onResolvePointerIcon [androidJvm] open override fun onResolvePointerIcon (p0: MotionEvent , p1: Int ): PointerIcon onRtlPropertiesChanged [androidJvm] open fun onRtlPropertiesChanged (p0: Int ) onScreenStateChanged [androidJvm] open fun onScreenStateChanged (p0: Int ) onScrollCaptureSearch [androidJvm] open fun onScrollCaptureSearch (p0: Rect , p1: Point , p2: Consumer < ScrollCaptureTarget >) onScrollChanged [androidJvm] open fun onScrollChanged (p0: Int , p1: Int , p2: Int , p3: Int ) onSetAlpha [androidJvm] open fun onSetAlpha (p0: Int ): Boolean onSizeChanged [androidJvm] open fun onSizeChanged (p0: Int , p1: Int , p2: Int , p3: Int ) onStartNestedScroll [androidJvm] open override fun onStartNestedScroll (p0: View , p1: View , p2: Int ): Boolean onStartTemporaryDetach [androidJvm] open fun onStartTemporaryDetach () onStopNestedScroll [androidJvm] open override fun onStopNestedScroll (p0: View ) onTouchEvent [androidJvm] open fun onTouchEvent (p0: MotionEvent ): Boolean onTrackballEvent [androidJvm] open fun onTrackballEvent (p0: MotionEvent ): Boolean onViewAdded [androidJvm] open fun onViewAdded (p0: View ) onViewRemoved [androidJvm] open fun onViewRemoved (p0: View ) onViewTranslationResponse [androidJvm] open fun onViewTranslationResponse (p0: ViewTranslationResponse ) onVirtualViewTranslationResponses [androidJvm] open fun onVirtualViewTranslationResponses (p0: LongSparseArray < ViewTranslationResponse >) onVisibilityAggregated [androidJvm] open fun onVisibilityAggregated (p0: Boolean ) onVisibilityChanged [androidJvm] open fun onVisibilityChanged (p0: View , p1: Int ) onWindowFocusChanged [androidJvm] open fun onWindowFocusChanged (p0: Boolean ) onWindowVisibilityChanged [androidJvm] open fun onWindowVisibilityChanged (p0: Int ) overScrollBy [androidJvm] open fun overScrollBy (p0: Int , p1: Int , p2: Int , p3: Int , p4: Int , p5: Int , p6: Int , p7: Int , p8: Boolean ): Boolean performAccessibilityAction [androidJvm] open fun performAccessibilityAction (p0: Int , p1: Bundle ): Boolean performClick [androidJvm] open fun performClick (): Boolean performContextClick [androidJvm] open fun performContextClick (): Boolean open fun performContextClick (p0: Float , p1: Float ): Boolean performHapticFeedback [androidJvm] open fun performHapticFeedback (p0: Int ): Boolean open fun performHapticFeedback (p0: Int , p1: Int ): Boolean performLongClick [androidJvm] open fun performLongClick (): Boolean open fun performLongClick (p0: Float , p1: Float ): Boolean performReceiveContent [androidJvm] open fun performReceiveContent (p0: ContentInfo ): ContentInfo ? playSoundEffect [androidJvm] open fun playSoundEffect (p0: Int ) post [androidJvm] open fun post (p0: Runnable ): Boolean postDelayed [androidJvm] open fun postDelayed (p0: Runnable , p1: Long ): Boolean postInvalidate [androidJvm] open fun postInvalidate () open fun postInvalidate (p0: Int , p1: Int , p2: Int , p3: Int ) postInvalidateDelayed [androidJvm] open fun postInvalidateDelayed (p0: Long ) open fun postInvalidateDelayed (p0: Long , p1: Int , p2: Int , p3: Int , p4: Int ) postInvalidateOnAnimation [androidJvm] open fun postInvalidateOnAnimation () open fun postInvalidateOnAnimation (p0: Int , p1: Int , p2: Int , p3: Int ) postOnAnimation [androidJvm] open fun postOnAnimation (p0: Runnable ) postOnAnimationDelayed [androidJvm] open fun postOnAnimationDelayed (p0: Runnable , p1: Long ) recomputeViewAttributes [androidJvm] open override fun recomputeViewAttributes (p0: View ) refreshDrawableState [androidJvm] open fun refreshDrawableState () releasePointerCapture [androidJvm] open fun releasePointerCapture () removeAllViews [androidJvm] open fun removeAllViews () removeAllViewsInLayout [androidJvm] open fun removeAllViewsInLayout () removeCallbacks [androidJvm] open fun removeCallbacks (p0: Runnable ): Boolean removeDetachedView [androidJvm] open fun removeDetachedView (p0: View , p1: Boolean ) removeOnAttachStateChangeListener [androidJvm] open fun removeOnAttachStateChangeListener (p0: View.OnAttachStateChangeListener ) removeOnLayoutChangeListener [androidJvm] open fun removeOnLayoutChangeListener (p0: View.OnLayoutChangeListener ) removeOnUnhandledKeyEventListener [androidJvm] open fun removeOnUnhandledKeyEventListener (p0: View.OnUnhandledKeyEventListener ) removeView [androidJvm] open override fun removeView (p0: View ) removeViewAt [androidJvm] open fun removeViewAt (p0: Int ) removeViewInLayout [androidJvm] open fun removeViewInLayout (p0: View ) removeViews [androidJvm] open fun removeViews (p0: Int , p1: Int ) removeViewsInLayout [androidJvm] open fun removeViewsInLayout (p0: Int , p1: Int ) requestApplyInsets [androidJvm] open fun requestApplyInsets () requestChildFocus [androidJvm] open override fun requestChildFocus (p0: View , p1: View ) requestChildRectangleOnScreen [androidJvm] open override fun requestChildRectangleOnScreen (p0: View , p1: Rect , p2: Boolean ): Boolean requestDisallowInterceptTouchEvent [androidJvm] open override fun requestDisallowInterceptTouchEvent (p0: Boolean ) requestFocus [androidJvm] fun requestFocus (): Boolean fun requestFocus (p0: Int ): Boolean open override fun requestFocus (p0: Int , p1: Rect ): Boolean requestFocusFromTouch [androidJvm] fun requestFocusFromTouch (): Boolean requestLayout [androidJvm] open fun requestLayout () requestPointerCapture [androidJvm] open fun requestPointerCapture () requestRectangleOnScreen [androidJvm] open fun requestRectangleOnScreen (p0: Rect ): Boolean open fun requestRectangleOnScreen (p0: Rect , p1: Boolean ): Boolean requestSendAccessibilityEvent [androidJvm] open override fun requestSendAccessibilityEvent (p0: View , p1: AccessibilityEvent ): Boolean requestTransparentRegion [androidJvm] open override fun requestTransparentRegion (p0: View ) requestUnbufferedDispatch [androidJvm] fun requestUnbufferedDispatch (p0: MotionEvent ) fun requestUnbufferedDispatch (p0: Int ) requireViewById [androidJvm] fun < T : View > requireViewById (p0: Int ): T resetPivot [androidJvm] open fun resetPivot () restoreDefaultFocus [androidJvm] open override fun restoreDefaultFocus (): Boolean restoreHierarchyState [androidJvm] open fun restoreHierarchyState (p0: SparseArray < Parcelable >) saveAttributeDataForStyleable [androidJvm] fun saveAttributeDataForStyleable (p0: Context , p1: IntArray , p2: AttributeSet ?, p3: TypedArray , p4: Int , p5: Int ) saveHierarchyState [androidJvm] open fun saveHierarchyState (p0: SparseArray < Parcelable >) scheduleDrawable [androidJvm] open override fun scheduleDrawable (p0: Drawable , p1: Runnable , p2: Long ) scheduleLayoutAnimation [androidJvm] open fun scheduleLayoutAnimation () scrollBy [androidJvm] open fun scrollBy (p0: Int , p1: Int ) scrollTo [androidJvm] open fun scrollTo (p0: Int , p1: Int ) sendAccessibilityEvent [androidJvm] open override fun sendAccessibilityEvent (p0: Int ) sendAccessibilityEventUnchecked [androidJvm] open override fun sendAccessibilityEventUnchecked (p0: AccessibilityEvent ) setAccessibilityDelegate [androidJvm] open fun setAccessibilityDelegate (p0: View.AccessibilityDelegate ?) setAccessibilityHeading [androidJvm] open fun setAccessibilityHeading (p0: Boolean ) setAccessibilityLiveRegion [androidJvm] open fun setAccessibilityLiveRegion (p0: Int ) setAccessibilityPaneTitle [androidJvm] open fun setAccessibilityPaneTitle (p0: CharSequence ?) setAccessibilityTraversalAfter [androidJvm] open fun setAccessibilityTraversalAfter (p0: Int ) setAccessibilityTraversalBefore [androidJvm] open fun setAccessibilityTraversalBefore (p0: Int ) setActivated [androidJvm] open fun setActivated (p0: Boolean ) setAddStatesFromChildren [androidJvm] open fun setAddStatesFromChildren (p0: Boolean ) setAllowClickWhenDisabled [androidJvm] open fun setAllowClickWhenDisabled (p0: Boolean ) setAlpha [androidJvm] open fun setAlpha (p0: Float ) setAnimation [androidJvm] open fun setAnimation (p0: Animation ) setAnimationMatrix [androidJvm] open fun setAnimationMatrix (p0: Matrix ?) setAutofillHints [androidJvm] open fun setAutofillHints (vararg p0: String ) setAutofillId [androidJvm] open fun setAutofillId (p0: AutofillId ?) setBackground [androidJvm] open fun setBackground (p0: Drawable ) setBackgroundColor [androidJvm] open fun setBackgroundColor (p0: Int ) setBackgroundResource [androidJvm] open fun setBackgroundResource (p0: Int ) setBackgroundTintBlendMode [androidJvm] open fun setBackgroundTintBlendMode (p0: BlendMode ?) setBackgroundTintList [androidJvm] open fun setBackgroundTintList (p0: ColorStateList ?) setBackgroundTintMode [androidJvm] open fun setBackgroundTintMode (p0: PorterDuff.Mode ?) setBottom [androidJvm] fun setBottom (p0: Int ) setCameraDistance [androidJvm] open fun setCameraDistance (p0: Float ) setChildrenDrawingOrderEnabled [androidJvm] open fun setChildrenDrawingOrderEnabled (p0: Boolean ) setClickable [androidJvm] open fun setClickable (p0: Boolean ) setClipBounds [androidJvm] open fun setClipBounds (p0: Rect ) setClipChildren [androidJvm] open fun setClipChildren (p0: Boolean ) setClipToOutline [androidJvm] open fun setClipToOutline (p0: Boolean ) setClipToPadding [androidJvm] open fun setClipToPadding (p0: Boolean ) setContentCaptureSession [androidJvm] open fun setContentCaptureSession (p0: ContentCaptureSession ?) setContentDescription [androidJvm] open fun setContentDescription (p0: CharSequence ) setContextClickable [androidJvm] open fun setContextClickable (p0: Boolean ) setDefaultFocusHighlightEnabled [androidJvm] open fun setDefaultFocusHighlightEnabled (p0: Boolean ) setDescendantFocusability [androidJvm] open fun setDescendantFocusability (p0: Int ) setDuplicateParentStateEnabled [androidJvm] open fun setDuplicateParentStateEnabled (p0: Boolean ) setElevation [androidJvm] open fun setElevation (p0: Float ) setEnabled [androidJvm] open fun setEnabled (p0: Boolean ) setFadingEdgeLength [androidJvm] open fun setFadingEdgeLength (p0: Int ) setFilterTouchesWhenObscured [androidJvm] open fun setFilterTouchesWhenObscured (p0: Boolean ) setFitsSystemWindows [androidJvm] open fun setFitsSystemWindows (p0: Boolean ) setFocusable [androidJvm] open fun setFocusable (p0: Boolean ) open fun setFocusable (p0: Int ) setFocusableInTouchMode [androidJvm] open fun setFocusableInTouchMode (p0: Boolean ) setFocusedByDefault [androidJvm] open fun setFocusedByDefault (p0: Boolean ) setForceDarkAllowed [androidJvm] open fun setForceDarkAllowed (p0: Boolean ) setForeground [androidJvm] open fun setForeground (p0: Drawable ) setForegroundGravity [androidJvm] open override fun setForegroundGravity (p0: Int ) setForegroundTintBlendMode [androidJvm] open fun setForegroundTintBlendMode (p0: BlendMode ?) setForegroundTintList [androidJvm] open fun setForegroundTintList (p0: ColorStateList ?) setForegroundTintMode [androidJvm] open fun setForegroundTintMode (p0: PorterDuff.Mode ?) setHapticFeedbackEnabled [androidJvm] open fun setHapticFeedbackEnabled (p0: Boolean ) setHasTransientState [androidJvm] open fun setHasTransientState (p0: Boolean ) setHorizontalFadingEdgeEnabled [androidJvm] open fun setHorizontalFadingEdgeEnabled (p0: Boolean ) setHorizontalScrollBarEnabled [androidJvm] open fun setHorizontalScrollBarEnabled (p0: Boolean ) setHorizontalScrollbarThumbDrawable [androidJvm] open fun setHorizontalScrollbarThumbDrawable (p0: Drawable ?) setHorizontalScrollbarTrackDrawable [androidJvm] open fun setHorizontalScrollbarTrackDrawable (p0: Drawable ?) setHovered [androidJvm] open fun setHovered (p0: Boolean ) setId [androidJvm] open fun setId (p0: Int ) setImportantForAccessibility [androidJvm] open fun setImportantForAccessibility (p0: Int ) setImportantForAutofill [androidJvm] open fun setImportantForAutofill (p0: Int ) setImportantForContentCapture [androidJvm] open fun setImportantForContentCapture (p0: Int ) setKeepScreenOn [androidJvm] open fun setKeepScreenOn (p0: Boolean ) setKeyboardNavigationCluster [androidJvm] open fun setKeyboardNavigationCluster (p0: Boolean ) setLabelFor [androidJvm] open fun setLabelFor (p0: Int ) setLayerPaint [androidJvm] open fun setLayerPaint (p0: Paint ?) setLayerType [androidJvm] open fun setLayerType (p0: Int , p1: Paint ?) setLayoutAnimation [androidJvm] open fun setLayoutAnimation (p0: LayoutAnimationController ) setLayoutAnimationListener [androidJvm] open fun setLayoutAnimationListener (p0: Animation.AnimationListener ) setLayoutDirection [androidJvm] open fun setLayoutDirection (p0: Int ) setLayoutMode [androidJvm] open fun setLayoutMode (p0: Int ) setLayoutParams [androidJvm] open fun setLayoutParams (p0: ViewGroup.LayoutParams ) setLayoutTransition [androidJvm] open fun setLayoutTransition (p0: LayoutTransition ) setLeft [androidJvm] fun setLeft (p0: Int ) setLeftTopRightBottom [androidJvm] fun setLeftTopRightBottom (p0: Int , p1: Int , p2: Int , p3: Int ) setLongClickable [androidJvm] open fun setLongClickable (p0: Boolean ) setMeasureAllChildren [androidJvm] open fun setMeasureAllChildren (p0: Boolean ) setMeasuredDimension [androidJvm] fun setMeasuredDimension (p0: Int , p1: Int ) setMinimumHeight [androidJvm] open fun setMinimumHeight (p0: Int ) setMinimumWidth [androidJvm] open fun setMinimumWidth (p0: Int ) setMotionEventSplittingEnabled [androidJvm] open fun setMotionEventSplittingEnabled (p0: Boolean ) setNestedScrollingEnabled [androidJvm] open fun setNestedScrollingEnabled (p0: Boolean ) setNextClusterForwardId [androidJvm] open fun setNextClusterForwardId (p0: Int ) setNextFocusDownId [androidJvm] open fun setNextFocusDownId (p0: Int ) setNextFocusForwardId [androidJvm] open fun setNextFocusForwardId (p0: Int ) setNextFocusLeftId [androidJvm] open fun setNextFocusLeftId (p0: Int ) setNextFocusRightId [androidJvm] open fun setNextFocusRightId (p0: Int ) setNextFocusUpId [androidJvm] open fun setNextFocusUpId (p0: Int ) setOnApplyWindowInsetsListener [androidJvm] open fun setOnApplyWindowInsetsListener (p0: View.OnApplyWindowInsetsListener ) setOnCapturedPointerListener [androidJvm] open fun setOnCapturedPointerListener (p0: View.OnCapturedPointerListener ) setOnClickListener [androidJvm] open fun setOnClickListener (p0: View.OnClickListener ?) setOnContextClickListener [androidJvm] open fun setOnContextClickListener (p0: View.OnContextClickListener ?) setOnCreateContextMenuListener [androidJvm] open fun setOnCreateContextMenuListener (p0: View.OnCreateContextMenuListener ) setOnDragListener [androidJvm] open fun setOnDragListener (p0: View.OnDragListener ) setOnFocusChangeListener [androidJvm] open fun setOnFocusChangeListener (p0: View.OnFocusChangeListener ) setOnGenericMotionListener [androidJvm] open fun setOnGenericMotionListener (p0: View.OnGenericMotionListener ) setOnHierarchyChangeListener [androidJvm] open fun setOnHierarchyChangeListener (p0: ViewGroup.OnHierarchyChangeListener ) setOnHoverListener [androidJvm] open fun setOnHoverListener (p0: View.OnHoverListener ) setOnKeyListener [androidJvm] open fun setOnKeyListener (p0: View.OnKeyListener ) setOnLongClickListener [androidJvm] open fun setOnLongClickListener (p0: View.OnLongClickListener ?) setOnReceiveContentListener [androidJvm] open fun setOnReceiveContentListener (p0: Array < String >?, p1: OnReceiveContentListener ?) setOnScrollChangeListener [androidJvm] open fun setOnScrollChangeListener (p0: View.OnScrollChangeListener ) setOnTouchListener [androidJvm] open fun setOnTouchListener (p0: View.OnTouchListener ) setOutlineAmbientShadowColor [androidJvm] open fun setOutlineAmbientShadowColor (p0: Int ) setOutlineProvider [androidJvm] open fun setOutlineProvider (p0: ViewOutlineProvider ) setOutlineSpotShadowColor [androidJvm] open fun setOutlineSpotShadowColor (p0: Int ) setOverScrollMode [androidJvm] open fun setOverScrollMode (p0: Int ) setPadding [androidJvm] open fun setPadding (p0: Int , p1: Int , p2: Int , p3: Int ) setPaddingRelative [androidJvm] open fun setPaddingRelative (p0: Int , p1: Int , p2: Int , p3: Int ) setPivotX [androidJvm] open fun setPivotX (p0: Float ) setPivotY [androidJvm] open fun setPivotY (p0: Float ) setPointerIcon [androidJvm] open fun setPointerIcon (p0: PointerIcon ) setPressed [androidJvm] open fun setPressed (p0: Boolean ) setRenderEffect [androidJvm] open fun setRenderEffect (p0: RenderEffect ?) setRevealOnFocusHint [androidJvm] fun setRevealOnFocusHint (p0: Boolean ) setRight [androidJvm] fun setRight (p0: Int ) setRotation [androidJvm] open fun setRotation (p0: Float ) setRotationX [androidJvm] open fun setRotationX (p0: Float ) setRotationY [androidJvm] open fun setRotationY (p0: Float ) setSaveEnabled [androidJvm] open fun setSaveEnabled (p0: Boolean ) setSaveFromParentEnabled [androidJvm] open fun setSaveFromParentEnabled (p0: Boolean ) setScaleX [androidJvm] open fun setScaleX (p0: Float ) setScaleY [androidJvm] open fun setScaleY (p0: Float ) setScreenReaderFocusable [androidJvm] open fun setScreenReaderFocusable (p0: Boolean ) setScrollBarDefaultDelayBeforeFade [androidJvm] open fun setScrollBarDefaultDelayBeforeFade (p0: Int ) setScrollBarFadeDuration [androidJvm] open fun setScrollBarFadeDuration (p0: Int ) setScrollbarFadingEnabled [androidJvm] open fun setScrollbarFadingEnabled (p0: Boolean ) setScrollBarSize [androidJvm] open fun setScrollBarSize (p0: Int ) setScrollBarStyle [androidJvm] open fun setScrollBarStyle (p0: Int ) setScrollCaptureCallback [androidJvm] fun setScrollCaptureCallback (p0: ScrollCaptureCallback ?) setScrollCaptureHint [androidJvm] open fun setScrollCaptureHint (p0: Int ) setScrollContainer [androidJvm] open fun setScrollContainer (p0: Boolean ) setScrollIndicators [androidJvm] open fun setScrollIndicators (p0: Int ) open fun setScrollIndicators (p0: Int , p1: Int ) setScrollX [androidJvm] open fun setScrollX (p0: Int ) setScrollY [androidJvm] open fun setScrollY (p0: Int ) setSelected [androidJvm] open fun setSelected (p0: Boolean ) setSoundEffectsEnabled [androidJvm] open fun setSoundEffectsEnabled (p0: Boolean ) setStateDescription [androidJvm] open fun setStateDescription (p0: CharSequence ?) setStateListAnimator [androidJvm] open fun setStateListAnimator (p0: StateListAnimator ) setStaticTransformationsEnabled [androidJvm] open fun setStaticTransformationsEnabled (p0: Boolean ) setSystemGestureExclusionRects [androidJvm] open fun setSystemGestureExclusionRects (p0: MutableList < Rect >) setTag [androidJvm] open fun setTag (p0: Any ) open fun setTag (p0: Int , p1: Any ) setTextAlignment [androidJvm] open fun setTextAlignment (p0: Int ) setTextDirection [androidJvm] open fun setTextDirection (p0: Int ) setTooltipText [androidJvm] open fun setTooltipText (p0: CharSequence ?) setTop [androidJvm] fun setTop (p0: Int ) setTouchDelegate [androidJvm] open fun setTouchDelegate (p0: TouchDelegate ) setTouchscreenBlocksFocus [androidJvm] open fun setTouchscreenBlocksFocus (p0: Boolean ) setTransitionAlpha [androidJvm] open fun setTransitionAlpha (p0: Float ) setTransitionGroup [androidJvm] open fun setTransitionGroup (p0: Boolean ) setTransitionName [androidJvm] fun setTransitionName (p0: String ) setTransitionVisibility [androidJvm] open fun setTransitionVisibility (p0: Int ) setTranslationX [androidJvm] open fun setTranslationX (p0: Float ) setTranslationY [androidJvm] open fun setTranslationY (p0: Float ) setTranslationZ [androidJvm] open fun setTranslationZ (p0: Float ) setVerticalFadingEdgeEnabled [androidJvm] open fun setVerticalFadingEdgeEnabled (p0: Boolean ) setVerticalScrollBarEnabled [androidJvm] open fun setVerticalScrollBarEnabled (p0: Boolean ) setVerticalScrollbarPosition [androidJvm] open fun setVerticalScrollbarPosition (p0: Int ) setVerticalScrollbarThumbDrawable [androidJvm] open fun setVerticalScrollbarThumbDrawable (p0: Drawable ?) setVerticalScrollbarTrackDrawable [androidJvm] open fun setVerticalScrollbarTrackDrawable (p0: Drawable ?) setViewTranslationCallback [androidJvm] open fun setViewTranslationCallback (p0: ViewTranslationCallback ) setVisibility [androidJvm] open fun setVisibility (p0: Int ) setWillNotDraw [androidJvm] open fun setWillNotDraw (p0: Boolean ) setWindowInsetsAnimationCallback [androidJvm] open override fun setWindowInsetsAnimationCallback (p0: WindowInsetsAnimation.Callback ?) setX [androidJvm] open fun setX (p0: Float ) setY [androidJvm] open fun setY (p0: Float ) setZ [androidJvm] open fun setZ (p0: Float ) shouldDelayChildPressedState [androidJvm] open override fun shouldDelayChildPressedState (): Boolean showContextMenu [androidJvm] open fun showContextMenu (): Boolean open fun showContextMenu (p0: Float , p1: Float ): Boolean showContextMenuForChild [androidJvm] open override fun showContextMenuForChild (p0: View ): Boolean open override fun showContextMenuForChild (p0: View , p1: Float , p2: Float ): Boolean startActionMode [androidJvm] open fun startActionMode (p0: ActionMode.Callback ): ActionMode open fun startActionMode (p0: ActionMode.Callback , p1: Int ): ActionMode startActionModeForChild [androidJvm] open override fun startActionModeForChild (p0: View , p1: ActionMode.Callback ): ActionMode open override fun startActionModeForChild (p0: View , p1: ActionMode.Callback , p2: Int ): ActionMode startAnimation [androidJvm] open fun startAnimation (p0: Animation ) startDragAndDrop [androidJvm] fun startDragAndDrop (p0: ClipData , p1: View.DragShadowBuilder , p2: Any , p3: Int ): Boolean startLayoutAnimation [androidJvm] open fun startLayoutAnimation () startNestedScroll [androidJvm] open fun startNestedScroll (p0: Int ): Boolean startViewTransition [androidJvm] open fun startViewTransition (p0: View ) stopNestedScroll [androidJvm] open fun stopNestedScroll () suppressLayout [androidJvm] open fun suppressLayout (p0: Boolean ) toString [androidJvm] open override fun toString (): String transformMatrixToGlobal [androidJvm] open fun transformMatrixToGlobal (p0: Matrix ) transformMatrixToLocal [androidJvm] open fun transformMatrixToLocal (p0: Matrix ) unscheduleDrawable [androidJvm] open fun unscheduleDrawable (p0: Drawable ) open override fun unscheduleDrawable (p0: Drawable , p1: Runnable ) updateDragShadow [androidJvm] fun updateDragShadow (p0: View.DragShadowBuilder ) updateViewLayout [androidJvm] open override fun updateViewLayout (p0: View , p1: ViewGroup.LayoutParams ) verifyDrawable [androidJvm] open fun verifyDrawable (p0: Drawable ): Boolean willNotDraw [androidJvm] open fun willNotDraw (): Boolean","title":"Functions"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-modal-container/#inheritors","text":"Name AlertContainer ModalViewContainer","title":"Inheritors"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-modal-container/-modal-container/","text":"// workflow / com.squareup.workflow1.ui.modal / ModalContainer / ModalContainer ModalContainer \u00b6 [androidJvm]\\ @ JvmOverloads fun ModalContainer (context: Context , attributeSet: AttributeSet ? = null, defStyle: Int = 0, defStyleRes: Int = 0) Parameters \u00b6 androidJvm ModalRenderingT the type of the nested renderings to be shown in a dialog window.","title":" modal container"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-modal-container/-modal-container/#modalcontainer","text":"[androidJvm]\\ @ JvmOverloads fun ModalContainer (context: Context , attributeSet: AttributeSet ? = null, defStyle: Int = 0, defStyleRes: Int = 0)","title":"ModalContainer"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-modal-container/-modal-container/#parameters","text":"androidJvm ModalRenderingT the type of the nested renderings to be shown in a dialog window.","title":"Parameters"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-modal-view-container/","text":"// workflow / com.squareup.workflow1.ui.modal / ModalViewContainer ModalViewContainer \u00b6 [androidJvm]\\ @WorkflowUiExperimentalApi open class ModalViewContainer @ JvmOverloads constructor(context: Context , attributeSet: AttributeSet ?, defStyle: Int , defStyleRes: Int ) : ModalContainer < Any > Container that shows HasModals.modals as arbitrary views in a Dialog window. Provides compatibility with View.backPressedHandler . Use binding to assign particular rendering types to be shown this way. Constructors \u00b6 ModalViewContainer [androidJvm] @ JvmOverloads fun ModalViewContainer (context: Context , attributeSet: AttributeSet ? = null, defStyle: Int = 0, defStyleRes: Int = 0) Types \u00b6 Name Summary Companion [androidJvm] object Companion Functions \u00b6 Name Summary addChildrenForAccessibility [androidJvm] open override fun addChildrenForAccessibility (p0: ArrayList < View >) addExtraDataToAccessibilityNodeInfo [androidJvm] open override fun addExtraDataToAccessibilityNodeInfo (p0: AccessibilityNodeInfo , p1: String , p2: Bundle ?) addFocusables [androidJvm] open fun addFocusables (p0: ArrayList < View >, p1: Int ) open override fun addFocusables (p0: ArrayList < View >, p1: Int , p2: Int ) addKeyboardNavigationClusters [androidJvm] open override fun addKeyboardNavigationClusters (p0: MutableCollection < View >, p1: Int ) addOnAttachStateChangeListener [androidJvm] open fun addOnAttachStateChangeListener (p0: View.OnAttachStateChangeListener ) addOnLayoutChangeListener [androidJvm] open fun addOnLayoutChangeListener (p0: View.OnLayoutChangeListener ) addOnUnhandledKeyEventListener [androidJvm] open fun addOnUnhandledKeyEventListener (p0: View.OnUnhandledKeyEventListener ) addStatesFromChildren [androidJvm] open fun addStatesFromChildren (): Boolean addTouchables [androidJvm] open override fun addTouchables (p0: ArrayList < View >) addView [androidJvm] open fun addView (p0: View ) open override fun addView (p0: View , p1: ViewGroup.LayoutParams ) open fun addView (p0: View , p1: Int ) open fun addView (p0: View , p1: Int , p2: ViewGroup.LayoutParams ) open fun addView (p0: View , p1: Int , p2: Int ) addViewInLayout [androidJvm] open fun addViewInLayout (p0: View , p1: Int , p2: ViewGroup.LayoutParams ): Boolean open fun addViewInLayout (p0: View , p1: Int , p2: ViewGroup.LayoutParams , p3: Boolean ): Boolean animate [androidJvm] open fun animate (): ViewPropertyAnimator announceForAccessibility [androidJvm] open fun announceForAccessibility (p0: CharSequence ) attachLayoutAnimationParameters [androidJvm] open fun attachLayoutAnimationParameters (p0: View , p1: ViewGroup.LayoutParams , p2: Int , p3: Int ) attachViewToParent [androidJvm] open fun attachViewToParent (p0: View , p1: Int , p2: ViewGroup.LayoutParams ) autofill [androidJvm] open fun autofill (p0: SparseArray < AutofillValue >) open fun autofill (p0: AutofillValue ) awakenScrollBars [androidJvm] open fun awakenScrollBars (): Boolean open fun awakenScrollBars (p0: Int ): Boolean open fun awakenScrollBars (p0: Int , p1: Boolean ): Boolean bringChildToFront [androidJvm] open override fun bringChildToFront (p0: View ) bringToFront [androidJvm] open fun bringToFront () buildDialogForView [androidJvm] open fun buildDialogForView (view: View ): Dialog Called from buildDialog. Builds (but does not show) the Dialog to display a view built via ViewRegistry . buildLayer [androidJvm] open fun buildLayer () callOnClick [androidJvm] open fun callOnClick (): Boolean canAnimate [androidJvm] open fun canAnimate (): Boolean cancelDragAndDrop [androidJvm] fun cancelDragAndDrop () cancelLongPress [androidJvm] open fun cancelLongPress () cancelPendingInputEvents [androidJvm] fun cancelPendingInputEvents () canResolveLayoutDirection [androidJvm] open fun canResolveLayoutDirection (): Boolean canResolveTextAlignment [androidJvm] open fun canResolveTextAlignment (): Boolean canResolveTextDirection [androidJvm] open fun canResolveTextDirection (): Boolean canScrollHorizontally [androidJvm] open fun canScrollHorizontally (p0: Int ): Boolean canScrollVertically [androidJvm] open fun canScrollVertically (p0: Int ): Boolean checkInputConnectionProxy [androidJvm] open fun checkInputConnectionProxy (p0: View ): Boolean checkLayoutParams [androidJvm] open override fun checkLayoutParams (p0: ViewGroup.LayoutParams ): Boolean childDrawableStateChanged [androidJvm] open override fun childDrawableStateChanged (p0: View ) childHasTransientStateChanged [androidJvm] open override fun childHasTransientStateChanged (p0: View , p1: Boolean ) cleanupLayoutState [androidJvm] open fun cleanupLayoutState (p0: View ) clearAnimation [androidJvm] open fun clearAnimation () clearChildFocus [androidJvm] open override fun clearChildFocus (p0: View ) clearDisappearingChildren [androidJvm] open fun clearDisappearingChildren () clearFocus [androidJvm] open override fun clearFocus () clearViewTranslationCallback [androidJvm] open fun clearViewTranslationCallback () computeHorizontalScrollExtent [androidJvm] open fun computeHorizontalScrollExtent (): Int computeHorizontalScrollOffset [androidJvm] open fun computeHorizontalScrollOffset (): Int computeHorizontalScrollRange [androidJvm] open fun computeHorizontalScrollRange (): Int computeScroll [androidJvm] open fun computeScroll () computeSystemWindowInsets [androidJvm] open fun computeSystemWindowInsets (p0: WindowInsets , p1: Rect ): WindowInsets computeVerticalScrollExtent [androidJvm] open fun computeVerticalScrollExtent (): Int computeVerticalScrollOffset [androidJvm] open fun computeVerticalScrollOffset (): Int computeVerticalScrollRange [androidJvm] open fun computeVerticalScrollRange (): Int createAccessibilityNodeInfo [androidJvm] open fun createAccessibilityNodeInfo (): AccessibilityNodeInfo createContextMenu [androidJvm] open fun createContextMenu (p0: ContextMenu ) debug [androidJvm] open fun debug (p0: Int ) detachAllViewsFromParent [androidJvm] open fun detachAllViewsFromParent () detachViewFromParent [androidJvm] open fun detachViewFromParent (p0: View ) open fun detachViewFromParent (p0: Int ) detachViewsFromParent [androidJvm] open fun detachViewsFromParent (p0: Int , p1: Int ) dispatchApplyWindowInsets [androidJvm] open override fun dispatchApplyWindowInsets (p0: WindowInsets ): WindowInsets dispatchCapturedPointerEvent [androidJvm] open override fun dispatchCapturedPointerEvent (p0: MotionEvent ): Boolean dispatchConfigurationChanged [androidJvm] open override fun dispatchConfigurationChanged (p0: Configuration ) dispatchCreateViewTranslationRequest [androidJvm] open override fun dispatchCreateViewTranslationRequest (p0: MutableMap < AutofillId , LongArray >, p1: IntArray , p2: TranslationCapability , p3: MutableList < ViewTranslationRequest >) dispatchDisplayHint [androidJvm] open override fun dispatchDisplayHint (p0: Int ) dispatchDragEvent [androidJvm] open override fun dispatchDragEvent (p0: DragEvent ): Boolean dispatchDraw [androidJvm] open override fun dispatchDraw (p0: Canvas ) dispatchDrawableHotspotChanged [androidJvm] open override fun dispatchDrawableHotspotChanged (p0: Float , p1: Float ) dispatchFinishTemporaryDetach [androidJvm] open override fun dispatchFinishTemporaryDetach () dispatchFreezeSelfOnly [androidJvm] open fun dispatchFreezeSelfOnly (p0: SparseArray < Parcelable >) dispatchGenericFocusedEvent [androidJvm] open override fun dispatchGenericFocusedEvent (p0: MotionEvent ): Boolean dispatchGenericMotionEvent [androidJvm] open fun dispatchGenericMotionEvent (p0: MotionEvent ): Boolean dispatchGenericPointerEvent [androidJvm] open override fun dispatchGenericPointerEvent (p0: MotionEvent ): Boolean dispatchHoverEvent [androidJvm] open override fun dispatchHoverEvent (p0: MotionEvent ): Boolean dispatchKeyEvent [androidJvm] open override fun dispatchKeyEvent (p0: KeyEvent ): Boolean dispatchKeyEventPreIme [androidJvm] open override fun dispatchKeyEventPreIme (p0: KeyEvent ): Boolean dispatchKeyShortcutEvent [androidJvm] open override fun dispatchKeyShortcutEvent (p0: KeyEvent ): Boolean dispatchNestedFling [androidJvm] open fun dispatchNestedFling (p0: Float , p1: Float , p2: Boolean ): Boolean dispatchNestedPreFling [androidJvm] open fun dispatchNestedPreFling (p0: Float , p1: Float ): Boolean dispatchNestedPrePerformAccessibilityAction [androidJvm] open fun dispatchNestedPrePerformAccessibilityAction (p0: Int , p1: Bundle ): Boolean dispatchNestedPreScroll [androidJvm] open fun dispatchNestedPreScroll (p0: Int , p1: Int , p2: IntArray ?, p3: IntArray ?): Boolean dispatchNestedScroll [androidJvm] open fun dispatchNestedScroll (p0: Int , p1: Int , p2: Int , p3: Int , p4: IntArray ?): Boolean dispatchPointerCaptureChanged [androidJvm] open override fun dispatchPointerCaptureChanged (p0: Boolean ) dispatchPopulateAccessibilityEvent [androidJvm] open fun dispatchPopulateAccessibilityEvent (p0: AccessibilityEvent ): Boolean dispatchProvideAutofillStructure [androidJvm] open override fun dispatchProvideAutofillStructure (p0: ViewStructure , p1: Int ) dispatchProvideStructure [androidJvm] open override fun dispatchProvideStructure (p0: ViewStructure ) dispatchRestoreInstanceState [androidJvm] open override fun dispatchRestoreInstanceState (p0: SparseArray < Parcelable >) dispatchSaveInstanceState [androidJvm] open override fun dispatchSaveInstanceState (p0: SparseArray < Parcelable >) dispatchScrollCaptureSearch [androidJvm] open override fun dispatchScrollCaptureSearch (p0: Rect , p1: Point , p2: Consumer < ScrollCaptureTarget >) dispatchSetActivated [androidJvm] open override fun dispatchSetActivated (p0: Boolean ) dispatchSetPressed [androidJvm] open override fun dispatchSetPressed (p0: Boolean ) dispatchSetSelected [androidJvm] open override fun dispatchSetSelected (p0: Boolean ) dispatchStartTemporaryDetach [androidJvm] open override fun dispatchStartTemporaryDetach () dispatchThawSelfOnly [androidJvm] open fun dispatchThawSelfOnly (p0: SparseArray < Parcelable >) dispatchTouchEvent [androidJvm] open override fun dispatchTouchEvent (p0: MotionEvent ): Boolean dispatchTrackballEvent [androidJvm] open override fun dispatchTrackballEvent (p0: MotionEvent ): Boolean dispatchUnhandledMove [androidJvm] open override fun dispatchUnhandledMove (p0: View , p1: Int ): Boolean dispatchVisibilityChanged [androidJvm] open override fun dispatchVisibilityChanged (p0: View , p1: Int ) dispatchWindowFocusChanged [androidJvm] open override fun dispatchWindowFocusChanged (p0: Boolean ) dispatchWindowInsetsAnimationEnd [androidJvm] open override fun dispatchWindowInsetsAnimationEnd (p0: WindowInsetsAnimation ) dispatchWindowInsetsAnimationPrepare [androidJvm] open override fun dispatchWindowInsetsAnimationPrepare (p0: WindowInsetsAnimation ) dispatchWindowInsetsAnimationProgress [androidJvm] open override fun dispatchWindowInsetsAnimationProgress (p0: WindowInsets , p1: MutableList < WindowInsetsAnimation >): WindowInsets dispatchWindowInsetsAnimationStart [androidJvm] open override fun dispatchWindowInsetsAnimationStart (p0: WindowInsetsAnimation , p1: WindowInsetsAnimation.Bounds ): WindowInsetsAnimation.Bounds dispatchWindowVisibilityChanged [androidJvm] open override fun dispatchWindowVisibilityChanged (p0: Int ) draw [androidJvm] open fun draw (p0: Canvas ) drawableHotspotChanged [androidJvm] open fun drawableHotspotChanged (p0: Float , p1: Float ) drawableStateChanged [androidJvm] open override fun drawableStateChanged () drawChild [androidJvm] open fun drawChild (p0: Canvas , p1: View , p2: Long ): Boolean endViewTransition [androidJvm] open fun endViewTransition (p0: View ) findFocus [androidJvm] open override fun findFocus (): View findViewById [androidJvm] fun < T : View > findViewById (p0: Int ): T findViewsWithText [androidJvm] open override fun findViewsWithText (p0: ArrayList < View >, p1: CharSequence , p2: Int ) findViewWithTag [androidJvm] fun < T : View > findViewWithTag (p0: Any ): T focusableViewAvailable [androidJvm] open override fun focusableViewAvailable (p0: View ) focusSearch [androidJvm] open fun focusSearch (p0: Int ): View open override fun focusSearch (p0: View , p1: Int ): View forceHasOverlappingRendering [androidJvm] open fun forceHasOverlappingRendering (p0: Boolean ) forceLayout [androidJvm] open fun forceLayout () gatherTransparentRegion [androidJvm] open override fun gatherTransparentRegion (p0: Region ?): Boolean generateDefaultLayoutParams [androidJvm] open override fun generateDefaultLayoutParams (): FrameLayout.LayoutParams generateDisplayHash [androidJvm] open fun generateDisplayHash (p0: String , p1: Rect ?, p2: Executor , p3: DisplayHashResultCallback ) generateLayoutParams [androidJvm] open override fun generateLayoutParams (p0: AttributeSet ): FrameLayout.LayoutParams open override fun generateLayoutParams (p0: ViewGroup.LayoutParams ): ViewGroup.LayoutParams getAccessibilityClassName [androidJvm] open override fun getAccessibilityClassName (): CharSequence getAccessibilityDelegate [androidJvm] open fun getAccessibilityDelegate (): View.AccessibilityDelegate getAccessibilityLiveRegion [androidJvm] open fun getAccessibilityLiveRegion (): Int getAccessibilityNodeProvider [androidJvm] open fun getAccessibilityNodeProvider (): AccessibilityNodeProvider getAccessibilityPaneTitle [androidJvm] open fun getAccessibilityPaneTitle (): CharSequence ? getAccessibilityTraversalAfter [androidJvm] open fun getAccessibilityTraversalAfter (): Int getAccessibilityTraversalBefore [androidJvm] open fun getAccessibilityTraversalBefore (): Int getAlpha [androidJvm] open fun getAlpha (): Float getAnimation [androidJvm] open fun getAnimation (): Animation getAnimationMatrix [androidJvm] open fun getAnimationMatrix (): Matrix ? getApplicationWindowToken [androidJvm] open fun getApplicationWindowToken (): IBinder getAttributeResolutionStack [androidJvm] open fun getAttributeResolutionStack (p0: Int ): IntArray getAttributeSourceResourceMap [androidJvm] open fun getAttributeSourceResourceMap (): MutableMap < Int , Int > getAutofillHints [androidJvm] open fun getAutofillHints (): Array < String >? getAutofillId [androidJvm] fun getAutofillId (): AutofillId getAutofillType [androidJvm] open fun getAutofillType (): Int getAutofillValue [androidJvm] open fun getAutofillValue (): AutofillValue ? getBackground [androidJvm] open fun getBackground (): Drawable getBackgroundTintBlendMode [androidJvm] open fun getBackgroundTintBlendMode (): BlendMode ? getBackgroundTintList [androidJvm] open fun getBackgroundTintList (): ColorStateList ? getBackgroundTintMode [androidJvm] open fun getBackgroundTintMode (): PorterDuff.Mode ? getBaseline [androidJvm] open fun getBaseline (): Int getBottom [androidJvm] fun getBottom (): Int getBottomFadingEdgeStrength [androidJvm] open fun getBottomFadingEdgeStrength (): Float getBottomPaddingOffset [androidJvm] open fun getBottomPaddingOffset (): Int getCameraDistance [androidJvm] open fun getCameraDistance (): Float getChildAt [androidJvm] open fun getChildAt (p0: Int ): View getChildCount [androidJvm] open fun getChildCount (): Int getChildDrawingOrder [androidJvm] fun getChildDrawingOrder (p0: Int ): Int open fun getChildDrawingOrder (p0: Int , p1: Int ): Int getChildStaticTransformation [androidJvm] open fun getChildStaticTransformation (p0: View , p1: Transformation ): Boolean getChildVisibleRect [androidJvm] open override fun getChildVisibleRect (p0: View , p1: Rect , p2: Point ): Boolean getClipBounds [androidJvm] open fun getClipBounds (): Rect open fun getClipBounds (p0: Rect ): Boolean getClipChildren [androidJvm] open fun getClipChildren (): Boolean getClipToOutline [androidJvm] fun getClipToOutline (): Boolean getClipToPadding [androidJvm] open fun getClipToPadding (): Boolean getContentCaptureSession [androidJvm] fun getContentCaptureSession (): ContentCaptureSession ? getContentDescription [androidJvm] open fun getContentDescription (): CharSequence getContext [androidJvm] fun getContext (): Context getContextMenuInfo [androidJvm] open fun getContextMenuInfo (): ContextMenu.ContextMenuInfo getDefaultFocusHighlightEnabled [androidJvm] fun getDefaultFocusHighlightEnabled (): Boolean getDescendantFocusability [androidJvm] open fun getDescendantFocusability (): Int getDisplay [androidJvm] open fun getDisplay (): Display getDrawableState [androidJvm] fun getDrawableState (): IntArray getDrawingRect [androidJvm] open fun getDrawingRect (p0: Rect ) getDrawingTime [androidJvm] open fun getDrawingTime (): Long getElevation [androidJvm] open fun getElevation (): Float getExplicitStyle [androidJvm] open fun getExplicitStyle (): Int getFilterTouchesWhenObscured [androidJvm] open fun getFilterTouchesWhenObscured (): Boolean getFitsSystemWindows [androidJvm] open fun getFitsSystemWindows (): Boolean getFocusable [androidJvm] open fun getFocusable (): Int getFocusables [androidJvm] open fun getFocusables (p0: Int ): ArrayList < View > getFocusedChild [androidJvm] open fun getFocusedChild (): View getFocusedRect [androidJvm] open fun getFocusedRect (p0: Rect ) getForeground [androidJvm] open fun getForeground (): Drawable getForegroundGravity [androidJvm] open fun getForegroundGravity (): Int getForegroundTintBlendMode [androidJvm] open fun getForegroundTintBlendMode (): BlendMode ? getForegroundTintList [androidJvm] open fun getForegroundTintList (): ColorStateList ? getForegroundTintMode [androidJvm] open fun getForegroundTintMode (): PorterDuff.Mode ? getGlobalVisibleRect [androidJvm] fun getGlobalVisibleRect (p0: Rect ): Boolean open fun getGlobalVisibleRect (p0: Rect , p1: Point ): Boolean getHandler [androidJvm] open fun getHandler (): Handler getHasOverlappingRendering [androidJvm] fun getHasOverlappingRendering (): Boolean getHeight [androidJvm] fun getHeight (): Int getHitRect [androidJvm] open fun getHitRect (p0: Rect ) getHorizontalFadingEdgeLength [androidJvm] open fun getHorizontalFadingEdgeLength (): Int getHorizontalScrollbarHeight [androidJvm] open fun getHorizontalScrollbarHeight (): Int getHorizontalScrollbarThumbDrawable [androidJvm] open fun getHorizontalScrollbarThumbDrawable (): Drawable ? getHorizontalScrollbarTrackDrawable [androidJvm] open fun getHorizontalScrollbarTrackDrawable (): Drawable ? getId [androidJvm] open fun getId (): Int getImportantForAccessibility [androidJvm] open fun getImportantForAccessibility (): Int getImportantForAutofill [androidJvm] open fun getImportantForAutofill (): Int getImportantForContentCapture [androidJvm] open fun getImportantForContentCapture (): Int getKeepScreenOn [androidJvm] open fun getKeepScreenOn (): Boolean getKeyDispatcherState [androidJvm] open fun getKeyDispatcherState (): KeyEvent.DispatcherState getLabelFor [androidJvm] open fun getLabelFor (): Int getLayerType [androidJvm] open fun getLayerType (): Int getLayoutAnimation [androidJvm] open fun getLayoutAnimation (): LayoutAnimationController getLayoutAnimationListener [androidJvm] open fun getLayoutAnimationListener (): Animation.AnimationListener getLayoutDirection [androidJvm] open fun getLayoutDirection (): Int getLayoutMode [androidJvm] open fun getLayoutMode (): Int getLayoutParams [androidJvm] open fun getLayoutParams (): ViewGroup.LayoutParams getLayoutTransition [androidJvm] open fun getLayoutTransition (): LayoutTransition getLeft [androidJvm] fun getLeft (): Int getLeftFadingEdgeStrength [androidJvm] open fun getLeftFadingEdgeStrength (): Float getLeftPaddingOffset [androidJvm] open fun getLeftPaddingOffset (): Int getLocalVisibleRect [androidJvm] fun getLocalVisibleRect (p0: Rect ): Boolean getLocationInSurface [androidJvm] open fun getLocationInSurface (p0: IntArray ) getLocationInWindow [androidJvm] open fun getLocationInWindow (p0: IntArray ) getLocationOnScreen [androidJvm] open fun getLocationOnScreen (p0: IntArray ) getMatrix [androidJvm] open fun getMatrix (): Matrix getMeasureAllChildren [androidJvm] open fun getMeasureAllChildren (): Boolean getMeasuredHeight [androidJvm] fun getMeasuredHeight (): Int getMeasuredHeightAndState [androidJvm] fun getMeasuredHeightAndState (): Int getMeasuredState [androidJvm] fun getMeasuredState (): Int getMeasuredWidth [androidJvm] fun getMeasuredWidth (): Int getMeasuredWidthAndState [androidJvm] fun getMeasuredWidthAndState (): Int getMinimumHeight [androidJvm] open fun getMinimumHeight (): Int getMinimumWidth [androidJvm] open fun getMinimumWidth (): Int getNestedScrollAxes [androidJvm] open fun getNestedScrollAxes (): Int getNextClusterForwardId [androidJvm] open fun getNextClusterForwardId (): Int getNextFocusDownId [androidJvm] open fun getNextFocusDownId (): Int getNextFocusForwardId [androidJvm] open fun getNextFocusForwardId (): Int getNextFocusLeftId [androidJvm] open fun getNextFocusLeftId (): Int getNextFocusRightId [androidJvm] open fun getNextFocusRightId (): Int getNextFocusUpId [androidJvm] open fun getNextFocusUpId (): Int getOnFocusChangeListener [androidJvm] open fun getOnFocusChangeListener (): View.OnFocusChangeListener getOutlineAmbientShadowColor [androidJvm] open fun getOutlineAmbientShadowColor (): Int getOutlineProvider [androidJvm] open fun getOutlineProvider (): ViewOutlineProvider getOutlineSpotShadowColor [androidJvm] open fun getOutlineSpotShadowColor (): Int getOverlay [androidJvm] open override fun getOverlay (): ViewGroupOverlay getOverScrollMode [androidJvm] open fun getOverScrollMode (): Int getPaddingBottom [androidJvm] open fun getPaddingBottom (): Int getPaddingEnd [androidJvm] open fun getPaddingEnd (): Int getPaddingLeft [androidJvm] open fun getPaddingLeft (): Int getPaddingRight [androidJvm] open fun getPaddingRight (): Int getPaddingStart [androidJvm] open fun getPaddingStart (): Int getPaddingTop [androidJvm] open fun getPaddingTop (): Int getParent [androidJvm] fun getParent (): ViewParent getParentForAccessibility [androidJvm] open fun getParentForAccessibility (): ViewParent getPivotX [androidJvm] open fun getPivotX (): Float getPivotY [androidJvm] open fun getPivotY (): Float getPointerIcon [androidJvm] open fun getPointerIcon (): PointerIcon getReceiveContentMimeTypes [androidJvm] open fun getReceiveContentMimeTypes (): Array < String >? getResources [androidJvm] open fun getResources (): Resources getRevealOnFocusHint [androidJvm] fun getRevealOnFocusHint (): Boolean getRight [androidJvm] fun getRight (): Int getRightFadingEdgeStrength [androidJvm] open fun getRightFadingEdgeStrength (): Float getRightPaddingOffset [androidJvm] open fun getRightPaddingOffset (): Int getRootSurfaceControl [androidJvm] open fun getRootSurfaceControl (): AttachedSurfaceControl ? getRootView [androidJvm] open fun getRootView (): View getRootWindowInsets [androidJvm] open fun getRootWindowInsets (): WindowInsets getRotation [androidJvm] open fun getRotation (): Float getRotationX [androidJvm] open fun getRotationX (): Float getRotationY [androidJvm] open fun getRotationY (): Float getScaleX [androidJvm] open fun getScaleX (): Float getScaleY [androidJvm] open fun getScaleY (): Float getScrollBarDefaultDelayBeforeFade [androidJvm] open fun getScrollBarDefaultDelayBeforeFade (): Int getScrollBarFadeDuration [androidJvm] open fun getScrollBarFadeDuration (): Int getScrollBarSize [androidJvm] open fun getScrollBarSize (): Int getScrollBarStyle [androidJvm] open fun getScrollBarStyle (): Int getScrollCaptureHint [androidJvm] open fun getScrollCaptureHint (): Int getScrollIndicators [androidJvm] open fun getScrollIndicators (): Int getScrollX [androidJvm] fun getScrollX (): Int getScrollY [androidJvm] fun getScrollY (): Int getSolidColor [androidJvm] open fun getSolidColor (): Int getSourceLayoutResId [androidJvm] open fun getSourceLayoutResId (): Int getStateDescription [androidJvm] fun getStateDescription (): CharSequence ? getStateListAnimator [androidJvm] open fun getStateListAnimator (): StateListAnimator getSuggestedMinimumHeight [androidJvm] open fun getSuggestedMinimumHeight (): Int getSuggestedMinimumWidth [androidJvm] open fun getSuggestedMinimumWidth (): Int getSystemGestureExclusionRects [androidJvm] open fun getSystemGestureExclusionRects (): MutableList < Rect > getTag [androidJvm] open fun getTag (): Any open fun getTag (p0: Int ): Any getTextAlignment [androidJvm] open fun getTextAlignment (): Int getTextDirection [androidJvm] open fun getTextDirection (): Int getTooltipText [androidJvm] open fun getTooltipText (): CharSequence ? getTop [androidJvm] fun getTop (): Int getTopFadingEdgeStrength [androidJvm] open fun getTopFadingEdgeStrength (): Float getTopPaddingOffset [androidJvm] open fun getTopPaddingOffset (): Int getTouchables [androidJvm] open fun getTouchables (): ArrayList < View > getTouchDelegate [androidJvm] open fun getTouchDelegate (): TouchDelegate getTouchscreenBlocksFocus [androidJvm] open fun getTouchscreenBlocksFocus (): Boolean getTransitionAlpha [androidJvm] open fun getTransitionAlpha (): Float getTransitionName [androidJvm] open fun getTransitionName (): String getTranslationX [androidJvm] open fun getTranslationX (): Float getTranslationY [androidJvm] open fun getTranslationY (): Float getTranslationZ [androidJvm] open fun getTranslationZ (): Float getUniqueDrawingId [androidJvm] open fun getUniqueDrawingId (): Long getVerticalFadingEdgeLength [androidJvm] open fun getVerticalFadingEdgeLength (): Int getVerticalScrollbarPosition [androidJvm] open fun getVerticalScrollbarPosition (): Int getVerticalScrollbarThumbDrawable [androidJvm] open fun getVerticalScrollbarThumbDrawable (): Drawable ? getVerticalScrollbarTrackDrawable [androidJvm] open fun getVerticalScrollbarTrackDrawable (): Drawable ? getVerticalScrollbarWidth [androidJvm] open fun getVerticalScrollbarWidth (): Int getViewTranslationResponse [androidJvm] open fun getViewTranslationResponse (): ViewTranslationResponse ? getViewTreeObserver [androidJvm] open fun getViewTreeObserver (): ViewTreeObserver getVisibility [androidJvm] open fun getVisibility (): Int getWidth [androidJvm] fun getWidth (): Int getWindowAttachCount [androidJvm] open fun getWindowAttachCount (): Int getWindowId [androidJvm] open fun getWindowId (): WindowId getWindowInsetsController [androidJvm] open fun getWindowInsetsController (): WindowInsetsController ? getWindowToken [androidJvm] open fun getWindowToken (): IBinder getWindowVisibility [androidJvm] open fun getWindowVisibility (): Int getWindowVisibleDisplayFrame [androidJvm] open fun getWindowVisibleDisplayFrame (p0: Rect ) getX [androidJvm] open fun getX (): Float getY [androidJvm] open fun getY (): Float getZ [androidJvm] open fun getZ (): Float hasExplicitFocusable [androidJvm] open fun hasExplicitFocusable (): Boolean hasFocus [androidJvm] open override fun hasFocus (): Boolean hasFocusable [androidJvm] open fun hasFocusable (): Boolean hasNestedScrollingParent [androidJvm] open fun hasNestedScrollingParent (): Boolean hasOnClickListeners [androidJvm] open fun hasOnClickListeners (): Boolean hasOnLongClickListeners [androidJvm] open fun hasOnLongClickListeners (): Boolean hasOverlappingRendering [androidJvm] open fun hasOverlappingRendering (): Boolean hasPointerCapture [androidJvm] open fun hasPointerCapture (): Boolean hasTransientState [androidJvm] open override fun hasTransientState (): Boolean hasWindowFocus [androidJvm] open fun hasWindowFocus (): Boolean indexOfChild [androidJvm] open fun indexOfChild (p0: View ): Int invalidate [androidJvm] open fun invalidate () invalidateDrawable [androidJvm] open override fun invalidateDrawable (p0: Drawable ) invalidateOutline [androidJvm] open fun invalidateOutline () isAccessibilityFocused [androidJvm] open fun isAccessibilityFocused (): Boolean isAccessibilityHeading [androidJvm] open fun isAccessibilityHeading (): Boolean isActivated [androidJvm] open fun isActivated (): Boolean isAttachedToWindow [androidJvm] open fun isAttachedToWindow (): Boolean isChildrenDrawingOrderEnabled [androidJvm] open fun isChildrenDrawingOrderEnabled (): Boolean isClickable [androidJvm] open fun isClickable (): Boolean isContextClickable [androidJvm] open fun isContextClickable (): Boolean isDirty [androidJvm] open fun isDirty (): Boolean isDuplicateParentStateEnabled [androidJvm] open fun isDuplicateParentStateEnabled (): Boolean isEnabled [androidJvm] open fun isEnabled (): Boolean isFocusable [androidJvm] fun isFocusable (): Boolean isFocusableInTouchMode [androidJvm] fun isFocusableInTouchMode (): Boolean isFocused [androidJvm] open fun isFocused (): Boolean isFocusedByDefault [androidJvm] fun isFocusedByDefault (): Boolean isForceDarkAllowed [androidJvm] open fun isForceDarkAllowed (): Boolean isHapticFeedbackEnabled [androidJvm] open fun isHapticFeedbackEnabled (): Boolean isHardwareAccelerated [androidJvm] open fun isHardwareAccelerated (): Boolean isHorizontalFadingEdgeEnabled [androidJvm] open fun isHorizontalFadingEdgeEnabled (): Boolean isHorizontalScrollBarEnabled [androidJvm] open fun isHorizontalScrollBarEnabled (): Boolean isHovered [androidJvm] open fun isHovered (): Boolean isImportantForAccessibility [androidJvm] open fun isImportantForAccessibility (): Boolean isImportantForAutofill [androidJvm] fun isImportantForAutofill (): Boolean isImportantForContentCapture [androidJvm] fun isImportantForContentCapture (): Boolean isInEditMode [androidJvm] open fun isInEditMode (): Boolean isInLayout [androidJvm] open fun isInLayout (): Boolean isInTouchMode [androidJvm] open fun isInTouchMode (): Boolean isKeyboardNavigationCluster [androidJvm] fun isKeyboardNavigationCluster (): Boolean isLaidOut [androidJvm] open fun isLaidOut (): Boolean isLayoutDirectionResolved [androidJvm] open fun isLayoutDirectionResolved (): Boolean isLayoutRequested [androidJvm] open fun isLayoutRequested (): Boolean isLayoutSuppressed [androidJvm] open fun isLayoutSuppressed (): Boolean isLongClickable [androidJvm] open fun isLongClickable (): Boolean isMotionEventSplittingEnabled [androidJvm] open fun isMotionEventSplittingEnabled (): Boolean isNestedScrollingEnabled [androidJvm] open fun isNestedScrollingEnabled (): Boolean isOpaque [androidJvm] open fun isOpaque (): Boolean isPaddingOffsetRequired [androidJvm] open fun isPaddingOffsetRequired (): Boolean isPaddingRelative [androidJvm] open fun isPaddingRelative (): Boolean isPivotSet [androidJvm] open fun isPivotSet (): Boolean isPressed [androidJvm] open fun isPressed (): Boolean isSaveEnabled [androidJvm] open fun isSaveEnabled (): Boolean isSaveFromParentEnabled [androidJvm] open fun isSaveFromParentEnabled (): Boolean isScreenReaderFocusable [androidJvm] open fun isScreenReaderFocusable (): Boolean isScrollbarFadingEnabled [androidJvm] open fun isScrollbarFadingEnabled (): Boolean isScrollContainer [androidJvm] open fun isScrollContainer (): Boolean isSelected [androidJvm] open fun isSelected (): Boolean isShowingLayoutBounds [androidJvm] fun isShowingLayoutBounds (): Boolean isShown [androidJvm] open fun isShown (): Boolean isSoundEffectsEnabled [androidJvm] open fun isSoundEffectsEnabled (): Boolean isTemporarilyDetached [androidJvm] fun isTemporarilyDetached (): Boolean isTextAlignmentResolved [androidJvm] open fun isTextAlignmentResolved (): Boolean isTextDirectionResolved [androidJvm] open fun isTextDirectionResolved (): Boolean isTransitionGroup [androidJvm] open fun isTransitionGroup (): Boolean isVerticalFadingEdgeEnabled [androidJvm] open fun isVerticalFadingEdgeEnabled (): Boolean isVerticalScrollBarEnabled [androidJvm] open fun isVerticalScrollBarEnabled (): Boolean isVisibleToUserForAutofill [androidJvm] open fun isVisibleToUserForAutofill (p0: Int ): Boolean jumpDrawablesToCurrentState [androidJvm] open override fun jumpDrawablesToCurrentState () keyboardNavigationClusterSearch [androidJvm] open fun keyboardNavigationClusterSearch (p0: View , p1: Int ): View layout [androidJvm] override fun layout (p0: Int , p1: Int , p2: Int , p3: Int ) measure [androidJvm] fun measure (p0: Int , p1: Int ) measureChild [androidJvm] open fun measureChild (p0: View , p1: Int , p2: Int ) measureChildren [androidJvm] open fun measureChildren (p0: Int , p1: Int ) measureChildWithMargins [androidJvm] open fun measureChildWithMargins (p0: View , p1: Int , p2: Int , p3: Int , p4: Int ) notifySubtreeAccessibilityStateChanged [androidJvm] open override fun notifySubtreeAccessibilityStateChanged (p0: View , p1: View , p2: Int ) offsetDescendantRectToMyCoords [androidJvm] fun offsetDescendantRectToMyCoords (p0: View , p1: Rect ) offsetLeftAndRight [androidJvm] open fun offsetLeftAndRight (p0: Int ) offsetRectIntoDescendantCoords [androidJvm] fun offsetRectIntoDescendantCoords (p0: View , p1: Rect ) offsetTopAndBottom [androidJvm] open fun offsetTopAndBottom (p0: Int ) onAnimationEnd [androidJvm] open fun onAnimationEnd () onAnimationStart [androidJvm] open fun onAnimationStart () onApplyWindowInsets [androidJvm] open fun onApplyWindowInsets (p0: WindowInsets ): WindowInsets onAttachedToWindow [androidJvm] open override fun onAttachedToWindow () onCancelPendingInputEvents [androidJvm] open fun onCancelPendingInputEvents () onCapturedPointerEvent [androidJvm] open fun onCapturedPointerEvent (p0: MotionEvent ): Boolean onCheckIsTextEditor [androidJvm] open fun onCheckIsTextEditor (): Boolean onConfigurationChanged [androidJvm] open fun onConfigurationChanged (p0: Configuration ) onCreateContextMenu [androidJvm] open fun onCreateContextMenu (p0: ContextMenu ) onCreateDrawableState [androidJvm] open override fun onCreateDrawableState (p0: Int ): IntArray onCreateInputConnection [androidJvm] open fun onCreateInputConnection (p0: EditorInfo ): InputConnection onCreateViewTranslationRequest [androidJvm] open fun onCreateViewTranslationRequest (p0: IntArray , p1: Consumer < ViewTranslationRequest >) onCreateVirtualViewTranslationRequests [androidJvm] open fun onCreateVirtualViewTranslationRequests (p0: LongArray , p1: IntArray , p2: Consumer < ViewTranslationRequest >) onDescendantInvalidated [androidJvm] open override fun onDescendantInvalidated (p0: View , p1: View ) onDetachedFromWindow [androidJvm] open override fun onDetachedFromWindow () onDisplayHint [androidJvm] open fun onDisplayHint (p0: Int ) onDragEvent [androidJvm] open fun onDragEvent (p0: DragEvent ): Boolean onDraw [androidJvm] open fun onDraw (p0: Canvas ) onDrawForeground [androidJvm] open fun onDrawForeground (p0: Canvas ) onDrawScrollBars [androidJvm] fun onDrawScrollBars (p0: Canvas ) onFilterTouchEventForSecurity [androidJvm] open fun onFilterTouchEventForSecurity (p0: MotionEvent ): Boolean onFinishInflate [androidJvm] open fun onFinishInflate () onFinishTemporaryDetach [androidJvm] open fun onFinishTemporaryDetach () onFocusChanged [androidJvm] open fun onFocusChanged (p0: Boolean , p1: Int , p2: Rect ?) onGenericMotionEvent [androidJvm] open fun onGenericMotionEvent (p0: MotionEvent ): Boolean onHoverChanged [androidJvm] open fun onHoverChanged (p0: Boolean ) onHoverEvent [androidJvm] open fun onHoverEvent (p0: MotionEvent ): Boolean onInitializeAccessibilityEvent [androidJvm] open fun onInitializeAccessibilityEvent (p0: AccessibilityEvent ) onInitializeAccessibilityNodeInfo [androidJvm] open fun onInitializeAccessibilityNodeInfo (p0: AccessibilityNodeInfo ) onInterceptHoverEvent [androidJvm] open fun onInterceptHoverEvent (p0: MotionEvent ): Boolean onInterceptTouchEvent [androidJvm] open fun onInterceptTouchEvent (p0: MotionEvent ): Boolean onKeyDown [androidJvm] open override fun onKeyDown (p0: Int , p1: KeyEvent ): Boolean onKeyLongPress [androidJvm] open override fun onKeyLongPress (p0: Int , p1: KeyEvent ): Boolean onKeyMultiple [androidJvm] open override fun onKeyMultiple (p0: Int , p1: Int , p2: KeyEvent ): Boolean onKeyPreIme [androidJvm] open fun onKeyPreIme (p0: Int , p1: KeyEvent ): Boolean onKeyShortcut [androidJvm] open fun onKeyShortcut (p0: Int , p1: KeyEvent ): Boolean onKeyUp [androidJvm] open override fun onKeyUp (p0: Int , p1: KeyEvent ): Boolean onLayout [androidJvm] open override fun onLayout (p0: Boolean , p1: Int , p2: Int , p3: Int , p4: Int ) onMeasure [androidJvm] open override fun onMeasure (p0: Int , p1: Int ) onNestedFling [androidJvm] open override fun onNestedFling (p0: View , p1: Float , p2: Float , p3: Boolean ): Boolean onNestedPreFling [androidJvm] open override fun onNestedPreFling (p0: View , p1: Float , p2: Float ): Boolean onNestedPrePerformAccessibilityAction [androidJvm] open override fun onNestedPrePerformAccessibilityAction (p0: View , p1: Int , p2: Bundle ): Boolean onNestedPreScroll [androidJvm] open override fun onNestedPreScroll (p0: View , p1: Int , p2: Int , p3: IntArray ) onNestedScroll [androidJvm] open override fun onNestedScroll (p0: View , p1: Int , p2: Int , p3: Int , p4: Int ) onNestedScrollAccepted [androidJvm] open override fun onNestedScrollAccepted (p0: View , p1: View , p2: Int ) onOverScrolled [androidJvm] open fun onOverScrolled (p0: Int , p1: Int , p2: Boolean , p3: Boolean ) onPointerCaptureChange [androidJvm] open fun onPointerCaptureChange (p0: Boolean ) onPopulateAccessibilityEvent [androidJvm] open fun onPopulateAccessibilityEvent (p0: AccessibilityEvent ) onProvideAutofillStructure [androidJvm] open fun onProvideAutofillStructure (p0: ViewStructure , p1: Int ) onProvideAutofillVirtualStructure [androidJvm] open fun onProvideAutofillVirtualStructure (p0: ViewStructure , p1: Int ) onProvideContentCaptureStructure [androidJvm] open fun onProvideContentCaptureStructure (p0: ViewStructure , p1: Int ) onProvideStructure [androidJvm] open fun onProvideStructure (p0: ViewStructure ) onProvideVirtualStructure [androidJvm] open fun onProvideVirtualStructure (p0: ViewStructure ) onReceiveContent [androidJvm] open fun onReceiveContent (p0: ContentInfo ): ContentInfo ? onRequestFocusInDescendants [androidJvm] open fun onRequestFocusInDescendants (p0: Int , p1: Rect ): Boolean onRequestSendAccessibilityEvent [androidJvm] open fun onRequestSendAccessibilityEvent (p0: View , p1: AccessibilityEvent ): Boolean onResolvePointerIcon [androidJvm] open override fun onResolvePointerIcon (p0: MotionEvent , p1: Int ): PointerIcon onRtlPropertiesChanged [androidJvm] open fun onRtlPropertiesChanged (p0: Int ) onScreenStateChanged [androidJvm] open fun onScreenStateChanged (p0: Int ) onScrollCaptureSearch [androidJvm] open fun onScrollCaptureSearch (p0: Rect , p1: Point , p2: Consumer < ScrollCaptureTarget >) onScrollChanged [androidJvm] open fun onScrollChanged (p0: Int , p1: Int , p2: Int , p3: Int ) onSetAlpha [androidJvm] open fun onSetAlpha (p0: Int ): Boolean onSizeChanged [androidJvm] open fun onSizeChanged (p0: Int , p1: Int , p2: Int , p3: Int ) onStartNestedScroll [androidJvm] open override fun onStartNestedScroll (p0: View , p1: View , p2: Int ): Boolean onStartTemporaryDetach [androidJvm] open fun onStartTemporaryDetach () onStopNestedScroll [androidJvm] open override fun onStopNestedScroll (p0: View ) onTouchEvent [androidJvm] open fun onTouchEvent (p0: MotionEvent ): Boolean onTrackballEvent [androidJvm] open fun onTrackballEvent (p0: MotionEvent ): Boolean onViewAdded [androidJvm] open fun onViewAdded (p0: View ) onViewRemoved [androidJvm] open fun onViewRemoved (p0: View ) onViewTranslationResponse [androidJvm] open fun onViewTranslationResponse (p0: ViewTranslationResponse ) onVirtualViewTranslationResponses [androidJvm] open fun onVirtualViewTranslationResponses (p0: LongSparseArray < ViewTranslationResponse >) onVisibilityAggregated [androidJvm] open fun onVisibilityAggregated (p0: Boolean ) onVisibilityChanged [androidJvm] open fun onVisibilityChanged (p0: View , p1: Int ) onWindowFocusChanged [androidJvm] open fun onWindowFocusChanged (p0: Boolean ) onWindowVisibilityChanged [androidJvm] open fun onWindowVisibilityChanged (p0: Int ) overScrollBy [androidJvm] open fun overScrollBy (p0: Int , p1: Int , p2: Int , p3: Int , p4: Int , p5: Int , p6: Int , p7: Int , p8: Boolean ): Boolean performAccessibilityAction [androidJvm] open fun performAccessibilityAction (p0: Int , p1: Bundle ): Boolean performClick [androidJvm] open fun performClick (): Boolean performContextClick [androidJvm] open fun performContextClick (): Boolean open fun performContextClick (p0: Float , p1: Float ): Boolean performHapticFeedback [androidJvm] open fun performHapticFeedback (p0: Int ): Boolean open fun performHapticFeedback (p0: Int , p1: Int ): Boolean performLongClick [androidJvm] open fun performLongClick (): Boolean open fun performLongClick (p0: Float , p1: Float ): Boolean performReceiveContent [androidJvm] open fun performReceiveContent (p0: ContentInfo ): ContentInfo ? playSoundEffect [androidJvm] open fun playSoundEffect (p0: Int ) post [androidJvm] open fun post (p0: Runnable ): Boolean postDelayed [androidJvm] open fun postDelayed (p0: Runnable , p1: Long ): Boolean postInvalidate [androidJvm] open fun postInvalidate () open fun postInvalidate (p0: Int , p1: Int , p2: Int , p3: Int ) postInvalidateDelayed [androidJvm] open fun postInvalidateDelayed (p0: Long ) open fun postInvalidateDelayed (p0: Long , p1: Int , p2: Int , p3: Int , p4: Int ) postInvalidateOnAnimation [androidJvm] open fun postInvalidateOnAnimation () open fun postInvalidateOnAnimation (p0: Int , p1: Int , p2: Int , p3: Int ) postOnAnimation [androidJvm] open fun postOnAnimation (p0: Runnable ) postOnAnimationDelayed [androidJvm] open fun postOnAnimationDelayed (p0: Runnable , p1: Long ) recomputeViewAttributes [androidJvm] open override fun recomputeViewAttributes (p0: View ) refreshDrawableState [androidJvm] open fun refreshDrawableState () releasePointerCapture [androidJvm] open fun releasePointerCapture () removeAllViews [androidJvm] open fun removeAllViews () removeAllViewsInLayout [androidJvm] open fun removeAllViewsInLayout () removeCallbacks [androidJvm] open fun removeCallbacks (p0: Runnable ): Boolean removeDetachedView [androidJvm] open fun removeDetachedView (p0: View , p1: Boolean ) removeOnAttachStateChangeListener [androidJvm] open fun removeOnAttachStateChangeListener (p0: View.OnAttachStateChangeListener ) removeOnLayoutChangeListener [androidJvm] open fun removeOnLayoutChangeListener (p0: View.OnLayoutChangeListener ) removeOnUnhandledKeyEventListener [androidJvm] open fun removeOnUnhandledKeyEventListener (p0: View.OnUnhandledKeyEventListener ) removeView [androidJvm] open override fun removeView (p0: View ) removeViewAt [androidJvm] open fun removeViewAt (p0: Int ) removeViewInLayout [androidJvm] open fun removeViewInLayout (p0: View ) removeViews [androidJvm] open fun removeViews (p0: Int , p1: Int ) removeViewsInLayout [androidJvm] open fun removeViewsInLayout (p0: Int , p1: Int ) requestApplyInsets [androidJvm] open fun requestApplyInsets () requestChildFocus [androidJvm] open override fun requestChildFocus (p0: View , p1: View ) requestChildRectangleOnScreen [androidJvm] open override fun requestChildRectangleOnScreen (p0: View , p1: Rect , p2: Boolean ): Boolean requestDisallowInterceptTouchEvent [androidJvm] open override fun requestDisallowInterceptTouchEvent (p0: Boolean ) requestFocus [androidJvm] fun requestFocus (): Boolean fun requestFocus (p0: Int ): Boolean open override fun requestFocus (p0: Int , p1: Rect ): Boolean requestFocusFromTouch [androidJvm] fun requestFocusFromTouch (): Boolean requestLayout [androidJvm] open fun requestLayout () requestPointerCapture [androidJvm] open fun requestPointerCapture () requestRectangleOnScreen [androidJvm] open fun requestRectangleOnScreen (p0: Rect ): Boolean open fun requestRectangleOnScreen (p0: Rect , p1: Boolean ): Boolean requestSendAccessibilityEvent [androidJvm] open override fun requestSendAccessibilityEvent (p0: View , p1: AccessibilityEvent ): Boolean requestTransparentRegion [androidJvm] open override fun requestTransparentRegion (p0: View ) requestUnbufferedDispatch [androidJvm] fun requestUnbufferedDispatch (p0: MotionEvent ) fun requestUnbufferedDispatch (p0: Int ) requireViewById [androidJvm] fun < T : View > requireViewById (p0: Int ): T resetPivot [androidJvm] open fun resetPivot () restoreDefaultFocus [androidJvm] open override fun restoreDefaultFocus (): Boolean restoreHierarchyState [androidJvm] open fun restoreHierarchyState (p0: SparseArray < Parcelable >) saveAttributeDataForStyleable [androidJvm] fun saveAttributeDataForStyleable (p0: Context , p1: IntArray , p2: AttributeSet ?, p3: TypedArray , p4: Int , p5: Int ) saveHierarchyState [androidJvm] open fun saveHierarchyState (p0: SparseArray < Parcelable >) scheduleDrawable [androidJvm] open override fun scheduleDrawable (p0: Drawable , p1: Runnable , p2: Long ) scheduleLayoutAnimation [androidJvm] open fun scheduleLayoutAnimation () scrollBy [androidJvm] open fun scrollBy (p0: Int , p1: Int ) scrollTo [androidJvm] open fun scrollTo (p0: Int , p1: Int ) sendAccessibilityEvent [androidJvm] open override fun sendAccessibilityEvent (p0: Int ) sendAccessibilityEventUnchecked [androidJvm] open override fun sendAccessibilityEventUnchecked (p0: AccessibilityEvent ) setAccessibilityDelegate [androidJvm] open fun setAccessibilityDelegate (p0: View.AccessibilityDelegate ?) setAccessibilityHeading [androidJvm] open fun setAccessibilityHeading (p0: Boolean ) setAccessibilityLiveRegion [androidJvm] open fun setAccessibilityLiveRegion (p0: Int ) setAccessibilityPaneTitle [androidJvm] open fun setAccessibilityPaneTitle (p0: CharSequence ?) setAccessibilityTraversalAfter [androidJvm] open fun setAccessibilityTraversalAfter (p0: Int ) setAccessibilityTraversalBefore [androidJvm] open fun setAccessibilityTraversalBefore (p0: Int ) setActivated [androidJvm] open fun setActivated (p0: Boolean ) setAddStatesFromChildren [androidJvm] open fun setAddStatesFromChildren (p0: Boolean ) setAllowClickWhenDisabled [androidJvm] open fun setAllowClickWhenDisabled (p0: Boolean ) setAlpha [androidJvm] open fun setAlpha (p0: Float ) setAnimation [androidJvm] open fun setAnimation (p0: Animation ) setAnimationMatrix [androidJvm] open fun setAnimationMatrix (p0: Matrix ?) setAutofillHints [androidJvm] open fun setAutofillHints (vararg p0: String ) setAutofillId [androidJvm] open fun setAutofillId (p0: AutofillId ?) setBackground [androidJvm] open fun setBackground (p0: Drawable ) setBackgroundColor [androidJvm] open fun setBackgroundColor (p0: Int ) setBackgroundResource [androidJvm] open fun setBackgroundResource (p0: Int ) setBackgroundTintBlendMode [androidJvm] open fun setBackgroundTintBlendMode (p0: BlendMode ?) setBackgroundTintList [androidJvm] open fun setBackgroundTintList (p0: ColorStateList ?) setBackgroundTintMode [androidJvm] open fun setBackgroundTintMode (p0: PorterDuff.Mode ?) setBottom [androidJvm] fun setBottom (p0: Int ) setCameraDistance [androidJvm] open fun setCameraDistance (p0: Float ) setChildrenDrawingOrderEnabled [androidJvm] open fun setChildrenDrawingOrderEnabled (p0: Boolean ) setClickable [androidJvm] open fun setClickable (p0: Boolean ) setClipBounds [androidJvm] open fun setClipBounds (p0: Rect ) setClipChildren [androidJvm] open fun setClipChildren (p0: Boolean ) setClipToOutline [androidJvm] open fun setClipToOutline (p0: Boolean ) setClipToPadding [androidJvm] open fun setClipToPadding (p0: Boolean ) setContentCaptureSession [androidJvm] open fun setContentCaptureSession (p0: ContentCaptureSession ?) setContentDescription [androidJvm] open fun setContentDescription (p0: CharSequence ) setContextClickable [androidJvm] open fun setContextClickable (p0: Boolean ) setDefaultFocusHighlightEnabled [androidJvm] open fun setDefaultFocusHighlightEnabled (p0: Boolean ) setDescendantFocusability [androidJvm] open fun setDescendantFocusability (p0: Int ) setDuplicateParentStateEnabled [androidJvm] open fun setDuplicateParentStateEnabled (p0: Boolean ) setElevation [androidJvm] open fun setElevation (p0: Float ) setEnabled [androidJvm] open fun setEnabled (p0: Boolean ) setFadingEdgeLength [androidJvm] open fun setFadingEdgeLength (p0: Int ) setFilterTouchesWhenObscured [androidJvm] open fun setFilterTouchesWhenObscured (p0: Boolean ) setFitsSystemWindows [androidJvm] open fun setFitsSystemWindows (p0: Boolean ) setFocusable [androidJvm] open fun setFocusable (p0: Boolean ) open fun setFocusable (p0: Int ) setFocusableInTouchMode [androidJvm] open fun setFocusableInTouchMode (p0: Boolean ) setFocusedByDefault [androidJvm] open fun setFocusedByDefault (p0: Boolean ) setForceDarkAllowed [androidJvm] open fun setForceDarkAllowed (p0: Boolean ) setForeground [androidJvm] open fun setForeground (p0: Drawable ) setForegroundGravity [androidJvm] open override fun setForegroundGravity (p0: Int ) setForegroundTintBlendMode [androidJvm] open fun setForegroundTintBlendMode (p0: BlendMode ?) setForegroundTintList [androidJvm] open fun setForegroundTintList (p0: ColorStateList ?) setForegroundTintMode [androidJvm] open fun setForegroundTintMode (p0: PorterDuff.Mode ?) setHapticFeedbackEnabled [androidJvm] open fun setHapticFeedbackEnabled (p0: Boolean ) setHasTransientState [androidJvm] open fun setHasTransientState (p0: Boolean ) setHorizontalFadingEdgeEnabled [androidJvm] open fun setHorizontalFadingEdgeEnabled (p0: Boolean ) setHorizontalScrollBarEnabled [androidJvm] open fun setHorizontalScrollBarEnabled (p0: Boolean ) setHorizontalScrollbarThumbDrawable [androidJvm] open fun setHorizontalScrollbarThumbDrawable (p0: Drawable ?) setHorizontalScrollbarTrackDrawable [androidJvm] open fun setHorizontalScrollbarTrackDrawable (p0: Drawable ?) setHovered [androidJvm] open fun setHovered (p0: Boolean ) setId [androidJvm] open fun setId (p0: Int ) setImportantForAccessibility [androidJvm] open fun setImportantForAccessibility (p0: Int ) setImportantForAutofill [androidJvm] open fun setImportantForAutofill (p0: Int ) setImportantForContentCapture [androidJvm] open fun setImportantForContentCapture (p0: Int ) setKeepScreenOn [androidJvm] open fun setKeepScreenOn (p0: Boolean ) setKeyboardNavigationCluster [androidJvm] open fun setKeyboardNavigationCluster (p0: Boolean ) setLabelFor [androidJvm] open fun setLabelFor (p0: Int ) setLayerPaint [androidJvm] open fun setLayerPaint (p0: Paint ?) setLayerType [androidJvm] open fun setLayerType (p0: Int , p1: Paint ?) setLayoutAnimation [androidJvm] open fun setLayoutAnimation (p0: LayoutAnimationController ) setLayoutAnimationListener [androidJvm] open fun setLayoutAnimationListener (p0: Animation.AnimationListener ) setLayoutDirection [androidJvm] open fun setLayoutDirection (p0: Int ) setLayoutMode [androidJvm] open fun setLayoutMode (p0: Int ) setLayoutParams [androidJvm] open fun setLayoutParams (p0: ViewGroup.LayoutParams ) setLayoutTransition [androidJvm] open fun setLayoutTransition (p0: LayoutTransition ) setLeft [androidJvm] fun setLeft (p0: Int ) setLeftTopRightBottom [androidJvm] fun setLeftTopRightBottom (p0: Int , p1: Int , p2: Int , p3: Int ) setLongClickable [androidJvm] open fun setLongClickable (p0: Boolean ) setMeasureAllChildren [androidJvm] open fun setMeasureAllChildren (p0: Boolean ) setMeasuredDimension [androidJvm] fun setMeasuredDimension (p0: Int , p1: Int ) setMinimumHeight [androidJvm] open fun setMinimumHeight (p0: Int ) setMinimumWidth [androidJvm] open fun setMinimumWidth (p0: Int ) setMotionEventSplittingEnabled [androidJvm] open fun setMotionEventSplittingEnabled (p0: Boolean ) setNestedScrollingEnabled [androidJvm] open fun setNestedScrollingEnabled (p0: Boolean ) setNextClusterForwardId [androidJvm] open fun setNextClusterForwardId (p0: Int ) setNextFocusDownId [androidJvm] open fun setNextFocusDownId (p0: Int ) setNextFocusForwardId [androidJvm] open fun setNextFocusForwardId (p0: Int ) setNextFocusLeftId [androidJvm] open fun setNextFocusLeftId (p0: Int ) setNextFocusRightId [androidJvm] open fun setNextFocusRightId (p0: Int ) setNextFocusUpId [androidJvm] open fun setNextFocusUpId (p0: Int ) setOnApplyWindowInsetsListener [androidJvm] open fun setOnApplyWindowInsetsListener (p0: View.OnApplyWindowInsetsListener ) setOnCapturedPointerListener [androidJvm] open fun setOnCapturedPointerListener (p0: View.OnCapturedPointerListener ) setOnClickListener [androidJvm] open fun setOnClickListener (p0: View.OnClickListener ?) setOnContextClickListener [androidJvm] open fun setOnContextClickListener (p0: View.OnContextClickListener ?) setOnCreateContextMenuListener [androidJvm] open fun setOnCreateContextMenuListener (p0: View.OnCreateContextMenuListener ) setOnDragListener [androidJvm] open fun setOnDragListener (p0: View.OnDragListener ) setOnFocusChangeListener [androidJvm] open fun setOnFocusChangeListener (p0: View.OnFocusChangeListener ) setOnGenericMotionListener [androidJvm] open fun setOnGenericMotionListener (p0: View.OnGenericMotionListener ) setOnHierarchyChangeListener [androidJvm] open fun setOnHierarchyChangeListener (p0: ViewGroup.OnHierarchyChangeListener ) setOnHoverListener [androidJvm] open fun setOnHoverListener (p0: View.OnHoverListener ) setOnKeyListener [androidJvm] open fun setOnKeyListener (p0: View.OnKeyListener ) setOnLongClickListener [androidJvm] open fun setOnLongClickListener (p0: View.OnLongClickListener ?) setOnReceiveContentListener [androidJvm] open fun setOnReceiveContentListener (p0: Array < String >?, p1: OnReceiveContentListener ?) setOnScrollChangeListener [androidJvm] open fun setOnScrollChangeListener (p0: View.OnScrollChangeListener ) setOnTouchListener [androidJvm] open fun setOnTouchListener (p0: View.OnTouchListener ) setOutlineAmbientShadowColor [androidJvm] open fun setOutlineAmbientShadowColor (p0: Int ) setOutlineProvider [androidJvm] open fun setOutlineProvider (p0: ViewOutlineProvider ) setOutlineSpotShadowColor [androidJvm] open fun setOutlineSpotShadowColor (p0: Int ) setOverScrollMode [androidJvm] open fun setOverScrollMode (p0: Int ) setPadding [androidJvm] open fun setPadding (p0: Int , p1: Int , p2: Int , p3: Int ) setPaddingRelative [androidJvm] open fun setPaddingRelative (p0: Int , p1: Int , p2: Int , p3: Int ) setPivotX [androidJvm] open fun setPivotX (p0: Float ) setPivotY [androidJvm] open fun setPivotY (p0: Float ) setPointerIcon [androidJvm] open fun setPointerIcon (p0: PointerIcon ) setPressed [androidJvm] open fun setPressed (p0: Boolean ) setRenderEffect [androidJvm] open fun setRenderEffect (p0: RenderEffect ?) setRevealOnFocusHint [androidJvm] fun setRevealOnFocusHint (p0: Boolean ) setRight [androidJvm] fun setRight (p0: Int ) setRotation [androidJvm] open fun setRotation (p0: Float ) setRotationX [androidJvm] open fun setRotationX (p0: Float ) setRotationY [androidJvm] open fun setRotationY (p0: Float ) setSaveEnabled [androidJvm] open fun setSaveEnabled (p0: Boolean ) setSaveFromParentEnabled [androidJvm] open fun setSaveFromParentEnabled (p0: Boolean ) setScaleX [androidJvm] open fun setScaleX (p0: Float ) setScaleY [androidJvm] open fun setScaleY (p0: Float ) setScreenReaderFocusable [androidJvm] open fun setScreenReaderFocusable (p0: Boolean ) setScrollBarDefaultDelayBeforeFade [androidJvm] open fun setScrollBarDefaultDelayBeforeFade (p0: Int ) setScrollBarFadeDuration [androidJvm] open fun setScrollBarFadeDuration (p0: Int ) setScrollbarFadingEnabled [androidJvm] open fun setScrollbarFadingEnabled (p0: Boolean ) setScrollBarSize [androidJvm] open fun setScrollBarSize (p0: Int ) setScrollBarStyle [androidJvm] open fun setScrollBarStyle (p0: Int ) setScrollCaptureCallback [androidJvm] fun setScrollCaptureCallback (p0: ScrollCaptureCallback ?) setScrollCaptureHint [androidJvm] open fun setScrollCaptureHint (p0: Int ) setScrollContainer [androidJvm] open fun setScrollContainer (p0: Boolean ) setScrollIndicators [androidJvm] open fun setScrollIndicators (p0: Int ) open fun setScrollIndicators (p0: Int , p1: Int ) setScrollX [androidJvm] open fun setScrollX (p0: Int ) setScrollY [androidJvm] open fun setScrollY (p0: Int ) setSelected [androidJvm] open fun setSelected (p0: Boolean ) setSoundEffectsEnabled [androidJvm] open fun setSoundEffectsEnabled (p0: Boolean ) setStateDescription [androidJvm] open fun setStateDescription (p0: CharSequence ?) setStateListAnimator [androidJvm] open fun setStateListAnimator (p0: StateListAnimator ) setStaticTransformationsEnabled [androidJvm] open fun setStaticTransformationsEnabled (p0: Boolean ) setSystemGestureExclusionRects [androidJvm] open fun setSystemGestureExclusionRects (p0: MutableList < Rect >) setTag [androidJvm] open fun setTag (p0: Any ) open fun setTag (p0: Int , p1: Any ) setTextAlignment [androidJvm] open fun setTextAlignment (p0: Int ) setTextDirection [androidJvm] open fun setTextDirection (p0: Int ) setTooltipText [androidJvm] open fun setTooltipText (p0: CharSequence ?) setTop [androidJvm] fun setTop (p0: Int ) setTouchDelegate [androidJvm] open fun setTouchDelegate (p0: TouchDelegate ) setTouchscreenBlocksFocus [androidJvm] open fun setTouchscreenBlocksFocus (p0: Boolean ) setTransitionAlpha [androidJvm] open fun setTransitionAlpha (p0: Float ) setTransitionGroup [androidJvm] open fun setTransitionGroup (p0: Boolean ) setTransitionName [androidJvm] fun setTransitionName (p0: String ) setTransitionVisibility [androidJvm] open fun setTransitionVisibility (p0: Int ) setTranslationX [androidJvm] open fun setTranslationX (p0: Float ) setTranslationY [androidJvm] open fun setTranslationY (p0: Float ) setTranslationZ [androidJvm] open fun setTranslationZ (p0: Float ) setVerticalFadingEdgeEnabled [androidJvm] open fun setVerticalFadingEdgeEnabled (p0: Boolean ) setVerticalScrollBarEnabled [androidJvm] open fun setVerticalScrollBarEnabled (p0: Boolean ) setVerticalScrollbarPosition [androidJvm] open fun setVerticalScrollbarPosition (p0: Int ) setVerticalScrollbarThumbDrawable [androidJvm] open fun setVerticalScrollbarThumbDrawable (p0: Drawable ?) setVerticalScrollbarTrackDrawable [androidJvm] open fun setVerticalScrollbarTrackDrawable (p0: Drawable ?) setViewTranslationCallback [androidJvm] open fun setViewTranslationCallback (p0: ViewTranslationCallback ) setVisibility [androidJvm] open fun setVisibility (p0: Int ) setWillNotDraw [androidJvm] open fun setWillNotDraw (p0: Boolean ) setWindowInsetsAnimationCallback [androidJvm] open override fun setWindowInsetsAnimationCallback (p0: WindowInsetsAnimation.Callback ?) setX [androidJvm] open fun setX (p0: Float ) setY [androidJvm] open fun setY (p0: Float ) setZ [androidJvm] open fun setZ (p0: Float ) shouldDelayChildPressedState [androidJvm] open override fun shouldDelayChildPressedState (): Boolean showContextMenu [androidJvm] open fun showContextMenu (): Boolean open fun showContextMenu (p0: Float , p1: Float ): Boolean showContextMenuForChild [androidJvm] open override fun showContextMenuForChild (p0: View ): Boolean open override fun showContextMenuForChild (p0: View , p1: Float , p2: Float ): Boolean startActionMode [androidJvm] open fun startActionMode (p0: ActionMode.Callback ): ActionMode open fun startActionMode (p0: ActionMode.Callback , p1: Int ): ActionMode startActionModeForChild [androidJvm] open override fun startActionModeForChild (p0: View , p1: ActionMode.Callback ): ActionMode open override fun startActionModeForChild (p0: View , p1: ActionMode.Callback , p2: Int ): ActionMode startAnimation [androidJvm] open fun startAnimation (p0: Animation ) startDragAndDrop [androidJvm] fun startDragAndDrop (p0: ClipData , p1: View.DragShadowBuilder , p2: Any , p3: Int ): Boolean startLayoutAnimation [androidJvm] open fun startLayoutAnimation () startNestedScroll [androidJvm] open fun startNestedScroll (p0: Int ): Boolean startViewTransition [androidJvm] open fun startViewTransition (p0: View ) stopNestedScroll [androidJvm] open fun stopNestedScroll () suppressLayout [androidJvm] open fun suppressLayout (p0: Boolean ) toString [androidJvm] open override fun toString (): String transformMatrixToGlobal [androidJvm] open fun transformMatrixToGlobal (p0: Matrix ) transformMatrixToLocal [androidJvm] open fun transformMatrixToLocal (p0: Matrix ) unscheduleDrawable [androidJvm] open fun unscheduleDrawable (p0: Drawable ) open override fun unscheduleDrawable (p0: Drawable , p1: Runnable ) updateDragShadow [androidJvm] fun updateDragShadow (p0: View.DragShadowBuilder ) updateViewLayout [androidJvm] open override fun updateViewLayout (p0: View , p1: ViewGroup.LayoutParams ) verifyDrawable [androidJvm] open fun verifyDrawable (p0: Drawable ): Boolean willNotDraw [androidJvm] open fun willNotDraw (): Boolean","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-modal-view-container/#modalviewcontainer","text":"[androidJvm]\\ @WorkflowUiExperimentalApi open class ModalViewContainer @ JvmOverloads constructor(context: Context , attributeSet: AttributeSet ?, defStyle: Int , defStyleRes: Int ) : ModalContainer < Any > Container that shows HasModals.modals as arbitrary views in a Dialog window. Provides compatibility with View.backPressedHandler . Use binding to assign particular rendering types to be shown this way.","title":"ModalViewContainer"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-modal-view-container/#constructors","text":"ModalViewContainer [androidJvm] @ JvmOverloads fun ModalViewContainer (context: Context , attributeSet: AttributeSet ? = null, defStyle: Int = 0, defStyleRes: Int = 0)","title":"Constructors"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-modal-view-container/#types","text":"Name Summary Companion [androidJvm] object Companion","title":"Types"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-modal-view-container/#functions","text":"Name Summary addChildrenForAccessibility [androidJvm] open override fun addChildrenForAccessibility (p0: ArrayList < View >) addExtraDataToAccessibilityNodeInfo [androidJvm] open override fun addExtraDataToAccessibilityNodeInfo (p0: AccessibilityNodeInfo , p1: String , p2: Bundle ?) addFocusables [androidJvm] open fun addFocusables (p0: ArrayList < View >, p1: Int ) open override fun addFocusables (p0: ArrayList < View >, p1: Int , p2: Int ) addKeyboardNavigationClusters [androidJvm] open override fun addKeyboardNavigationClusters (p0: MutableCollection < View >, p1: Int ) addOnAttachStateChangeListener [androidJvm] open fun addOnAttachStateChangeListener (p0: View.OnAttachStateChangeListener ) addOnLayoutChangeListener [androidJvm] open fun addOnLayoutChangeListener (p0: View.OnLayoutChangeListener ) addOnUnhandledKeyEventListener [androidJvm] open fun addOnUnhandledKeyEventListener (p0: View.OnUnhandledKeyEventListener ) addStatesFromChildren [androidJvm] open fun addStatesFromChildren (): Boolean addTouchables [androidJvm] open override fun addTouchables (p0: ArrayList < View >) addView [androidJvm] open fun addView (p0: View ) open override fun addView (p0: View , p1: ViewGroup.LayoutParams ) open fun addView (p0: View , p1: Int ) open fun addView (p0: View , p1: Int , p2: ViewGroup.LayoutParams ) open fun addView (p0: View , p1: Int , p2: Int ) addViewInLayout [androidJvm] open fun addViewInLayout (p0: View , p1: Int , p2: ViewGroup.LayoutParams ): Boolean open fun addViewInLayout (p0: View , p1: Int , p2: ViewGroup.LayoutParams , p3: Boolean ): Boolean animate [androidJvm] open fun animate (): ViewPropertyAnimator announceForAccessibility [androidJvm] open fun announceForAccessibility (p0: CharSequence ) attachLayoutAnimationParameters [androidJvm] open fun attachLayoutAnimationParameters (p0: View , p1: ViewGroup.LayoutParams , p2: Int , p3: Int ) attachViewToParent [androidJvm] open fun attachViewToParent (p0: View , p1: Int , p2: ViewGroup.LayoutParams ) autofill [androidJvm] open fun autofill (p0: SparseArray < AutofillValue >) open fun autofill (p0: AutofillValue ) awakenScrollBars [androidJvm] open fun awakenScrollBars (): Boolean open fun awakenScrollBars (p0: Int ): Boolean open fun awakenScrollBars (p0: Int , p1: Boolean ): Boolean bringChildToFront [androidJvm] open override fun bringChildToFront (p0: View ) bringToFront [androidJvm] open fun bringToFront () buildDialogForView [androidJvm] open fun buildDialogForView (view: View ): Dialog Called from buildDialog. Builds (but does not show) the Dialog to display a view built via ViewRegistry . buildLayer [androidJvm] open fun buildLayer () callOnClick [androidJvm] open fun callOnClick (): Boolean canAnimate [androidJvm] open fun canAnimate (): Boolean cancelDragAndDrop [androidJvm] fun cancelDragAndDrop () cancelLongPress [androidJvm] open fun cancelLongPress () cancelPendingInputEvents [androidJvm] fun cancelPendingInputEvents () canResolveLayoutDirection [androidJvm] open fun canResolveLayoutDirection (): Boolean canResolveTextAlignment [androidJvm] open fun canResolveTextAlignment (): Boolean canResolveTextDirection [androidJvm] open fun canResolveTextDirection (): Boolean canScrollHorizontally [androidJvm] open fun canScrollHorizontally (p0: Int ): Boolean canScrollVertically [androidJvm] open fun canScrollVertically (p0: Int ): Boolean checkInputConnectionProxy [androidJvm] open fun checkInputConnectionProxy (p0: View ): Boolean checkLayoutParams [androidJvm] open override fun checkLayoutParams (p0: ViewGroup.LayoutParams ): Boolean childDrawableStateChanged [androidJvm] open override fun childDrawableStateChanged (p0: View ) childHasTransientStateChanged [androidJvm] open override fun childHasTransientStateChanged (p0: View , p1: Boolean ) cleanupLayoutState [androidJvm] open fun cleanupLayoutState (p0: View ) clearAnimation [androidJvm] open fun clearAnimation () clearChildFocus [androidJvm] open override fun clearChildFocus (p0: View ) clearDisappearingChildren [androidJvm] open fun clearDisappearingChildren () clearFocus [androidJvm] open override fun clearFocus () clearViewTranslationCallback [androidJvm] open fun clearViewTranslationCallback () computeHorizontalScrollExtent [androidJvm] open fun computeHorizontalScrollExtent (): Int computeHorizontalScrollOffset [androidJvm] open fun computeHorizontalScrollOffset (): Int computeHorizontalScrollRange [androidJvm] open fun computeHorizontalScrollRange (): Int computeScroll [androidJvm] open fun computeScroll () computeSystemWindowInsets [androidJvm] open fun computeSystemWindowInsets (p0: WindowInsets , p1: Rect ): WindowInsets computeVerticalScrollExtent [androidJvm] open fun computeVerticalScrollExtent (): Int computeVerticalScrollOffset [androidJvm] open fun computeVerticalScrollOffset (): Int computeVerticalScrollRange [androidJvm] open fun computeVerticalScrollRange (): Int createAccessibilityNodeInfo [androidJvm] open fun createAccessibilityNodeInfo (): AccessibilityNodeInfo createContextMenu [androidJvm] open fun createContextMenu (p0: ContextMenu ) debug [androidJvm] open fun debug (p0: Int ) detachAllViewsFromParent [androidJvm] open fun detachAllViewsFromParent () detachViewFromParent [androidJvm] open fun detachViewFromParent (p0: View ) open fun detachViewFromParent (p0: Int ) detachViewsFromParent [androidJvm] open fun detachViewsFromParent (p0: Int , p1: Int ) dispatchApplyWindowInsets [androidJvm] open override fun dispatchApplyWindowInsets (p0: WindowInsets ): WindowInsets dispatchCapturedPointerEvent [androidJvm] open override fun dispatchCapturedPointerEvent (p0: MotionEvent ): Boolean dispatchConfigurationChanged [androidJvm] open override fun dispatchConfigurationChanged (p0: Configuration ) dispatchCreateViewTranslationRequest [androidJvm] open override fun dispatchCreateViewTranslationRequest (p0: MutableMap < AutofillId , LongArray >, p1: IntArray , p2: TranslationCapability , p3: MutableList < ViewTranslationRequest >) dispatchDisplayHint [androidJvm] open override fun dispatchDisplayHint (p0: Int ) dispatchDragEvent [androidJvm] open override fun dispatchDragEvent (p0: DragEvent ): Boolean dispatchDraw [androidJvm] open override fun dispatchDraw (p0: Canvas ) dispatchDrawableHotspotChanged [androidJvm] open override fun dispatchDrawableHotspotChanged (p0: Float , p1: Float ) dispatchFinishTemporaryDetach [androidJvm] open override fun dispatchFinishTemporaryDetach () dispatchFreezeSelfOnly [androidJvm] open fun dispatchFreezeSelfOnly (p0: SparseArray < Parcelable >) dispatchGenericFocusedEvent [androidJvm] open override fun dispatchGenericFocusedEvent (p0: MotionEvent ): Boolean dispatchGenericMotionEvent [androidJvm] open fun dispatchGenericMotionEvent (p0: MotionEvent ): Boolean dispatchGenericPointerEvent [androidJvm] open override fun dispatchGenericPointerEvent (p0: MotionEvent ): Boolean dispatchHoverEvent [androidJvm] open override fun dispatchHoverEvent (p0: MotionEvent ): Boolean dispatchKeyEvent [androidJvm] open override fun dispatchKeyEvent (p0: KeyEvent ): Boolean dispatchKeyEventPreIme [androidJvm] open override fun dispatchKeyEventPreIme (p0: KeyEvent ): Boolean dispatchKeyShortcutEvent [androidJvm] open override fun dispatchKeyShortcutEvent (p0: KeyEvent ): Boolean dispatchNestedFling [androidJvm] open fun dispatchNestedFling (p0: Float , p1: Float , p2: Boolean ): Boolean dispatchNestedPreFling [androidJvm] open fun dispatchNestedPreFling (p0: Float , p1: Float ): Boolean dispatchNestedPrePerformAccessibilityAction [androidJvm] open fun dispatchNestedPrePerformAccessibilityAction (p0: Int , p1: Bundle ): Boolean dispatchNestedPreScroll [androidJvm] open fun dispatchNestedPreScroll (p0: Int , p1: Int , p2: IntArray ?, p3: IntArray ?): Boolean dispatchNestedScroll [androidJvm] open fun dispatchNestedScroll (p0: Int , p1: Int , p2: Int , p3: Int , p4: IntArray ?): Boolean dispatchPointerCaptureChanged [androidJvm] open override fun dispatchPointerCaptureChanged (p0: Boolean ) dispatchPopulateAccessibilityEvent [androidJvm] open fun dispatchPopulateAccessibilityEvent (p0: AccessibilityEvent ): Boolean dispatchProvideAutofillStructure [androidJvm] open override fun dispatchProvideAutofillStructure (p0: ViewStructure , p1: Int ) dispatchProvideStructure [androidJvm] open override fun dispatchProvideStructure (p0: ViewStructure ) dispatchRestoreInstanceState [androidJvm] open override fun dispatchRestoreInstanceState (p0: SparseArray < Parcelable >) dispatchSaveInstanceState [androidJvm] open override fun dispatchSaveInstanceState (p0: SparseArray < Parcelable >) dispatchScrollCaptureSearch [androidJvm] open override fun dispatchScrollCaptureSearch (p0: Rect , p1: Point , p2: Consumer < ScrollCaptureTarget >) dispatchSetActivated [androidJvm] open override fun dispatchSetActivated (p0: Boolean ) dispatchSetPressed [androidJvm] open override fun dispatchSetPressed (p0: Boolean ) dispatchSetSelected [androidJvm] open override fun dispatchSetSelected (p0: Boolean ) dispatchStartTemporaryDetach [androidJvm] open override fun dispatchStartTemporaryDetach () dispatchThawSelfOnly [androidJvm] open fun dispatchThawSelfOnly (p0: SparseArray < Parcelable >) dispatchTouchEvent [androidJvm] open override fun dispatchTouchEvent (p0: MotionEvent ): Boolean dispatchTrackballEvent [androidJvm] open override fun dispatchTrackballEvent (p0: MotionEvent ): Boolean dispatchUnhandledMove [androidJvm] open override fun dispatchUnhandledMove (p0: View , p1: Int ): Boolean dispatchVisibilityChanged [androidJvm] open override fun dispatchVisibilityChanged (p0: View , p1: Int ) dispatchWindowFocusChanged [androidJvm] open override fun dispatchWindowFocusChanged (p0: Boolean ) dispatchWindowInsetsAnimationEnd [androidJvm] open override fun dispatchWindowInsetsAnimationEnd (p0: WindowInsetsAnimation ) dispatchWindowInsetsAnimationPrepare [androidJvm] open override fun dispatchWindowInsetsAnimationPrepare (p0: WindowInsetsAnimation ) dispatchWindowInsetsAnimationProgress [androidJvm] open override fun dispatchWindowInsetsAnimationProgress (p0: WindowInsets , p1: MutableList < WindowInsetsAnimation >): WindowInsets dispatchWindowInsetsAnimationStart [androidJvm] open override fun dispatchWindowInsetsAnimationStart (p0: WindowInsetsAnimation , p1: WindowInsetsAnimation.Bounds ): WindowInsetsAnimation.Bounds dispatchWindowVisibilityChanged [androidJvm] open override fun dispatchWindowVisibilityChanged (p0: Int ) draw [androidJvm] open fun draw (p0: Canvas ) drawableHotspotChanged [androidJvm] open fun drawableHotspotChanged (p0: Float , p1: Float ) drawableStateChanged [androidJvm] open override fun drawableStateChanged () drawChild [androidJvm] open fun drawChild (p0: Canvas , p1: View , p2: Long ): Boolean endViewTransition [androidJvm] open fun endViewTransition (p0: View ) findFocus [androidJvm] open override fun findFocus (): View findViewById [androidJvm] fun < T : View > findViewById (p0: Int ): T findViewsWithText [androidJvm] open override fun findViewsWithText (p0: ArrayList < View >, p1: CharSequence , p2: Int ) findViewWithTag [androidJvm] fun < T : View > findViewWithTag (p0: Any ): T focusableViewAvailable [androidJvm] open override fun focusableViewAvailable (p0: View ) focusSearch [androidJvm] open fun focusSearch (p0: Int ): View open override fun focusSearch (p0: View , p1: Int ): View forceHasOverlappingRendering [androidJvm] open fun forceHasOverlappingRendering (p0: Boolean ) forceLayout [androidJvm] open fun forceLayout () gatherTransparentRegion [androidJvm] open override fun gatherTransparentRegion (p0: Region ?): Boolean generateDefaultLayoutParams [androidJvm] open override fun generateDefaultLayoutParams (): FrameLayout.LayoutParams generateDisplayHash [androidJvm] open fun generateDisplayHash (p0: String , p1: Rect ?, p2: Executor , p3: DisplayHashResultCallback ) generateLayoutParams [androidJvm] open override fun generateLayoutParams (p0: AttributeSet ): FrameLayout.LayoutParams open override fun generateLayoutParams (p0: ViewGroup.LayoutParams ): ViewGroup.LayoutParams getAccessibilityClassName [androidJvm] open override fun getAccessibilityClassName (): CharSequence getAccessibilityDelegate [androidJvm] open fun getAccessibilityDelegate (): View.AccessibilityDelegate getAccessibilityLiveRegion [androidJvm] open fun getAccessibilityLiveRegion (): Int getAccessibilityNodeProvider [androidJvm] open fun getAccessibilityNodeProvider (): AccessibilityNodeProvider getAccessibilityPaneTitle [androidJvm] open fun getAccessibilityPaneTitle (): CharSequence ? getAccessibilityTraversalAfter [androidJvm] open fun getAccessibilityTraversalAfter (): Int getAccessibilityTraversalBefore [androidJvm] open fun getAccessibilityTraversalBefore (): Int getAlpha [androidJvm] open fun getAlpha (): Float getAnimation [androidJvm] open fun getAnimation (): Animation getAnimationMatrix [androidJvm] open fun getAnimationMatrix (): Matrix ? getApplicationWindowToken [androidJvm] open fun getApplicationWindowToken (): IBinder getAttributeResolutionStack [androidJvm] open fun getAttributeResolutionStack (p0: Int ): IntArray getAttributeSourceResourceMap [androidJvm] open fun getAttributeSourceResourceMap (): MutableMap < Int , Int > getAutofillHints [androidJvm] open fun getAutofillHints (): Array < String >? getAutofillId [androidJvm] fun getAutofillId (): AutofillId getAutofillType [androidJvm] open fun getAutofillType (): Int getAutofillValue [androidJvm] open fun getAutofillValue (): AutofillValue ? getBackground [androidJvm] open fun getBackground (): Drawable getBackgroundTintBlendMode [androidJvm] open fun getBackgroundTintBlendMode (): BlendMode ? getBackgroundTintList [androidJvm] open fun getBackgroundTintList (): ColorStateList ? getBackgroundTintMode [androidJvm] open fun getBackgroundTintMode (): PorterDuff.Mode ? getBaseline [androidJvm] open fun getBaseline (): Int getBottom [androidJvm] fun getBottom (): Int getBottomFadingEdgeStrength [androidJvm] open fun getBottomFadingEdgeStrength (): Float getBottomPaddingOffset [androidJvm] open fun getBottomPaddingOffset (): Int getCameraDistance [androidJvm] open fun getCameraDistance (): Float getChildAt [androidJvm] open fun getChildAt (p0: Int ): View getChildCount [androidJvm] open fun getChildCount (): Int getChildDrawingOrder [androidJvm] fun getChildDrawingOrder (p0: Int ): Int open fun getChildDrawingOrder (p0: Int , p1: Int ): Int getChildStaticTransformation [androidJvm] open fun getChildStaticTransformation (p0: View , p1: Transformation ): Boolean getChildVisibleRect [androidJvm] open override fun getChildVisibleRect (p0: View , p1: Rect , p2: Point ): Boolean getClipBounds [androidJvm] open fun getClipBounds (): Rect open fun getClipBounds (p0: Rect ): Boolean getClipChildren [androidJvm] open fun getClipChildren (): Boolean getClipToOutline [androidJvm] fun getClipToOutline (): Boolean getClipToPadding [androidJvm] open fun getClipToPadding (): Boolean getContentCaptureSession [androidJvm] fun getContentCaptureSession (): ContentCaptureSession ? getContentDescription [androidJvm] open fun getContentDescription (): CharSequence getContext [androidJvm] fun getContext (): Context getContextMenuInfo [androidJvm] open fun getContextMenuInfo (): ContextMenu.ContextMenuInfo getDefaultFocusHighlightEnabled [androidJvm] fun getDefaultFocusHighlightEnabled (): Boolean getDescendantFocusability [androidJvm] open fun getDescendantFocusability (): Int getDisplay [androidJvm] open fun getDisplay (): Display getDrawableState [androidJvm] fun getDrawableState (): IntArray getDrawingRect [androidJvm] open fun getDrawingRect (p0: Rect ) getDrawingTime [androidJvm] open fun getDrawingTime (): Long getElevation [androidJvm] open fun getElevation (): Float getExplicitStyle [androidJvm] open fun getExplicitStyle (): Int getFilterTouchesWhenObscured [androidJvm] open fun getFilterTouchesWhenObscured (): Boolean getFitsSystemWindows [androidJvm] open fun getFitsSystemWindows (): Boolean getFocusable [androidJvm] open fun getFocusable (): Int getFocusables [androidJvm] open fun getFocusables (p0: Int ): ArrayList < View > getFocusedChild [androidJvm] open fun getFocusedChild (): View getFocusedRect [androidJvm] open fun getFocusedRect (p0: Rect ) getForeground [androidJvm] open fun getForeground (): Drawable getForegroundGravity [androidJvm] open fun getForegroundGravity (): Int getForegroundTintBlendMode [androidJvm] open fun getForegroundTintBlendMode (): BlendMode ? getForegroundTintList [androidJvm] open fun getForegroundTintList (): ColorStateList ? getForegroundTintMode [androidJvm] open fun getForegroundTintMode (): PorterDuff.Mode ? getGlobalVisibleRect [androidJvm] fun getGlobalVisibleRect (p0: Rect ): Boolean open fun getGlobalVisibleRect (p0: Rect , p1: Point ): Boolean getHandler [androidJvm] open fun getHandler (): Handler getHasOverlappingRendering [androidJvm] fun getHasOverlappingRendering (): Boolean getHeight [androidJvm] fun getHeight (): Int getHitRect [androidJvm] open fun getHitRect (p0: Rect ) getHorizontalFadingEdgeLength [androidJvm] open fun getHorizontalFadingEdgeLength (): Int getHorizontalScrollbarHeight [androidJvm] open fun getHorizontalScrollbarHeight (): Int getHorizontalScrollbarThumbDrawable [androidJvm] open fun getHorizontalScrollbarThumbDrawable (): Drawable ? getHorizontalScrollbarTrackDrawable [androidJvm] open fun getHorizontalScrollbarTrackDrawable (): Drawable ? getId [androidJvm] open fun getId (): Int getImportantForAccessibility [androidJvm] open fun getImportantForAccessibility (): Int getImportantForAutofill [androidJvm] open fun getImportantForAutofill (): Int getImportantForContentCapture [androidJvm] open fun getImportantForContentCapture (): Int getKeepScreenOn [androidJvm] open fun getKeepScreenOn (): Boolean getKeyDispatcherState [androidJvm] open fun getKeyDispatcherState (): KeyEvent.DispatcherState getLabelFor [androidJvm] open fun getLabelFor (): Int getLayerType [androidJvm] open fun getLayerType (): Int getLayoutAnimation [androidJvm] open fun getLayoutAnimation (): LayoutAnimationController getLayoutAnimationListener [androidJvm] open fun getLayoutAnimationListener (): Animation.AnimationListener getLayoutDirection [androidJvm] open fun getLayoutDirection (): Int getLayoutMode [androidJvm] open fun getLayoutMode (): Int getLayoutParams [androidJvm] open fun getLayoutParams (): ViewGroup.LayoutParams getLayoutTransition [androidJvm] open fun getLayoutTransition (): LayoutTransition getLeft [androidJvm] fun getLeft (): Int getLeftFadingEdgeStrength [androidJvm] open fun getLeftFadingEdgeStrength (): Float getLeftPaddingOffset [androidJvm] open fun getLeftPaddingOffset (): Int getLocalVisibleRect [androidJvm] fun getLocalVisibleRect (p0: Rect ): Boolean getLocationInSurface [androidJvm] open fun getLocationInSurface (p0: IntArray ) getLocationInWindow [androidJvm] open fun getLocationInWindow (p0: IntArray ) getLocationOnScreen [androidJvm] open fun getLocationOnScreen (p0: IntArray ) getMatrix [androidJvm] open fun getMatrix (): Matrix getMeasureAllChildren [androidJvm] open fun getMeasureAllChildren (): Boolean getMeasuredHeight [androidJvm] fun getMeasuredHeight (): Int getMeasuredHeightAndState [androidJvm] fun getMeasuredHeightAndState (): Int getMeasuredState [androidJvm] fun getMeasuredState (): Int getMeasuredWidth [androidJvm] fun getMeasuredWidth (): Int getMeasuredWidthAndState [androidJvm] fun getMeasuredWidthAndState (): Int getMinimumHeight [androidJvm] open fun getMinimumHeight (): Int getMinimumWidth [androidJvm] open fun getMinimumWidth (): Int getNestedScrollAxes [androidJvm] open fun getNestedScrollAxes (): Int getNextClusterForwardId [androidJvm] open fun getNextClusterForwardId (): Int getNextFocusDownId [androidJvm] open fun getNextFocusDownId (): Int getNextFocusForwardId [androidJvm] open fun getNextFocusForwardId (): Int getNextFocusLeftId [androidJvm] open fun getNextFocusLeftId (): Int getNextFocusRightId [androidJvm] open fun getNextFocusRightId (): Int getNextFocusUpId [androidJvm] open fun getNextFocusUpId (): Int getOnFocusChangeListener [androidJvm] open fun getOnFocusChangeListener (): View.OnFocusChangeListener getOutlineAmbientShadowColor [androidJvm] open fun getOutlineAmbientShadowColor (): Int getOutlineProvider [androidJvm] open fun getOutlineProvider (): ViewOutlineProvider getOutlineSpotShadowColor [androidJvm] open fun getOutlineSpotShadowColor (): Int getOverlay [androidJvm] open override fun getOverlay (): ViewGroupOverlay getOverScrollMode [androidJvm] open fun getOverScrollMode (): Int getPaddingBottom [androidJvm] open fun getPaddingBottom (): Int getPaddingEnd [androidJvm] open fun getPaddingEnd (): Int getPaddingLeft [androidJvm] open fun getPaddingLeft (): Int getPaddingRight [androidJvm] open fun getPaddingRight (): Int getPaddingStart [androidJvm] open fun getPaddingStart (): Int getPaddingTop [androidJvm] open fun getPaddingTop (): Int getParent [androidJvm] fun getParent (): ViewParent getParentForAccessibility [androidJvm] open fun getParentForAccessibility (): ViewParent getPivotX [androidJvm] open fun getPivotX (): Float getPivotY [androidJvm] open fun getPivotY (): Float getPointerIcon [androidJvm] open fun getPointerIcon (): PointerIcon getReceiveContentMimeTypes [androidJvm] open fun getReceiveContentMimeTypes (): Array < String >? getResources [androidJvm] open fun getResources (): Resources getRevealOnFocusHint [androidJvm] fun getRevealOnFocusHint (): Boolean getRight [androidJvm] fun getRight (): Int getRightFadingEdgeStrength [androidJvm] open fun getRightFadingEdgeStrength (): Float getRightPaddingOffset [androidJvm] open fun getRightPaddingOffset (): Int getRootSurfaceControl [androidJvm] open fun getRootSurfaceControl (): AttachedSurfaceControl ? getRootView [androidJvm] open fun getRootView (): View getRootWindowInsets [androidJvm] open fun getRootWindowInsets (): WindowInsets getRotation [androidJvm] open fun getRotation (): Float getRotationX [androidJvm] open fun getRotationX (): Float getRotationY [androidJvm] open fun getRotationY (): Float getScaleX [androidJvm] open fun getScaleX (): Float getScaleY [androidJvm] open fun getScaleY (): Float getScrollBarDefaultDelayBeforeFade [androidJvm] open fun getScrollBarDefaultDelayBeforeFade (): Int getScrollBarFadeDuration [androidJvm] open fun getScrollBarFadeDuration (): Int getScrollBarSize [androidJvm] open fun getScrollBarSize (): Int getScrollBarStyle [androidJvm] open fun getScrollBarStyle (): Int getScrollCaptureHint [androidJvm] open fun getScrollCaptureHint (): Int getScrollIndicators [androidJvm] open fun getScrollIndicators (): Int getScrollX [androidJvm] fun getScrollX (): Int getScrollY [androidJvm] fun getScrollY (): Int getSolidColor [androidJvm] open fun getSolidColor (): Int getSourceLayoutResId [androidJvm] open fun getSourceLayoutResId (): Int getStateDescription [androidJvm] fun getStateDescription (): CharSequence ? getStateListAnimator [androidJvm] open fun getStateListAnimator (): StateListAnimator getSuggestedMinimumHeight [androidJvm] open fun getSuggestedMinimumHeight (): Int getSuggestedMinimumWidth [androidJvm] open fun getSuggestedMinimumWidth (): Int getSystemGestureExclusionRects [androidJvm] open fun getSystemGestureExclusionRects (): MutableList < Rect > getTag [androidJvm] open fun getTag (): Any open fun getTag (p0: Int ): Any getTextAlignment [androidJvm] open fun getTextAlignment (): Int getTextDirection [androidJvm] open fun getTextDirection (): Int getTooltipText [androidJvm] open fun getTooltipText (): CharSequence ? getTop [androidJvm] fun getTop (): Int getTopFadingEdgeStrength [androidJvm] open fun getTopFadingEdgeStrength (): Float getTopPaddingOffset [androidJvm] open fun getTopPaddingOffset (): Int getTouchables [androidJvm] open fun getTouchables (): ArrayList < View > getTouchDelegate [androidJvm] open fun getTouchDelegate (): TouchDelegate getTouchscreenBlocksFocus [androidJvm] open fun getTouchscreenBlocksFocus (): Boolean getTransitionAlpha [androidJvm] open fun getTransitionAlpha (): Float getTransitionName [androidJvm] open fun getTransitionName (): String getTranslationX [androidJvm] open fun getTranslationX (): Float getTranslationY [androidJvm] open fun getTranslationY (): Float getTranslationZ [androidJvm] open fun getTranslationZ (): Float getUniqueDrawingId [androidJvm] open fun getUniqueDrawingId (): Long getVerticalFadingEdgeLength [androidJvm] open fun getVerticalFadingEdgeLength (): Int getVerticalScrollbarPosition [androidJvm] open fun getVerticalScrollbarPosition (): Int getVerticalScrollbarThumbDrawable [androidJvm] open fun getVerticalScrollbarThumbDrawable (): Drawable ? getVerticalScrollbarTrackDrawable [androidJvm] open fun getVerticalScrollbarTrackDrawable (): Drawable ? getVerticalScrollbarWidth [androidJvm] open fun getVerticalScrollbarWidth (): Int getViewTranslationResponse [androidJvm] open fun getViewTranslationResponse (): ViewTranslationResponse ? getViewTreeObserver [androidJvm] open fun getViewTreeObserver (): ViewTreeObserver getVisibility [androidJvm] open fun getVisibility (): Int getWidth [androidJvm] fun getWidth (): Int getWindowAttachCount [androidJvm] open fun getWindowAttachCount (): Int getWindowId [androidJvm] open fun getWindowId (): WindowId getWindowInsetsController [androidJvm] open fun getWindowInsetsController (): WindowInsetsController ? getWindowToken [androidJvm] open fun getWindowToken (): IBinder getWindowVisibility [androidJvm] open fun getWindowVisibility (): Int getWindowVisibleDisplayFrame [androidJvm] open fun getWindowVisibleDisplayFrame (p0: Rect ) getX [androidJvm] open fun getX (): Float getY [androidJvm] open fun getY (): Float getZ [androidJvm] open fun getZ (): Float hasExplicitFocusable [androidJvm] open fun hasExplicitFocusable (): Boolean hasFocus [androidJvm] open override fun hasFocus (): Boolean hasFocusable [androidJvm] open fun hasFocusable (): Boolean hasNestedScrollingParent [androidJvm] open fun hasNestedScrollingParent (): Boolean hasOnClickListeners [androidJvm] open fun hasOnClickListeners (): Boolean hasOnLongClickListeners [androidJvm] open fun hasOnLongClickListeners (): Boolean hasOverlappingRendering [androidJvm] open fun hasOverlappingRendering (): Boolean hasPointerCapture [androidJvm] open fun hasPointerCapture (): Boolean hasTransientState [androidJvm] open override fun hasTransientState (): Boolean hasWindowFocus [androidJvm] open fun hasWindowFocus (): Boolean indexOfChild [androidJvm] open fun indexOfChild (p0: View ): Int invalidate [androidJvm] open fun invalidate () invalidateDrawable [androidJvm] open override fun invalidateDrawable (p0: Drawable ) invalidateOutline [androidJvm] open fun invalidateOutline () isAccessibilityFocused [androidJvm] open fun isAccessibilityFocused (): Boolean isAccessibilityHeading [androidJvm] open fun isAccessibilityHeading (): Boolean isActivated [androidJvm] open fun isActivated (): Boolean isAttachedToWindow [androidJvm] open fun isAttachedToWindow (): Boolean isChildrenDrawingOrderEnabled [androidJvm] open fun isChildrenDrawingOrderEnabled (): Boolean isClickable [androidJvm] open fun isClickable (): Boolean isContextClickable [androidJvm] open fun isContextClickable (): Boolean isDirty [androidJvm] open fun isDirty (): Boolean isDuplicateParentStateEnabled [androidJvm] open fun isDuplicateParentStateEnabled (): Boolean isEnabled [androidJvm] open fun isEnabled (): Boolean isFocusable [androidJvm] fun isFocusable (): Boolean isFocusableInTouchMode [androidJvm] fun isFocusableInTouchMode (): Boolean isFocused [androidJvm] open fun isFocused (): Boolean isFocusedByDefault [androidJvm] fun isFocusedByDefault (): Boolean isForceDarkAllowed [androidJvm] open fun isForceDarkAllowed (): Boolean isHapticFeedbackEnabled [androidJvm] open fun isHapticFeedbackEnabled (): Boolean isHardwareAccelerated [androidJvm] open fun isHardwareAccelerated (): Boolean isHorizontalFadingEdgeEnabled [androidJvm] open fun isHorizontalFadingEdgeEnabled (): Boolean isHorizontalScrollBarEnabled [androidJvm] open fun isHorizontalScrollBarEnabled (): Boolean isHovered [androidJvm] open fun isHovered (): Boolean isImportantForAccessibility [androidJvm] open fun isImportantForAccessibility (): Boolean isImportantForAutofill [androidJvm] fun isImportantForAutofill (): Boolean isImportantForContentCapture [androidJvm] fun isImportantForContentCapture (): Boolean isInEditMode [androidJvm] open fun isInEditMode (): Boolean isInLayout [androidJvm] open fun isInLayout (): Boolean isInTouchMode [androidJvm] open fun isInTouchMode (): Boolean isKeyboardNavigationCluster [androidJvm] fun isKeyboardNavigationCluster (): Boolean isLaidOut [androidJvm] open fun isLaidOut (): Boolean isLayoutDirectionResolved [androidJvm] open fun isLayoutDirectionResolved (): Boolean isLayoutRequested [androidJvm] open fun isLayoutRequested (): Boolean isLayoutSuppressed [androidJvm] open fun isLayoutSuppressed (): Boolean isLongClickable [androidJvm] open fun isLongClickable (): Boolean isMotionEventSplittingEnabled [androidJvm] open fun isMotionEventSplittingEnabled (): Boolean isNestedScrollingEnabled [androidJvm] open fun isNestedScrollingEnabled (): Boolean isOpaque [androidJvm] open fun isOpaque (): Boolean isPaddingOffsetRequired [androidJvm] open fun isPaddingOffsetRequired (): Boolean isPaddingRelative [androidJvm] open fun isPaddingRelative (): Boolean isPivotSet [androidJvm] open fun isPivotSet (): Boolean isPressed [androidJvm] open fun isPressed (): Boolean isSaveEnabled [androidJvm] open fun isSaveEnabled (): Boolean isSaveFromParentEnabled [androidJvm] open fun isSaveFromParentEnabled (): Boolean isScreenReaderFocusable [androidJvm] open fun isScreenReaderFocusable (): Boolean isScrollbarFadingEnabled [androidJvm] open fun isScrollbarFadingEnabled (): Boolean isScrollContainer [androidJvm] open fun isScrollContainer (): Boolean isSelected [androidJvm] open fun isSelected (): Boolean isShowingLayoutBounds [androidJvm] fun isShowingLayoutBounds (): Boolean isShown [androidJvm] open fun isShown (): Boolean isSoundEffectsEnabled [androidJvm] open fun isSoundEffectsEnabled (): Boolean isTemporarilyDetached [androidJvm] fun isTemporarilyDetached (): Boolean isTextAlignmentResolved [androidJvm] open fun isTextAlignmentResolved (): Boolean isTextDirectionResolved [androidJvm] open fun isTextDirectionResolved (): Boolean isTransitionGroup [androidJvm] open fun isTransitionGroup (): Boolean isVerticalFadingEdgeEnabled [androidJvm] open fun isVerticalFadingEdgeEnabled (): Boolean isVerticalScrollBarEnabled [androidJvm] open fun isVerticalScrollBarEnabled (): Boolean isVisibleToUserForAutofill [androidJvm] open fun isVisibleToUserForAutofill (p0: Int ): Boolean jumpDrawablesToCurrentState [androidJvm] open override fun jumpDrawablesToCurrentState () keyboardNavigationClusterSearch [androidJvm] open fun keyboardNavigationClusterSearch (p0: View , p1: Int ): View layout [androidJvm] override fun layout (p0: Int , p1: Int , p2: Int , p3: Int ) measure [androidJvm] fun measure (p0: Int , p1: Int ) measureChild [androidJvm] open fun measureChild (p0: View , p1: Int , p2: Int ) measureChildren [androidJvm] open fun measureChildren (p0: Int , p1: Int ) measureChildWithMargins [androidJvm] open fun measureChildWithMargins (p0: View , p1: Int , p2: Int , p3: Int , p4: Int ) notifySubtreeAccessibilityStateChanged [androidJvm] open override fun notifySubtreeAccessibilityStateChanged (p0: View , p1: View , p2: Int ) offsetDescendantRectToMyCoords [androidJvm] fun offsetDescendantRectToMyCoords (p0: View , p1: Rect ) offsetLeftAndRight [androidJvm] open fun offsetLeftAndRight (p0: Int ) offsetRectIntoDescendantCoords [androidJvm] fun offsetRectIntoDescendantCoords (p0: View , p1: Rect ) offsetTopAndBottom [androidJvm] open fun offsetTopAndBottom (p0: Int ) onAnimationEnd [androidJvm] open fun onAnimationEnd () onAnimationStart [androidJvm] open fun onAnimationStart () onApplyWindowInsets [androidJvm] open fun onApplyWindowInsets (p0: WindowInsets ): WindowInsets onAttachedToWindow [androidJvm] open override fun onAttachedToWindow () onCancelPendingInputEvents [androidJvm] open fun onCancelPendingInputEvents () onCapturedPointerEvent [androidJvm] open fun onCapturedPointerEvent (p0: MotionEvent ): Boolean onCheckIsTextEditor [androidJvm] open fun onCheckIsTextEditor (): Boolean onConfigurationChanged [androidJvm] open fun onConfigurationChanged (p0: Configuration ) onCreateContextMenu [androidJvm] open fun onCreateContextMenu (p0: ContextMenu ) onCreateDrawableState [androidJvm] open override fun onCreateDrawableState (p0: Int ): IntArray onCreateInputConnection [androidJvm] open fun onCreateInputConnection (p0: EditorInfo ): InputConnection onCreateViewTranslationRequest [androidJvm] open fun onCreateViewTranslationRequest (p0: IntArray , p1: Consumer < ViewTranslationRequest >) onCreateVirtualViewTranslationRequests [androidJvm] open fun onCreateVirtualViewTranslationRequests (p0: LongArray , p1: IntArray , p2: Consumer < ViewTranslationRequest >) onDescendantInvalidated [androidJvm] open override fun onDescendantInvalidated (p0: View , p1: View ) onDetachedFromWindow [androidJvm] open override fun onDetachedFromWindow () onDisplayHint [androidJvm] open fun onDisplayHint (p0: Int ) onDragEvent [androidJvm] open fun onDragEvent (p0: DragEvent ): Boolean onDraw [androidJvm] open fun onDraw (p0: Canvas ) onDrawForeground [androidJvm] open fun onDrawForeground (p0: Canvas ) onDrawScrollBars [androidJvm] fun onDrawScrollBars (p0: Canvas ) onFilterTouchEventForSecurity [androidJvm] open fun onFilterTouchEventForSecurity (p0: MotionEvent ): Boolean onFinishInflate [androidJvm] open fun onFinishInflate () onFinishTemporaryDetach [androidJvm] open fun onFinishTemporaryDetach () onFocusChanged [androidJvm] open fun onFocusChanged (p0: Boolean , p1: Int , p2: Rect ?) onGenericMotionEvent [androidJvm] open fun onGenericMotionEvent (p0: MotionEvent ): Boolean onHoverChanged [androidJvm] open fun onHoverChanged (p0: Boolean ) onHoverEvent [androidJvm] open fun onHoverEvent (p0: MotionEvent ): Boolean onInitializeAccessibilityEvent [androidJvm] open fun onInitializeAccessibilityEvent (p0: AccessibilityEvent ) onInitializeAccessibilityNodeInfo [androidJvm] open fun onInitializeAccessibilityNodeInfo (p0: AccessibilityNodeInfo ) onInterceptHoverEvent [androidJvm] open fun onInterceptHoverEvent (p0: MotionEvent ): Boolean onInterceptTouchEvent [androidJvm] open fun onInterceptTouchEvent (p0: MotionEvent ): Boolean onKeyDown [androidJvm] open override fun onKeyDown (p0: Int , p1: KeyEvent ): Boolean onKeyLongPress [androidJvm] open override fun onKeyLongPress (p0: Int , p1: KeyEvent ): Boolean onKeyMultiple [androidJvm] open override fun onKeyMultiple (p0: Int , p1: Int , p2: KeyEvent ): Boolean onKeyPreIme [androidJvm] open fun onKeyPreIme (p0: Int , p1: KeyEvent ): Boolean onKeyShortcut [androidJvm] open fun onKeyShortcut (p0: Int , p1: KeyEvent ): Boolean onKeyUp [androidJvm] open override fun onKeyUp (p0: Int , p1: KeyEvent ): Boolean onLayout [androidJvm] open override fun onLayout (p0: Boolean , p1: Int , p2: Int , p3: Int , p4: Int ) onMeasure [androidJvm] open override fun onMeasure (p0: Int , p1: Int ) onNestedFling [androidJvm] open override fun onNestedFling (p0: View , p1: Float , p2: Float , p3: Boolean ): Boolean onNestedPreFling [androidJvm] open override fun onNestedPreFling (p0: View , p1: Float , p2: Float ): Boolean onNestedPrePerformAccessibilityAction [androidJvm] open override fun onNestedPrePerformAccessibilityAction (p0: View , p1: Int , p2: Bundle ): Boolean onNestedPreScroll [androidJvm] open override fun onNestedPreScroll (p0: View , p1: Int , p2: Int , p3: IntArray ) onNestedScroll [androidJvm] open override fun onNestedScroll (p0: View , p1: Int , p2: Int , p3: Int , p4: Int ) onNestedScrollAccepted [androidJvm] open override fun onNestedScrollAccepted (p0: View , p1: View , p2: Int ) onOverScrolled [androidJvm] open fun onOverScrolled (p0: Int , p1: Int , p2: Boolean , p3: Boolean ) onPointerCaptureChange [androidJvm] open fun onPointerCaptureChange (p0: Boolean ) onPopulateAccessibilityEvent [androidJvm] open fun onPopulateAccessibilityEvent (p0: AccessibilityEvent ) onProvideAutofillStructure [androidJvm] open fun onProvideAutofillStructure (p0: ViewStructure , p1: Int ) onProvideAutofillVirtualStructure [androidJvm] open fun onProvideAutofillVirtualStructure (p0: ViewStructure , p1: Int ) onProvideContentCaptureStructure [androidJvm] open fun onProvideContentCaptureStructure (p0: ViewStructure , p1: Int ) onProvideStructure [androidJvm] open fun onProvideStructure (p0: ViewStructure ) onProvideVirtualStructure [androidJvm] open fun onProvideVirtualStructure (p0: ViewStructure ) onReceiveContent [androidJvm] open fun onReceiveContent (p0: ContentInfo ): ContentInfo ? onRequestFocusInDescendants [androidJvm] open fun onRequestFocusInDescendants (p0: Int , p1: Rect ): Boolean onRequestSendAccessibilityEvent [androidJvm] open fun onRequestSendAccessibilityEvent (p0: View , p1: AccessibilityEvent ): Boolean onResolvePointerIcon [androidJvm] open override fun onResolvePointerIcon (p0: MotionEvent , p1: Int ): PointerIcon onRtlPropertiesChanged [androidJvm] open fun onRtlPropertiesChanged (p0: Int ) onScreenStateChanged [androidJvm] open fun onScreenStateChanged (p0: Int ) onScrollCaptureSearch [androidJvm] open fun onScrollCaptureSearch (p0: Rect , p1: Point , p2: Consumer < ScrollCaptureTarget >) onScrollChanged [androidJvm] open fun onScrollChanged (p0: Int , p1: Int , p2: Int , p3: Int ) onSetAlpha [androidJvm] open fun onSetAlpha (p0: Int ): Boolean onSizeChanged [androidJvm] open fun onSizeChanged (p0: Int , p1: Int , p2: Int , p3: Int ) onStartNestedScroll [androidJvm] open override fun onStartNestedScroll (p0: View , p1: View , p2: Int ): Boolean onStartTemporaryDetach [androidJvm] open fun onStartTemporaryDetach () onStopNestedScroll [androidJvm] open override fun onStopNestedScroll (p0: View ) onTouchEvent [androidJvm] open fun onTouchEvent (p0: MotionEvent ): Boolean onTrackballEvent [androidJvm] open fun onTrackballEvent (p0: MotionEvent ): Boolean onViewAdded [androidJvm] open fun onViewAdded (p0: View ) onViewRemoved [androidJvm] open fun onViewRemoved (p0: View ) onViewTranslationResponse [androidJvm] open fun onViewTranslationResponse (p0: ViewTranslationResponse ) onVirtualViewTranslationResponses [androidJvm] open fun onVirtualViewTranslationResponses (p0: LongSparseArray < ViewTranslationResponse >) onVisibilityAggregated [androidJvm] open fun onVisibilityAggregated (p0: Boolean ) onVisibilityChanged [androidJvm] open fun onVisibilityChanged (p0: View , p1: Int ) onWindowFocusChanged [androidJvm] open fun onWindowFocusChanged (p0: Boolean ) onWindowVisibilityChanged [androidJvm] open fun onWindowVisibilityChanged (p0: Int ) overScrollBy [androidJvm] open fun overScrollBy (p0: Int , p1: Int , p2: Int , p3: Int , p4: Int , p5: Int , p6: Int , p7: Int , p8: Boolean ): Boolean performAccessibilityAction [androidJvm] open fun performAccessibilityAction (p0: Int , p1: Bundle ): Boolean performClick [androidJvm] open fun performClick (): Boolean performContextClick [androidJvm] open fun performContextClick (): Boolean open fun performContextClick (p0: Float , p1: Float ): Boolean performHapticFeedback [androidJvm] open fun performHapticFeedback (p0: Int ): Boolean open fun performHapticFeedback (p0: Int , p1: Int ): Boolean performLongClick [androidJvm] open fun performLongClick (): Boolean open fun performLongClick (p0: Float , p1: Float ): Boolean performReceiveContent [androidJvm] open fun performReceiveContent (p0: ContentInfo ): ContentInfo ? playSoundEffect [androidJvm] open fun playSoundEffect (p0: Int ) post [androidJvm] open fun post (p0: Runnable ): Boolean postDelayed [androidJvm] open fun postDelayed (p0: Runnable , p1: Long ): Boolean postInvalidate [androidJvm] open fun postInvalidate () open fun postInvalidate (p0: Int , p1: Int , p2: Int , p3: Int ) postInvalidateDelayed [androidJvm] open fun postInvalidateDelayed (p0: Long ) open fun postInvalidateDelayed (p0: Long , p1: Int , p2: Int , p3: Int , p4: Int ) postInvalidateOnAnimation [androidJvm] open fun postInvalidateOnAnimation () open fun postInvalidateOnAnimation (p0: Int , p1: Int , p2: Int , p3: Int ) postOnAnimation [androidJvm] open fun postOnAnimation (p0: Runnable ) postOnAnimationDelayed [androidJvm] open fun postOnAnimationDelayed (p0: Runnable , p1: Long ) recomputeViewAttributes [androidJvm] open override fun recomputeViewAttributes (p0: View ) refreshDrawableState [androidJvm] open fun refreshDrawableState () releasePointerCapture [androidJvm] open fun releasePointerCapture () removeAllViews [androidJvm] open fun removeAllViews () removeAllViewsInLayout [androidJvm] open fun removeAllViewsInLayout () removeCallbacks [androidJvm] open fun removeCallbacks (p0: Runnable ): Boolean removeDetachedView [androidJvm] open fun removeDetachedView (p0: View , p1: Boolean ) removeOnAttachStateChangeListener [androidJvm] open fun removeOnAttachStateChangeListener (p0: View.OnAttachStateChangeListener ) removeOnLayoutChangeListener [androidJvm] open fun removeOnLayoutChangeListener (p0: View.OnLayoutChangeListener ) removeOnUnhandledKeyEventListener [androidJvm] open fun removeOnUnhandledKeyEventListener (p0: View.OnUnhandledKeyEventListener ) removeView [androidJvm] open override fun removeView (p0: View ) removeViewAt [androidJvm] open fun removeViewAt (p0: Int ) removeViewInLayout [androidJvm] open fun removeViewInLayout (p0: View ) removeViews [androidJvm] open fun removeViews (p0: Int , p1: Int ) removeViewsInLayout [androidJvm] open fun removeViewsInLayout (p0: Int , p1: Int ) requestApplyInsets [androidJvm] open fun requestApplyInsets () requestChildFocus [androidJvm] open override fun requestChildFocus (p0: View , p1: View ) requestChildRectangleOnScreen [androidJvm] open override fun requestChildRectangleOnScreen (p0: View , p1: Rect , p2: Boolean ): Boolean requestDisallowInterceptTouchEvent [androidJvm] open override fun requestDisallowInterceptTouchEvent (p0: Boolean ) requestFocus [androidJvm] fun requestFocus (): Boolean fun requestFocus (p0: Int ): Boolean open override fun requestFocus (p0: Int , p1: Rect ): Boolean requestFocusFromTouch [androidJvm] fun requestFocusFromTouch (): Boolean requestLayout [androidJvm] open fun requestLayout () requestPointerCapture [androidJvm] open fun requestPointerCapture () requestRectangleOnScreen [androidJvm] open fun requestRectangleOnScreen (p0: Rect ): Boolean open fun requestRectangleOnScreen (p0: Rect , p1: Boolean ): Boolean requestSendAccessibilityEvent [androidJvm] open override fun requestSendAccessibilityEvent (p0: View , p1: AccessibilityEvent ): Boolean requestTransparentRegion [androidJvm] open override fun requestTransparentRegion (p0: View ) requestUnbufferedDispatch [androidJvm] fun requestUnbufferedDispatch (p0: MotionEvent ) fun requestUnbufferedDispatch (p0: Int ) requireViewById [androidJvm] fun < T : View > requireViewById (p0: Int ): T resetPivot [androidJvm] open fun resetPivot () restoreDefaultFocus [androidJvm] open override fun restoreDefaultFocus (): Boolean restoreHierarchyState [androidJvm] open fun restoreHierarchyState (p0: SparseArray < Parcelable >) saveAttributeDataForStyleable [androidJvm] fun saveAttributeDataForStyleable (p0: Context , p1: IntArray , p2: AttributeSet ?, p3: TypedArray , p4: Int , p5: Int ) saveHierarchyState [androidJvm] open fun saveHierarchyState (p0: SparseArray < Parcelable >) scheduleDrawable [androidJvm] open override fun scheduleDrawable (p0: Drawable , p1: Runnable , p2: Long ) scheduleLayoutAnimation [androidJvm] open fun scheduleLayoutAnimation () scrollBy [androidJvm] open fun scrollBy (p0: Int , p1: Int ) scrollTo [androidJvm] open fun scrollTo (p0: Int , p1: Int ) sendAccessibilityEvent [androidJvm] open override fun sendAccessibilityEvent (p0: Int ) sendAccessibilityEventUnchecked [androidJvm] open override fun sendAccessibilityEventUnchecked (p0: AccessibilityEvent ) setAccessibilityDelegate [androidJvm] open fun setAccessibilityDelegate (p0: View.AccessibilityDelegate ?) setAccessibilityHeading [androidJvm] open fun setAccessibilityHeading (p0: Boolean ) setAccessibilityLiveRegion [androidJvm] open fun setAccessibilityLiveRegion (p0: Int ) setAccessibilityPaneTitle [androidJvm] open fun setAccessibilityPaneTitle (p0: CharSequence ?) setAccessibilityTraversalAfter [androidJvm] open fun setAccessibilityTraversalAfter (p0: Int ) setAccessibilityTraversalBefore [androidJvm] open fun setAccessibilityTraversalBefore (p0: Int ) setActivated [androidJvm] open fun setActivated (p0: Boolean ) setAddStatesFromChildren [androidJvm] open fun setAddStatesFromChildren (p0: Boolean ) setAllowClickWhenDisabled [androidJvm] open fun setAllowClickWhenDisabled (p0: Boolean ) setAlpha [androidJvm] open fun setAlpha (p0: Float ) setAnimation [androidJvm] open fun setAnimation (p0: Animation ) setAnimationMatrix [androidJvm] open fun setAnimationMatrix (p0: Matrix ?) setAutofillHints [androidJvm] open fun setAutofillHints (vararg p0: String ) setAutofillId [androidJvm] open fun setAutofillId (p0: AutofillId ?) setBackground [androidJvm] open fun setBackground (p0: Drawable ) setBackgroundColor [androidJvm] open fun setBackgroundColor (p0: Int ) setBackgroundResource [androidJvm] open fun setBackgroundResource (p0: Int ) setBackgroundTintBlendMode [androidJvm] open fun setBackgroundTintBlendMode (p0: BlendMode ?) setBackgroundTintList [androidJvm] open fun setBackgroundTintList (p0: ColorStateList ?) setBackgroundTintMode [androidJvm] open fun setBackgroundTintMode (p0: PorterDuff.Mode ?) setBottom [androidJvm] fun setBottom (p0: Int ) setCameraDistance [androidJvm] open fun setCameraDistance (p0: Float ) setChildrenDrawingOrderEnabled [androidJvm] open fun setChildrenDrawingOrderEnabled (p0: Boolean ) setClickable [androidJvm] open fun setClickable (p0: Boolean ) setClipBounds [androidJvm] open fun setClipBounds (p0: Rect ) setClipChildren [androidJvm] open fun setClipChildren (p0: Boolean ) setClipToOutline [androidJvm] open fun setClipToOutline (p0: Boolean ) setClipToPadding [androidJvm] open fun setClipToPadding (p0: Boolean ) setContentCaptureSession [androidJvm] open fun setContentCaptureSession (p0: ContentCaptureSession ?) setContentDescription [androidJvm] open fun setContentDescription (p0: CharSequence ) setContextClickable [androidJvm] open fun setContextClickable (p0: Boolean ) setDefaultFocusHighlightEnabled [androidJvm] open fun setDefaultFocusHighlightEnabled (p0: Boolean ) setDescendantFocusability [androidJvm] open fun setDescendantFocusability (p0: Int ) setDuplicateParentStateEnabled [androidJvm] open fun setDuplicateParentStateEnabled (p0: Boolean ) setElevation [androidJvm] open fun setElevation (p0: Float ) setEnabled [androidJvm] open fun setEnabled (p0: Boolean ) setFadingEdgeLength [androidJvm] open fun setFadingEdgeLength (p0: Int ) setFilterTouchesWhenObscured [androidJvm] open fun setFilterTouchesWhenObscured (p0: Boolean ) setFitsSystemWindows [androidJvm] open fun setFitsSystemWindows (p0: Boolean ) setFocusable [androidJvm] open fun setFocusable (p0: Boolean ) open fun setFocusable (p0: Int ) setFocusableInTouchMode [androidJvm] open fun setFocusableInTouchMode (p0: Boolean ) setFocusedByDefault [androidJvm] open fun setFocusedByDefault (p0: Boolean ) setForceDarkAllowed [androidJvm] open fun setForceDarkAllowed (p0: Boolean ) setForeground [androidJvm] open fun setForeground (p0: Drawable ) setForegroundGravity [androidJvm] open override fun setForegroundGravity (p0: Int ) setForegroundTintBlendMode [androidJvm] open fun setForegroundTintBlendMode (p0: BlendMode ?) setForegroundTintList [androidJvm] open fun setForegroundTintList (p0: ColorStateList ?) setForegroundTintMode [androidJvm] open fun setForegroundTintMode (p0: PorterDuff.Mode ?) setHapticFeedbackEnabled [androidJvm] open fun setHapticFeedbackEnabled (p0: Boolean ) setHasTransientState [androidJvm] open fun setHasTransientState (p0: Boolean ) setHorizontalFadingEdgeEnabled [androidJvm] open fun setHorizontalFadingEdgeEnabled (p0: Boolean ) setHorizontalScrollBarEnabled [androidJvm] open fun setHorizontalScrollBarEnabled (p0: Boolean ) setHorizontalScrollbarThumbDrawable [androidJvm] open fun setHorizontalScrollbarThumbDrawable (p0: Drawable ?) setHorizontalScrollbarTrackDrawable [androidJvm] open fun setHorizontalScrollbarTrackDrawable (p0: Drawable ?) setHovered [androidJvm] open fun setHovered (p0: Boolean ) setId [androidJvm] open fun setId (p0: Int ) setImportantForAccessibility [androidJvm] open fun setImportantForAccessibility (p0: Int ) setImportantForAutofill [androidJvm] open fun setImportantForAutofill (p0: Int ) setImportantForContentCapture [androidJvm] open fun setImportantForContentCapture (p0: Int ) setKeepScreenOn [androidJvm] open fun setKeepScreenOn (p0: Boolean ) setKeyboardNavigationCluster [androidJvm] open fun setKeyboardNavigationCluster (p0: Boolean ) setLabelFor [androidJvm] open fun setLabelFor (p0: Int ) setLayerPaint [androidJvm] open fun setLayerPaint (p0: Paint ?) setLayerType [androidJvm] open fun setLayerType (p0: Int , p1: Paint ?) setLayoutAnimation [androidJvm] open fun setLayoutAnimation (p0: LayoutAnimationController ) setLayoutAnimationListener [androidJvm] open fun setLayoutAnimationListener (p0: Animation.AnimationListener ) setLayoutDirection [androidJvm] open fun setLayoutDirection (p0: Int ) setLayoutMode [androidJvm] open fun setLayoutMode (p0: Int ) setLayoutParams [androidJvm] open fun setLayoutParams (p0: ViewGroup.LayoutParams ) setLayoutTransition [androidJvm] open fun setLayoutTransition (p0: LayoutTransition ) setLeft [androidJvm] fun setLeft (p0: Int ) setLeftTopRightBottom [androidJvm] fun setLeftTopRightBottom (p0: Int , p1: Int , p2: Int , p3: Int ) setLongClickable [androidJvm] open fun setLongClickable (p0: Boolean ) setMeasureAllChildren [androidJvm] open fun setMeasureAllChildren (p0: Boolean ) setMeasuredDimension [androidJvm] fun setMeasuredDimension (p0: Int , p1: Int ) setMinimumHeight [androidJvm] open fun setMinimumHeight (p0: Int ) setMinimumWidth [androidJvm] open fun setMinimumWidth (p0: Int ) setMotionEventSplittingEnabled [androidJvm] open fun setMotionEventSplittingEnabled (p0: Boolean ) setNestedScrollingEnabled [androidJvm] open fun setNestedScrollingEnabled (p0: Boolean ) setNextClusterForwardId [androidJvm] open fun setNextClusterForwardId (p0: Int ) setNextFocusDownId [androidJvm] open fun setNextFocusDownId (p0: Int ) setNextFocusForwardId [androidJvm] open fun setNextFocusForwardId (p0: Int ) setNextFocusLeftId [androidJvm] open fun setNextFocusLeftId (p0: Int ) setNextFocusRightId [androidJvm] open fun setNextFocusRightId (p0: Int ) setNextFocusUpId [androidJvm] open fun setNextFocusUpId (p0: Int ) setOnApplyWindowInsetsListener [androidJvm] open fun setOnApplyWindowInsetsListener (p0: View.OnApplyWindowInsetsListener ) setOnCapturedPointerListener [androidJvm] open fun setOnCapturedPointerListener (p0: View.OnCapturedPointerListener ) setOnClickListener [androidJvm] open fun setOnClickListener (p0: View.OnClickListener ?) setOnContextClickListener [androidJvm] open fun setOnContextClickListener (p0: View.OnContextClickListener ?) setOnCreateContextMenuListener [androidJvm] open fun setOnCreateContextMenuListener (p0: View.OnCreateContextMenuListener ) setOnDragListener [androidJvm] open fun setOnDragListener (p0: View.OnDragListener ) setOnFocusChangeListener [androidJvm] open fun setOnFocusChangeListener (p0: View.OnFocusChangeListener ) setOnGenericMotionListener [androidJvm] open fun setOnGenericMotionListener (p0: View.OnGenericMotionListener ) setOnHierarchyChangeListener [androidJvm] open fun setOnHierarchyChangeListener (p0: ViewGroup.OnHierarchyChangeListener ) setOnHoverListener [androidJvm] open fun setOnHoverListener (p0: View.OnHoverListener ) setOnKeyListener [androidJvm] open fun setOnKeyListener (p0: View.OnKeyListener ) setOnLongClickListener [androidJvm] open fun setOnLongClickListener (p0: View.OnLongClickListener ?) setOnReceiveContentListener [androidJvm] open fun setOnReceiveContentListener (p0: Array < String >?, p1: OnReceiveContentListener ?) setOnScrollChangeListener [androidJvm] open fun setOnScrollChangeListener (p0: View.OnScrollChangeListener ) setOnTouchListener [androidJvm] open fun setOnTouchListener (p0: View.OnTouchListener ) setOutlineAmbientShadowColor [androidJvm] open fun setOutlineAmbientShadowColor (p0: Int ) setOutlineProvider [androidJvm] open fun setOutlineProvider (p0: ViewOutlineProvider ) setOutlineSpotShadowColor [androidJvm] open fun setOutlineSpotShadowColor (p0: Int ) setOverScrollMode [androidJvm] open fun setOverScrollMode (p0: Int ) setPadding [androidJvm] open fun setPadding (p0: Int , p1: Int , p2: Int , p3: Int ) setPaddingRelative [androidJvm] open fun setPaddingRelative (p0: Int , p1: Int , p2: Int , p3: Int ) setPivotX [androidJvm] open fun setPivotX (p0: Float ) setPivotY [androidJvm] open fun setPivotY (p0: Float ) setPointerIcon [androidJvm] open fun setPointerIcon (p0: PointerIcon ) setPressed [androidJvm] open fun setPressed (p0: Boolean ) setRenderEffect [androidJvm] open fun setRenderEffect (p0: RenderEffect ?) setRevealOnFocusHint [androidJvm] fun setRevealOnFocusHint (p0: Boolean ) setRight [androidJvm] fun setRight (p0: Int ) setRotation [androidJvm] open fun setRotation (p0: Float ) setRotationX [androidJvm] open fun setRotationX (p0: Float ) setRotationY [androidJvm] open fun setRotationY (p0: Float ) setSaveEnabled [androidJvm] open fun setSaveEnabled (p0: Boolean ) setSaveFromParentEnabled [androidJvm] open fun setSaveFromParentEnabled (p0: Boolean ) setScaleX [androidJvm] open fun setScaleX (p0: Float ) setScaleY [androidJvm] open fun setScaleY (p0: Float ) setScreenReaderFocusable [androidJvm] open fun setScreenReaderFocusable (p0: Boolean ) setScrollBarDefaultDelayBeforeFade [androidJvm] open fun setScrollBarDefaultDelayBeforeFade (p0: Int ) setScrollBarFadeDuration [androidJvm] open fun setScrollBarFadeDuration (p0: Int ) setScrollbarFadingEnabled [androidJvm] open fun setScrollbarFadingEnabled (p0: Boolean ) setScrollBarSize [androidJvm] open fun setScrollBarSize (p0: Int ) setScrollBarStyle [androidJvm] open fun setScrollBarStyle (p0: Int ) setScrollCaptureCallback [androidJvm] fun setScrollCaptureCallback (p0: ScrollCaptureCallback ?) setScrollCaptureHint [androidJvm] open fun setScrollCaptureHint (p0: Int ) setScrollContainer [androidJvm] open fun setScrollContainer (p0: Boolean ) setScrollIndicators [androidJvm] open fun setScrollIndicators (p0: Int ) open fun setScrollIndicators (p0: Int , p1: Int ) setScrollX [androidJvm] open fun setScrollX (p0: Int ) setScrollY [androidJvm] open fun setScrollY (p0: Int ) setSelected [androidJvm] open fun setSelected (p0: Boolean ) setSoundEffectsEnabled [androidJvm] open fun setSoundEffectsEnabled (p0: Boolean ) setStateDescription [androidJvm] open fun setStateDescription (p0: CharSequence ?) setStateListAnimator [androidJvm] open fun setStateListAnimator (p0: StateListAnimator ) setStaticTransformationsEnabled [androidJvm] open fun setStaticTransformationsEnabled (p0: Boolean ) setSystemGestureExclusionRects [androidJvm] open fun setSystemGestureExclusionRects (p0: MutableList < Rect >) setTag [androidJvm] open fun setTag (p0: Any ) open fun setTag (p0: Int , p1: Any ) setTextAlignment [androidJvm] open fun setTextAlignment (p0: Int ) setTextDirection [androidJvm] open fun setTextDirection (p0: Int ) setTooltipText [androidJvm] open fun setTooltipText (p0: CharSequence ?) setTop [androidJvm] fun setTop (p0: Int ) setTouchDelegate [androidJvm] open fun setTouchDelegate (p0: TouchDelegate ) setTouchscreenBlocksFocus [androidJvm] open fun setTouchscreenBlocksFocus (p0: Boolean ) setTransitionAlpha [androidJvm] open fun setTransitionAlpha (p0: Float ) setTransitionGroup [androidJvm] open fun setTransitionGroup (p0: Boolean ) setTransitionName [androidJvm] fun setTransitionName (p0: String ) setTransitionVisibility [androidJvm] open fun setTransitionVisibility (p0: Int ) setTranslationX [androidJvm] open fun setTranslationX (p0: Float ) setTranslationY [androidJvm] open fun setTranslationY (p0: Float ) setTranslationZ [androidJvm] open fun setTranslationZ (p0: Float ) setVerticalFadingEdgeEnabled [androidJvm] open fun setVerticalFadingEdgeEnabled (p0: Boolean ) setVerticalScrollBarEnabled [androidJvm] open fun setVerticalScrollBarEnabled (p0: Boolean ) setVerticalScrollbarPosition [androidJvm] open fun setVerticalScrollbarPosition (p0: Int ) setVerticalScrollbarThumbDrawable [androidJvm] open fun setVerticalScrollbarThumbDrawable (p0: Drawable ?) setVerticalScrollbarTrackDrawable [androidJvm] open fun setVerticalScrollbarTrackDrawable (p0: Drawable ?) setViewTranslationCallback [androidJvm] open fun setViewTranslationCallback (p0: ViewTranslationCallback ) setVisibility [androidJvm] open fun setVisibility (p0: Int ) setWillNotDraw [androidJvm] open fun setWillNotDraw (p0: Boolean ) setWindowInsetsAnimationCallback [androidJvm] open override fun setWindowInsetsAnimationCallback (p0: WindowInsetsAnimation.Callback ?) setX [androidJvm] open fun setX (p0: Float ) setY [androidJvm] open fun setY (p0: Float ) setZ [androidJvm] open fun setZ (p0: Float ) shouldDelayChildPressedState [androidJvm] open override fun shouldDelayChildPressedState (): Boolean showContextMenu [androidJvm] open fun showContextMenu (): Boolean open fun showContextMenu (p0: Float , p1: Float ): Boolean showContextMenuForChild [androidJvm] open override fun showContextMenuForChild (p0: View ): Boolean open override fun showContextMenuForChild (p0: View , p1: Float , p2: Float ): Boolean startActionMode [androidJvm] open fun startActionMode (p0: ActionMode.Callback ): ActionMode open fun startActionMode (p0: ActionMode.Callback , p1: Int ): ActionMode startActionModeForChild [androidJvm] open override fun startActionModeForChild (p0: View , p1: ActionMode.Callback ): ActionMode open override fun startActionModeForChild (p0: View , p1: ActionMode.Callback , p2: Int ): ActionMode startAnimation [androidJvm] open fun startAnimation (p0: Animation ) startDragAndDrop [androidJvm] fun startDragAndDrop (p0: ClipData , p1: View.DragShadowBuilder , p2: Any , p3: Int ): Boolean startLayoutAnimation [androidJvm] open fun startLayoutAnimation () startNestedScroll [androidJvm] open fun startNestedScroll (p0: Int ): Boolean startViewTransition [androidJvm] open fun startViewTransition (p0: View ) stopNestedScroll [androidJvm] open fun stopNestedScroll () suppressLayout [androidJvm] open fun suppressLayout (p0: Boolean ) toString [androidJvm] open override fun toString (): String transformMatrixToGlobal [androidJvm] open fun transformMatrixToGlobal (p0: Matrix ) transformMatrixToLocal [androidJvm] open fun transformMatrixToLocal (p0: Matrix ) unscheduleDrawable [androidJvm] open fun unscheduleDrawable (p0: Drawable ) open override fun unscheduleDrawable (p0: Drawable , p1: Runnable ) updateDragShadow [androidJvm] fun updateDragShadow (p0: View.DragShadowBuilder ) updateViewLayout [androidJvm] open override fun updateViewLayout (p0: View , p1: ViewGroup.LayoutParams ) verifyDrawable [androidJvm] open fun verifyDrawable (p0: Drawable ): Boolean willNotDraw [androidJvm] open fun willNotDraw (): Boolean","title":"Functions"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-modal-view-container/-modal-view-container/","text":"// workflow / com.squareup.workflow1.ui.modal / ModalViewContainer / ModalViewContainer ModalViewContainer \u00b6 [androidJvm]\\ @ JvmOverloads fun ModalViewContainer (context: Context , attributeSet: AttributeSet ? = null, defStyle: Int = 0, defStyleRes: Int = 0)","title":" modal view container"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-modal-view-container/-modal-view-container/#modalviewcontainer","text":"[androidJvm]\\ @ JvmOverloads fun ModalViewContainer (context: Context , attributeSet: AttributeSet ? = null, defStyle: Int = 0, defStyleRes: Int = 0)","title":"ModalViewContainer"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-modal-view-container/build-dialog-for-view/","text":"// workflow / com.squareup.workflow1.ui.modal / ModalViewContainer / buildDialogForView buildDialogForView \u00b6 [androidJvm]\\ open fun buildDialogForView (view: View ): Dialog Called from buildDialog. Builds (but does not show) the Dialog to display a view built via ViewRegistry . Subclasses may override completely to build their own kind of Dialog , there is no need to call super.","title":"Build dialog for view"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-modal-view-container/build-dialog-for-view/#builddialogforview","text":"[androidJvm]\\ open fun buildDialogForView (view: View ): Dialog Called from buildDialog. Builds (but does not show) the Dialog to display a view built via ViewRegistry . Subclasses may override completely to build their own kind of Dialog , there is no need to call super.","title":"buildDialogForView"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-modal-view-container/-companion/","text":"// workflow / com.squareup.workflow1.ui.modal / ModalViewContainer / Companion Companion \u00b6 [androidJvm]\\ object Companion Functions \u00b6 Name Summary binding [androidJvm] inline fun < H : HasModals<*, *>> binding (@ IdRes id: Int = View.NO_ID): ViewFactory < H > Creates a ViewFactory for modal container screens of type H .","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-modal-view-container/-companion/#companion","text":"[androidJvm]\\ object Companion","title":"Companion"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-modal-view-container/-companion/#functions","text":"Name Summary binding [androidJvm] inline fun < H : HasModals<*, *>> binding (@ IdRes id: Int = View.NO_ID): ViewFactory < H > Creates a ViewFactory for modal container screens of type H .","title":"Functions"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-modal-view-container/-companion/binding/","text":"// workflow / com.squareup.workflow1.ui.modal / ModalViewContainer / Companion / binding binding \u00b6 [androidJvm]\\ inline fun < H : HasModals<*, *>> binding (@ IdRes id: Int = View.NO_ID): ViewFactory < H > Creates a ViewFactory for modal container screens of type H . Each view created for HasModals.modals will be shown in a Dialog whose window is set to size itself to WRAP_CONTENT (see android.view.Window.setLayout ). Parameters \u00b6 androidJvm id a unique identifier for containers of this type, allowing them to participate view persistence","title":"Binding"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-modal-view-container/-companion/binding/#binding","text":"[androidJvm]\\ inline fun < H : HasModals<*, *>> binding (@ IdRes id: Int = View.NO_ID): ViewFactory < H > Creates a ViewFactory for modal container screens of type H . Each view created for HasModals.modals will be shown in a Dialog whose window is set to size itself to WRAP_CONTENT (see android.view.Window.setLayout ).","title":"binding"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.modal/-modal-view-container/-companion/binding/#parameters","text":"androidJvm id a unique identifier for containers of this type, allowing them to participate view persistence","title":"Parameters"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.radiography/","text":"// workflow / com.squareup.workflow1.ui.radiography Package com.squareup.workflow1.ui.radiography \u00b6 Properties \u00b6 Name Summary WorkflowViewRenderer [androidJvm] val ViewStateRenderers. WorkflowViewRenderer : ViewStateRenderer Renders information about views that were created by view factories, i.e. views with associated rendering tags.","title":"Index"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.radiography/#package-comsquareupworkflow1uiradiography","text":"","title":"Package com.squareup.workflow1.ui.radiography"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.radiography/#properties","text":"Name Summary WorkflowViewRenderer [androidJvm] val ViewStateRenderers. WorkflowViewRenderer : ViewStateRenderer Renders information about views that were created by view factories, i.e. views with associated rendering tags.","title":"Properties"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.radiography/-workflow-view-renderer/","text":"// workflow / com.squareup.workflow1.ui.radiography / WorkflowViewRenderer WorkflowViewRenderer \u00b6 [androidJvm]\\ val ViewStateRenderers. WorkflowViewRenderer : ViewStateRenderer Renders information about views that were created by view factories, i.e. views with associated rendering tags.","title":" workflow view renderer"},{"location":"kotlin/api/workflow/com.squareup.workflow1.ui.radiography/-workflow-view-renderer/#workflowviewrenderer","text":"[androidJvm]\\ val ViewStateRenderers. WorkflowViewRenderer : ViewStateRenderer Renders information about views that were created by view factories, i.e. views with associated rendering tags.","title":"WorkflowViewRenderer"},{"location":"sequence_diagrams/","text":"Sequence Diagrams \u00b6 These are the source files used to generate the sequence diagrams via WebSequenceDiagrams .","title":"Sequence Diagrams"},{"location":"sequence_diagrams/#sequence-diagrams","text":"These are the source files used to generate the sequence diagrams via WebSequenceDiagrams .","title":"Sequence Diagrams"},{"location":"swift/api/Workflow/","text":"Reference Documentation \u00b6 Protocols \u00b6 AnyWorkflowConvertible Workflow WorkflowAction WorkflowDebugger Structs \u00b6 AnyWorkflow AnyWorkflowAction Sink WorkflowHierarchyDebugSnapshot WorkflowHierarchyDebugSnapshot.Child WorkflowUpdateDebugInfo Classes \u00b6 Lifetime RenderContext WorkflowHost Enums \u00b6 WorkflowUpdateDebugInfo.Kind WorkflowUpdateDebugInfo.Source Extensions \u00b6 AnyWorkflow AnyWorkflowAction AnyWorkflowConvertible RenderContext Workflow WorkflowUpdateDebugInfo.Kind WorkflowUpdateDebugInfo.Source This file was generated by SourceDocs on 2022-01-27 21:10:06 +0000","title":"Workflow "},{"location":"swift/api/Workflow/#reference-documentation","text":"","title":"Reference Documentation"},{"location":"swift/api/Workflow/#protocols","text":"AnyWorkflowConvertible Workflow WorkflowAction WorkflowDebugger","title":"Protocols"},{"location":"swift/api/Workflow/#structs","text":"AnyWorkflow AnyWorkflowAction Sink WorkflowHierarchyDebugSnapshot WorkflowHierarchyDebugSnapshot.Child WorkflowUpdateDebugInfo","title":"Structs"},{"location":"swift/api/Workflow/#classes","text":"Lifetime RenderContext WorkflowHost","title":"Classes"},{"location":"swift/api/Workflow/#enums","text":"WorkflowUpdateDebugInfo.Kind WorkflowUpdateDebugInfo.Source","title":"Enums"},{"location":"swift/api/Workflow/#extensions","text":"AnyWorkflow AnyWorkflowAction AnyWorkflowConvertible RenderContext Workflow WorkflowUpdateDebugInfo.Kind WorkflowUpdateDebugInfo.Source This file was generated by SourceDocs on 2022-01-27 21:10:06 +0000","title":"Extensions"},{"location":"swift/api/Workflow/classes/Lifetime/","text":"CLASS Lifetime \u00b6 public final class Lifetime Represents the lifetime of an object. Once ended, the onEnded closure is called. Properties \u00b6 hasEnded \u00b6 public private ( set ) var hasEnded : Bool = false Methods \u00b6 onEnded(_:) \u00b6 public func onEnded ( _ action : @ escaping () -> Void ) Hook to clean-up after end of lifetime . deinit \u00b6 deinit","title":"Lifetime"},{"location":"swift/api/Workflow/classes/Lifetime/#lifetime","text":"public final class Lifetime Represents the lifetime of an object. Once ended, the onEnded closure is called.","title":"Lifetime"},{"location":"swift/api/Workflow/classes/Lifetime/#properties","text":"","title":"Properties"},{"location":"swift/api/Workflow/classes/Lifetime/#hasended","text":"public private ( set ) var hasEnded : Bool = false","title":"hasEnded"},{"location":"swift/api/Workflow/classes/Lifetime/#methods","text":"","title":"Methods"},{"location":"swift/api/Workflow/classes/Lifetime/#onended_","text":"public func onEnded ( _ action : @ escaping () -> Void ) Hook to clean-up after end of lifetime .","title":"onEnded(_:)"},{"location":"swift/api/Workflow/classes/Lifetime/#deinit","text":"deinit","title":"deinit"},{"location":"swift/api/Workflow/classes/RenderContext/","text":"CLASS RenderContext \u00b6 public class RenderContext < WorkflowType : Workflow >: RenderContextType RenderContext is the composition point for the workflow tree. During a render pass, a workflow may want to defer to a child workflow to render some portion of its content. For example, a workflow that renders to a split-screen view model might delegate to child A for the left side, and child B for the right side view models. Nesting allows for a fractal tree that is constructed out of many small parts. If a parent wants to delegate to a child workflow, it must first create an instance of that workflow. This can be thought of as the model of the child workflow. It does not contain any active state, it simply contains the data necessary to create or update a workflow node. The parent then calls render(workflow:outputMap:) with two values: - The child workflow. - A closure that transforms the child\u2019s output events into the parent\u2019s Event type so that the parent can respond to events generated by the child. If the parent had previously rendered a child of the same type, the existing child workflow node is updated. If the parent had not rendered a child of the same type in the previous render pass, a new child workflow node is generated. The infrastructure then performs a render pass on the child to obtain its Rendering value, which is then returned to the caller. Methods \u00b6 makeSink(of:) \u00b6 public func makeSink < Action >( of actionType : Action . Type ) -> Sink < Action > where Action : WorkflowAction , Action . WorkflowType == WorkflowType runSideEffect(key:action:) \u00b6 public func runSideEffect ( key : AnyHashable , action : ( Lifetime ) -> Void ) Execute a side-effect action. Note that it is a programmer error to run two side-effects with the same key during the same render pass. action will be executed the first time a side-effect is run with a given key . runSideEffect calls with a given key on subsequent renders are ignored. If after a render pass, a side-effect with a key that was previously used is not used, it\u2019s lifetime ends and the Lifetime object\u2019s onEnded closure will be called. Parameters: key: represents the block of work that needs to be executed. action: a block of work that will be executed. Parameters \u00b6 Name Description key represents the block of work that needs to be executed. action a block of work that will be executed.","title":"RenderContext"},{"location":"swift/api/Workflow/classes/RenderContext/#rendercontext","text":"public class RenderContext < WorkflowType : Workflow >: RenderContextType RenderContext is the composition point for the workflow tree. During a render pass, a workflow may want to defer to a child workflow to render some portion of its content. For example, a workflow that renders to a split-screen view model might delegate to child A for the left side, and child B for the right side view models. Nesting allows for a fractal tree that is constructed out of many small parts. If a parent wants to delegate to a child workflow, it must first create an instance of that workflow. This can be thought of as the model of the child workflow. It does not contain any active state, it simply contains the data necessary to create or update a workflow node. The parent then calls render(workflow:outputMap:) with two values: - The child workflow. - A closure that transforms the child\u2019s output events into the parent\u2019s Event type so that the parent can respond to events generated by the child. If the parent had previously rendered a child of the same type, the existing child workflow node is updated. If the parent had not rendered a child of the same type in the previous render pass, a new child workflow node is generated. The infrastructure then performs a render pass on the child to obtain its Rendering value, which is then returned to the caller.","title":"RenderContext"},{"location":"swift/api/Workflow/classes/RenderContext/#methods","text":"","title":"Methods"},{"location":"swift/api/Workflow/classes/RenderContext/#makesinkof","text":"public func makeSink < Action >( of actionType : Action . Type ) -> Sink < Action > where Action : WorkflowAction , Action . WorkflowType == WorkflowType","title":"makeSink(of:)"},{"location":"swift/api/Workflow/classes/RenderContext/#runsideeffectkeyaction","text":"public func runSideEffect ( key : AnyHashable , action : ( Lifetime ) -> Void ) Execute a side-effect action. Note that it is a programmer error to run two side-effects with the same key during the same render pass. action will be executed the first time a side-effect is run with a given key . runSideEffect calls with a given key on subsequent renders are ignored. If after a render pass, a side-effect with a key that was previously used is not used, it\u2019s lifetime ends and the Lifetime object\u2019s onEnded closure will be called. Parameters: key: represents the block of work that needs to be executed. action: a block of work that will be executed.","title":"runSideEffect(key:action:)"},{"location":"swift/api/Workflow/classes/RenderContext/#parameters","text":"Name Description key represents the block of work that needs to be executed. action a block of work that will be executed.","title":"Parameters"},{"location":"swift/api/Workflow/classes/WorkflowHost/","text":"CLASS WorkflowHost \u00b6 public final class WorkflowHost < WorkflowType : Workflow > Manages an active workflow hierarchy. Properties \u00b6 rendering \u00b6 public let rendering : Property < WorkflowType . Rendering > Represents the Rendering produced by the root workflow in the hierarchy. New Rendering values are produced as state transitions occur within the hierarchy. output \u00b6 public var output : Signal < WorkflowType . Output , Never > A signal containing output events emitted by the root workflow in the hierarchy. Methods \u00b6 init(workflow:debugger:) \u00b6 public init ( workflow : WorkflowType , debugger : WorkflowDebugger ? = nil ) Initializes a new host with the given workflow at the root. Parameter workflow: The root workflow in the hierarchy Parameter debugger: An optional debugger. If provided, the host will notify the debugger of updates to the workflow hierarchy as state transitions occur. Parameters \u00b6 Name Description workflow The root workflow in the hierarchy debugger An optional debugger. If provided, the host will notify the debugger of updates to the workflow hierarchy as state transitions occur. update(workflow:) \u00b6 public func update ( workflow : WorkflowType ) Update the input for the workflow. Will cause a render pass.","title":"WorkflowHost"},{"location":"swift/api/Workflow/classes/WorkflowHost/#workflowhost","text":"public final class WorkflowHost < WorkflowType : Workflow > Manages an active workflow hierarchy.","title":"WorkflowHost"},{"location":"swift/api/Workflow/classes/WorkflowHost/#properties","text":"","title":"Properties"},{"location":"swift/api/Workflow/classes/WorkflowHost/#rendering","text":"public let rendering : Property < WorkflowType . Rendering > Represents the Rendering produced by the root workflow in the hierarchy. New Rendering values are produced as state transitions occur within the hierarchy.","title":"rendering"},{"location":"swift/api/Workflow/classes/WorkflowHost/#output","text":"public var output : Signal < WorkflowType . Output , Never > A signal containing output events emitted by the root workflow in the hierarchy.","title":"output"},{"location":"swift/api/Workflow/classes/WorkflowHost/#methods","text":"","title":"Methods"},{"location":"swift/api/Workflow/classes/WorkflowHost/#initworkflowdebugger","text":"public init ( workflow : WorkflowType , debugger : WorkflowDebugger ? = nil ) Initializes a new host with the given workflow at the root. Parameter workflow: The root workflow in the hierarchy Parameter debugger: An optional debugger. If provided, the host will notify the debugger of updates to the workflow hierarchy as state transitions occur.","title":"init(workflow:debugger:)"},{"location":"swift/api/Workflow/classes/WorkflowHost/#parameters","text":"Name Description workflow The root workflow in the hierarchy debugger An optional debugger. If provided, the host will notify the debugger of updates to the workflow hierarchy as state transitions occur.","title":"Parameters"},{"location":"swift/api/Workflow/classes/WorkflowHost/#updateworkflow","text":"public func update ( workflow : WorkflowType ) Update the input for the workflow. Will cause a render pass.","title":"update(workflow:)"},{"location":"swift/api/Workflow/enums/WorkflowUpdateDebugInfo.Kind/","text":"ENUM WorkflowUpdateDebugInfo.Kind \u00b6 public indirect enum Kind : Equatable Cases \u00b6 didUpdate(source:) \u00b6 case didUpdate ( source : Source ) childDidUpdate(_:) \u00b6 case childDidUpdate ( WorkflowUpdateDebugInfo )","title":"WorkflowUpdateDebugInfo.Kind"},{"location":"swift/api/Workflow/enums/WorkflowUpdateDebugInfo.Kind/#workflowupdatedebuginfokind","text":"public indirect enum Kind : Equatable","title":"WorkflowUpdateDebugInfo.Kind"},{"location":"swift/api/Workflow/enums/WorkflowUpdateDebugInfo.Kind/#cases","text":"","title":"Cases"},{"location":"swift/api/Workflow/enums/WorkflowUpdateDebugInfo.Kind/#didupdatesource","text":"case didUpdate ( source : Source )","title":"didUpdate(source:)"},{"location":"swift/api/Workflow/enums/WorkflowUpdateDebugInfo.Kind/#childdidupdate_","text":"case childDidUpdate ( WorkflowUpdateDebugInfo )","title":"childDidUpdate(_:)"},{"location":"swift/api/Workflow/enums/WorkflowUpdateDebugInfo.Source/","text":"ENUM WorkflowUpdateDebugInfo.Source \u00b6 public indirect enum Source : Equatable Cases \u00b6 external \u00b6 case external worker \u00b6 case worker sideEffect \u00b6 case sideEffect subtree(_:) \u00b6 case subtree ( WorkflowUpdateDebugInfo )","title":"WorkflowUpdateDebugInfo.Source"},{"location":"swift/api/Workflow/enums/WorkflowUpdateDebugInfo.Source/#workflowupdatedebuginfosource","text":"public indirect enum Source : Equatable","title":"WorkflowUpdateDebugInfo.Source"},{"location":"swift/api/Workflow/enums/WorkflowUpdateDebugInfo.Source/#cases","text":"","title":"Cases"},{"location":"swift/api/Workflow/enums/WorkflowUpdateDebugInfo.Source/#external","text":"case external","title":"external"},{"location":"swift/api/Workflow/enums/WorkflowUpdateDebugInfo.Source/#worker","text":"case worker","title":"worker"},{"location":"swift/api/Workflow/enums/WorkflowUpdateDebugInfo.Source/#sideeffect","text":"case sideEffect","title":"sideEffect"},{"location":"swift/api/Workflow/enums/WorkflowUpdateDebugInfo.Source/#subtree_","text":"case subtree ( WorkflowUpdateDebugInfo )","title":"subtree(_:)"},{"location":"swift/api/Workflow/extensions/AnyWorkflow/","text":"EXTENSION AnyWorkflow \u00b6 extension AnyWorkflow : AnyWorkflowConvertible Methods \u00b6 asAnyWorkflow() \u00b6 public func asAnyWorkflow () -> AnyWorkflow < Rendering , Output > mapOutput(_:) \u00b6 public func mapOutput < NewOutput >( _ transform : @ escaping ( Output ) -> NewOutput ) -> AnyWorkflow < Rendering , NewOutput > Returns a new AnyWorkflow whose Output type has been transformed into the given type. Parameter transform: An escaping closure that maps the original output type into the new output type. Returns: A type erased workflow with the new output type (the rendering type remains unchanged). Parameters \u00b6 Name Description transform An escaping closure that maps the original output type into the new output type. mapRendering(_:) \u00b6 public func mapRendering < NewRendering >( _ transform : @ escaping ( Rendering ) -> NewRendering ) -> AnyWorkflow < NewRendering , Output > Returns a new AnyWorkflow whose Rendering type has been transformed into the given type. Parameter transform: An escaping closure that maps the original rendering type into the new rendering type. Returns: A type erased workflow with the new rendering type (the output type remains unchanged). Parameters \u00b6 Name Description transform An escaping closure that maps the original rendering type into the new rendering type.","title":"AnyWorkflow"},{"location":"swift/api/Workflow/extensions/AnyWorkflow/#anyworkflow","text":"extension AnyWorkflow : AnyWorkflowConvertible","title":"AnyWorkflow"},{"location":"swift/api/Workflow/extensions/AnyWorkflow/#methods","text":"","title":"Methods"},{"location":"swift/api/Workflow/extensions/AnyWorkflow/#asanyworkflow","text":"public func asAnyWorkflow () -> AnyWorkflow < Rendering , Output >","title":"asAnyWorkflow()"},{"location":"swift/api/Workflow/extensions/AnyWorkflow/#mapoutput_","text":"public func mapOutput < NewOutput >( _ transform : @ escaping ( Output ) -> NewOutput ) -> AnyWorkflow < Rendering , NewOutput > Returns a new AnyWorkflow whose Output type has been transformed into the given type. Parameter transform: An escaping closure that maps the original output type into the new output type. Returns: A type erased workflow with the new output type (the rendering type remains unchanged).","title":"mapOutput(_:)"},{"location":"swift/api/Workflow/extensions/AnyWorkflow/#parameters","text":"Name Description transform An escaping closure that maps the original output type into the new output type.","title":"Parameters"},{"location":"swift/api/Workflow/extensions/AnyWorkflow/#maprendering_","text":"public func mapRendering < NewRendering >( _ transform : @ escaping ( Rendering ) -> NewRendering ) -> AnyWorkflow < NewRendering , Output > Returns a new AnyWorkflow whose Rendering type has been transformed into the given type. Parameter transform: An escaping closure that maps the original rendering type into the new rendering type. Returns: A type erased workflow with the new rendering type (the output type remains unchanged).","title":"mapRendering(_:)"},{"location":"swift/api/Workflow/extensions/AnyWorkflow/#parameters_1","text":"Name Description transform An escaping closure that maps the original rendering type into the new rendering type.","title":"Parameters"},{"location":"swift/api/Workflow/extensions/AnyWorkflowAction/","text":"EXTENSION AnyWorkflowAction \u00b6 extension AnyWorkflowAction Properties \u00b6 noAction \u00b6 public static var noAction : AnyWorkflowAction < WorkflowType > Creates a type-erased workflow action that does nothing (it leaves state unchanged and does not emit an output event). Methods \u00b6 init(sendingOutput:) \u00b6 public init ( sendingOutput output : WorkflowType . Output ) Creates a type-erased workflow action that simply sends the given output event. Parameter output: The output event to send when this action is applied. Parameters \u00b6 Name Description output The output event to send when this action is applied.","title":"AnyWorkflowAction"},{"location":"swift/api/Workflow/extensions/AnyWorkflowAction/#anyworkflowaction","text":"extension AnyWorkflowAction","title":"AnyWorkflowAction"},{"location":"swift/api/Workflow/extensions/AnyWorkflowAction/#properties","text":"","title":"Properties"},{"location":"swift/api/Workflow/extensions/AnyWorkflowAction/#noaction","text":"public static var noAction : AnyWorkflowAction < WorkflowType > Creates a type-erased workflow action that does nothing (it leaves state unchanged and does not emit an output event).","title":"noAction"},{"location":"swift/api/Workflow/extensions/AnyWorkflowAction/#methods","text":"","title":"Methods"},{"location":"swift/api/Workflow/extensions/AnyWorkflowAction/#initsendingoutput","text":"public init ( sendingOutput output : WorkflowType . Output ) Creates a type-erased workflow action that simply sends the given output event. Parameter output: The output event to send when this action is applied.","title":"init(sendingOutput:)"},{"location":"swift/api/Workflow/extensions/AnyWorkflowAction/#parameters","text":"Name Description output The output event to send when this action is applied.","title":"Parameters"},{"location":"swift/api/Workflow/extensions/AnyWorkflowConvertible/","text":"EXTENSION AnyWorkflowConvertible \u00b6 extension AnyWorkflowConvertible Methods \u00b6 mapOutput(_:) \u00b6 public func mapOutput < NewOutput >( _ transform : @ escaping ( Output ) -> NewOutput ) -> AnyWorkflow < Rendering , NewOutput > mapRendering(_:) \u00b6 public func mapRendering < NewRendering >( _ transform : @ escaping ( Rendering ) -> NewRendering ) -> AnyWorkflow < NewRendering , Output > rendered(in:key:) \u00b6 public func rendered < Parent >( in context : RenderContext < Parent >, key : String = \"\" ) -> Rendering where Output : WorkflowAction , Output . WorkflowType == Parent Creates or updates a child workflow of the given type, performs a render pass, and returns the result. Note that it is a programmer error to render two instances of a given workflow type with the same key during the same render pass. Parameter context: The context with which the workflow will be rendered. Parameter key: A string that uniquely identifies this workflow. Returns: The Rendering generated by the workflow. Parameters \u00b6 Name Description context The context with which the workflow will be rendered. key A string that uniquely identifies this workflow. rendered(in:key:outputMap:) \u00b6 public func rendered < Parent , Action >( in context : RenderContext < Parent >, key : String = \"\" , outputMap : @ escaping ( Output ) -> Action ) -> Rendering where Action : WorkflowAction , Action . WorkflowType == Parent rendered(in:key:) \u00b6 public func rendered < Parent >( in context : RenderContext < Parent >, key : String = \"\" ) -> Rendering where Output == AnyWorkflowAction < Parent > rendered(in:key:) \u00b6 public func rendered < T >( in context : RenderContext < T >, key : String = \"\" ) -> Rendering Creates or updates a child workflow of the given type, performs a render pass, and returns the result. Note that it is a programmer error to render two instances of a given workflow type with the same key during the same render pass. Parameter context: The context with which the workflow will be rendered. Parameter key: A string that uniquely identifies this workflow. Returns: The Rendering generated by the workflow. Parameters \u00b6 Name Description context The context with which the workflow will be rendered. key A string that uniquely identifies this workflow. running(in:key:outputMap:) \u00b6 public func running < Parent , Action >( in context : RenderContext < Parent >, key : String = \"\" , outputMap : @ escaping ( Output ) -> Action ) where Action : WorkflowAction , Action . WorkflowType == Parent running(in:key:) \u00b6 public func running < Parent >( in context : RenderContext < Parent >, key : String = \"\" ) where Output . WorkflowType == Parent onOutput(_:) \u00b6 public func onOutput < Parent >( _ apply : @ escaping (( inout Parent . State , Output ) -> Parent . Output ?)) -> AnyWorkflow < Rendering , AnyWorkflowAction < Parent > > Process an Output Parameter apply: On Output , mutate State as necessary and return new Output (or nil ). Parameters \u00b6 Name Description apply On Output , mutate State as necessary and return new Output (or nil ). ignoringOutput() \u00b6 public func ignoringOutput () -> AnyWorkflow < Rendering , Never > Wraps this workflow in a workflow that ignores all outputs. Returns: An AnyWorkflow with the same rendering and no output.","title":"AnyWorkflowConvertible"},{"location":"swift/api/Workflow/extensions/AnyWorkflowConvertible/#anyworkflowconvertible","text":"extension AnyWorkflowConvertible","title":"AnyWorkflowConvertible"},{"location":"swift/api/Workflow/extensions/AnyWorkflowConvertible/#methods","text":"","title":"Methods"},{"location":"swift/api/Workflow/extensions/AnyWorkflowConvertible/#mapoutput_","text":"public func mapOutput < NewOutput >( _ transform : @ escaping ( Output ) -> NewOutput ) -> AnyWorkflow < Rendering , NewOutput >","title":"mapOutput(_:)"},{"location":"swift/api/Workflow/extensions/AnyWorkflowConvertible/#maprendering_","text":"public func mapRendering < NewRendering >( _ transform : @ escaping ( Rendering ) -> NewRendering ) -> AnyWorkflow < NewRendering , Output >","title":"mapRendering(_:)"},{"location":"swift/api/Workflow/extensions/AnyWorkflowConvertible/#renderedinkey","text":"public func rendered < Parent >( in context : RenderContext < Parent >, key : String = \"\" ) -> Rendering where Output : WorkflowAction , Output . WorkflowType == Parent Creates or updates a child workflow of the given type, performs a render pass, and returns the result. Note that it is a programmer error to render two instances of a given workflow type with the same key during the same render pass. Parameter context: The context with which the workflow will be rendered. Parameter key: A string that uniquely identifies this workflow. Returns: The Rendering generated by the workflow.","title":"rendered(in:key:)"},{"location":"swift/api/Workflow/extensions/AnyWorkflowConvertible/#parameters","text":"Name Description context The context with which the workflow will be rendered. key A string that uniquely identifies this workflow.","title":"Parameters"},{"location":"swift/api/Workflow/extensions/AnyWorkflowConvertible/#renderedinkeyoutputmap","text":"public func rendered < Parent , Action >( in context : RenderContext < Parent >, key : String = \"\" , outputMap : @ escaping ( Output ) -> Action ) -> Rendering where Action : WorkflowAction , Action . WorkflowType == Parent","title":"rendered(in:key:outputMap:)"},{"location":"swift/api/Workflow/extensions/AnyWorkflowConvertible/#renderedinkey_1","text":"public func rendered < Parent >( in context : RenderContext < Parent >, key : String = \"\" ) -> Rendering where Output == AnyWorkflowAction < Parent >","title":"rendered(in:key:)"},{"location":"swift/api/Workflow/extensions/AnyWorkflowConvertible/#renderedinkey_2","text":"public func rendered < T >( in context : RenderContext < T >, key : String = \"\" ) -> Rendering Creates or updates a child workflow of the given type, performs a render pass, and returns the result. Note that it is a programmer error to render two instances of a given workflow type with the same key during the same render pass. Parameter context: The context with which the workflow will be rendered. Parameter key: A string that uniquely identifies this workflow. Returns: The Rendering generated by the workflow.","title":"rendered(in:key:)"},{"location":"swift/api/Workflow/extensions/AnyWorkflowConvertible/#parameters_1","text":"Name Description context The context with which the workflow will be rendered. key A string that uniquely identifies this workflow.","title":"Parameters"},{"location":"swift/api/Workflow/extensions/AnyWorkflowConvertible/#runninginkeyoutputmap","text":"public func running < Parent , Action >( in context : RenderContext < Parent >, key : String = \"\" , outputMap : @ escaping ( Output ) -> Action ) where Action : WorkflowAction , Action . WorkflowType == Parent","title":"running(in:key:outputMap:)"},{"location":"swift/api/Workflow/extensions/AnyWorkflowConvertible/#runninginkey","text":"public func running < Parent >( in context : RenderContext < Parent >, key : String = \"\" ) where Output . WorkflowType == Parent","title":"running(in:key:)"},{"location":"swift/api/Workflow/extensions/AnyWorkflowConvertible/#onoutput_","text":"public func onOutput < Parent >( _ apply : @ escaping (( inout Parent . State , Output ) -> Parent . Output ?)) -> AnyWorkflow < Rendering , AnyWorkflowAction < Parent > > Process an Output Parameter apply: On Output , mutate State as necessary and return new Output (or nil ).","title":"onOutput(_:)"},{"location":"swift/api/Workflow/extensions/AnyWorkflowConvertible/#parameters_2","text":"Name Description apply On Output , mutate State as necessary and return new Output (or nil ).","title":"Parameters"},{"location":"swift/api/Workflow/extensions/AnyWorkflowConvertible/#ignoringoutput","text":"public func ignoringOutput () -> AnyWorkflow < Rendering , Never > Wraps this workflow in a workflow that ignores all outputs. Returns: An AnyWorkflow with the same rendering and no output.","title":"ignoringOutput()"},{"location":"swift/api/Workflow/extensions/RenderContext/","text":"EXTENSION RenderContext \u00b6 extension RenderContext Methods \u00b6 makeSink(of:onEvent:) \u00b6 public func makeSink < Event >( of eventType : Event . Type , onEvent : @ escaping ( Event , inout WorkflowType . State ) -> WorkflowType . Output ?) -> Sink < Event > makeOutputSink() \u00b6 public func makeOutputSink () -> Sink < WorkflowType . Output > Generates a sink that allows sending the Workflow\u2019s output wrapped in an AnyWorkflowAction, allowing bypassing an intermediate action.","title":"RenderContext"},{"location":"swift/api/Workflow/extensions/RenderContext/#rendercontext","text":"extension RenderContext","title":"RenderContext"},{"location":"swift/api/Workflow/extensions/RenderContext/#methods","text":"","title":"Methods"},{"location":"swift/api/Workflow/extensions/RenderContext/#makesinkofonevent","text":"public func makeSink < Event >( of eventType : Event . Type , onEvent : @ escaping ( Event , inout WorkflowType . State ) -> WorkflowType . Output ?) -> Sink < Event >","title":"makeSink(of:onEvent:)"},{"location":"swift/api/Workflow/extensions/RenderContext/#makeoutputsink","text":"public func makeOutputSink () -> Sink < WorkflowType . Output > Generates a sink that allows sending the Workflow\u2019s output wrapped in an AnyWorkflowAction, allowing bypassing an intermediate action.","title":"makeOutputSink()"},{"location":"swift/api/Workflow/extensions/Workflow/","text":"EXTENSION Workflow \u00b6 extension Workflow Methods \u00b6 workflowDidChange(from:state:) \u00b6 public func workflowDidChange ( from previousWorkflow : Self , state : inout State ) Parameters \u00b6 Name Description previousWorkflow The workflow before the update. state The current state. makeInitialState() \u00b6 public func makeInitialState () -> State workflowDidChange(from:state:) \u00b6 public func workflowDidChange ( from previousWorkflow : Self , state : inout State ) Parameters \u00b6 Name Description previousWorkflow The workflow before the update. state The current state. asAnyWorkflow() \u00b6 public func asAnyWorkflow () -> AnyWorkflow < Rendering , Output >","title":"Workflow"},{"location":"swift/api/Workflow/extensions/Workflow/#workflow","text":"extension Workflow","title":"Workflow"},{"location":"swift/api/Workflow/extensions/Workflow/#methods","text":"","title":"Methods"},{"location":"swift/api/Workflow/extensions/Workflow/#workflowdidchangefromstate","text":"public func workflowDidChange ( from previousWorkflow : Self , state : inout State )","title":"workflowDidChange(from:state:)"},{"location":"swift/api/Workflow/extensions/Workflow/#parameters","text":"Name Description previousWorkflow The workflow before the update. state The current state.","title":"Parameters"},{"location":"swift/api/Workflow/extensions/Workflow/#makeinitialstate","text":"public func makeInitialState () -> State","title":"makeInitialState()"},{"location":"swift/api/Workflow/extensions/Workflow/#workflowdidchangefromstate_1","text":"public func workflowDidChange ( from previousWorkflow : Self , state : inout State )","title":"workflowDidChange(from:state:)"},{"location":"swift/api/Workflow/extensions/Workflow/#parameters_1","text":"Name Description previousWorkflow The workflow before the update. state The current state.","title":"Parameters"},{"location":"swift/api/Workflow/extensions/Workflow/#asanyworkflow","text":"public func asAnyWorkflow () -> AnyWorkflow < Rendering , Output >","title":"asAnyWorkflow()"},{"location":"swift/api/Workflow/extensions/WorkflowUpdateDebugInfo.Kind/","text":"EXTENSION WorkflowUpdateDebugInfo.Kind \u00b6 extension WorkflowUpdateDebugInfo . Kind : Codable Methods \u00b6 encode(to:) \u00b6 public func encode ( to encoder : Encoder ) throws Parameters \u00b6 Name Description encoder The encoder to write data to. init(from:) \u00b6 public init ( from decoder : Decoder ) throws Parameters \u00b6 Name Description decoder The decoder to read data from.","title":"WorkflowUpdateDebugInfo.Kind"},{"location":"swift/api/Workflow/extensions/WorkflowUpdateDebugInfo.Kind/#workflowupdatedebuginfokind","text":"extension WorkflowUpdateDebugInfo . Kind : Codable","title":"WorkflowUpdateDebugInfo.Kind"},{"location":"swift/api/Workflow/extensions/WorkflowUpdateDebugInfo.Kind/#methods","text":"","title":"Methods"},{"location":"swift/api/Workflow/extensions/WorkflowUpdateDebugInfo.Kind/#encodeto","text":"public func encode ( to encoder : Encoder ) throws","title":"encode(to:)"},{"location":"swift/api/Workflow/extensions/WorkflowUpdateDebugInfo.Kind/#parameters","text":"Name Description encoder The encoder to write data to.","title":"Parameters"},{"location":"swift/api/Workflow/extensions/WorkflowUpdateDebugInfo.Kind/#initfrom","text":"public init ( from decoder : Decoder ) throws","title":"init(from:)"},{"location":"swift/api/Workflow/extensions/WorkflowUpdateDebugInfo.Kind/#parameters_1","text":"Name Description decoder The decoder to read data from.","title":"Parameters"},{"location":"swift/api/Workflow/extensions/WorkflowUpdateDebugInfo.Source/","text":"EXTENSION WorkflowUpdateDebugInfo.Source \u00b6 extension WorkflowUpdateDebugInfo . Source : Codable Methods \u00b6 encode(to:) \u00b6 public func encode ( to encoder : Encoder ) throws Parameters \u00b6 Name Description encoder The encoder to write data to. init(from:) \u00b6 public init ( from decoder : Decoder ) throws Parameters \u00b6 Name Description decoder The decoder to read data from.","title":"WorkflowUpdateDebugInfo.Source"},{"location":"swift/api/Workflow/extensions/WorkflowUpdateDebugInfo.Source/#workflowupdatedebuginfosource","text":"extension WorkflowUpdateDebugInfo . Source : Codable","title":"WorkflowUpdateDebugInfo.Source"},{"location":"swift/api/Workflow/extensions/WorkflowUpdateDebugInfo.Source/#methods","text":"","title":"Methods"},{"location":"swift/api/Workflow/extensions/WorkflowUpdateDebugInfo.Source/#encodeto","text":"public func encode ( to encoder : Encoder ) throws","title":"encode(to:)"},{"location":"swift/api/Workflow/extensions/WorkflowUpdateDebugInfo.Source/#parameters","text":"Name Description encoder The encoder to write data to.","title":"Parameters"},{"location":"swift/api/Workflow/extensions/WorkflowUpdateDebugInfo.Source/#initfrom","text":"public init ( from decoder : Decoder ) throws","title":"init(from:)"},{"location":"swift/api/Workflow/extensions/WorkflowUpdateDebugInfo.Source/#parameters_1","text":"Name Description decoder The decoder to read data from.","title":"Parameters"},{"location":"swift/api/Workflow/protocols/AnyWorkflowConvertible/","text":"PROTOCOL AnyWorkflowConvertible \u00b6 public protocol AnyWorkflowConvertible Conforming types can be converted into AnyWorkflow values, allowing them to participate in a workflow hierarchy. Methods \u00b6 asAnyWorkflow() \u00b6 func asAnyWorkflow () -> AnyWorkflow < Rendering , Output > Returns an AnyWorkflow representing this value.","title":"AnyWorkflowConvertible"},{"location":"swift/api/Workflow/protocols/AnyWorkflowConvertible/#anyworkflowconvertible","text":"public protocol AnyWorkflowConvertible Conforming types can be converted into AnyWorkflow values, allowing them to participate in a workflow hierarchy.","title":"AnyWorkflowConvertible"},{"location":"swift/api/Workflow/protocols/AnyWorkflowConvertible/#methods","text":"","title":"Methods"},{"location":"swift/api/Workflow/protocols/AnyWorkflowConvertible/#asanyworkflow","text":"func asAnyWorkflow () -> AnyWorkflow < Rendering , Output > Returns an AnyWorkflow representing this value.","title":"asAnyWorkflow()"},{"location":"swift/api/Workflow/protocols/Workflow/","text":"PROTOCOL Workflow \u00b6 public protocol Workflow : AnyWorkflowConvertible Defines a node in the workflow tree. Initialization and Updating A workflow node comes into existence after its parent produces an instance of that workflow and uses it during a render pass (see the render method for more details). If this is the first time the parent has rendered a child of this type, a new workflow node is created. The workflow passed in from the parent will be used to invoke initialState() to obtain an initial state. If the parent had previously rendered a child of this type, the existing workflow node will be updated. workflowDidChange(from:state:) will be invoked to allow the workflow to respond to the change. Render After a workflow node has been created, or any time its state changes, a render pass occurs. The render pass takes the workflow that was passed down from the parent along with the current state and generates a value of type Rendering . In a common case, a workflow might render to a screen model for display. func render(state: State, context: RenderContext<Self>) -> MyScreenModel { return MyScreenModel() } Methods \u00b6 makeInitialState() \u00b6 func makeInitialState () -> State This method is invoked once when a workflow node comes into existence. Returns: The initial state for the workflow. workflowDidChange(from:state:) \u00b6 func workflowDidChange ( from previousWorkflow : Self , state : inout State ) Called when a new workflow is passed down from the parent to an existing workflow node. Parameter previousWorkflow: The workflow before the update. Parameter state: The current state. Parameters \u00b6 Name Description previousWorkflow The workflow before the update. state The current state. render(state:context:) \u00b6 func render ( state : State , context : RenderContext < Self >) -> Rendering Called by the internal Workflow infrastructure to \u201crender\u201d the current state into Rendering . A workflow\u2019s Rendering type is commonly a view or screen model. Parameter state: The current state. Parameter context: The workflow context is the composition point for the workflow tree. To use a nested workflow, instantiate it based on the current state, then call rendered(in:key:outputMap:) . This will return the child\u2019s Rendering type after creating or updating the nested workflow. Parameters \u00b6 Name Description state The current state. context The workflow context is the composition point for the workflow tree. To use a nested workflow, instantiate it based on the current state, then call rendered(in:key:outputMap:) . This will return the child\u2019s Rendering type after creating or updating the nested workflow.","title":"Workflow"},{"location":"swift/api/Workflow/protocols/Workflow/#workflow","text":"public protocol Workflow : AnyWorkflowConvertible Defines a node in the workflow tree. Initialization and Updating A workflow node comes into existence after its parent produces an instance of that workflow and uses it during a render pass (see the render method for more details). If this is the first time the parent has rendered a child of this type, a new workflow node is created. The workflow passed in from the parent will be used to invoke initialState() to obtain an initial state. If the parent had previously rendered a child of this type, the existing workflow node will be updated. workflowDidChange(from:state:) will be invoked to allow the workflow to respond to the change. Render After a workflow node has been created, or any time its state changes, a render pass occurs. The render pass takes the workflow that was passed down from the parent along with the current state and generates a value of type Rendering . In a common case, a workflow might render to a screen model for display. func render(state: State, context: RenderContext<Self>) -> MyScreenModel { return MyScreenModel() }","title":"Workflow"},{"location":"swift/api/Workflow/protocols/Workflow/#methods","text":"","title":"Methods"},{"location":"swift/api/Workflow/protocols/Workflow/#makeinitialstate","text":"func makeInitialState () -> State This method is invoked once when a workflow node comes into existence. Returns: The initial state for the workflow.","title":"makeInitialState()"},{"location":"swift/api/Workflow/protocols/Workflow/#workflowdidchangefromstate","text":"func workflowDidChange ( from previousWorkflow : Self , state : inout State ) Called when a new workflow is passed down from the parent to an existing workflow node. Parameter previousWorkflow: The workflow before the update. Parameter state: The current state.","title":"workflowDidChange(from:state:)"},{"location":"swift/api/Workflow/protocols/Workflow/#parameters","text":"Name Description previousWorkflow The workflow before the update. state The current state.","title":"Parameters"},{"location":"swift/api/Workflow/protocols/Workflow/#renderstatecontext","text":"func render ( state : State , context : RenderContext < Self >) -> Rendering Called by the internal Workflow infrastructure to \u201crender\u201d the current state into Rendering . A workflow\u2019s Rendering type is commonly a view or screen model. Parameter state: The current state. Parameter context: The workflow context is the composition point for the workflow tree. To use a nested workflow, instantiate it based on the current state, then call rendered(in:key:outputMap:) . This will return the child\u2019s Rendering type after creating or updating the nested workflow.","title":"render(state:context:)"},{"location":"swift/api/Workflow/protocols/Workflow/#parameters_1","text":"Name Description state The current state. context The workflow context is the composition point for the workflow tree. To use a nested workflow, instantiate it based on the current state, then call rendered(in:key:outputMap:) . This will return the child\u2019s Rendering type after creating or updating the nested workflow.","title":"Parameters"},{"location":"swift/api/Workflow/protocols/WorkflowAction/","text":"PROTOCOL WorkflowAction \u00b6 public protocol WorkflowAction Conforming types represent an action that advances a workflow. When applied, an action emits the next state and / or output for the workflow. Methods \u00b6 apply(toState:) \u00b6 func apply ( toState state : inout WorkflowType . State ) -> WorkflowType . Output ? Applies this action to a given state of the workflow, optionally returning an output event. Parameter state: The current state of the workflow. The state is passed as an inout param, allowing actions to modify state during application. Returns: An optional output event for the workflow. If an output event is returned, it will be passed up the workflow hierarchy to this workflow\u2019s parent. Parameters \u00b6 Name Description state The current state of the workflow. The state is passed as an inout param, allowing actions to modify state during application.","title":"WorkflowAction"},{"location":"swift/api/Workflow/protocols/WorkflowAction/#workflowaction","text":"public protocol WorkflowAction Conforming types represent an action that advances a workflow. When applied, an action emits the next state and / or output for the workflow.","title":"WorkflowAction"},{"location":"swift/api/Workflow/protocols/WorkflowAction/#methods","text":"","title":"Methods"},{"location":"swift/api/Workflow/protocols/WorkflowAction/#applytostate","text":"func apply ( toState state : inout WorkflowType . State ) -> WorkflowType . Output ? Applies this action to a given state of the workflow, optionally returning an output event. Parameter state: The current state of the workflow. The state is passed as an inout param, allowing actions to modify state during application. Returns: An optional output event for the workflow. If an output event is returned, it will be passed up the workflow hierarchy to this workflow\u2019s parent.","title":"apply(toState:)"},{"location":"swift/api/Workflow/protocols/WorkflowAction/#parameters","text":"Name Description state The current state of the workflow. The state is passed as an inout param, allowing actions to modify state during application.","title":"Parameters"},{"location":"swift/api/Workflow/protocols/WorkflowDebugger/","text":"PROTOCOL WorkflowDebugger \u00b6 public protocol WorkflowDebugger Defines a type that receives debug information about a running workflow hierarchy. Methods \u00b6 didEnterInitialState(snapshot:) \u00b6 func didEnterInitialState ( snapshot : WorkflowHierarchyDebugSnapshot ) Called once when the workflow hierarchy initializes. Parameter snapshot: Debug information about the workflow hierarchy. Parameters \u00b6 Name Description snapshot Debug information about the workflow hierarchy. didUpdate(snapshot:updateInfo:) \u00b6 func didUpdate ( snapshot : WorkflowHierarchyDebugSnapshot , updateInfo : WorkflowUpdateDebugInfo ) Called when an update occurs anywhere within the workflow hierarchy. Parameter snapshot: Debug information about the workflow hierarchy after the update. Parameter updateInfo: Information about the update. Parameters \u00b6 Name Description snapshot Debug information about the workflow hierarchy the update. updateInfo Information about the update.","title":"WorkflowDebugger"},{"location":"swift/api/Workflow/protocols/WorkflowDebugger/#workflowdebugger","text":"public protocol WorkflowDebugger Defines a type that receives debug information about a running workflow hierarchy.","title":"WorkflowDebugger"},{"location":"swift/api/Workflow/protocols/WorkflowDebugger/#methods","text":"","title":"Methods"},{"location":"swift/api/Workflow/protocols/WorkflowDebugger/#didenterinitialstatesnapshot","text":"func didEnterInitialState ( snapshot : WorkflowHierarchyDebugSnapshot ) Called once when the workflow hierarchy initializes. Parameter snapshot: Debug information about the workflow hierarchy.","title":"didEnterInitialState(snapshot:)"},{"location":"swift/api/Workflow/protocols/WorkflowDebugger/#parameters","text":"Name Description snapshot Debug information about the workflow hierarchy.","title":"Parameters"},{"location":"swift/api/Workflow/protocols/WorkflowDebugger/#didupdatesnapshotupdateinfo","text":"func didUpdate ( snapshot : WorkflowHierarchyDebugSnapshot , updateInfo : WorkflowUpdateDebugInfo ) Called when an update occurs anywhere within the workflow hierarchy. Parameter snapshot: Debug information about the workflow hierarchy after the update. Parameter updateInfo: Information about the update.","title":"didUpdate(snapshot:updateInfo:)"},{"location":"swift/api/Workflow/protocols/WorkflowDebugger/#parameters_1","text":"Name Description snapshot Debug information about the workflow hierarchy the update. updateInfo Information about the update.","title":"Parameters"},{"location":"swift/api/Workflow/structs/AnyWorkflow/","text":"STRUCT AnyWorkflow \u00b6 public struct AnyWorkflow < Rendering , Output > A type-erased wrapper that contains a workflow with the given Rendering and Output types. Properties \u00b6 workflowType \u00b6 public var workflowType : Any . Type The underlying workflow\u2019s implementation type. Methods \u00b6 init(_:) \u00b6 public init < T : Workflow >( _ workflow : T ) where T . Rendering == Rendering , T . Output == Output Initializes a new type-erased wrapper for the given workflow.","title":"AnyWorkflow"},{"location":"swift/api/Workflow/structs/AnyWorkflow/#anyworkflow","text":"public struct AnyWorkflow < Rendering , Output > A type-erased wrapper that contains a workflow with the given Rendering and Output types.","title":"AnyWorkflow"},{"location":"swift/api/Workflow/structs/AnyWorkflow/#properties","text":"","title":"Properties"},{"location":"swift/api/Workflow/structs/AnyWorkflow/#workflowtype","text":"public var workflowType : Any . Type The underlying workflow\u2019s implementation type.","title":"workflowType"},{"location":"swift/api/Workflow/structs/AnyWorkflow/#methods","text":"","title":"Methods"},{"location":"swift/api/Workflow/structs/AnyWorkflow/#init_","text":"public init < T : Workflow >( _ workflow : T ) where T . Rendering == Rendering , T . Output == Output Initializes a new type-erased wrapper for the given workflow.","title":"init(_:)"},{"location":"swift/api/Workflow/structs/AnyWorkflowAction/","text":"STRUCT AnyWorkflowAction \u00b6 public struct AnyWorkflowAction < WorkflowType : Workflow >: WorkflowAction A type-erased workflow action. The AnyWorkflowAction type forwards apply to an underlying workflow action, hiding its specific underlying type, or to a closure that implements the apply logic. Methods \u00b6 init(_:) \u00b6 public init < E >( _ base : E ) where E : WorkflowAction , E . WorkflowType == WorkflowType Creates a type-erased workflow action that wraps the given instance. Parameter base: A workflow action to wrap. Parameters \u00b6 Name Description base A workflow action to wrap. init(_:) \u00b6 public init ( _ apply : @ escaping ( inout WorkflowType . State ) -> WorkflowType . Output ?) Creates a type-erased workflow action with the given apply implementation. Parameter apply: the apply function for the resulting action. Parameters \u00b6 Name Description apply the apply function for the resulting action. apply(toState:) \u00b6 public func apply ( toState state : inout WorkflowType . State ) -> WorkflowType . Output ? Parameters \u00b6 Name Description state The current state of the workflow. The state is passed as an inout param, allowing actions to modify state during application.","title":"AnyWorkflowAction"},{"location":"swift/api/Workflow/structs/AnyWorkflowAction/#anyworkflowaction","text":"public struct AnyWorkflowAction < WorkflowType : Workflow >: WorkflowAction A type-erased workflow action. The AnyWorkflowAction type forwards apply to an underlying workflow action, hiding its specific underlying type, or to a closure that implements the apply logic.","title":"AnyWorkflowAction"},{"location":"swift/api/Workflow/structs/AnyWorkflowAction/#methods","text":"","title":"Methods"},{"location":"swift/api/Workflow/structs/AnyWorkflowAction/#init_","text":"public init < E >( _ base : E ) where E : WorkflowAction , E . WorkflowType == WorkflowType Creates a type-erased workflow action that wraps the given instance. Parameter base: A workflow action to wrap.","title":"init(_:)"},{"location":"swift/api/Workflow/structs/AnyWorkflowAction/#parameters","text":"Name Description base A workflow action to wrap.","title":"Parameters"},{"location":"swift/api/Workflow/structs/AnyWorkflowAction/#init__1","text":"public init ( _ apply : @ escaping ( inout WorkflowType . State ) -> WorkflowType . Output ?) Creates a type-erased workflow action with the given apply implementation. Parameter apply: the apply function for the resulting action.","title":"init(_:)"},{"location":"swift/api/Workflow/structs/AnyWorkflowAction/#parameters_1","text":"Name Description apply the apply function for the resulting action.","title":"Parameters"},{"location":"swift/api/Workflow/structs/AnyWorkflowAction/#applytostate","text":"public func apply ( toState state : inout WorkflowType . State ) -> WorkflowType . Output ?","title":"apply(toState:)"},{"location":"swift/api/Workflow/structs/AnyWorkflowAction/#parameters_2","text":"Name Description state The current state of the workflow. The state is passed as an inout param, allowing actions to modify state during application.","title":"Parameters"},{"location":"swift/api/Workflow/structs/Sink/","text":"STRUCT Sink \u00b6 public struct Sink < Value > Sink is a type that receives incoming values (commonly events or WorkflowAction ) Use RenderContext.makeSink to create instances. Methods \u00b6 init(_:) \u00b6 public init ( _ onValue : @ escaping ( Value ) -> Void ) Initializes a new sink with the given closure. send(_:) \u00b6 public func send ( _ value : Value ) Sends a new event into the sink. Parameter event: The value to send into the sink. Parameters \u00b6 Name Description event The value to send into the sink. contraMap(_:) \u00b6 public func contraMap < NewValue >( _ transform : @ escaping ( NewValue ) -> Value ) -> Sink < NewValue > Generates a new sink of type NewValue. Given a transform closure, the following code is functionally equivalent: sink.send(transform(value)) sink.contraMap(transform).send(value) Trivia : Why is this called contraMap ? - map turns Type<T> into Type<U> via (T)->U . - contraMap turns Type<T> into Type<U> via (U)->T Another way to think about this is: map transforms a type by changing the output types of its API, while contraMap transforms a type by changing the input types of its API. Parameter transform: An escaping closure that transforms T into Event . Parameters \u00b6 Name Description transform An escaping closure that transforms T into Event .","title":"Sink"},{"location":"swift/api/Workflow/structs/Sink/#sink","text":"public struct Sink < Value > Sink is a type that receives incoming values (commonly events or WorkflowAction ) Use RenderContext.makeSink to create instances.","title":"Sink"},{"location":"swift/api/Workflow/structs/Sink/#methods","text":"","title":"Methods"},{"location":"swift/api/Workflow/structs/Sink/#init_","text":"public init ( _ onValue : @ escaping ( Value ) -> Void ) Initializes a new sink with the given closure.","title":"init(_:)"},{"location":"swift/api/Workflow/structs/Sink/#send_","text":"public func send ( _ value : Value ) Sends a new event into the sink. Parameter event: The value to send into the sink.","title":"send(_:)"},{"location":"swift/api/Workflow/structs/Sink/#parameters","text":"Name Description event The value to send into the sink.","title":"Parameters"},{"location":"swift/api/Workflow/structs/Sink/#contramap_","text":"public func contraMap < NewValue >( _ transform : @ escaping ( NewValue ) -> Value ) -> Sink < NewValue > Generates a new sink of type NewValue. Given a transform closure, the following code is functionally equivalent: sink.send(transform(value)) sink.contraMap(transform).send(value) Trivia : Why is this called contraMap ? - map turns Type<T> into Type<U> via (T)->U . - contraMap turns Type<T> into Type<U> via (U)->T Another way to think about this is: map transforms a type by changing the output types of its API, while contraMap transforms a type by changing the input types of its API. Parameter transform: An escaping closure that transforms T into Event .","title":"contraMap(_:)"},{"location":"swift/api/Workflow/structs/Sink/#parameters_1","text":"Name Description transform An escaping closure that transforms T into Event .","title":"Parameters"},{"location":"swift/api/Workflow/structs/WorkflowHierarchyDebugSnapshot.Child/","text":"STRUCT WorkflowHierarchyDebugSnapshot.Child \u00b6 public struct Child : Codable , Equatable Properties \u00b6 key \u00b6 public var key : String snapshot \u00b6 public var snapshot : WorkflowHierarchyDebugSnapshot","title":"WorkflowHierarchyDebugSnapshot.Child"},{"location":"swift/api/Workflow/structs/WorkflowHierarchyDebugSnapshot.Child/#workflowhierarchydebugsnapshotchild","text":"public struct Child : Codable , Equatable","title":"WorkflowHierarchyDebugSnapshot.Child"},{"location":"swift/api/Workflow/structs/WorkflowHierarchyDebugSnapshot.Child/#properties","text":"","title":"Properties"},{"location":"swift/api/Workflow/structs/WorkflowHierarchyDebugSnapshot.Child/#key","text":"public var key : String","title":"key"},{"location":"swift/api/Workflow/structs/WorkflowHierarchyDebugSnapshot.Child/#snapshot","text":"public var snapshot : WorkflowHierarchyDebugSnapshot","title":"snapshot"},{"location":"swift/api/Workflow/structs/WorkflowHierarchyDebugSnapshot/","text":"STRUCT WorkflowHierarchyDebugSnapshot \u00b6 public struct WorkflowHierarchyDebugSnapshot : Codable , Equatable Properties \u00b6 workflowType \u00b6 public var workflowType : String stateDescription \u00b6 public var stateDescription : String children \u00b6 public var children : [ Child ]","title":"WorkflowHierarchyDebugSnapshot"},{"location":"swift/api/Workflow/structs/WorkflowHierarchyDebugSnapshot/#workflowhierarchydebugsnapshot","text":"public struct WorkflowHierarchyDebugSnapshot : Codable , Equatable","title":"WorkflowHierarchyDebugSnapshot"},{"location":"swift/api/Workflow/structs/WorkflowHierarchyDebugSnapshot/#properties","text":"","title":"Properties"},{"location":"swift/api/Workflow/structs/WorkflowHierarchyDebugSnapshot/#workflowtype","text":"public var workflowType : String","title":"workflowType"},{"location":"swift/api/Workflow/structs/WorkflowHierarchyDebugSnapshot/#statedescription","text":"public var stateDescription : String","title":"stateDescription"},{"location":"swift/api/Workflow/structs/WorkflowHierarchyDebugSnapshot/#children","text":"public var children : [ Child ]","title":"children"},{"location":"swift/api/Workflow/structs/WorkflowUpdateDebugInfo/","text":"STRUCT WorkflowUpdateDebugInfo \u00b6 public struct WorkflowUpdateDebugInfo : Codable , Equatable Properties \u00b6 workflowType \u00b6 public var workflowType : String kind \u00b6 public var kind : Kind","title":"WorkflowUpdateDebugInfo"},{"location":"swift/api/Workflow/structs/WorkflowUpdateDebugInfo/#workflowupdatedebuginfo","text":"public struct WorkflowUpdateDebugInfo : Codable , Equatable","title":"WorkflowUpdateDebugInfo"},{"location":"swift/api/Workflow/structs/WorkflowUpdateDebugInfo/#properties","text":"","title":"Properties"},{"location":"swift/api/Workflow/structs/WorkflowUpdateDebugInfo/#workflowtype","text":"public var workflowType : String","title":"workflowType"},{"location":"swift/api/Workflow/structs/WorkflowUpdateDebugInfo/#kind","text":"public var kind : Kind","title":"kind"},{"location":"swift/api/WorkflowReactiveSwift/","text":"Reference Documentation \u00b6 Protocols \u00b6 Worker Extensions \u00b6 Signal SignalProducer Worker Typealiases \u00b6 SignalProducerWorkflow.Output SignalProducerWorkflow.Rendering SignalProducerWorkflow.State This file was generated by SourceDocs on 2022-01-27 21:10:39 +0000","title":"WorkflowReactiveSwift"},{"location":"swift/api/WorkflowReactiveSwift/#reference-documentation","text":"","title":"Reference Documentation"},{"location":"swift/api/WorkflowReactiveSwift/#protocols","text":"Worker","title":"Protocols"},{"location":"swift/api/WorkflowReactiveSwift/#extensions","text":"Signal SignalProducer Worker","title":"Extensions"},{"location":"swift/api/WorkflowReactiveSwift/#typealiases","text":"SignalProducerWorkflow.Output SignalProducerWorkflow.Rendering SignalProducerWorkflow.State This file was generated by SourceDocs on 2022-01-27 21:10:39 +0000","title":"Typealiases"},{"location":"swift/api/WorkflowReactiveSwift/extensions/Signal/","text":"EXTENSION Signal \u00b6 extension Signal : AnyWorkflowConvertible where Error == Never Methods \u00b6 asAnyWorkflow() \u00b6 public func asAnyWorkflow () -> AnyWorkflow < Void , Value >","title":"Signal"},{"location":"swift/api/WorkflowReactiveSwift/extensions/Signal/#signal","text":"extension Signal : AnyWorkflowConvertible where Error == Never","title":"Signal"},{"location":"swift/api/WorkflowReactiveSwift/extensions/Signal/#methods","text":"","title":"Methods"},{"location":"swift/api/WorkflowReactiveSwift/extensions/Signal/#asanyworkflow","text":"public func asAnyWorkflow () -> AnyWorkflow < Void , Value >","title":"asAnyWorkflow()"},{"location":"swift/api/WorkflowReactiveSwift/extensions/SignalProducer/","text":"EXTENSION SignalProducer \u00b6 extension SignalProducer : AnyWorkflowConvertible where Error == Never Methods \u00b6 asAnyWorkflow() \u00b6 public func asAnyWorkflow () -> AnyWorkflow < Void , Value >","title":"SignalProducer"},{"location":"swift/api/WorkflowReactiveSwift/extensions/SignalProducer/#signalproducer","text":"extension SignalProducer : AnyWorkflowConvertible where Error == Never","title":"SignalProducer"},{"location":"swift/api/WorkflowReactiveSwift/extensions/SignalProducer/#methods","text":"","title":"Methods"},{"location":"swift/api/WorkflowReactiveSwift/extensions/SignalProducer/#asanyworkflow","text":"public func asAnyWorkflow () -> AnyWorkflow < Void , Value >","title":"asAnyWorkflow()"},{"location":"swift/api/WorkflowReactiveSwift/extensions/Worker/","text":"EXTENSION Worker \u00b6 extension Worker Methods \u00b6 asAnyWorkflow() \u00b6 public func asAnyWorkflow () -> AnyWorkflow < Void , Output > isEquivalent(to:) \u00b6 public func isEquivalent ( to otherWorker : Self ) -> Bool","title":"Worker"},{"location":"swift/api/WorkflowReactiveSwift/extensions/Worker/#worker","text":"extension Worker","title":"Worker"},{"location":"swift/api/WorkflowReactiveSwift/extensions/Worker/#methods","text":"","title":"Methods"},{"location":"swift/api/WorkflowReactiveSwift/extensions/Worker/#asanyworkflow","text":"public func asAnyWorkflow () -> AnyWorkflow < Void , Output >","title":"asAnyWorkflow()"},{"location":"swift/api/WorkflowReactiveSwift/extensions/Worker/#isequivalentto","text":"public func isEquivalent ( to otherWorker : Self ) -> Bool","title":"isEquivalent(to:)"},{"location":"swift/api/WorkflowReactiveSwift/protocols/Worker/","text":"PROTOCOL Worker \u00b6 public protocol Worker : AnyWorkflowConvertible where Rendering == Void Workers define a unit of asynchronous work. During a render pass, a workflow can ask the context to await the result of a worker. When this occurs, the context checks to see if there is already a running worker of the same type. If there is, and if the workers are \u2018equivalent\u2019, the context leaves the existing worker running. If there is not an existing worker of this type, the context will kick off the new worker (via run ). Methods \u00b6 run() \u00b6 func run () -> SignalProducer < Output , Never > Returns a signal producer to execute the work represented by this worker. isEquivalent(to:) \u00b6 func isEquivalent ( to otherWorker : Self ) -> Bool Returns true if the other worker should be considered equivalent to self . Equivalence should take into account whatever data is meaningful to the task. For example, a worker that loads a user account from a server would not be equivalent to another worker with a different user ID.","title":"Worker"},{"location":"swift/api/WorkflowReactiveSwift/protocols/Worker/#worker","text":"public protocol Worker : AnyWorkflowConvertible where Rendering == Void Workers define a unit of asynchronous work. During a render pass, a workflow can ask the context to await the result of a worker. When this occurs, the context checks to see if there is already a running worker of the same type. If there is, and if the workers are \u2018equivalent\u2019, the context leaves the existing worker running. If there is not an existing worker of this type, the context will kick off the new worker (via run ).","title":"Worker"},{"location":"swift/api/WorkflowReactiveSwift/protocols/Worker/#methods","text":"","title":"Methods"},{"location":"swift/api/WorkflowReactiveSwift/protocols/Worker/#run","text":"func run () -> SignalProducer < Output , Never > Returns a signal producer to execute the work represented by this worker.","title":"run()"},{"location":"swift/api/WorkflowReactiveSwift/protocols/Worker/#isequivalentto","text":"func isEquivalent ( to otherWorker : Self ) -> Bool Returns true if the other worker should be considered equivalent to self . Equivalence should take into account whatever data is meaningful to the task. For example, a worker that loads a user account from a server would not be equivalent to another worker with a different user ID.","title":"isEquivalent(to:)"},{"location":"swift/api/WorkflowReactiveSwift/typealiases/SignalProducerWorkflow.Output/","text":"TYPEALIAS SignalProducerWorkflow.Output \u00b6 public typealias Output = Value","title":"SignalProducerWorkflow.Output"},{"location":"swift/api/WorkflowReactiveSwift/typealiases/SignalProducerWorkflow.Output/#signalproducerworkflowoutput","text":"public typealias Output = Value","title":"SignalProducerWorkflow.Output"},{"location":"swift/api/WorkflowReactiveSwift/typealiases/SignalProducerWorkflow.Rendering/","text":"TYPEALIAS SignalProducerWorkflow.Rendering \u00b6 public typealias Rendering = Void","title":"SignalProducerWorkflow.Rendering"},{"location":"swift/api/WorkflowReactiveSwift/typealiases/SignalProducerWorkflow.Rendering/#signalproducerworkflowrendering","text":"public typealias Rendering = Void","title":"SignalProducerWorkflow.Rendering"},{"location":"swift/api/WorkflowReactiveSwift/typealiases/SignalProducerWorkflow.State/","text":"TYPEALIAS SignalProducerWorkflow.State \u00b6 public typealias State = Void","title":"SignalProducerWorkflow.State"},{"location":"swift/api/WorkflowReactiveSwift/typealiases/SignalProducerWorkflow.State/#signalproducerworkflowstate","text":"public typealias State = Void","title":"SignalProducerWorkflow.State"},{"location":"swift/api/WorkflowTesting/","text":"Reference Documentation \u00b6 Structs \u00b6 RenderTester RenderTesterResult WorkflowActionTester Extensions \u00b6 RenderTesterResult Workflow WorkflowAction WorkflowActionTester This file was generated by SourceDocs on 2022-01-27 21:10:30 +0000","title":"WorkflowTesting "},{"location":"swift/api/WorkflowTesting/#reference-documentation","text":"","title":"Reference Documentation"},{"location":"swift/api/WorkflowTesting/#structs","text":"RenderTester RenderTesterResult WorkflowActionTester","title":"Structs"},{"location":"swift/api/WorkflowTesting/#extensions","text":"RenderTesterResult Workflow WorkflowAction WorkflowActionTester This file was generated by SourceDocs on 2022-01-27 21:10:30 +0000","title":"Extensions"},{"location":"swift/api/WorkflowTesting/extensions/RenderTesterResult/","text":"EXTENSION RenderTesterResult \u00b6 extension RenderTesterResult where WorkflowType . State : Equatable Methods \u00b6 assert(state:file:line:) \u00b6 public func assert ( state expectedState : WorkflowType . State , file : StaticString = #file , line : UInt = #line ) -> RenderTesterResult < WorkflowType > Verifies that the resulting state is equal to the given state. assert(output:file:line:) \u00b6 public func assert ( output expectedOutput : WorkflowType . Output , file : StaticString = #file , line : UInt = #line ) -> RenderTesterResult < WorkflowType > Verifies that the resulting output is equal to the given output.","title":"RenderTesterResult"},{"location":"swift/api/WorkflowTesting/extensions/RenderTesterResult/#rendertesterresult","text":"extension RenderTesterResult where WorkflowType . State : Equatable","title":"RenderTesterResult"},{"location":"swift/api/WorkflowTesting/extensions/RenderTesterResult/#methods","text":"","title":"Methods"},{"location":"swift/api/WorkflowTesting/extensions/RenderTesterResult/#assertstatefileline","text":"public func assert ( state expectedState : WorkflowType . State , file : StaticString = #file , line : UInt = #line ) -> RenderTesterResult < WorkflowType > Verifies that the resulting state is equal to the given state.","title":"assert(state:file:line:)"},{"location":"swift/api/WorkflowTesting/extensions/RenderTesterResult/#assertoutputfileline","text":"public func assert ( output expectedOutput : WorkflowType . Output , file : StaticString = #file , line : UInt = #line ) -> RenderTesterResult < WorkflowType > Verifies that the resulting output is equal to the given output.","title":"assert(output:file:line:)"},{"location":"swift/api/WorkflowTesting/extensions/Workflow/","text":"EXTENSION Workflow \u00b6 extension Workflow Methods \u00b6 renderTester(initialState:) \u00b6 public func renderTester ( initialState : Self . State ) -> RenderTester < Self > Returns a RenderTester with a specified initial state. renderTester() \u00b6 public func renderTester () -> RenderTester < Self > Returns a RenderTester with an initial state provided by self.makeInitialState()","title":"Workflow"},{"location":"swift/api/WorkflowTesting/extensions/Workflow/#workflow","text":"extension Workflow","title":"Workflow"},{"location":"swift/api/WorkflowTesting/extensions/Workflow/#methods","text":"","title":"Methods"},{"location":"swift/api/WorkflowTesting/extensions/Workflow/#rendertesterinitialstate","text":"public func renderTester ( initialState : Self . State ) -> RenderTester < Self > Returns a RenderTester with a specified initial state.","title":"renderTester(initialState:)"},{"location":"swift/api/WorkflowTesting/extensions/Workflow/#rendertester","text":"public func renderTester () -> RenderTester < Self > Returns a RenderTester with an initial state provided by self.makeInitialState()","title":"renderTester()"},{"location":"swift/api/WorkflowTesting/extensions/WorkflowAction/","text":"EXTENSION WorkflowAction \u00b6 extension WorkflowAction Methods \u00b6 tester(withState:) \u00b6 public static func tester ( withState state : WorkflowType . State ) -> WorkflowActionTester < WorkflowType , Self > Returns a state tester containing self .","title":"WorkflowAction"},{"location":"swift/api/WorkflowTesting/extensions/WorkflowAction/#workflowaction","text":"extension WorkflowAction","title":"WorkflowAction"},{"location":"swift/api/WorkflowTesting/extensions/WorkflowAction/#methods","text":"","title":"Methods"},{"location":"swift/api/WorkflowTesting/extensions/WorkflowAction/#testerwithstate","text":"public static func tester ( withState state : WorkflowType . State ) -> WorkflowActionTester < WorkflowType , Self > Returns a state tester containing self .","title":"tester(withState:)"},{"location":"swift/api/WorkflowTesting/extensions/WorkflowActionTester/","text":"EXTENSION WorkflowActionTester \u00b6 extension WorkflowActionTester where WorkflowType . State : Equatable Methods \u00b6 assert(state:file:line:) \u00b6 public func assert ( state expectedState : WorkflowType . State , file : StaticString = #file , line : UInt = #line ) -> WorkflowActionTester < WorkflowType , Action > Triggers a test failure if the current state does not match the given expected state Parameters: expectedState: The expected state returns: A tester containing the current state and output. Parameters \u00b6 Name Description expectedState The expected state assert(output:file:line:) \u00b6 public func assert ( output expectedOutput : WorkflowType . Output , file : StaticString = #file , line : UInt = #line ) -> WorkflowActionTester < WorkflowType , Action > Triggers a test failure if the produced output does not match the given expected output Parameters: expectedState: The expected output returns: A tester containing the current state and output. Parameters \u00b6 Name Description expectedState The expected output","title":"WorkflowActionTester"},{"location":"swift/api/WorkflowTesting/extensions/WorkflowActionTester/#workflowactiontester","text":"extension WorkflowActionTester where WorkflowType . State : Equatable","title":"WorkflowActionTester"},{"location":"swift/api/WorkflowTesting/extensions/WorkflowActionTester/#methods","text":"","title":"Methods"},{"location":"swift/api/WorkflowTesting/extensions/WorkflowActionTester/#assertstatefileline","text":"public func assert ( state expectedState : WorkflowType . State , file : StaticString = #file , line : UInt = #line ) -> WorkflowActionTester < WorkflowType , Action > Triggers a test failure if the current state does not match the given expected state Parameters: expectedState: The expected state returns: A tester containing the current state and output.","title":"assert(state:file:line:)"},{"location":"swift/api/WorkflowTesting/extensions/WorkflowActionTester/#parameters","text":"Name Description expectedState The expected state","title":"Parameters"},{"location":"swift/api/WorkflowTesting/extensions/WorkflowActionTester/#assertoutputfileline","text":"public func assert ( output expectedOutput : WorkflowType . Output , file : StaticString = #file , line : UInt = #line ) -> WorkflowActionTester < WorkflowType , Action > Triggers a test failure if the produced output does not match the given expected output Parameters: expectedState: The expected output returns: A tester containing the current state and output.","title":"assert(output:file:line:)"},{"location":"swift/api/WorkflowTesting/extensions/WorkflowActionTester/#parameters_1","text":"Name Description expectedState The expected output","title":"Parameters"},{"location":"swift/api/WorkflowTesting/structs/RenderTester/","text":"STRUCT RenderTester \u00b6 public struct RenderTester < WorkflowType : Workflow > Testing helper for validating the behavior of calls to render . Usage: expect workflows and side effects then validate with a call to render and the resulting RenderTesterResult . Side-effects may be performed against the rendering to validate the behavior of actions. To directly test actions and their effects, use the WorkflowActionTester . workflow .renderTester(initialState: TestWorkflow.State()) .expect( worker: TestWorker(), producingOutput: TestWorker.Output.success ) .expectWorkflow( type: ChildWorkflow.self, key: \"key\", rendering: \"rendering\", producingOutput: ChildWorkflow.Output.success ) .render { rendering in XCTAssertEqual(\"expected text on rendering\", rendering.text) } .assert(state: TestWorkflow.State()) .assert(output: TestWorkflow.Output.finished) Validating the rendering only from the initial state provided by the workflow: workflow .renderTester() .render { rendering in XCTAssertEqual(\"expected text on rendering\", rendering.text) } Validate the state was updated from a callback on the rendering: workflow .renderTester() .render { rendering in XCTAssertEqual(\"expected text on rendering\", rendering.text) rendering.updateText(\"updated\") } .assert( state: TestWorkflow.State(text: \"updated\") ) Validate an output was received from the workflow. The action() on the rendering will cause an action that will return an output. workflow .renderTester() .render { rendering in rendering.action() } .assert( output: .success ) Validate a worker is running, and simulate the effect of its output: workflow .renderTester(initialState: TestWorkflow.State(loadingState: .loading)) .expect( worker: TestWorker(), output: TestWorker.Output.success ) .render { _ in } Validate a child workflow is run, and simulate the effect of its output: workflow .renderTester(initialState: TestWorkflow.State(loadingState: .loading)) .expectWorkflow( type: ChildWorkflow.self, rendering: \"rendering\", producingOutput: ChildWorkflow.Output.success ) .render { _ in } Methods \u00b6 expectWorkflow(type:key:producingRendering:producingOutput:file:line:assertions:) \u00b6 public func expectWorkflow < ExpectedWorkflowType : Workflow >( type : ExpectedWorkflowType . Type , key : String = \"\" , producingRendering rendering : ExpectedWorkflowType . Rendering , producingOutput output : ExpectedWorkflowType . Output ? = nil , file : StaticString = #file , line : UInt = #line , assertions : @ escaping ( ExpectedWorkflowType ) -> Void = { _ in } ) -> RenderTester < WorkflowType > Expect the given workflow type in the next rendering. Parameters: type: The type of the expected workflow. key: The key of the expected workflow (if specified). rendering: The rendering result that should be returned when the workflow of this type is rendered. output: An output that should be returned after the workflow of this type is rendered, if any. assertions: Additional assertions for the given workflow, if any. You may use this to assert the properties of the requested workflow are as expected. Parameters \u00b6 Name Description type The type of the expected workflow. key The key of the expected workflow (if specified). rendering The rendering result that should be returned when the workflow of this type is rendered. output An output that should be returned after the workflow of this type is rendered, if any. assertions Additional assertions for the given workflow, if any. You may use this to assert the properties of the requested workflow are as expected. expectWorkflowIgnoringOutput(type:key:producingRendering:file:line:assertions:) \u00b6 public func expectWorkflowIgnoringOutput < ExpectedWorkflowType : Workflow >( type : ExpectedWorkflowType . Type , key : String = \"\" , producingRendering rendering : ExpectedWorkflowType . Rendering , file : StaticString = #file , line : UInt = #line , assertions : @ escaping ( ExpectedWorkflowType ) -> Void = { _ in } ) -> RenderTester < WorkflowType > Expect the given workflow type in the next rendering, with its output being ignored by a call to ignoringOutput() . Parameters: type: The type of the expected workflow. key: The key of the expected workflow (if specified). rendering: The rendering result that should be returned when the workflow of this type is rendered. assertions: Additional assertions for the given workflow, if any. You may use this to assert the properties of the requested workflow are as expected. Parameters \u00b6 Name Description type The type of the expected workflow. key The key of the expected workflow (if specified). rendering The rendering result that should be returned when the workflow of this type is rendered. assertions Additional assertions for the given workflow, if any. You may use this to assert the properties of the requested workflow are as expected. expectSideEffect(key:file:line:) \u00b6 public func expectSideEffect ( key : AnyHashable , file : StaticString = #file , line : UInt = #line ) -> RenderTester < WorkflowType > Expect a side-effect for the given key. Parameter key: The key to expect. Parameters \u00b6 Name Description key The key to expect. expectSideEffect(key:producingAction:file:line:) \u00b6 public func expectSideEffect < ActionType >( key : AnyHashable , producingAction action : ActionType , file : StaticString = #file , line : UInt = #line ) -> RenderTester < WorkflowType > where ActionType : WorkflowAction , ActionType . WorkflowType == WorkflowType Expect a side-effect for the given key, and produce the given action when it is requested. Parameters: key: The key to expect. action: The action to produce when this side-effect is requested. Parameters \u00b6 Name Description key The key to expect. action The action to produce when this side-effect is requested. render(file:line:assertions:) \u00b6 public func render ( file : StaticString = #file , line : UInt = #line , assertions : ( WorkflowType . Rendering ) throws -> Void ) rethrows -> RenderTesterResult < WorkflowType > Render the workflow under test. At this point, you should have set up all expectations. The given assertions closure will be called with the produced rendering, allowing you to assert its properties or perform actions on it (such as closures that are wired up to a Sink inside the workflow. Parameters: assertions: A closure called with the produced rendering for verification Returns: A RenderTesterResult that can be used to verify expected resulting state or outputs. Parameters \u00b6 Name Description assertions A closure called with the produced rendering for verification","title":"RenderTester"},{"location":"swift/api/WorkflowTesting/structs/RenderTester/#rendertester","text":"public struct RenderTester < WorkflowType : Workflow > Testing helper for validating the behavior of calls to render . Usage: expect workflows and side effects then validate with a call to render and the resulting RenderTesterResult . Side-effects may be performed against the rendering to validate the behavior of actions. To directly test actions and their effects, use the WorkflowActionTester . workflow .renderTester(initialState: TestWorkflow.State()) .expect( worker: TestWorker(), producingOutput: TestWorker.Output.success ) .expectWorkflow( type: ChildWorkflow.self, key: \"key\", rendering: \"rendering\", producingOutput: ChildWorkflow.Output.success ) .render { rendering in XCTAssertEqual(\"expected text on rendering\", rendering.text) } .assert(state: TestWorkflow.State()) .assert(output: TestWorkflow.Output.finished) Validating the rendering only from the initial state provided by the workflow: workflow .renderTester() .render { rendering in XCTAssertEqual(\"expected text on rendering\", rendering.text) } Validate the state was updated from a callback on the rendering: workflow .renderTester() .render { rendering in XCTAssertEqual(\"expected text on rendering\", rendering.text) rendering.updateText(\"updated\") } .assert( state: TestWorkflow.State(text: \"updated\") ) Validate an output was received from the workflow. The action() on the rendering will cause an action that will return an output. workflow .renderTester() .render { rendering in rendering.action() } .assert( output: .success ) Validate a worker is running, and simulate the effect of its output: workflow .renderTester(initialState: TestWorkflow.State(loadingState: .loading)) .expect( worker: TestWorker(), output: TestWorker.Output.success ) .render { _ in } Validate a child workflow is run, and simulate the effect of its output: workflow .renderTester(initialState: TestWorkflow.State(loadingState: .loading)) .expectWorkflow( type: ChildWorkflow.self, rendering: \"rendering\", producingOutput: ChildWorkflow.Output.success ) .render { _ in }","title":"RenderTester"},{"location":"swift/api/WorkflowTesting/structs/RenderTester/#methods","text":"","title":"Methods"},{"location":"swift/api/WorkflowTesting/structs/RenderTester/#expectworkflowtypekeyproducingrenderingproducingoutputfilelineassertions","text":"public func expectWorkflow < ExpectedWorkflowType : Workflow >( type : ExpectedWorkflowType . Type , key : String = \"\" , producingRendering rendering : ExpectedWorkflowType . Rendering , producingOutput output : ExpectedWorkflowType . Output ? = nil , file : StaticString = #file , line : UInt = #line , assertions : @ escaping ( ExpectedWorkflowType ) -> Void = { _ in } ) -> RenderTester < WorkflowType > Expect the given workflow type in the next rendering. Parameters: type: The type of the expected workflow. key: The key of the expected workflow (if specified). rendering: The rendering result that should be returned when the workflow of this type is rendered. output: An output that should be returned after the workflow of this type is rendered, if any. assertions: Additional assertions for the given workflow, if any. You may use this to assert the properties of the requested workflow are as expected.","title":"expectWorkflow(type:key:producingRendering:producingOutput:file:line:assertions:)"},{"location":"swift/api/WorkflowTesting/structs/RenderTester/#parameters","text":"Name Description type The type of the expected workflow. key The key of the expected workflow (if specified). rendering The rendering result that should be returned when the workflow of this type is rendered. output An output that should be returned after the workflow of this type is rendered, if any. assertions Additional assertions for the given workflow, if any. You may use this to assert the properties of the requested workflow are as expected.","title":"Parameters"},{"location":"swift/api/WorkflowTesting/structs/RenderTester/#expectworkflowignoringoutputtypekeyproducingrenderingfilelineassertions","text":"public func expectWorkflowIgnoringOutput < ExpectedWorkflowType : Workflow >( type : ExpectedWorkflowType . Type , key : String = \"\" , producingRendering rendering : ExpectedWorkflowType . Rendering , file : StaticString = #file , line : UInt = #line , assertions : @ escaping ( ExpectedWorkflowType ) -> Void = { _ in } ) -> RenderTester < WorkflowType > Expect the given workflow type in the next rendering, with its output being ignored by a call to ignoringOutput() . Parameters: type: The type of the expected workflow. key: The key of the expected workflow (if specified). rendering: The rendering result that should be returned when the workflow of this type is rendered. assertions: Additional assertions for the given workflow, if any. You may use this to assert the properties of the requested workflow are as expected.","title":"expectWorkflowIgnoringOutput(type:key:producingRendering:file:line:assertions:)"},{"location":"swift/api/WorkflowTesting/structs/RenderTester/#parameters_1","text":"Name Description type The type of the expected workflow. key The key of the expected workflow (if specified). rendering The rendering result that should be returned when the workflow of this type is rendered. assertions Additional assertions for the given workflow, if any. You may use this to assert the properties of the requested workflow are as expected.","title":"Parameters"},{"location":"swift/api/WorkflowTesting/structs/RenderTester/#expectsideeffectkeyfileline","text":"public func expectSideEffect ( key : AnyHashable , file : StaticString = #file , line : UInt = #line ) -> RenderTester < WorkflowType > Expect a side-effect for the given key. Parameter key: The key to expect.","title":"expectSideEffect(key:file:line:)"},{"location":"swift/api/WorkflowTesting/structs/RenderTester/#parameters_2","text":"Name Description key The key to expect.","title":"Parameters"},{"location":"swift/api/WorkflowTesting/structs/RenderTester/#expectsideeffectkeyproducingactionfileline","text":"public func expectSideEffect < ActionType >( key : AnyHashable , producingAction action : ActionType , file : StaticString = #file , line : UInt = #line ) -> RenderTester < WorkflowType > where ActionType : WorkflowAction , ActionType . WorkflowType == WorkflowType Expect a side-effect for the given key, and produce the given action when it is requested. Parameters: key: The key to expect. action: The action to produce when this side-effect is requested.","title":"expectSideEffect(key:producingAction:file:line:)"},{"location":"swift/api/WorkflowTesting/structs/RenderTester/#parameters_3","text":"Name Description key The key to expect. action The action to produce when this side-effect is requested.","title":"Parameters"},{"location":"swift/api/WorkflowTesting/structs/RenderTester/#renderfilelineassertions","text":"public func render ( file : StaticString = #file , line : UInt = #line , assertions : ( WorkflowType . Rendering ) throws -> Void ) rethrows -> RenderTesterResult < WorkflowType > Render the workflow under test. At this point, you should have set up all expectations. The given assertions closure will be called with the produced rendering, allowing you to assert its properties or perform actions on it (such as closures that are wired up to a Sink inside the workflow. Parameters: assertions: A closure called with the produced rendering for verification Returns: A RenderTesterResult that can be used to verify expected resulting state or outputs.","title":"render(file:line:assertions:)"},{"location":"swift/api/WorkflowTesting/structs/RenderTester/#parameters_4","text":"Name Description assertions A closure called with the produced rendering for verification","title":"Parameters"},{"location":"swift/api/WorkflowTesting/structs/RenderTesterResult/","text":"STRUCT RenderTesterResult \u00b6 public struct RenderTesterResult < WorkflowType : Workflow > The result of a RenderTester rendering. Used to verify state, output, and actions that were produced as a result of actions performed during the render (such as child workflow output being produced). Methods \u00b6 verifyState(file:line:assertions:) \u00b6 public func verifyState ( file : StaticString = #file , line : UInt = #line , assertions : ( WorkflowType . State ) throws -> Void ) rethrows -> RenderTesterResult < WorkflowType > Allows for assertions against the resulting state. assertNoAction(file:line:) \u00b6 public func assertNoAction ( file : StaticString = #file , line : UInt = #line ) -> RenderTesterResult < WorkflowType > Asserts that no actions were produced verifyAction(type:file:line:assertions:) \u00b6 public func verifyAction < ActionType : WorkflowAction >( type : ActionType . Type = ActionType . self , file : StaticString = #file , line : UInt = #line , assertions : ( ActionType ) throws -> Void ) rethrows -> RenderTesterResult < WorkflowType > where ActionType . WorkflowType == WorkflowType Allows for assertions agains the resulting action assert(action:file:line:) \u00b6 public func assert < ActionType : WorkflowAction >( action : ActionType , file : StaticString = #file , line : UInt = #line ) -> RenderTesterResult < WorkflowType > where ActionType . WorkflowType == WorkflowType , ActionType : Equatable Asserts that the resulting action is equal to the given action. assertNoOutput(file:line:) \u00b6 public func assertNoOutput ( file : StaticString = #file , line : UInt = #line ) -> RenderTesterResult < WorkflowType > Asserts that no output was produced. verifyOutput(file:line:assertions:) \u00b6 public func verifyOutput ( file : StaticString = #file , line : UInt = #line , assertions : ( WorkflowType . Output ) throws -> Void ) rethrows -> RenderTesterResult < WorkflowType > Allows for assertions agains the resulting output","title":"RenderTesterResult"},{"location":"swift/api/WorkflowTesting/structs/RenderTesterResult/#rendertesterresult","text":"public struct RenderTesterResult < WorkflowType : Workflow > The result of a RenderTester rendering. Used to verify state, output, and actions that were produced as a result of actions performed during the render (such as child workflow output being produced).","title":"RenderTesterResult"},{"location":"swift/api/WorkflowTesting/structs/RenderTesterResult/#methods","text":"","title":"Methods"},{"location":"swift/api/WorkflowTesting/structs/RenderTesterResult/#verifystatefilelineassertions","text":"public func verifyState ( file : StaticString = #file , line : UInt = #line , assertions : ( WorkflowType . State ) throws -> Void ) rethrows -> RenderTesterResult < WorkflowType > Allows for assertions against the resulting state.","title":"verifyState(file:line:assertions:)"},{"location":"swift/api/WorkflowTesting/structs/RenderTesterResult/#assertnoactionfileline","text":"public func assertNoAction ( file : StaticString = #file , line : UInt = #line ) -> RenderTesterResult < WorkflowType > Asserts that no actions were produced","title":"assertNoAction(file:line:)"},{"location":"swift/api/WorkflowTesting/structs/RenderTesterResult/#verifyactiontypefilelineassertions","text":"public func verifyAction < ActionType : WorkflowAction >( type : ActionType . Type = ActionType . self , file : StaticString = #file , line : UInt = #line , assertions : ( ActionType ) throws -> Void ) rethrows -> RenderTesterResult < WorkflowType > where ActionType . WorkflowType == WorkflowType Allows for assertions agains the resulting action","title":"verifyAction(type:file:line:assertions:)"},{"location":"swift/api/WorkflowTesting/structs/RenderTesterResult/#assertactionfileline","text":"public func assert < ActionType : WorkflowAction >( action : ActionType , file : StaticString = #file , line : UInt = #line ) -> RenderTesterResult < WorkflowType > where ActionType . WorkflowType == WorkflowType , ActionType : Equatable Asserts that the resulting action is equal to the given action.","title":"assert(action:file:line:)"},{"location":"swift/api/WorkflowTesting/structs/RenderTesterResult/#assertnooutputfileline","text":"public func assertNoOutput ( file : StaticString = #file , line : UInt = #line ) -> RenderTesterResult < WorkflowType > Asserts that no output was produced.","title":"assertNoOutput(file:line:)"},{"location":"swift/api/WorkflowTesting/structs/RenderTesterResult/#verifyoutputfilelineassertions","text":"public func verifyOutput ( file : StaticString = #file , line : UInt = #line , assertions : ( WorkflowType . Output ) throws -> Void ) rethrows -> RenderTesterResult < WorkflowType > Allows for assertions agains the resulting output","title":"verifyOutput(file:line:assertions:)"},{"location":"swift/api/WorkflowTesting/structs/WorkflowActionTester/","text":"STRUCT WorkflowActionTester \u00b6 public struct WorkflowActionTester < WorkflowType , Action > where Action : WorkflowAction , Action . WorkflowType == WorkflowType Testing helper that chains action sending and state/output assertions to make tests easier to write. MyWorkflow.Action .tester(withState: .firstState) .send(action: .exampleAction) .verifyOutput { output in XCTAssertEqual(.finished, output) } .verifyState { state in XCTAssertEqual(.differentState, state) } Or to assert that an action produces no output: MyWorkflow.Action .tester(withState: .firstState) .send(action: .actionProducingNoOutput) .assertNoOutput() .verifyState { state in XCTAssertEqual(.differentState, state) } If your State or Output are Equatable , you can use the convenience assertion methods: MyWorkflow.Action .tester(withState: .firstState) .send(action: .exampleAction) .assert(output: .finished) .assert(state: .differentState) Methods \u00b6 send(action:) \u00b6 public func send ( action : Action ) -> WorkflowActionTester < WorkflowType , Action > Sends an action to the reducer. parameter action: The action to send. returns: A new state tester containing the state and output (if any) after the update. Parameters \u00b6 Name Description action The action to send. assertNoOutput(file:line:) \u00b6 public func assertNoOutput ( file : StaticString = #file , line : UInt = #line ) -> WorkflowActionTester < WorkflowType , Action > Asserts that the action produced no output returns: A tester containing the current state and output. verifyOutput(file:line:_:) \u00b6 public func verifyOutput ( file : StaticString = #file , line : UInt = #line , _ assertions : ( WorkflowType . Output ) throws -> Void ) rethrows -> WorkflowActionTester < WorkflowType , Action > Invokes the given closure (which is intended to contain test assertions) with the produced output. If the previous action produced no output, the triggers a test failure and does not execute the closure. parameter assertions: A closure that accepts a single output value. returns: A tester containing the current state and output. Parameters \u00b6 Name Description assertions A closure that accepts a single output value. verifyState(_:) \u00b6 public func verifyState ( _ assertions : ( WorkflowType . State ) throws -> Void ) rethrows -> WorkflowActionTester < WorkflowType , Action > Invokes the given closure (which is intended to contain test assertions) with the current state. parameter assertions: A closure that accepts a single state value. returns: A tester containing the current state and output. Parameters \u00b6 Name Description assertions A closure that accepts a single state value.","title":"WorkflowActionTester"},{"location":"swift/api/WorkflowTesting/structs/WorkflowActionTester/#workflowactiontester","text":"public struct WorkflowActionTester < WorkflowType , Action > where Action : WorkflowAction , Action . WorkflowType == WorkflowType Testing helper that chains action sending and state/output assertions to make tests easier to write. MyWorkflow.Action .tester(withState: .firstState) .send(action: .exampleAction) .verifyOutput { output in XCTAssertEqual(.finished, output) } .verifyState { state in XCTAssertEqual(.differentState, state) } Or to assert that an action produces no output: MyWorkflow.Action .tester(withState: .firstState) .send(action: .actionProducingNoOutput) .assertNoOutput() .verifyState { state in XCTAssertEqual(.differentState, state) } If your State or Output are Equatable , you can use the convenience assertion methods: MyWorkflow.Action .tester(withState: .firstState) .send(action: .exampleAction) .assert(output: .finished) .assert(state: .differentState)","title":"WorkflowActionTester"},{"location":"swift/api/WorkflowTesting/structs/WorkflowActionTester/#methods","text":"","title":"Methods"},{"location":"swift/api/WorkflowTesting/structs/WorkflowActionTester/#sendaction","text":"public func send ( action : Action ) -> WorkflowActionTester < WorkflowType , Action > Sends an action to the reducer. parameter action: The action to send. returns: A new state tester containing the state and output (if any) after the update.","title":"send(action:)"},{"location":"swift/api/WorkflowTesting/structs/WorkflowActionTester/#parameters","text":"Name Description action The action to send.","title":"Parameters"},{"location":"swift/api/WorkflowTesting/structs/WorkflowActionTester/#assertnooutputfileline","text":"public func assertNoOutput ( file : StaticString = #file , line : UInt = #line ) -> WorkflowActionTester < WorkflowType , Action > Asserts that the action produced no output returns: A tester containing the current state and output.","title":"assertNoOutput(file:line:)"},{"location":"swift/api/WorkflowTesting/structs/WorkflowActionTester/#verifyoutputfileline_","text":"public func verifyOutput ( file : StaticString = #file , line : UInt = #line , _ assertions : ( WorkflowType . Output ) throws -> Void ) rethrows -> WorkflowActionTester < WorkflowType , Action > Invokes the given closure (which is intended to contain test assertions) with the produced output. If the previous action produced no output, the triggers a test failure and does not execute the closure. parameter assertions: A closure that accepts a single output value. returns: A tester containing the current state and output.","title":"verifyOutput(file:line:_:)"},{"location":"swift/api/WorkflowTesting/structs/WorkflowActionTester/#parameters_1","text":"Name Description assertions A closure that accepts a single output value.","title":"Parameters"},{"location":"swift/api/WorkflowTesting/structs/WorkflowActionTester/#verifystate_","text":"public func verifyState ( _ assertions : ( WorkflowType . State ) throws -> Void ) rethrows -> WorkflowActionTester < WorkflowType , Action > Invokes the given closure (which is intended to contain test assertions) with the current state. parameter assertions: A closure that accepts a single state value. returns: A tester containing the current state and output.","title":"verifyState(_:)"},{"location":"swift/api/WorkflowTesting/structs/WorkflowActionTester/#parameters_2","text":"Name Description assertions A closure that accepts a single state value.","title":"Parameters"},{"location":"swift/api/WorkflowUI/","text":"Reference Documentation \u00b6 Protocols \u00b6 Screen ViewEnvironmentKey Structs \u00b6 AnyScreen ViewControllerDescription ViewEnvironment Classes \u00b6 ContainerViewController DescribedViewController ScreenViewController Extensions \u00b6 Screen ScreenViewController This file was generated by SourceDocs on 2022-01-27 21:10:19 +0000","title":"WorkflowUI "},{"location":"swift/api/WorkflowUI/#reference-documentation","text":"","title":"Reference Documentation"},{"location":"swift/api/WorkflowUI/#protocols","text":"Screen ViewEnvironmentKey","title":"Protocols"},{"location":"swift/api/WorkflowUI/#structs","text":"AnyScreen ViewControllerDescription ViewEnvironment","title":"Structs"},{"location":"swift/api/WorkflowUI/#classes","text":"ContainerViewController DescribedViewController ScreenViewController","title":"Classes"},{"location":"swift/api/WorkflowUI/#extensions","text":"Screen ScreenViewController This file was generated by SourceDocs on 2022-01-27 21:10:19 +0000","title":"Extensions"},{"location":"swift/api/WorkflowUI/classes/ContainerViewController/","text":"CLASS ContainerViewController \u00b6 public final class ContainerViewController < ScreenType , Output >: UIViewController where ScreenType : Screen Drives view controllers from a root Workflow. Properties \u00b6 output \u00b6 public var output : Signal < Output , Never > Emits output events from the bound workflow. rootViewEnvironment \u00b6 public var rootViewEnvironment : ViewEnvironment childForStatusBarStyle \u00b6 override public var childForStatusBarStyle : UIViewController ? childForStatusBarHidden \u00b6 override public var childForStatusBarHidden : UIViewController ? childForHomeIndicatorAutoHidden \u00b6 override public var childForHomeIndicatorAutoHidden : UIViewController ? childForScreenEdgesDeferringSystemGestures \u00b6 override public var childForScreenEdgesDeferringSystemGestures : UIViewController ? supportedInterfaceOrientations \u00b6 override public var supportedInterfaceOrientations : UIInterfaceOrientationMask preferredStatusBarUpdateAnimation \u00b6 override public var preferredStatusBarUpdateAnimation : UIStatusBarAnimation childViewControllerForPointerLock \u00b6 override public var childViewControllerForPointerLock : UIViewController ? Methods \u00b6 init(workflow:rootViewEnvironment:) \u00b6 public init < W : AnyWorkflowConvertible >( workflow : W , rootViewEnvironment : ViewEnvironment = . empty ) where W . Rendering == ScreenType , W . Output == Output update(workflow:) \u00b6 public func update < W : AnyWorkflowConvertible >( workflow : W ) where W . Rendering == ScreenType , W . Output == Output Updates the root Workflow in this container. init(coder:) \u00b6 public required init ?( coder aDecoder : NSCoder ) viewDidLoad() \u00b6 override public func viewDidLoad () viewDidLayoutSubviews() \u00b6 override public func viewDidLayoutSubviews () preferredContentSizeDidChange(forChildContentContainer:) \u00b6 override public func preferredContentSizeDidChange ( forChildContentContainer container : UIContentContainer )","title":"ContainerViewController"},{"location":"swift/api/WorkflowUI/classes/ContainerViewController/#containerviewcontroller","text":"public final class ContainerViewController < ScreenType , Output >: UIViewController where ScreenType : Screen Drives view controllers from a root Workflow.","title":"ContainerViewController"},{"location":"swift/api/WorkflowUI/classes/ContainerViewController/#properties","text":"","title":"Properties"},{"location":"swift/api/WorkflowUI/classes/ContainerViewController/#output","text":"public var output : Signal < Output , Never > Emits output events from the bound workflow.","title":"output"},{"location":"swift/api/WorkflowUI/classes/ContainerViewController/#rootviewenvironment","text":"public var rootViewEnvironment : ViewEnvironment","title":"rootViewEnvironment"},{"location":"swift/api/WorkflowUI/classes/ContainerViewController/#childforstatusbarstyle","text":"override public var childForStatusBarStyle : UIViewController ?","title":"childForStatusBarStyle"},{"location":"swift/api/WorkflowUI/classes/ContainerViewController/#childforstatusbarhidden","text":"override public var childForStatusBarHidden : UIViewController ?","title":"childForStatusBarHidden"},{"location":"swift/api/WorkflowUI/classes/ContainerViewController/#childforhomeindicatorautohidden","text":"override public var childForHomeIndicatorAutoHidden : UIViewController ?","title":"childForHomeIndicatorAutoHidden"},{"location":"swift/api/WorkflowUI/classes/ContainerViewController/#childforscreenedgesdeferringsystemgestures","text":"override public var childForScreenEdgesDeferringSystemGestures : UIViewController ?","title":"childForScreenEdgesDeferringSystemGestures"},{"location":"swift/api/WorkflowUI/classes/ContainerViewController/#supportedinterfaceorientations","text":"override public var supportedInterfaceOrientations : UIInterfaceOrientationMask","title":"supportedInterfaceOrientations"},{"location":"swift/api/WorkflowUI/classes/ContainerViewController/#preferredstatusbarupdateanimation","text":"override public var preferredStatusBarUpdateAnimation : UIStatusBarAnimation","title":"preferredStatusBarUpdateAnimation"},{"location":"swift/api/WorkflowUI/classes/ContainerViewController/#childviewcontrollerforpointerlock","text":"override public var childViewControllerForPointerLock : UIViewController ?","title":"childViewControllerForPointerLock"},{"location":"swift/api/WorkflowUI/classes/ContainerViewController/#methods","text":"","title":"Methods"},{"location":"swift/api/WorkflowUI/classes/ContainerViewController/#initworkflowrootviewenvironment","text":"public init < W : AnyWorkflowConvertible >( workflow : W , rootViewEnvironment : ViewEnvironment = . empty ) where W . Rendering == ScreenType , W . Output == Output","title":"init(workflow:rootViewEnvironment:)"},{"location":"swift/api/WorkflowUI/classes/ContainerViewController/#updateworkflow","text":"public func update < W : AnyWorkflowConvertible >( workflow : W ) where W . Rendering == ScreenType , W . Output == Output Updates the root Workflow in this container.","title":"update(workflow:)"},{"location":"swift/api/WorkflowUI/classes/ContainerViewController/#initcoder","text":"public required init ?( coder aDecoder : NSCoder )","title":"init(coder:)"},{"location":"swift/api/WorkflowUI/classes/ContainerViewController/#viewdidload","text":"override public func viewDidLoad ()","title":"viewDidLoad()"},{"location":"swift/api/WorkflowUI/classes/ContainerViewController/#viewdidlayoutsubviews","text":"override public func viewDidLayoutSubviews ()","title":"viewDidLayoutSubviews()"},{"location":"swift/api/WorkflowUI/classes/ContainerViewController/#preferredcontentsizedidchangeforchildcontentcontainer","text":"override public func preferredContentSizeDidChange ( forChildContentContainer container : UIContentContainer )","title":"preferredContentSizeDidChange(forChildContentContainer:)"},{"location":"swift/api/WorkflowUI/classes/DescribedViewController/","text":"CLASS DescribedViewController \u00b6 public final class DescribedViewController : UIViewController Properties \u00b6 childForStatusBarStyle \u00b6 override public var childForStatusBarStyle : UIViewController ? childForStatusBarHidden \u00b6 override public var childForStatusBarHidden : UIViewController ? childForHomeIndicatorAutoHidden \u00b6 override public var childForHomeIndicatorAutoHidden : UIViewController ? childForScreenEdgesDeferringSystemGestures \u00b6 override public var childForScreenEdgesDeferringSystemGestures : UIViewController ? supportedInterfaceOrientations \u00b6 override public var supportedInterfaceOrientations : UIInterfaceOrientationMask preferredStatusBarUpdateAnimation \u00b6 override public var preferredStatusBarUpdateAnimation : UIStatusBarAnimation childViewControllerForPointerLock \u00b6 override public var childViewControllerForPointerLock : UIViewController ? Methods \u00b6 init(description:) \u00b6 public init ( description : ViewControllerDescription ) init(screen:environment:) \u00b6 public convenience init < S : Screen >( screen : S , environment : ViewEnvironment ) update(description:) \u00b6 public func update ( description : ViewControllerDescription ) update(screen:environment:) \u00b6 public func update < S : Screen >( screen : S , environment : ViewEnvironment ) viewDidLoad() \u00b6 override public func viewDidLoad () viewDidLayoutSubviews() \u00b6 override public func viewDidLayoutSubviews () preferredContentSizeDidChange(forChildContentContainer:) \u00b6 override public func preferredContentSizeDidChange ( forChildContentContainer container : UIContentContainer )","title":"DescribedViewController"},{"location":"swift/api/WorkflowUI/classes/DescribedViewController/#describedviewcontroller","text":"public final class DescribedViewController : UIViewController","title":"DescribedViewController"},{"location":"swift/api/WorkflowUI/classes/DescribedViewController/#properties","text":"","title":"Properties"},{"location":"swift/api/WorkflowUI/classes/DescribedViewController/#childforstatusbarstyle","text":"override public var childForStatusBarStyle : UIViewController ?","title":"childForStatusBarStyle"},{"location":"swift/api/WorkflowUI/classes/DescribedViewController/#childforstatusbarhidden","text":"override public var childForStatusBarHidden : UIViewController ?","title":"childForStatusBarHidden"},{"location":"swift/api/WorkflowUI/classes/DescribedViewController/#childforhomeindicatorautohidden","text":"override public var childForHomeIndicatorAutoHidden : UIViewController ?","title":"childForHomeIndicatorAutoHidden"},{"location":"swift/api/WorkflowUI/classes/DescribedViewController/#childforscreenedgesdeferringsystemgestures","text":"override public var childForScreenEdgesDeferringSystemGestures : UIViewController ?","title":"childForScreenEdgesDeferringSystemGestures"},{"location":"swift/api/WorkflowUI/classes/DescribedViewController/#supportedinterfaceorientations","text":"override public var supportedInterfaceOrientations : UIInterfaceOrientationMask","title":"supportedInterfaceOrientations"},{"location":"swift/api/WorkflowUI/classes/DescribedViewController/#preferredstatusbarupdateanimation","text":"override public var preferredStatusBarUpdateAnimation : UIStatusBarAnimation","title":"preferredStatusBarUpdateAnimation"},{"location":"swift/api/WorkflowUI/classes/DescribedViewController/#childviewcontrollerforpointerlock","text":"override public var childViewControllerForPointerLock : UIViewController ?","title":"childViewControllerForPointerLock"},{"location":"swift/api/WorkflowUI/classes/DescribedViewController/#methods","text":"","title":"Methods"},{"location":"swift/api/WorkflowUI/classes/DescribedViewController/#initdescription","text":"public init ( description : ViewControllerDescription )","title":"init(description:)"},{"location":"swift/api/WorkflowUI/classes/DescribedViewController/#initscreenenvironment","text":"public convenience init < S : Screen >( screen : S , environment : ViewEnvironment )","title":"init(screen:environment:)"},{"location":"swift/api/WorkflowUI/classes/DescribedViewController/#updatedescription","text":"public func update ( description : ViewControllerDescription )","title":"update(description:)"},{"location":"swift/api/WorkflowUI/classes/DescribedViewController/#updatescreenenvironment","text":"public func update < S : Screen >( screen : S , environment : ViewEnvironment )","title":"update(screen:environment:)"},{"location":"swift/api/WorkflowUI/classes/DescribedViewController/#viewdidload","text":"override public func viewDidLoad ()","title":"viewDidLoad()"},{"location":"swift/api/WorkflowUI/classes/DescribedViewController/#viewdidlayoutsubviews","text":"override public func viewDidLayoutSubviews ()","title":"viewDidLayoutSubviews()"},{"location":"swift/api/WorkflowUI/classes/DescribedViewController/#preferredcontentsizedidchangeforchildcontentcontainer","text":"override public func preferredContentSizeDidChange ( forChildContentContainer container : UIContentContainer )","title":"preferredContentSizeDidChange(forChildContentContainer:)"},{"location":"swift/api/WorkflowUI/classes/ScreenViewController/","text":"CLASS ScreenViewController \u00b6 open class ScreenViewController < ScreenType : Screen >: UIViewController Generic base class that can be subclassed in order to to define a UI implementation that is powered by the given screen type. Using this base class, a screen can be implemented as: struct MyScreen: Screen { func viewControllerDescription(environment: ViewEnvironment) -> ViewControllerDescription { return MyScreenViewController.description(for: self) } } private class MyScreenViewController: ScreenViewController<MyScreen> { override func screenDidChange(from previousScreen: MyScreen, previousEnvironment: ViewEnvironment) { // \u2026 update views as necessary } } Properties \u00b6 screen \u00b6 public private ( set ) final var screen : ScreenType screenType \u00b6 public final var screenType : Screen . Type environment \u00b6 public private ( set ) final var environment : ViewEnvironment Methods \u00b6 init(screen:environment:) \u00b6 public required init ( screen : ScreenType , environment : ViewEnvironment ) init(coder:) \u00b6 update(screen:environment:) \u00b6 public final func update ( screen : ScreenType , environment : ViewEnvironment ) screenDidChange(from:previousEnvironment:) \u00b6 open func screenDidChange ( from previousScreen : ScreenType , previousEnvironment : ViewEnvironment ) Subclasses should override this method in order to update any relevant UI bits when the screen model changes.","title":"ScreenViewController"},{"location":"swift/api/WorkflowUI/classes/ScreenViewController/#screenviewcontroller","text":"open class ScreenViewController < ScreenType : Screen >: UIViewController Generic base class that can be subclassed in order to to define a UI implementation that is powered by the given screen type. Using this base class, a screen can be implemented as: struct MyScreen: Screen { func viewControllerDescription(environment: ViewEnvironment) -> ViewControllerDescription { return MyScreenViewController.description(for: self) } } private class MyScreenViewController: ScreenViewController<MyScreen> { override func screenDidChange(from previousScreen: MyScreen, previousEnvironment: ViewEnvironment) { // \u2026 update views as necessary } }","title":"ScreenViewController"},{"location":"swift/api/WorkflowUI/classes/ScreenViewController/#properties","text":"","title":"Properties"},{"location":"swift/api/WorkflowUI/classes/ScreenViewController/#screen","text":"public private ( set ) final var screen : ScreenType","title":"screen"},{"location":"swift/api/WorkflowUI/classes/ScreenViewController/#screentype","text":"public final var screenType : Screen . Type","title":"screenType"},{"location":"swift/api/WorkflowUI/classes/ScreenViewController/#environment","text":"public private ( set ) final var environment : ViewEnvironment","title":"environment"},{"location":"swift/api/WorkflowUI/classes/ScreenViewController/#methods","text":"","title":"Methods"},{"location":"swift/api/WorkflowUI/classes/ScreenViewController/#initscreenenvironment","text":"public required init ( screen : ScreenType , environment : ViewEnvironment )","title":"init(screen:environment:)"},{"location":"swift/api/WorkflowUI/classes/ScreenViewController/#initcoder","text":"","title":"init(coder:)"},{"location":"swift/api/WorkflowUI/classes/ScreenViewController/#updatescreenenvironment","text":"public final func update ( screen : ScreenType , environment : ViewEnvironment )","title":"update(screen:environment:)"},{"location":"swift/api/WorkflowUI/classes/ScreenViewController/#screendidchangefrompreviousenvironment","text":"open func screenDidChange ( from previousScreen : ScreenType , previousEnvironment : ViewEnvironment ) Subclasses should override this method in order to update any relevant UI bits when the screen model changes.","title":"screenDidChange(from:previousEnvironment:)"},{"location":"swift/api/WorkflowUI/extensions/Screen/","text":"EXTENSION Screen \u00b6 extension Screen Methods \u00b6 asAnyScreen() \u00b6 public func asAnyScreen () -> AnyScreen Wraps the screen in an AnyScreen","title":"Screen"},{"location":"swift/api/WorkflowUI/extensions/Screen/#screen","text":"extension Screen","title":"Screen"},{"location":"swift/api/WorkflowUI/extensions/Screen/#methods","text":"","title":"Methods"},{"location":"swift/api/WorkflowUI/extensions/Screen/#asanyscreen","text":"public func asAnyScreen () -> AnyScreen Wraps the screen in an AnyScreen","title":"asAnyScreen()"},{"location":"swift/api/WorkflowUI/extensions/ScreenViewController/","text":"EXTENSION ScreenViewController \u00b6 extension ScreenViewController Methods \u00b6 description(for:environment:) \u00b6 public final class func description ( for screen : ScreenType , environment : ViewEnvironment ) -> ViewControllerDescription Convenience to create a view controller description for the given screen value. See the example on the comment for ScreenViewController for usage.","title":"ScreenViewController"},{"location":"swift/api/WorkflowUI/extensions/ScreenViewController/#screenviewcontroller","text":"extension ScreenViewController","title":"ScreenViewController"},{"location":"swift/api/WorkflowUI/extensions/ScreenViewController/#methods","text":"","title":"Methods"},{"location":"swift/api/WorkflowUI/extensions/ScreenViewController/#descriptionforenvironment","text":"public final class func description ( for screen : ScreenType , environment : ViewEnvironment ) -> ViewControllerDescription Convenience to create a view controller description for the given screen value. See the example on the comment for ScreenViewController for usage.","title":"description(for:environment:)"},{"location":"swift/api/WorkflowUI/protocols/Screen/","text":"PROTOCOL Screen \u00b6 public protocol Screen Screens are the building blocks of an interactive application. Conforming types contain any information needed to populate a screen: data, styling, event handlers, etc. Methods \u00b6 viewControllerDescription(environment:) \u00b6 func viewControllerDescription ( environment : ViewEnvironment ) -> ViewControllerDescription A view controller description that acts as a recipe to either build or update a previously-built view controller to match this screen.","title":"Screen"},{"location":"swift/api/WorkflowUI/protocols/Screen/#screen","text":"public protocol Screen Screens are the building blocks of an interactive application. Conforming types contain any information needed to populate a screen: data, styling, event handlers, etc.","title":"Screen"},{"location":"swift/api/WorkflowUI/protocols/Screen/#methods","text":"","title":"Methods"},{"location":"swift/api/WorkflowUI/protocols/Screen/#viewcontrollerdescriptionenvironment","text":"func viewControllerDescription ( environment : ViewEnvironment ) -> ViewControllerDescription A view controller description that acts as a recipe to either build or update a previously-built view controller to match this screen.","title":"viewControllerDescription(environment:)"},{"location":"swift/api/WorkflowUI/protocols/ViewEnvironmentKey/","text":"PROTOCOL ViewEnvironmentKey \u00b6 public protocol ViewEnvironmentKey A key into the ViewEnvironment. Environment keys are associated with a specific type of value ( Value ) and must declare a default value. Typically the key conforming to ViewEnvironmentKey will be private, and you are encouraged to provide a convenience accessor on ViewEnvironment as in the following example: private enum ThemeKey: ViewEnvironmentKey { typealias Value = Theme var defaultValue: Theme } extension ViewEnvironment { public var theme: Theme { get { self[ThemeKey.self] } set { self[ThemeKey.self] = newValue } } } Properties \u00b6 defaultValue \u00b6 static var defaultValue : Value","title":"ViewEnvironmentKey"},{"location":"swift/api/WorkflowUI/protocols/ViewEnvironmentKey/#viewenvironmentkey","text":"public protocol ViewEnvironmentKey A key into the ViewEnvironment. Environment keys are associated with a specific type of value ( Value ) and must declare a default value. Typically the key conforming to ViewEnvironmentKey will be private, and you are encouraged to provide a convenience accessor on ViewEnvironment as in the following example: private enum ThemeKey: ViewEnvironmentKey { typealias Value = Theme var defaultValue: Theme } extension ViewEnvironment { public var theme: Theme { get { self[ThemeKey.self] } set { self[ThemeKey.self] = newValue } } }","title":"ViewEnvironmentKey"},{"location":"swift/api/WorkflowUI/protocols/ViewEnvironmentKey/#properties","text":"","title":"Properties"},{"location":"swift/api/WorkflowUI/protocols/ViewEnvironmentKey/#defaultvalue","text":"static var defaultValue : Value","title":"defaultValue"},{"location":"swift/api/WorkflowUI/structs/AnyScreen/","text":"STRUCT AnyScreen \u00b6 public struct AnyScreen : Screen Methods \u00b6 init(_:) \u00b6 public init < T : Screen >( _ screen : T ) viewControllerDescription(environment:) \u00b6 public func viewControllerDescription ( environment : ViewEnvironment ) -> ViewControllerDescription","title":"AnyScreen"},{"location":"swift/api/WorkflowUI/structs/AnyScreen/#anyscreen","text":"public struct AnyScreen : Screen","title":"AnyScreen"},{"location":"swift/api/WorkflowUI/structs/AnyScreen/#methods","text":"","title":"Methods"},{"location":"swift/api/WorkflowUI/structs/AnyScreen/#init_","text":"public init < T : Screen >( _ screen : T )","title":"init(_:)"},{"location":"swift/api/WorkflowUI/structs/AnyScreen/#viewcontrollerdescriptionenvironment","text":"public func viewControllerDescription ( environment : ViewEnvironment ) -> ViewControllerDescription","title":"viewControllerDescription(environment:)"},{"location":"swift/api/WorkflowUI/structs/ViewControllerDescription/","text":"STRUCT ViewControllerDescription \u00b6 public struct ViewControllerDescription A ViewControllerDescription acts as a recipe for building and updating a specific UIViewController. Methods \u00b6 init(type:build:update:) \u00b6 public init < VC : UIViewController >( type : VC . Type = VC . self , build : @ escaping () -> VC , update : @ escaping ( VC ) -> Void ) Constructs a view controller description by providing a closure used to build and update a specific view controller type. Parameters: type: The type of view controller produced by this description. Typically, should should be able to omit this parameter, but in cases where type inference has trouble, it\u2019s offered as an escape hatch. build: Closure that produces a new instance of the view controller update: Closure that updates the given view controller Parameters \u00b6 Name Description type The type of view controller produced by this description. Typically, should should be able to omit this parameter, but in cases where type inference has trouble, it\u2019s offered as an escape hatch. build Closure that produces a new instance of the view controller update Closure that updates the given view controller","title":"ViewControllerDescription"},{"location":"swift/api/WorkflowUI/structs/ViewControllerDescription/#viewcontrollerdescription","text":"public struct ViewControllerDescription A ViewControllerDescription acts as a recipe for building and updating a specific UIViewController.","title":"ViewControllerDescription"},{"location":"swift/api/WorkflowUI/structs/ViewControllerDescription/#methods","text":"","title":"Methods"},{"location":"swift/api/WorkflowUI/structs/ViewControllerDescription/#inittypebuildupdate","text":"public init < VC : UIViewController >( type : VC . Type = VC . self , build : @ escaping () -> VC , update : @ escaping ( VC ) -> Void ) Constructs a view controller description by providing a closure used to build and update a specific view controller type. Parameters: type: The type of view controller produced by this description. Typically, should should be able to omit this parameter, but in cases where type inference has trouble, it\u2019s offered as an escape hatch. build: Closure that produces a new instance of the view controller update: Closure that updates the given view controller","title":"init(type:build:update:)"},{"location":"swift/api/WorkflowUI/structs/ViewControllerDescription/#parameters","text":"Name Description type The type of view controller produced by this description. Typically, should should be able to omit this parameter, but in cases where type inference has trouble, it\u2019s offered as an escape hatch. build Closure that produces a new instance of the view controller update Closure that updates the given view controller","title":"Parameters"},{"location":"swift/api/WorkflowUI/structs/ViewEnvironment/","text":"STRUCT ViewEnvironment \u00b6 public struct ViewEnvironment ViewEnvironment acts as a container for values to flow down the view-side of a rendering tree (as opposed to being passed down through Workflows). This will often be used by containers to let their children know in what context they\u2019re appearing (for example, a split screen container may set the environment of its two children according to which position they\u2019re appearing in). Properties \u00b6 empty \u00b6 public static let empty : ViewEnvironment = ViewEnvironment () An empty view environment. This should only be used when setting up a root workflow into a root ContainerViewController or when writing tests. In other scenarios, containers should pass down the ViewEnvironment value they get from above. Methods \u00b6 setting(key:to:) \u00b6 public func setting < Key >( key : Key . Type , to value : Key . Value ) -> ViewEnvironment where Key : ViewEnvironmentKey Returns a new ViewEnvironment with the given value set for the given environment key. This is provided as a convenience for modifying the environment while passing it down to children screens without the need for an intermediate mutable value. It is functionally equivalent to the subscript setter. setting(keyPath:to:) \u00b6 public func setting < Value >( keyPath : WritableKeyPath < ViewEnvironment , Value >, to value : Value ) -> ViewEnvironment Returns a new ViewEnvironment with the given value set for the given key path. This is provided as a convenience for modifying the environment while passing it down to children screens. The following are functionally equivalent: var newEnvironment = environment newEnvironment.someProperty = 42 and let newEnvironment = environment.setting(\\.someProperty, to: 42)","title":"ViewEnvironment"},{"location":"swift/api/WorkflowUI/structs/ViewEnvironment/#viewenvironment","text":"public struct ViewEnvironment ViewEnvironment acts as a container for values to flow down the view-side of a rendering tree (as opposed to being passed down through Workflows). This will often be used by containers to let their children know in what context they\u2019re appearing (for example, a split screen container may set the environment of its two children according to which position they\u2019re appearing in).","title":"ViewEnvironment"},{"location":"swift/api/WorkflowUI/structs/ViewEnvironment/#properties","text":"","title":"Properties"},{"location":"swift/api/WorkflowUI/structs/ViewEnvironment/#empty","text":"public static let empty : ViewEnvironment = ViewEnvironment () An empty view environment. This should only be used when setting up a root workflow into a root ContainerViewController or when writing tests. In other scenarios, containers should pass down the ViewEnvironment value they get from above.","title":"empty"},{"location":"swift/api/WorkflowUI/structs/ViewEnvironment/#methods","text":"","title":"Methods"},{"location":"swift/api/WorkflowUI/structs/ViewEnvironment/#settingkeyto","text":"public func setting < Key >( key : Key . Type , to value : Key . Value ) -> ViewEnvironment where Key : ViewEnvironmentKey Returns a new ViewEnvironment with the given value set for the given environment key. This is provided as a convenience for modifying the environment while passing it down to children screens without the need for an intermediate mutable value. It is functionally equivalent to the subscript setter.","title":"setting(key:to:)"},{"location":"swift/api/WorkflowUI/structs/ViewEnvironment/#settingkeypathto","text":"public func setting < Value >( keyPath : WritableKeyPath < ViewEnvironment , Value >, to value : Value ) -> ViewEnvironment Returns a new ViewEnvironment with the given value set for the given key path. This is provided as a convenience for modifying the environment while passing it down to children screens. The following are functionally equivalent: var newEnvironment = environment newEnvironment.someProperty = 42 and let newEnvironment = environment.setting(\\.someProperty, to: 42)","title":"setting(keyPath:to:)"},{"location":"tutorial/","text":"Swift \u00b6 Tip For a comprehensive tutorial with code that you can build and follow along with, see the Tutorials in the repo. This section will be restructured soon to incorporate that and Kotlin tutorials. In the meantime, check out workflow-kotlin for Kotlin examples. The Workflow infrastructure is split into several modules. Workflow \u00b6 The Workflow library contains the core types that are used to implement state-driven workflows, including the Workflow protocol and related infrastructure. WorkflowUI \u00b6 Contains the basic infrastructure required to build a Workflow-based application that uses UIKit . Workflow for iOS makes extensive use of ReactiveSwift . If you are new to reactive programming, you may want to familiarize yourself with some of the basics. Workflow takes care of a lot of the reactive plumbing in a typical application, but you will have a better time if you understand what the framework is doing. Core Reactive Primitives Basic Operators How does ReactiveSwift relate to RxSwift? Next Steps \u00b6 Tooling Adding Workflow to a Project Building a Workflow Building a View Controller from a Screen Using a Workflow to Show UI","title":"Overview"},{"location":"tutorial/#swift","text":"Tip For a comprehensive tutorial with code that you can build and follow along with, see the Tutorials in the repo. This section will be restructured soon to incorporate that and Kotlin tutorials. In the meantime, check out workflow-kotlin for Kotlin examples. The Workflow infrastructure is split into several modules.","title":"Swift"},{"location":"tutorial/#workflow","text":"The Workflow library contains the core types that are used to implement state-driven workflows, including the Workflow protocol and related infrastructure.","title":"Workflow"},{"location":"tutorial/#workflowui","text":"Contains the basic infrastructure required to build a Workflow-based application that uses UIKit . Workflow for iOS makes extensive use of ReactiveSwift . If you are new to reactive programming, you may want to familiarize yourself with some of the basics. Workflow takes care of a lot of the reactive plumbing in a typical application, but you will have a better time if you understand what the framework is doing. Core Reactive Primitives Basic Operators How does ReactiveSwift relate to RxSwift?","title":"WorkflowUI"},{"location":"tutorial/#next-steps","text":"Tooling Adding Workflow to a Project Building a Workflow Building a View Controller from a Screen Using a Workflow to Show UI","title":"Next Steps"},{"location":"tutorial/adding-workflow-to-a-project/","text":"Adding Workflow to a project \u00b6 This document will guide you through the process of adding Workflow to an iOS project. Libraries \u00b6 You\u2019ll need the following four libraries: import Workflow import WorkflowUI import ReactiveSwift The easiest way to integrate these libraries is via Cocoapods. If you are using Cocoapods, you can simply add the dependencies to your .podspec . # MySoftware.podspec Pod :: Spec . new do | s | # ... s . dependency 'Workflow' s . dependency 'WorkflowUI' s . dependency 'ReactiveSwift' # ... end","title":"Adding Workflow to a project"},{"location":"tutorial/adding-workflow-to-a-project/#adding-workflow-to-a-project","text":"This document will guide you through the process of adding Workflow to an iOS project.","title":"Adding Workflow to a project"},{"location":"tutorial/adding-workflow-to-a-project/#libraries","text":"You\u2019ll need the following four libraries: import Workflow import WorkflowUI import ReactiveSwift The easiest way to integrate these libraries is via Cocoapods. If you are using Cocoapods, you can simply add the dependencies to your .podspec . # MySoftware.podspec Pod :: Spec . new do | s | # ... s . dependency 'Workflow' s . dependency 'WorkflowUI' s . dependency 'ReactiveSwift' # ... end","title":"Libraries"},{"location":"tutorial/building-a-view-controller-from-screen/","text":"Building a View Controller from a Screen \u00b6 Now that we have a workflow, we need a way to map our screen to an actual view controller. ScreenViewController \u00b6 The ScreenViewController provides a base class that hides the plumbing of updating a view controller from a view model update. struct DemoScreen : Screen { let title : String let onTap : () -> Void func viewControllerDescription ( environment : ViewEnvironment ) -> ViewControllerDescription { return DemoScreenViewController . description ( for : self , environment : environment ) } } class DemoScreenViewController : ScreenViewController < DemoScreen > { private let button : UIButton required init ( screen : DemoScreen , environment : ViewEnvironment ) { button = UIButton () super . init ( screen : screen , environment : environment ) update ( screen : screen ) } override func viewDidLoad () { super . viewDidLoad () button . addTarget ( self , action : #selector ( buttonPressed ( sender :)), for : . touchUpInside ) view . addSubview ( button ) } override func viewWillLayoutSubviews () { super . viewWillLayoutSubviews () button . frame = view . bounds } override func screenDidChange ( from previousScreen : DemoScreen , previousEnvironment : ViewEnvironment ) { super . screenDidChange ( from : previousScreen , previousEnvironment : previousEnvironment ) update ( screen : screen ) } private func update ( screen : DemoScreen ) { button . setTitle ( screen . title , for : . normal ) } @objc private func buttonPressed ( sender : UIButton ) { screen . onTap () } } Lifecycle \u00b6 When the view controller is first created, it is given the initial screen value. In the example, we create the button and set the title for it via the update method. The view loads as normal, adding the button the hierarchy and setting up the target:action for the button being pressed. The button is tapped. When the callback is called, we call the onTap closure passed into the screen. The workflow will handle this event, update its state, and a new screen will be rendered. The updated screen is passed to the view controller via the screenDidChange(from previousScreen: previousEnvironment: previousEnvironment:) method. Again, the view controller updates the title of the button based on what was passed in the screen.","title":"Building a View Controller from a Screen"},{"location":"tutorial/building-a-view-controller-from-screen/#building-a-view-controller-from-a-screen","text":"Now that we have a workflow, we need a way to map our screen to an actual view controller.","title":"Building a View Controller from a Screen"},{"location":"tutorial/building-a-view-controller-from-screen/#screenviewcontroller","text":"The ScreenViewController provides a base class that hides the plumbing of updating a view controller from a view model update. struct DemoScreen : Screen { let title : String let onTap : () -> Void func viewControllerDescription ( environment : ViewEnvironment ) -> ViewControllerDescription { return DemoScreenViewController . description ( for : self , environment : environment ) } } class DemoScreenViewController : ScreenViewController < DemoScreen > { private let button : UIButton required init ( screen : DemoScreen , environment : ViewEnvironment ) { button = UIButton () super . init ( screen : screen , environment : environment ) update ( screen : screen ) } override func viewDidLoad () { super . viewDidLoad () button . addTarget ( self , action : #selector ( buttonPressed ( sender :)), for : . touchUpInside ) view . addSubview ( button ) } override func viewWillLayoutSubviews () { super . viewWillLayoutSubviews () button . frame = view . bounds } override func screenDidChange ( from previousScreen : DemoScreen , previousEnvironment : ViewEnvironment ) { super . screenDidChange ( from : previousScreen , previousEnvironment : previousEnvironment ) update ( screen : screen ) } private func update ( screen : DemoScreen ) { button . setTitle ( screen . title , for : . normal ) } @objc private func buttonPressed ( sender : UIButton ) { screen . onTap () } }","title":"ScreenViewController"},{"location":"tutorial/building-a-view-controller-from-screen/#lifecycle","text":"When the view controller is first created, it is given the initial screen value. In the example, we create the button and set the title for it via the update method. The view loads as normal, adding the button the hierarchy and setting up the target:action for the button being pressed. The button is tapped. When the callback is called, we call the onTap closure passed into the screen. The workflow will handle this event, update its state, and a new screen will be rendered. The updated screen is passed to the view controller via the screenDidChange(from previousScreen: previousEnvironment: previousEnvironment:) method. Again, the view controller updates the title of the button based on what was passed in the screen.","title":"Lifecycle"},{"location":"tutorial/building-a-workflow/","text":"Building a Workflow \u00b6 Introduction \u00b6 A simple workflow looks something like this: struct DemoWorkflow : Workflow { var name : String init ( name : String ) { self . name = name } } extension DemoWorkflow { struct State {} func makeInitialState () -> State { return State () } func workflowDidChange ( from previousWorkflow : DemoWorkflow , state : inout State ) { } func render ( state : State , context : RenderContext < DemoWorkflow >) -> String { return \"Hello, \\( name ) \" } } A type conforming to Workflow represents a single node in the workflow tree. It should contain any values that must be provided by its parent (who is generally responsible for creating child workflows). Configuration parameters, strings, network services\u2026 If your workflow needs access to a value or object that it cannot create itself, they should be passed into the workflow\u2019s initializer. Every workflow defines its own State type to contain any data that should persist through subsequent render passes. Render \u00b6 Workflows are only useful when they render a value for use by their parent (or, if they are the root workflow, for display). This type is very commonly a view model, or Screen . The render(state:context:) method has a couple of parameters, so we\u2019ll work through them one by one. func render ( state : State , context : RenderContext < DemoWorkflow >) -> Rendering state \u00b6 Contains a value of type State to provide access to the current state. Any time the state of workflow changes, render is called again to take into account the change in state. context \u00b6 The render context: provides a way for a workflow to defer to nested (child) workflows to generate some or all of its rendered output. We\u2019ll walk through that process later on when we cover composition. allows a workflow to request the execution of asynchronous tasks ( Worker s) generates event handlers for use in constructing view models. In order for us to see the anything in our app, we\u2019ll need to return a Screen that can be turned into a view controller: func render ( state : State , context : RenderContext < DemoWorkflow >) -> DemoScreen { return DemoScreen ( title : \"A nice title\" ) } Actions, or \u201cThings that advance a workflow\u201d \u00b6 So far we have only covered workflows that perform simple tasks like generate strings or simple screens with no actions. If our workflows take on a complicated roles like generating view models, however, they will inevitably be required to handle events of some kind \u2013 some from UI events such as button taps, others from infrastructure events such as network responses. In conventional UIKit code, it is common to deal with each of those event types differently. The common pattern is to implement a method like handleButtonTap(sender:) . Workflows are more strict about events, however. Workflows require that all events be expressed as \u201cWorkflow Actions.\u201d These actions should be thought of as the entry point to your workflow. If any action of any kind happens (that your workflow cares about), it should be modeled as an action. struct DemoWorkflow : Workflow { /// ... } enum Action : WorkflowAction { typealias WorkflowType = DemoWorkflow case refreshButtonTapped /// UI event case refreshRequestFinished ( RefreshResponse ) /// Network event func apply ( toState state : inout DemoWorkflow . State ) -> DemoWorkflow . Output ? { /// ... } } The Update Cycle \u00b6 Every time a new action is received, it is applied to the current state of the workflow. If your workflow does more than simply render values, the action\u2019s apply is the method where the logic lives. There are two things that the apply(toState:) method is responsible for: Transitioning state (Optionally) emitting an output event Note that the render(state:context:) method is called after every state change, so you can be sure that any state changes will be reflected. Since we have a way of expressing an event from our UI, we can now use the callback on our view model to send that event back to the workflow: func render ( state : State , context : RenderContext < DemoWorkflow >) -> DemoScreen { // Create a sink of our Action type so we can send actions back to the workflow. let sink = context . makeSink ( of : Action . self ) return DemoScreen ( title : \"A nice title\" , onTap : { sink . send ( Action . refreshButtonTapped ) } ) } State \u00b6 Some workflows do not need state at all \u2013 they simply render values based on the values they were initialized with. But for more complicated workflows, state management is critical. For example, a multi-screen flow only functions if we are able to define all of the possible steps (model the state), remember which one we are currently on (persist state), and move to other steps in the future (transition state). To define your workflow\u2019s state, simply implement the associatedtype State via an enum or struct. struct WelcomeFlowWorkflow : Workflow { enum State { case splashScreen case loginFlow case signupFlow } enum Action : WorkflowAction { case back /// ... } /// ... } Note Workflows (and their State ) should always be implemented through value types (structs and enums) due to the way the framework handles state changes. This means that you can never capture references to self , but the consistent flow of data pays dividends \u2013 try this architecture for a while and we are confident that you will see the benefits. Workers, or \u201cAsynchronous work the workflow needs done\u201d \u00b6 A workflow may need to do some amount of asynchronous work (such as a network request, reading from a SQLite database, etc). Workers provide a declarative interface to units of asynchronous work. To do something asynchronously, we define a worker that has an Output type and defines a run method that that returns a Reactive Swift SignalProducer . When this worker is run, the SignalProducer is subscribed to, starting the async task. struct RefreshWorker : Worker { enum Output { case success ( String ) case error ( Error ) } func run () -> SignalProducer < RefreshWorker . Output , Never > { return SignalProducer ( value : . success ( \"We did it!\" )) . delay ( 1.0 , on : QueueScheduler . main ) } func isEquivalent ( to otherWorker : RefreshWorker ) -> Bool { return true } } Because a Worker is a declarative representation of work, it also needs to define an isEquivalent to guarantee that we are not running more than one at the same time. For the simple example above, it is always considered equivalent as we want only one of this type of worker running at a time. In order to start asynchronous work, the workflow requests it in the render method, looking something like: public func render ( state : State , context : RenderContext < DemoWorkflow >) -> DemoScreen { RefreshWorker () . mapOutput { output -> Action in switch output { case . success ( let result ): return Action . refreshComplete ( result ) case . error ( let error ): return Action . refreshError ( error ) } } . running ( in : context ) } When running(in:) is executed on a worker, the context will do the following: Check if there is already a worker running of the same type: If there is not, or isEquivalent is false, call run on the worker and subscribe to the SignalProducer If there is already a worker running and isEquivalent is true, continue to wait for it to produce an output. When the SignalProducer from the Worker returns an output, it is mapped to an Action and handled the same way as any other action. Output Events \u00b6 The last role of the update cycle is to emit output events. As workflows form a hierarchy, it is common for children to send events up the tree. This may happen when a child workflow finishes or cancels, for example. Workflows can define an output type, which may then be returned by Actions. Composition \u00b6 Composition is the primary tool that we can use to manage complexity in a growing application. Workflows should always be kept small enough to be understandable \u2013 less than 150 lines is a good target. By composing together multiple workflows, complex problems can be broken down into individual pieces that can be quickly understood by other developers (including future you). The context provided to the render(state:context:) method defines the API through which composition is made possible. The Render Context \u00b6 The useful role of children is ultimately to provide rendered values (typically screen models) via their render(state:context:) implementation. To obtain that value from a child workflow, the rendered(with context:key:) method is invoked on the child workflow. When a workflow is rendered with the context, the context will do the following: Check if the child workflow is new or existing: If a workflow with the same type was used during the last render pass, the existing child workflow will be updated with the new workflow. Otherwise, a new child workflow node will be initialized. The child workflow\u2019s render(state:context:) method is called. The rendered value is returned. In practice, this looks something like this: struct ParentWorkflow : Workflow { func render ( state : State , context : RenderContext < ParentWorkflow >) -> String { let childWorkflow = ChildWorkflow ( text : \"Hello, World\" ) return childWorkflow . rendered ( with : context ) } } struct ChildWorkflow : Workflow { var text : String // ... func render ( state : State , context : RenderContext < ChildWorkflow >) -> String { return String ( text . reversed ()) } }","title":"Building a Workflow"},{"location":"tutorial/building-a-workflow/#building-a-workflow","text":"","title":"Building a Workflow"},{"location":"tutorial/building-a-workflow/#introduction","text":"A simple workflow looks something like this: struct DemoWorkflow : Workflow { var name : String init ( name : String ) { self . name = name } } extension DemoWorkflow { struct State {} func makeInitialState () -> State { return State () } func workflowDidChange ( from previousWorkflow : DemoWorkflow , state : inout State ) { } func render ( state : State , context : RenderContext < DemoWorkflow >) -> String { return \"Hello, \\( name ) \" } } A type conforming to Workflow represents a single node in the workflow tree. It should contain any values that must be provided by its parent (who is generally responsible for creating child workflows). Configuration parameters, strings, network services\u2026 If your workflow needs access to a value or object that it cannot create itself, they should be passed into the workflow\u2019s initializer. Every workflow defines its own State type to contain any data that should persist through subsequent render passes.","title":"Introduction"},{"location":"tutorial/building-a-workflow/#render","text":"Workflows are only useful when they render a value for use by their parent (or, if they are the root workflow, for display). This type is very commonly a view model, or Screen . The render(state:context:) method has a couple of parameters, so we\u2019ll work through them one by one. func render ( state : State , context : RenderContext < DemoWorkflow >) -> Rendering","title":"Render"},{"location":"tutorial/building-a-workflow/#state","text":"Contains a value of type State to provide access to the current state. Any time the state of workflow changes, render is called again to take into account the change in state.","title":"state"},{"location":"tutorial/building-a-workflow/#context","text":"The render context: provides a way for a workflow to defer to nested (child) workflows to generate some or all of its rendered output. We\u2019ll walk through that process later on when we cover composition. allows a workflow to request the execution of asynchronous tasks ( Worker s) generates event handlers for use in constructing view models. In order for us to see the anything in our app, we\u2019ll need to return a Screen that can be turned into a view controller: func render ( state : State , context : RenderContext < DemoWorkflow >) -> DemoScreen { return DemoScreen ( title : \"A nice title\" ) }","title":"context"},{"location":"tutorial/building-a-workflow/#actions-or-things-that-advance-a-workflow","text":"So far we have only covered workflows that perform simple tasks like generate strings or simple screens with no actions. If our workflows take on a complicated roles like generating view models, however, they will inevitably be required to handle events of some kind \u2013 some from UI events such as button taps, others from infrastructure events such as network responses. In conventional UIKit code, it is common to deal with each of those event types differently. The common pattern is to implement a method like handleButtonTap(sender:) . Workflows are more strict about events, however. Workflows require that all events be expressed as \u201cWorkflow Actions.\u201d These actions should be thought of as the entry point to your workflow. If any action of any kind happens (that your workflow cares about), it should be modeled as an action. struct DemoWorkflow : Workflow { /// ... } enum Action : WorkflowAction { typealias WorkflowType = DemoWorkflow case refreshButtonTapped /// UI event case refreshRequestFinished ( RefreshResponse ) /// Network event func apply ( toState state : inout DemoWorkflow . State ) -> DemoWorkflow . Output ? { /// ... } }","title":"Actions, or \u201cThings that advance a workflow\u201d"},{"location":"tutorial/building-a-workflow/#the-update-cycle","text":"Every time a new action is received, it is applied to the current state of the workflow. If your workflow does more than simply render values, the action\u2019s apply is the method where the logic lives. There are two things that the apply(toState:) method is responsible for: Transitioning state (Optionally) emitting an output event Note that the render(state:context:) method is called after every state change, so you can be sure that any state changes will be reflected. Since we have a way of expressing an event from our UI, we can now use the callback on our view model to send that event back to the workflow: func render ( state : State , context : RenderContext < DemoWorkflow >) -> DemoScreen { // Create a sink of our Action type so we can send actions back to the workflow. let sink = context . makeSink ( of : Action . self ) return DemoScreen ( title : \"A nice title\" , onTap : { sink . send ( Action . refreshButtonTapped ) } ) }","title":"The Update Cycle"},{"location":"tutorial/building-a-workflow/#state_1","text":"Some workflows do not need state at all \u2013 they simply render values based on the values they were initialized with. But for more complicated workflows, state management is critical. For example, a multi-screen flow only functions if we are able to define all of the possible steps (model the state), remember which one we are currently on (persist state), and move to other steps in the future (transition state). To define your workflow\u2019s state, simply implement the associatedtype State via an enum or struct. struct WelcomeFlowWorkflow : Workflow { enum State { case splashScreen case loginFlow case signupFlow } enum Action : WorkflowAction { case back /// ... } /// ... } Note Workflows (and their State ) should always be implemented through value types (structs and enums) due to the way the framework handles state changes. This means that you can never capture references to self , but the consistent flow of data pays dividends \u2013 try this architecture for a while and we are confident that you will see the benefits.","title":"State"},{"location":"tutorial/building-a-workflow/#workers-or-asynchronous-work-the-workflow-needs-done","text":"A workflow may need to do some amount of asynchronous work (such as a network request, reading from a SQLite database, etc). Workers provide a declarative interface to units of asynchronous work. To do something asynchronously, we define a worker that has an Output type and defines a run method that that returns a Reactive Swift SignalProducer . When this worker is run, the SignalProducer is subscribed to, starting the async task. struct RefreshWorker : Worker { enum Output { case success ( String ) case error ( Error ) } func run () -> SignalProducer < RefreshWorker . Output , Never > { return SignalProducer ( value : . success ( \"We did it!\" )) . delay ( 1.0 , on : QueueScheduler . main ) } func isEquivalent ( to otherWorker : RefreshWorker ) -> Bool { return true } } Because a Worker is a declarative representation of work, it also needs to define an isEquivalent to guarantee that we are not running more than one at the same time. For the simple example above, it is always considered equivalent as we want only one of this type of worker running at a time. In order to start asynchronous work, the workflow requests it in the render method, looking something like: public func render ( state : State , context : RenderContext < DemoWorkflow >) -> DemoScreen { RefreshWorker () . mapOutput { output -> Action in switch output { case . success ( let result ): return Action . refreshComplete ( result ) case . error ( let error ): return Action . refreshError ( error ) } } . running ( in : context ) } When running(in:) is executed on a worker, the context will do the following: Check if there is already a worker running of the same type: If there is not, or isEquivalent is false, call run on the worker and subscribe to the SignalProducer If there is already a worker running and isEquivalent is true, continue to wait for it to produce an output. When the SignalProducer from the Worker returns an output, it is mapped to an Action and handled the same way as any other action.","title":"Workers, or \"Asynchronous work the workflow needs done\""},{"location":"tutorial/building-a-workflow/#output-events","text":"The last role of the update cycle is to emit output events. As workflows form a hierarchy, it is common for children to send events up the tree. This may happen when a child workflow finishes or cancels, for example. Workflows can define an output type, which may then be returned by Actions.","title":"Output Events"},{"location":"tutorial/building-a-workflow/#composition","text":"Composition is the primary tool that we can use to manage complexity in a growing application. Workflows should always be kept small enough to be understandable \u2013 less than 150 lines is a good target. By composing together multiple workflows, complex problems can be broken down into individual pieces that can be quickly understood by other developers (including future you). The context provided to the render(state:context:) method defines the API through which composition is made possible.","title":"Composition"},{"location":"tutorial/building-a-workflow/#the-render-context","text":"The useful role of children is ultimately to provide rendered values (typically screen models) via their render(state:context:) implementation. To obtain that value from a child workflow, the rendered(with context:key:) method is invoked on the child workflow. When a workflow is rendered with the context, the context will do the following: Check if the child workflow is new or existing: If a workflow with the same type was used during the last render pass, the existing child workflow will be updated with the new workflow. Otherwise, a new child workflow node will be initialized. The child workflow\u2019s render(state:context:) method is called. The rendered value is returned. In practice, this looks something like this: struct ParentWorkflow : Workflow { func render ( state : State , context : RenderContext < ParentWorkflow >) -> String { let childWorkflow = ChildWorkflow ( text : \"Hello, World\" ) return childWorkflow . rendered ( with : context ) } } struct ChildWorkflow : Workflow { var text : String // ... func render ( state : State , context : RenderContext < ChildWorkflow >) -> String { return String ( text . reversed ()) } }","title":"The Render Context"},{"location":"tutorial/tooling/","text":"Tooling \u00b6 Xcode templates \u00b6 Workflow comes with a set of file templates to simplify the process of building features. After installation, these templates can be found via File > New > New File... in Xcode. Launch terminal and navigate to the Workflow source directory. Run ./Tooling/Templates/install-xcode-templates.sh . Restart Xcode.","title":"Tooling"},{"location":"tutorial/tooling/#tooling","text":"","title":"Tooling"},{"location":"tutorial/tooling/#xcode-templates","text":"Workflow comes with a set of file templates to simplify the process of building features. After installation, these templates can be found via File > New > New File... in Xcode. Launch terminal and navigate to the Workflow source directory. Run ./Tooling/Templates/install-xcode-templates.sh . Restart Xcode.","title":"Xcode templates"},{"location":"tutorial/using-a-workflow-for-ui/","text":"Using a workflow to show UI \u00b6 ContainerViewController \u00b6 In the Workflow architecture, the container acts as the glue between the state-driven world of Workflows and the UI that is ultimately displayed. On iOS, the container is implemented as ContainerViewController . /// Drives view controllers from a root Workflow. public final class ContainerViewController < Output , ScreenType >: UIViewController where ScreenType : Screen { /// Emits output events from the bound workflow. public let output : Signal < Output , Never > public convenience init < W : Workflow >( workflow : W ) where W . Rendering == ScreenType , W . Output == Output } The initializer argument is the workflow that will drive your application. import UIKit import Workflow import WorkflowUI @UIApplicationMain class AppDelegate : UIResponder , UIApplicationDelegate { var window : UIWindow ? func application ( _ application : UIApplication , didFinishLaunchingWithOptions launchOptions : [ UIApplication . LaunchOptionsKey : Any ]?) -> Bool { let window = UIWindow ( frame : UIScreen . main . bounds ) let container = ContainerViewController ( workflow : DemoWorkflow () ) window . rootViewController = container self . window = window window . makeKeyAndVisible () return true } } Now, when the ContainerViewController is shown, it will start the workflow and render will be called returning the DemoScreen . The container will use viewControllerDescription to build a DemoScreenViewController and add it to the view hierarchy to display.","title":"Using a Workflow to Show UI"},{"location":"tutorial/using-a-workflow-for-ui/#using-a-workflow-to-show-ui","text":"","title":"Using a workflow to show UI"},{"location":"tutorial/using-a-workflow-for-ui/#containerviewcontroller","text":"In the Workflow architecture, the container acts as the glue between the state-driven world of Workflows and the UI that is ultimately displayed. On iOS, the container is implemented as ContainerViewController . /// Drives view controllers from a root Workflow. public final class ContainerViewController < Output , ScreenType >: UIViewController where ScreenType : Screen { /// Emits output events from the bound workflow. public let output : Signal < Output , Never > public convenience init < W : Workflow >( workflow : W ) where W . Rendering == ScreenType , W . Output == Output } The initializer argument is the workflow that will drive your application. import UIKit import Workflow import WorkflowUI @UIApplicationMain class AppDelegate : UIResponder , UIApplicationDelegate { var window : UIWindow ? func application ( _ application : UIApplication , didFinishLaunchingWithOptions launchOptions : [ UIApplication . LaunchOptionsKey : Any ]?) -> Bool { let window = UIWindow ( frame : UIScreen . main . bounds ) let container = ContainerViewController ( workflow : DemoWorkflow () ) window . rootViewController = container self . window = window window . makeKeyAndVisible () return true } } Now, when the ContainerViewController is shown, it will start the workflow and render will be called returning the DemoScreen . The container will use viewControllerDescription to build a DemoScreenViewController and add it to the view hierarchy to display.","title":"ContainerViewController"},{"location":"userguide/comparison/","text":"Comparison with other frameworks \u00b6 Coming soon!","title":"Comparison with other frameworks"},{"location":"userguide/comparison/#comparison-with-other-frameworks","text":"Coming soon!","title":"Comparison with other frameworks"},{"location":"userguide/concepts/","text":"Core Concepts \u00b6 Architectural Concepts \u00b6 Unidirectional Data Flow \u00b6 There is a wealth of information on the web about Unidirectional Data Flow , but it very simply means that there is a single path along which data travel from your business logic to your UI, and events travel to your business logic from your UI, and they always and only travel in one direction along that path. For Workflow, this also implies that the UI is (almost) stateless, and that the interesting state for your app is centralized and not duplicated. In practice, this makes program flow much easier to reason about because anytime something happens in an app, it removes the questions of where the state came from that caused it, which components got which events, and which sequences of cause and effect actually occurred. It makes unit testing easier because state and events are explicit, and always live in the same place and flow through the same APIs, so unit tests only need to test state transitions, for the most part. Declarative vs Imperative \u00b6 Traditionally, most mobile code is \u201cimperative\u201d \u2013 it consists of instructions for how to build and display the UI. These instructions can include control flow like loops. Imperative code is usually stateful, state is usually sprinkled all over the place, and tends to care about instances and identity. When reading imperative code, you almost have to run an interpreter and keep all the pieces of state in your head to figure out what it does. Web UI is traditionally declarative \u2013 it describes what to render, and some aspects of how to render it (style), but doesn\u2019t say how to actually draw it. Declarative code is usually easier to read than imperative code. It describes what it produces, not how to generate it. Declarative code usually cares more about pure values than instance identities. However, since computers still need actual instructions at some point, declarative code requires something else, usually imperative, either a compiler or interpreter, to actually do something with it. Workflow code is written in regular Kotlin or Swift, which are both imperative languages, but the library encourages you to write your logic in a declarative and functional style. The library manages state and wiring up event handling for you, so the only code you need to write is code that is actually interesting for your particular problem. A note about functional programming \u00b6 Kotlin and Swift are not strictly functional programming languages, but both have features that allow you to write functional -style code. Functional code discourages side effects and is generally much easier to test than object-oriented code. Functional and declarative programming go very well together, and Workflow encourages you to write such code. Core Components \u00b6 Workflows \u00b6 The Workflows at the left of the diagram contain all state and business logic for the application. This is where network requests happen, navigation decisions are made, models are saved to or loaded from disk \u2013 if it\u2019s not UI, it\u2019s in this box. For more information, see Workflow Core Concepts . View Models \u00b6 The primary job of the Workflows is to emit an observable stream of view models representing the current state of the application\u2019s UI. You will sometimes hear these view models referred to as \u2018screens\u2019, which is just another way to refer to a view model that contains the data for an entire screen in the app. For more information, see Workflow UI Concepts . Container \u00b6 The container is responsible for plumbing together the two separate halves of the application. It subscribes to the stream of view models that the workflows provide, then implements the logic to update the live UI whenever a new view model is emitted. For more information, see Workflow UI Concepts . UI \u00b6 This is typically conventional platform-specific UI code. One important note is that UI code should never attempt to navigate using system components (navigation controller pushes, modal presentation, etc). In this architecture the workflows are in charge \u2013 any navigation that happens outside of the workflow will be disregarded and stomped on during the next update cycle. For more information, see Workflow UI Concepts . Events \u00b6 In order for the application to actually do anything, the workflow needs to receive events from the UI. When the user interacts with the application by, for example, tapping a button, the workflow receives that event \u2013 which may trigger a simple state transition, or more complex behavior such as a network request. For more information, see Workflow Core Concepts . Info While the core shape of the libraries is shared by Swift and Kotlin implementations, some of the naming and types differ slightly to accommodate each language\u2019s particular type system and naming conventions. Where those differences occur in this document, they are noted in \u201cSwift vs Kotlin\u201d blurbs. See Where Swift and Kotlin Libraries Differ for an overall summary. In general, any time a generic type is referred to as Foo , in source code the Swift associated type is called Foo and the Kotlin type parameter is called FooT .","title":"Core Concepts"},{"location":"userguide/concepts/#core-concepts","text":"","title":"Core Concepts"},{"location":"userguide/concepts/#architectural-concepts","text":"","title":"Architectural Concepts"},{"location":"userguide/concepts/#unidirectional-data-flow","text":"There is a wealth of information on the web about Unidirectional Data Flow , but it very simply means that there is a single path along which data travel from your business logic to your UI, and events travel to your business logic from your UI, and they always and only travel in one direction along that path. For Workflow, this also implies that the UI is (almost) stateless, and that the interesting state for your app is centralized and not duplicated. In practice, this makes program flow much easier to reason about because anytime something happens in an app, it removes the questions of where the state came from that caused it, which components got which events, and which sequences of cause and effect actually occurred. It makes unit testing easier because state and events are explicit, and always live in the same place and flow through the same APIs, so unit tests only need to test state transitions, for the most part.","title":"Unidirectional Data Flow"},{"location":"userguide/concepts/#declarative-vs-imperative","text":"Traditionally, most mobile code is \u201cimperative\u201d \u2013 it consists of instructions for how to build and display the UI. These instructions can include control flow like loops. Imperative code is usually stateful, state is usually sprinkled all over the place, and tends to care about instances and identity. When reading imperative code, you almost have to run an interpreter and keep all the pieces of state in your head to figure out what it does. Web UI is traditionally declarative \u2013 it describes what to render, and some aspects of how to render it (style), but doesn\u2019t say how to actually draw it. Declarative code is usually easier to read than imperative code. It describes what it produces, not how to generate it. Declarative code usually cares more about pure values than instance identities. However, since computers still need actual instructions at some point, declarative code requires something else, usually imperative, either a compiler or interpreter, to actually do something with it. Workflow code is written in regular Kotlin or Swift, which are both imperative languages, but the library encourages you to write your logic in a declarative and functional style. The library manages state and wiring up event handling for you, so the only code you need to write is code that is actually interesting for your particular problem.","title":"Declarative vs Imperative"},{"location":"userguide/concepts/#a-note-about-functional-programming","text":"Kotlin and Swift are not strictly functional programming languages, but both have features that allow you to write functional -style code. Functional code discourages side effects and is generally much easier to test than object-oriented code. Functional and declarative programming go very well together, and Workflow encourages you to write such code.","title":"A note about functional programming"},{"location":"userguide/concepts/#core-components","text":"","title":"Core Components"},{"location":"userguide/concepts/#workflows","text":"The Workflows at the left of the diagram contain all state and business logic for the application. This is where network requests happen, navigation decisions are made, models are saved to or loaded from disk \u2013 if it\u2019s not UI, it\u2019s in this box. For more information, see Workflow Core Concepts .","title":"Workflows"},{"location":"userguide/concepts/#view-models","text":"The primary job of the Workflows is to emit an observable stream of view models representing the current state of the application\u2019s UI. You will sometimes hear these view models referred to as \u2018screens\u2019, which is just another way to refer to a view model that contains the data for an entire screen in the app. For more information, see Workflow UI Concepts .","title":"View Models"},{"location":"userguide/concepts/#container","text":"The container is responsible for plumbing together the two separate halves of the application. It subscribes to the stream of view models that the workflows provide, then implements the logic to update the live UI whenever a new view model is emitted. For more information, see Workflow UI Concepts .","title":"Container"},{"location":"userguide/concepts/#ui","text":"This is typically conventional platform-specific UI code. One important note is that UI code should never attempt to navigate using system components (navigation controller pushes, modal presentation, etc). In this architecture the workflows are in charge \u2013 any navigation that happens outside of the workflow will be disregarded and stomped on during the next update cycle. For more information, see Workflow UI Concepts .","title":"UI"},{"location":"userguide/concepts/#events","text":"In order for the application to actually do anything, the workflow needs to receive events from the UI. When the user interacts with the application by, for example, tapping a button, the workflow receives that event \u2013 which may trigger a simple state transition, or more complex behavior such as a network request. For more information, see Workflow Core Concepts . Info While the core shape of the libraries is shared by Swift and Kotlin implementations, some of the naming and types differ slightly to accommodate each language\u2019s particular type system and naming conventions. Where those differences occur in this document, they are noted in \u201cSwift vs Kotlin\u201d blurbs. See Where Swift and Kotlin Libraries Differ for an overall summary. In general, any time a generic type is referred to as Foo , in source code the Swift associated type is called Foo and the Kotlin type parameter is called FooT .","title":"Events"},{"location":"userguide/core-patterns/","text":"Workflow Core: Patterns/Variations \u00b6 There are a lot associated/generic types in workflow code \u2013 that doesn\u2019t mean you always need to use all of them. Here are some common configurations we\u2019ve seen. Stateless Workflows \u00b6 Remember that workflow state is made up of public and private parts. When a workflow\u2019s state consists entirely of public state (i.e. it\u2019s initializer arguments in Swift or PropsT in Kotlin), it can ignore all the machinery for private state. In Swift, the State type can be Void , and in Kotlin it can be Unit \u2013 such workflows are often referred to as \u201cstateless\u201d, since they have no state of their own. Props-less Workflows \u00b6 Some workflows manage all of their state internally, and have no public state (aka props). In Swift, this just means the workflow implementation has no parameters (although this is rare, see Injecting Dependencies below). In Kotlin, the PropsT type can be Unit . RenderContext has convenience overloads of most of its functions to implicitly pass Unit for these workflows. Outputless Workflows \u00b6 Workflows that only talk to their parent via their Rendering , and never emit any output, are encouraged to indicate that by using the bottom type as their Output type. In addition to documenting the fact that the workflow will never output, using the bottom type also lets the compiler enforce it \u2013 code that tries to emit outputs will not compile. In Swift, the Output type is specified as Never . In Kotlin, use Nothing . Composite Workflows \u00b6 Composition is a powerful tool for working with Workflows. A workflow can often accomplish a lot simply by rendering various children. It may just combine the renderings of multiple children, or use its props to determine which of a set of children to render. Such workflows can often be stateless. Props values v. Injected Dependencies \u00b6 Dependency injection is a technique for making code less coupled and more testable. In short, it\u2019s better for classes/structs to accept their dependencies when they\u2019re created instead of hard-coding them. Workflows typically have dependencies like specific Workers they need to perform some tasks, child workflows to delegate rendering to, or helpers for things like network requests, formatting and logging. Swift \u00b6 A Swift workflow typically receives its dependencies as initializer arguments, just like its input values, and is normally instantiated anew by its parent in each call to the parent\u2019s render method. The factory pattern can be employed to keep knowledge of children\u2019s implementation details from leaking into their parents. Kotlin \u00b6 Kotlin workflows make a more formal distinction between dependencies and props, via the PropsT parameter type on the Kotlin Workflow interface. Dependencies (e.g. a network service) are typically provided as constructor parameters, while props values (e.g. a record locator) are provided by the parent as an argument to the RenderContext.renderChild method. This works seamlessly with DI libraries like Dagger . The careful reader will note that this is technically storing \u201cstate\u201d in the workflow instance \u2013 something that is generally discouraged. However, since this \u201cstate\u201d is never changed, we can make an exception for this case. If a workflow has properties, they should only be used to store injected dependencies or dependencies derived from injected ones (e.g. Worker s created from Observable s). Info This difference between Swift and Kotlin practices is a side effect of Kotlin\u2019s lack of a parallel to Swift\u2019s Self type. Kotlin has no practical way to provide a method like Swift\u2019s Workflow.workflowDidChange , which accepts a strongly typed reference to the instance from the previous run of a parent\u2019s Render method. Kotlin\u2019s alternative, StatefulWorkflow.onPropsChanged , requires the extra PropsT type parameter.","title":"Patterns"},{"location":"userguide/core-patterns/#workflow-core-patternsvariations","text":"There are a lot associated/generic types in workflow code \u2013 that doesn\u2019t mean you always need to use all of them. Here are some common configurations we\u2019ve seen.","title":"Workflow Core: Patterns/Variations"},{"location":"userguide/core-patterns/#stateless-workflows","text":"Remember that workflow state is made up of public and private parts. When a workflow\u2019s state consists entirely of public state (i.e. it\u2019s initializer arguments in Swift or PropsT in Kotlin), it can ignore all the machinery for private state. In Swift, the State type can be Void , and in Kotlin it can be Unit \u2013 such workflows are often referred to as \u201cstateless\u201d, since they have no state of their own.","title":"Stateless Workflows"},{"location":"userguide/core-patterns/#props-less-workflows","text":"Some workflows manage all of their state internally, and have no public state (aka props). In Swift, this just means the workflow implementation has no parameters (although this is rare, see Injecting Dependencies below). In Kotlin, the PropsT type can be Unit . RenderContext has convenience overloads of most of its functions to implicitly pass Unit for these workflows.","title":"Props-less Workflows"},{"location":"userguide/core-patterns/#outputless-workflows","text":"Workflows that only talk to their parent via their Rendering , and never emit any output, are encouraged to indicate that by using the bottom type as their Output type. In addition to documenting the fact that the workflow will never output, using the bottom type also lets the compiler enforce it \u2013 code that tries to emit outputs will not compile. In Swift, the Output type is specified as Never . In Kotlin, use Nothing .","title":"Outputless Workflows"},{"location":"userguide/core-patterns/#composite-workflows","text":"Composition is a powerful tool for working with Workflows. A workflow can often accomplish a lot simply by rendering various children. It may just combine the renderings of multiple children, or use its props to determine which of a set of children to render. Such workflows can often be stateless.","title":"Composite Workflows"},{"location":"userguide/core-patterns/#props-values-v-injected-dependencies","text":"Dependency injection is a technique for making code less coupled and more testable. In short, it\u2019s better for classes/structs to accept their dependencies when they\u2019re created instead of hard-coding them. Workflows typically have dependencies like specific Workers they need to perform some tasks, child workflows to delegate rendering to, or helpers for things like network requests, formatting and logging.","title":"Props values v. Injected Dependencies"},{"location":"userguide/core-patterns/#swift","text":"A Swift workflow typically receives its dependencies as initializer arguments, just like its input values, and is normally instantiated anew by its parent in each call to the parent\u2019s render method. The factory pattern can be employed to keep knowledge of children\u2019s implementation details from leaking into their parents.","title":"Swift"},{"location":"userguide/core-patterns/#kotlin","text":"Kotlin workflows make a more formal distinction between dependencies and props, via the PropsT parameter type on the Kotlin Workflow interface. Dependencies (e.g. a network service) are typically provided as constructor parameters, while props values (e.g. a record locator) are provided by the parent as an argument to the RenderContext.renderChild method. This works seamlessly with DI libraries like Dagger . The careful reader will note that this is technically storing \u201cstate\u201d in the workflow instance \u2013 something that is generally discouraged. However, since this \u201cstate\u201d is never changed, we can make an exception for this case. If a workflow has properties, they should only be used to store injected dependencies or dependencies derived from injected ones (e.g. Worker s created from Observable s). Info This difference between Swift and Kotlin practices is a side effect of Kotlin\u2019s lack of a parallel to Swift\u2019s Self type. Kotlin has no practical way to provide a method like Swift\u2019s Workflow.workflowDidChange , which accepts a strongly typed reference to the instance from the previous run of a parent\u2019s Render method. Kotlin\u2019s alternative, StatefulWorkflow.onPropsChanged , requires the extra PropsT type parameter.","title":"Kotlin"},{"location":"userguide/core-worker/","text":"Workflow Core: Worker \u00b6 The Role of a Worker \u00b6 Worker is a protocol (in Swift) and interface (in Kotlin) that defines an asynchronous task that can be performed by a Workflow . Worker s only emit outputs, they do not have a Rendering type. They are similar to child workflows with Void / Unit rendering types. A workflow can ask the infrastructure to await the result of a worker by passing that worker to the RenderContext.runningWorker method within a call to the render method. A workflow can handle outputs from a Worker . Workers provide a declarative window into the imperative world \u00b6 As nice as it is to write declarative code, real apps need to interact with imperative APIs. Workers allow wrapping imperative APIs so that Workflows can interact with them in a declarative fashion. Instead of making imperative \u201cstart this, do that, now stop\u201d calls, a Workflow can say \u201cI declare that this task should now be running\u201d and let the infrastructure worry about ensuring the task is actually started when necessary, continues running if it was already in flight, and torn down when it\u2019s not needed anymore. Workers can perform side effects \u00b6 Unlike workflows\u2019 render method, which can be called many times and must be idempotent, workers are started and then ran until completion (or cancellation) \u2013 independently of how many times the workflow running them is actually rendered. This means that side effects that should be performed only once when a workflow enters a particular state, for example, should be placed into a Worker that the workflow runs while in that state. Workers are cold reactive streams \u00b6 Workers are effectively simple wrappers around asynchronous streams with explicit equivalence. In Swift, workers are backed by ReactiveSwift SignalProducer s . In Kotlin, they\u2019re backed by Kotlin Flow s . They are also easily derived from Reactive Streams Publishers , including RxJava Observable , Flowable , or Single instances. Worker subscriptions are managed automatically \u00b6 While Workers are backed by reactive streams with library-specific subscription APIs, you never actually subscribe directly to a worker yourself. Instead, a Workflow asks the infrastructure to run a worker, and the infrastructure will take care of initializing and tearing down the subscription as appropriate \u2013 much like how child workflows\u2019 lifetimes are automatically managed by the runtime. This makes it impossible to accidentally leak a subscription to a worker. Workers manage their own internal state \u00b6 Unlike Workflows, which are effectively collections of functions defining state transitions, Workers represent long-running tasks. For example, Workers commonly execute network requests. The worker\u2019s stream will open a socket and, either blocking on a background thread or asynchronously, read from that socket and eventually emit data to the workflow that is running it. Workers define their own equivalence \u00b6 Since Workers represent ongoing tasks, the infrastructure needs to be able to tell when two workers represent the same task (so it doesn\u2019t perform the task twice), or when a worker has changed between render passes such that it needs to be torn down and re-started for the new work. For these reasons, any time a workflow requests that a worker be run in sequential render passes, it is asked to compare itself with its last instance and determine if they are equivalent. In Swift, this is determined by the Worker isEquivalent:to: method. Worker s that conform to Equatable will automatically get an isEquivalent:to: method based on the Equatable implementation. In Kotlin, the Worker interface defines the doesSameWorkAs method which is passed the previous worker. Kotlin: Why don\u2019t Workers use equals ? Worker equivalence is a key part of the Worker API. The default implementation of equals , which just compares object identity, is almost always incorrect for workers. Defining a separate method forces implementers to think about how equivalence is defined. Workers are lifecycle-aware \u00b6 Workers are aware of when they\u2019re started (just like Workflows), but they are also aware of when they are torn down. This makes them handy for managing resources as well.","title":"Worker"},{"location":"userguide/core-worker/#workflow-core-worker","text":"","title":"Workflow Core: Worker"},{"location":"userguide/core-worker/#the-role-of-a-worker","text":"Worker is a protocol (in Swift) and interface (in Kotlin) that defines an asynchronous task that can be performed by a Workflow . Worker s only emit outputs, they do not have a Rendering type. They are similar to child workflows with Void / Unit rendering types. A workflow can ask the infrastructure to await the result of a worker by passing that worker to the RenderContext.runningWorker method within a call to the render method. A workflow can handle outputs from a Worker .","title":"The Role of a Worker"},{"location":"userguide/core-worker/#workers-provide-a-declarative-window-into-the-imperative-world","text":"As nice as it is to write declarative code, real apps need to interact with imperative APIs. Workers allow wrapping imperative APIs so that Workflows can interact with them in a declarative fashion. Instead of making imperative \u201cstart this, do that, now stop\u201d calls, a Workflow can say \u201cI declare that this task should now be running\u201d and let the infrastructure worry about ensuring the task is actually started when necessary, continues running if it was already in flight, and torn down when it\u2019s not needed anymore.","title":"Workers provide a declarative window into the imperative world"},{"location":"userguide/core-worker/#workers-can-perform-side-effects","text":"Unlike workflows\u2019 render method, which can be called many times and must be idempotent, workers are started and then ran until completion (or cancellation) \u2013 independently of how many times the workflow running them is actually rendered. This means that side effects that should be performed only once when a workflow enters a particular state, for example, should be placed into a Worker that the workflow runs while in that state.","title":"Workers can perform side effects"},{"location":"userguide/core-worker/#workers-are-cold-reactive-streams","text":"Workers are effectively simple wrappers around asynchronous streams with explicit equivalence. In Swift, workers are backed by ReactiveSwift SignalProducer s . In Kotlin, they\u2019re backed by Kotlin Flow s . They are also easily derived from Reactive Streams Publishers , including RxJava Observable , Flowable , or Single instances.","title":"Workers are cold reactive streams"},{"location":"userguide/core-worker/#worker-subscriptions-are-managed-automatically","text":"While Workers are backed by reactive streams with library-specific subscription APIs, you never actually subscribe directly to a worker yourself. Instead, a Workflow asks the infrastructure to run a worker, and the infrastructure will take care of initializing and tearing down the subscription as appropriate \u2013 much like how child workflows\u2019 lifetimes are automatically managed by the runtime. This makes it impossible to accidentally leak a subscription to a worker.","title":"Worker subscriptions are managed automatically"},{"location":"userguide/core-worker/#workers-manage-their-own-internal-state","text":"Unlike Workflows, which are effectively collections of functions defining state transitions, Workers represent long-running tasks. For example, Workers commonly execute network requests. The worker\u2019s stream will open a socket and, either blocking on a background thread or asynchronously, read from that socket and eventually emit data to the workflow that is running it.","title":"Workers manage their own internal state"},{"location":"userguide/core-worker/#workers-define-their-own-equivalence","text":"Since Workers represent ongoing tasks, the infrastructure needs to be able to tell when two workers represent the same task (so it doesn\u2019t perform the task twice), or when a worker has changed between render passes such that it needs to be torn down and re-started for the new work. For these reasons, any time a workflow requests that a worker be run in sequential render passes, it is asked to compare itself with its last instance and determine if they are equivalent. In Swift, this is determined by the Worker isEquivalent:to: method. Worker s that conform to Equatable will automatically get an isEquivalent:to: method based on the Equatable implementation. In Kotlin, the Worker interface defines the doesSameWorkAs method which is passed the previous worker. Kotlin: Why don\u2019t Workers use equals ? Worker equivalence is a key part of the Worker API. The default implementation of equals , which just compares object identity, is almost always incorrect for workers. Defining a separate method forces implementers to think about how equivalence is defined.","title":"Workers define their own equivalence"},{"location":"userguide/core-worker/#workers-are-lifecycle-aware","text":"Workers are aware of when they\u2019re started (just like Workflows), but they are also aware of when they are torn down. This makes them handy for managing resources as well.","title":"Workers are lifecycle-aware"},{"location":"userguide/core-workflow/","text":"Workflow Core: Workflow \u00b6 The Role of a Workflow \u00b6 Workflow is a protocol (in Swift) and interface (in Kotlin) that defines the contract for a single node in the workflow hierarchy. Swift public protocol Workflow : AnyWorkflowConvertible { associatedtype State associatedtype Output = Never associatedtype Rendering func makeInitialState () -> State func workflowDidChange ( from previousWorkflow : Self , state : inout State ) func render ( state : State , context : RenderContext < Self >) -> Rendering } Kotlin abstract class StatefulWorkflow < in PropsT , StateT , out OutputT : Any , out RenderingT > : Workflow < PropsT , OutputT , RenderingT > { abstract fun initialState ( props : PropsT , initialSnapshot : Snapshot? ): StateT open fun onPropsChanged ( old : PropsT , new : PropsT , state : StateT ): StateT = state abstract fun render ( props : PropsT , state : StateT , context : RenderContext < StateT , OutputT > ): RenderingT abstract fun snapshotState ( state : StateT ): Snapshot } Swift: What is AnyWorkflowConvertible ? When a protocol has an associated Self type, Swift requires the use of a type-erasing wrapper to store references to instances of that protocol. AnyWorkflow is such a wrapper for Workflow . AnyWorkflowConvertible is a protocol with a single method that returns an AnyWorkflow . It is useful as a base type because it allows instances of Workflow to be used directly by any code that requires the type-erased AnyWorkflow . Kotlin: StatefulWorkflow vs Workflow It is a common practice in Kotlin to divide types into two parts: an interface for public API, and a class for private implementation. The Workflow library defines a Workflow interface, which should be used as the type of properties and parameters by code that needs to refer to a particular Workflow interface. The Workflow interface contains a single method, which simply returns a StatefulWorkflow \u2013 a Workflow can be described as \u201canything that can be expressed as a StatefulWorkflow .\u201d The library also defines two abstract classes which define the contract for workflows and should be subclassed to implement your workflows: StatefulWorkflow should be subclassed to implement Workflows that have private state . StatelessWorkflow should be subclassed to implement Workflows that don\u2019t have any private state. See Stateless Workflows . Workflows have several responsibilities: Workflows have state \u00b6 Once a Workflow has been started, it always operates in the context of some state. This state is divided into two parts: private state, which only the Workflow implementation itself knows about, which is defined by the State type, and properties (or \u201cprops\u201d), which is passed to the Workflow from its parent (more on hierarchical workflows below). Private state \u00b6 Every Workflow implementation defines a State type to maintain any necessary state while the workflow is running. For example, a tic-tac-toe game might have a state like this: Swift struct State { enum Player { case x case o } enum Space { case unfilled filled ( Player ) } // 3 rows * 3 columns = 9 spaces var spaces : [ Space ] = Array ( repeating : . unfilled , count : 9 ) var currentTurn : Player = . x } Kotlin data class State ( // 3 rows * 3 columns = 9 spaces val spaces : List < Space > = List ( 9 ) { Unfilled }, val currentTurn : Player = X ) { enum class Player { X , O } sealed class Space { object Unfilled : Space () data class Filled ( val player : Player ) : Space () } } When the workflow is first started, it is queried for an initial state value. From that point forward, the workflow may advance to a new state as the result of events occurring from various sources (which will be covered below). Stateless Workflows If a workflow does not have any private state, it is often referred to as a \u201cstateless workflow\u201d. A stateless Workflow is simply a Workflow that has a Void or Unit State type. See more below . Props \u00b6 Every Workflow implementation also defines data that is passed into it. The Workflow is not able to modify this state itself, but it may change between render passes. This public state is called Props . In Swift, the props are simply defined as properties of the struct implementing Workflow itself. In Kotlin, the Workflow interface defines a separate PropsT type parameter. (This additional type parameter is necessary due to Kotlin\u2019s lack of the Self type that Swift workflow\u2019s workflowDidChange method relies upon.) Swift TK Kotlin data class Props ( val playerXName : String val playerOName : String ) Workflows are advanced by WorkflowAction s \u00b6 Any time something happens that should advance a workflow \u2013 a UI event, a network response, a child\u2019s output event \u2013 actions are used to perform the update. For example, a workflow may respond to UI events by mapping those events into a type conforming to/implementing WorkflowAction . These types implement the logic to advance a workflow by: Advancing to a new state (Optionally) emitting an output event up the tree. WorkflowAction s are typically defined as enums with associated types (Swift) or sealed classes (Kotlin), and can include data from the event \u2013 for example, the ID of the item in the list that was clicked. Side effects such as logging button clicks to an analytics framework are also typically performed in actions. If you\u2019re familiar with React/Redux, WorkflowAction s are essentially reducers. Workflows can emit output events up the hierarchy to their parent \u00b6 When a workflow is advanced by an action, an optional output event can be sent up the workflow hierarchy. This is the opportunity for a workflow to notify its parent that something has happened (and the parent\u2019s opportunity to respond to that event by dispatching its own action, continuing up the tree as long as output events are emitted). Workflows produce an external representation of their state via Rendering \u00b6 Immediately after starting up, or after a state transition occurs, a workflow will have its render method called. This method is responsible for creating and returning a value of type Rendering . You can think of Rendering as the \u201cexternal published state\u201d of the workflow, and the render function as a map of ( Props + State + childrens\u2019 Rendering s) -> Rendering . While a workflow\u2019s internal state may contain more detailed or comprehensive state, the Rendering (external state) is a type that is useful outside of the workflow. Because a workflow\u2019s render method may be called by infrastructure for a variety of reasons, it\u2019s important to not perform side effects when rendering \u2014 render methods must be idempotent. Event-based side effects should use Actions and state-based side effects should use Workers. When building an interactive application, the Rendering type is commonly (but not always) a view model that will drive the UI layer. Workflows can respond to UI events \u00b6 The RenderContext that is passed into render as the last parameter provides some useful tools to assist in creating the Rendering value. If a workflow is producing a view model, it is common to need an event handler to respond to UI events. The RenderContext has API to create an event handler, called a Sink , that when called will advance the workflow by dispatching an action back to the workflow (for more on actions, see below ). Swift func render ( state : State , context : RenderContext < DemoWorkflow >) -> DemoScreen { // Create a sink of our Action type so we can send actions back to the workflow. let sink = context . makeSink ( of : Action . self ) return DemoScreen ( title : \"A nice title\" , onTap : { sink . send ( Action . refreshButtonTapped ) } } Kotlin TK Workflows form a hierarchy (they may have children) \u00b6 As they produce a Rendering value, it is common for workflows to delegate some portion of that work to a child workflow . This is done via the RenderContext that is passed into the render method. In order to delegate to a child, the parent calls renderChild on the context, with the child workflow as the single argument. The infrastructure will spin up the child workflow (including initializing its initial state) if this is the first time this child has been used, or, if the child was also used on the previous render pass, the existing child will be updated. Either way, render will immediately be called on the child (by the Workflow infrastructure), and the resulting child\u2019s Rendering value will be returned to the parent. This allows a parent to return complex Rendering types (such as a view model representing the entire UI state of an application) without needing to model all of that complexity within a single workflow. Workflow Identity The Workflow infrastructure automatically detects the first time and the last subsequent time you\u2019ve asked to render a child workflow, and will automatically initialize the child and clean it up. In both Swift and Kotlin, this is done using the workflow\u2019s concrete type. Both languages use reflection to do this comparison (e.g. in Kotlin, the workflows\u2019 KClass es are compared). It is an error to render workflows of the same type more than once in the same render pass. Since type is used for workflow identity, the child rendering APIs take an optional string key to differentiate between multiple child workflows of the same type. Workflows can subscribe to external event sources \u00b6 If a workflow needs to respond to some external event source (e.g. push notifications), the workflow can ask the context to listen to those events from within the render method. Swift vs Kotlin In the Swift library, there is a special API for subscribing to hot streams ( Signal in ReactiveSwift). The Kotlin library does not have any special API for subscribing to hot streams (channels), though it does have extension methods to convert ReceiveChannel s , and RxJava Flowable s and Observables , to Worker s . The reason for this discrepancy is simply that we don\u2019t have any uses of channels yet in production, and so we\u2019ve decided to keep the API simpler. If we start using channels in the future, it may make sense to make subscribing to them a first-class API like in Swift. Workflows can perform asynchronous tasks (Workers) \u00b6 Workers are very similar in concept to child workflows. Unlike child workflows, however, workers do not have a Rendering type; they only exist to perform a single asynchronous task before sending zero or more output events back up the tree to their parent. For more information about workers, see the Worker section below. Workflows can be saved to and restored from a snapshot (Kotlin only) \u00b6 On every render pass, each workflow is asked to create a \u201csnapshot\u201d of its state \u2013 a lazily-produced serialization of the workflow\u2019s State as a binary blob. These Snapshot s are aggregated into a single Snapshot for the entire workflow tree and emitted along with the root workflow\u2019s Rendering . When the workflow runtime is started, it can be passed an optional Snapshot to restore the tree from. When non-null, the root workflow\u2019s snapshot is extracted and passed to the root workflow\u2019s initialState . The workflow can choose to either ignore the snapshot or use it to restore its State . On the first render pass, if the root workflow renders any children that were also being rendered when the snapshot was taken, those children\u2019s snapshots are also extracted from the aggregate and used to initialize their states. !!! faq Why don\u2019t Swift Workflows support snapshotting? Snapshotting was built into Kotlin workflows specifically to support Android\u2019s app lifecycle, which requires apps to serialize their current state before being backgrounded so that they can be restored in case the system needs to kill the hosting process. iOS apps don\u2019t have this requirement, so the Swift library doesn\u2019t need to support it.","title":"Workflow"},{"location":"userguide/core-workflow/#workflow-core-workflow","text":"","title":"Workflow Core: Workflow"},{"location":"userguide/core-workflow/#the-role-of-a-workflow","text":"Workflow is a protocol (in Swift) and interface (in Kotlin) that defines the contract for a single node in the workflow hierarchy. Swift public protocol Workflow : AnyWorkflowConvertible { associatedtype State associatedtype Output = Never associatedtype Rendering func makeInitialState () -> State func workflowDidChange ( from previousWorkflow : Self , state : inout State ) func render ( state : State , context : RenderContext < Self >) -> Rendering } Kotlin abstract class StatefulWorkflow < in PropsT , StateT , out OutputT : Any , out RenderingT > : Workflow < PropsT , OutputT , RenderingT > { abstract fun initialState ( props : PropsT , initialSnapshot : Snapshot? ): StateT open fun onPropsChanged ( old : PropsT , new : PropsT , state : StateT ): StateT = state abstract fun render ( props : PropsT , state : StateT , context : RenderContext < StateT , OutputT > ): RenderingT abstract fun snapshotState ( state : StateT ): Snapshot } Swift: What is AnyWorkflowConvertible ? When a protocol has an associated Self type, Swift requires the use of a type-erasing wrapper to store references to instances of that protocol. AnyWorkflow is such a wrapper for Workflow . AnyWorkflowConvertible is a protocol with a single method that returns an AnyWorkflow . It is useful as a base type because it allows instances of Workflow to be used directly by any code that requires the type-erased AnyWorkflow . Kotlin: StatefulWorkflow vs Workflow It is a common practice in Kotlin to divide types into two parts: an interface for public API, and a class for private implementation. The Workflow library defines a Workflow interface, which should be used as the type of properties and parameters by code that needs to refer to a particular Workflow interface. The Workflow interface contains a single method, which simply returns a StatefulWorkflow \u2013 a Workflow can be described as \u201canything that can be expressed as a StatefulWorkflow .\u201d The library also defines two abstract classes which define the contract for workflows and should be subclassed to implement your workflows: StatefulWorkflow should be subclassed to implement Workflows that have private state . StatelessWorkflow should be subclassed to implement Workflows that don\u2019t have any private state. See Stateless Workflows . Workflows have several responsibilities:","title":"The Role of a Workflow"},{"location":"userguide/core-workflow/#workflows-have-state","text":"Once a Workflow has been started, it always operates in the context of some state. This state is divided into two parts: private state, which only the Workflow implementation itself knows about, which is defined by the State type, and properties (or \u201cprops\u201d), which is passed to the Workflow from its parent (more on hierarchical workflows below).","title":"Workflows have state"},{"location":"userguide/core-workflow/#private-state","text":"Every Workflow implementation defines a State type to maintain any necessary state while the workflow is running. For example, a tic-tac-toe game might have a state like this: Swift struct State { enum Player { case x case o } enum Space { case unfilled filled ( Player ) } // 3 rows * 3 columns = 9 spaces var spaces : [ Space ] = Array ( repeating : . unfilled , count : 9 ) var currentTurn : Player = . x } Kotlin data class State ( // 3 rows * 3 columns = 9 spaces val spaces : List < Space > = List ( 9 ) { Unfilled }, val currentTurn : Player = X ) { enum class Player { X , O } sealed class Space { object Unfilled : Space () data class Filled ( val player : Player ) : Space () } } When the workflow is first started, it is queried for an initial state value. From that point forward, the workflow may advance to a new state as the result of events occurring from various sources (which will be covered below). Stateless Workflows If a workflow does not have any private state, it is often referred to as a \u201cstateless workflow\u201d. A stateless Workflow is simply a Workflow that has a Void or Unit State type. See more below .","title":"Private state"},{"location":"userguide/core-workflow/#props","text":"Every Workflow implementation also defines data that is passed into it. The Workflow is not able to modify this state itself, but it may change between render passes. This public state is called Props . In Swift, the props are simply defined as properties of the struct implementing Workflow itself. In Kotlin, the Workflow interface defines a separate PropsT type parameter. (This additional type parameter is necessary due to Kotlin\u2019s lack of the Self type that Swift workflow\u2019s workflowDidChange method relies upon.) Swift TK Kotlin data class Props ( val playerXName : String val playerOName : String )","title":"Props"},{"location":"userguide/core-workflow/#workflows-are-advanced-by-workflowactions","text":"Any time something happens that should advance a workflow \u2013 a UI event, a network response, a child\u2019s output event \u2013 actions are used to perform the update. For example, a workflow may respond to UI events by mapping those events into a type conforming to/implementing WorkflowAction . These types implement the logic to advance a workflow by: Advancing to a new state (Optionally) emitting an output event up the tree. WorkflowAction s are typically defined as enums with associated types (Swift) or sealed classes (Kotlin), and can include data from the event \u2013 for example, the ID of the item in the list that was clicked. Side effects such as logging button clicks to an analytics framework are also typically performed in actions. If you\u2019re familiar with React/Redux, WorkflowAction s are essentially reducers.","title":"Workflows are advanced by WorkflowActions"},{"location":"userguide/core-workflow/#workflows-can-emit-output-events-up-the-hierarchy-to-their-parent","text":"When a workflow is advanced by an action, an optional output event can be sent up the workflow hierarchy. This is the opportunity for a workflow to notify its parent that something has happened (and the parent\u2019s opportunity to respond to that event by dispatching its own action, continuing up the tree as long as output events are emitted).","title":"Workflows can emit output events up the hierarchy to their parent"},{"location":"userguide/core-workflow/#workflows-produce-an-external-representation-of-their-state-via-rendering","text":"Immediately after starting up, or after a state transition occurs, a workflow will have its render method called. This method is responsible for creating and returning a value of type Rendering . You can think of Rendering as the \u201cexternal published state\u201d of the workflow, and the render function as a map of ( Props + State + childrens\u2019 Rendering s) -> Rendering . While a workflow\u2019s internal state may contain more detailed or comprehensive state, the Rendering (external state) is a type that is useful outside of the workflow. Because a workflow\u2019s render method may be called by infrastructure for a variety of reasons, it\u2019s important to not perform side effects when rendering \u2014 render methods must be idempotent. Event-based side effects should use Actions and state-based side effects should use Workers. When building an interactive application, the Rendering type is commonly (but not always) a view model that will drive the UI layer.","title":"Workflows produce an external representation of their state via Rendering"},{"location":"userguide/core-workflow/#workflows-can-respond-to-ui-events","text":"The RenderContext that is passed into render as the last parameter provides some useful tools to assist in creating the Rendering value. If a workflow is producing a view model, it is common to need an event handler to respond to UI events. The RenderContext has API to create an event handler, called a Sink , that when called will advance the workflow by dispatching an action back to the workflow (for more on actions, see below ). Swift func render ( state : State , context : RenderContext < DemoWorkflow >) -> DemoScreen { // Create a sink of our Action type so we can send actions back to the workflow. let sink = context . makeSink ( of : Action . self ) return DemoScreen ( title : \"A nice title\" , onTap : { sink . send ( Action . refreshButtonTapped ) } } Kotlin TK","title":"Workflows can respond to UI events"},{"location":"userguide/core-workflow/#workflows-form-a-hierarchy-they-may-have-children","text":"As they produce a Rendering value, it is common for workflows to delegate some portion of that work to a child workflow . This is done via the RenderContext that is passed into the render method. In order to delegate to a child, the parent calls renderChild on the context, with the child workflow as the single argument. The infrastructure will spin up the child workflow (including initializing its initial state) if this is the first time this child has been used, or, if the child was also used on the previous render pass, the existing child will be updated. Either way, render will immediately be called on the child (by the Workflow infrastructure), and the resulting child\u2019s Rendering value will be returned to the parent. This allows a parent to return complex Rendering types (such as a view model representing the entire UI state of an application) without needing to model all of that complexity within a single workflow. Workflow Identity The Workflow infrastructure automatically detects the first time and the last subsequent time you\u2019ve asked to render a child workflow, and will automatically initialize the child and clean it up. In both Swift and Kotlin, this is done using the workflow\u2019s concrete type. Both languages use reflection to do this comparison (e.g. in Kotlin, the workflows\u2019 KClass es are compared). It is an error to render workflows of the same type more than once in the same render pass. Since type is used for workflow identity, the child rendering APIs take an optional string key to differentiate between multiple child workflows of the same type.","title":"Workflows form a hierarchy (they may have children)"},{"location":"userguide/core-workflow/#workflows-can-subscribe-to-external-event-sources","text":"If a workflow needs to respond to some external event source (e.g. push notifications), the workflow can ask the context to listen to those events from within the render method. Swift vs Kotlin In the Swift library, there is a special API for subscribing to hot streams ( Signal in ReactiveSwift). The Kotlin library does not have any special API for subscribing to hot streams (channels), though it does have extension methods to convert ReceiveChannel s , and RxJava Flowable s and Observables , to Worker s . The reason for this discrepancy is simply that we don\u2019t have any uses of channels yet in production, and so we\u2019ve decided to keep the API simpler. If we start using channels in the future, it may make sense to make subscribing to them a first-class API like in Swift.","title":"Workflows can subscribe to external event sources"},{"location":"userguide/core-workflow/#workflows-can-perform-asynchronous-tasks-workers","text":"Workers are very similar in concept to child workflows. Unlike child workflows, however, workers do not have a Rendering type; they only exist to perform a single asynchronous task before sending zero or more output events back up the tree to their parent. For more information about workers, see the Worker section below.","title":"Workflows can perform asynchronous tasks (Workers)"},{"location":"userguide/core-workflow/#workflows-can-be-saved-to-and-restored-from-a-snapshot-kotlin-only","text":"On every render pass, each workflow is asked to create a \u201csnapshot\u201d of its state \u2013 a lazily-produced serialization of the workflow\u2019s State as a binary blob. These Snapshot s are aggregated into a single Snapshot for the entire workflow tree and emitted along with the root workflow\u2019s Rendering . When the workflow runtime is started, it can be passed an optional Snapshot to restore the tree from. When non-null, the root workflow\u2019s snapshot is extracted and passed to the root workflow\u2019s initialState . The workflow can choose to either ignore the snapshot or use it to restore its State . On the first render pass, if the root workflow renders any children that were also being rendered when the snapshot was taken, those children\u2019s snapshots are also extracted from the aggregate and used to initialize their states. !!! faq Why don\u2019t Swift Workflows support snapshotting? Snapshotting was built into Kotlin workflows specifically to support Android\u2019s app lifecycle, which requires apps to serialize their current state before being backgrounded so that they can be restored in case the system needs to kill the hosting process. iOS apps don\u2019t have this requirement, so the Swift library doesn\u2019t need to support it.","title":"Workflows can be saved to and restored from a snapshot (Kotlin only)"},{"location":"userguide/implementation/","text":"Implementation Notes \u00b6 Work in progress\u2026 Swift \u00b6 The Render loop \u00b6 Initial pass \u00b6 The root of your workflow hierarchy gets put into a WorkflowHost (if you\u2019re using ContainerViewController this is created for you). As part of its initializer, WorkflowHost creates a WorkflowNode that wraps the given root Workflow (and keeps track of the Workflow \u2018s State ). It then calls render() on the node: // WorkflowHost public init ( workflow : WorkflowType , debugger : WorkflowDebugger ? = nil ) { self . debugger = debugger self . rootNode = WorkflowNode ( workflow : workflow ) // 1. Create the node self . mutableRendering = MutableProperty ( self . rootNode . render ()) // 2. Call render() WorkflowNode contains a SubtreeManager , whose primary purpose is to manage child workflows (more on this later). When render() gets invoked on the node, it calls render on the SubtreeManager and passes a closure that takes a RenderContext and returns a Rendering for the Workflow associated with the node. // WorkflowNode func render () -> WorkflowType . Rendering { return subtreeManager . render { context in return workflow . render ( state : state , context : context ) } } The SubtreeManager instantiates a RenderContext and invokes the closure that was passed in. This last step generates the Rendering . This Rendering then gets passed back up the call stack until it reaches the WorkflowHost . Composition \u00b6 In cases where a Workflow has child Workflow s, the render sequence is similar. The [tutorial] (../tutorial/building-a-workflow/#the-render-context) goes through this in more detail. Essentially, a Workflow containing child Workflow s calls render(context:key:outputMap:) on each child Workflow and passes in the RenderContext . The context does some bookkeeping for the child Workflow (creating or updating a ChildWorkflow<T> ) and then calls render() . ChildWorkflow<T>.render() calls render() on its WorkflowNode and we recurse back to step 2.","title":"Implementation Notes"},{"location":"userguide/implementation/#implementation-notes","text":"Work in progress\u2026","title":"Implementation Notes"},{"location":"userguide/implementation/#swift","text":"","title":"Swift"},{"location":"userguide/implementation/#the-render-loop","text":"","title":"The Render loop"},{"location":"userguide/implementation/#initial-pass","text":"The root of your workflow hierarchy gets put into a WorkflowHost (if you\u2019re using ContainerViewController this is created for you). As part of its initializer, WorkflowHost creates a WorkflowNode that wraps the given root Workflow (and keeps track of the Workflow \u2018s State ). It then calls render() on the node: // WorkflowHost public init ( workflow : WorkflowType , debugger : WorkflowDebugger ? = nil ) { self . debugger = debugger self . rootNode = WorkflowNode ( workflow : workflow ) // 1. Create the node self . mutableRendering = MutableProperty ( self . rootNode . render ()) // 2. Call render() WorkflowNode contains a SubtreeManager , whose primary purpose is to manage child workflows (more on this later). When render() gets invoked on the node, it calls render on the SubtreeManager and passes a closure that takes a RenderContext and returns a Rendering for the Workflow associated with the node. // WorkflowNode func render () -> WorkflowType . Rendering { return subtreeManager . render { context in return workflow . render ( state : state , context : context ) } } The SubtreeManager instantiates a RenderContext and invokes the closure that was passed in. This last step generates the Rendering . This Rendering then gets passed back up the call stack until it reaches the WorkflowHost .","title":"Initial pass"},{"location":"userguide/implementation/#composition","text":"In cases where a Workflow has child Workflow s, the render sequence is similar. The [tutorial] (../tutorial/building-a-workflow/#the-render-context) goes through this in more detail. Essentially, a Workflow containing child Workflow s calls render(context:key:outputMap:) on each child Workflow and passes in the RenderContext . The context does some bookkeeping for the child Workflow (creating or updating a ChildWorkflow<T> ) and then calls render() . ChildWorkflow<T>.render() calls render() on its WorkflowNode and we recurse back to step 2.","title":"Composition"},{"location":"userguide/motivation/","text":"Motivation & Architectural Concepts \u00b6 Coming soon!","title":"Motivation & Architectural Concepts"},{"location":"userguide/motivation/#motivation-architectural-concepts","text":"Coming soon!","title":"Motivation &amp; Architectural Concepts"},{"location":"userguide/testing-concepts/","text":"Workflow Testing \u00b6 Coming soon!","title":"Workflow Testing"},{"location":"userguide/testing-concepts/#workflow-testing","text":"Coming soon!","title":"Workflow Testing"},{"location":"userguide/ui-concepts/","text":"Workflow UI \u00b6 Coming soon!","title":"Workflow UI"},{"location":"userguide/ui-concepts/#workflow-ui","text":"Coming soon!","title":"Workflow UI"},{"location":"userguide/whyworkflow/","text":"Why Workflow? \u00b6 So you want me to take the application feature I have to develop and break it down into separate components? And then enumerate every possible state for each of those components? As well as writing classes or structs that represent each of these states in addition to the collection of objects that each component might pass to another? That sounds like a lot of work just to help the seller order a set of gift cards! Why make something simple so complicated? Why should I use Workflow? I think even those of us who use Workflow all the time end up asking this question. It\u2019s a very reasonable question that we try to answer here. At the heart of the matter, there are two complementary justifications for Workflow, which we will expand on below: Software clarity, correctness, and testability (especially at scale). Encouraging programming paradigms that are best practices for the mobile domain. Software clarity, correctness, and testability (at scale) \u00b6 I like to think that most of us have been there: It\u2019s our second straight day staring at the logs from over 200 customers. We know what the problem is : the user gets to screen Y and object foo\u2019s state is bar, but foo should not be bar while in screen Y. Why is foo bar? Unfortunately we don\u2019t have any debug log for foo\u2019s state at the time we start screen Y. We only have one when the user tries to click on button Z, and at that point the state is already bar even though it should only ever be baz or buz. What happened? How did foo get to state bar on screen Y? Looking at the code, foo is shared state with 15 other screens, and it is mutable in all of them. The logic to update foo\u2019s state in screen Y happens in code that is coupled to interaction with button Z, so we cannot simply add a unit test for this, we need a complex UI test to reproduce screen Y. We don\u2019t know how the problem happened and it almost seems like we can\u2019t know how without significant effort! The story above is a little dramatic but I hope the feeling it invokes is familiar. It is a daunting task to reason through application code and build up a sufficient mental model of all possible side effects in any one feature area. Now scale up the numbers a bit \u2014 foo is shared by 150 other screens \u2014 and the once daunting task seems almost impossible. All mobile developers face some form of the above problem, and at Square within our Point of Sale applications we face the scaled up version every day. What do we want? \u00b6 Clear boundaries between each feature\u2019s software components that can be instrumented with logs and that have contracts that can be tested. Clear expectations for outcomes within a particular feature\u2019s software component that can be verified for correctness with tests. Immutable State within any particular scope (e.g. Screen Y in the context above) so that the code handling mutations to provide a new State as a result of some event is in a \u201cprotected area\u201d that can be instrumented and tested. A clear separation of the State updates from the presentation of the UI. We want the conditions above because we want: Not to have bugs like the one we started this discussion with. In other words, we want our tests to give us confidence in our application logic. In the inevitable case that we do have a bug, we want to be able to isolate the scenario, reproduce the exact conditions, fix the bug and write a test so that it doesn\u2019t happen again. Workflow facilitates these goals for native mobile applications by providing a pattern (and a supporting application Runtime) similar to React, Elm, or any number of other web application JavaScript frameworks (not to mention forthcoming native mobile frameworks such as Jetpack Compose and SwiftUI). Each logical component area is separated into a Workflow with a finite set of states and the logic to transition between them. Workflows can be composed together for a full feature with each Workflow\u2019s signature specifying a clear contract. The Workflow Runtime\u2019s event loop handles the production of new immutable states for each Workflow so that within the Workflow render logic it is immutable. Workflows can be executed and instrumented in a testable way with extra hooks for simple verification of outcomes in unit tests. On an even simpler level Workflow improves clarity by giving a large team of developers a shared idiom of software components with which to discuss business logic across feature areas, and across mobile platforms (Android, iOS). Further, as the application is composed with multiple Workflows, the framework enables loose coupling between features to focus the impact of code changes. Encouraging programming paradigms that are best practices for the mobile domain \u00b6 Mobile applications receive and display a lot of data! Our applications at Square certainly do. As a result of this, there is a growing trend towards reactive programming for mobile applications. In this paradigm, the application logic subscribes to a stream of data which is then pushed to the logic rather than having to be periodically pulled and operated on. This has the profound effect of ensuring that the data shown to the application user is never stale. This style of programming also makes clear that most mobile applications are a series of mapping operations on a stream of data that is eventually mapped into some UI. Another mobile programming best practice (arising out of a long tradition) is to favor declarative programming over imperative programming . With this style choice, the code for a feature declares what should be occurring for a particular state, rather than consisting of a series of statements that are essentially how to make that occur. This is a best practice because when a program\u2019s logic is defined in this way, it is very simple to test (so more likely to be tested!): \u201cFor state Y we expect Rendering Z;\u201d \u201cFrom state Y given input A we expect Rendering Z+.\u201d Possibly more important, it is easier to read, comprehend quickly, and to reason about than a series of complex commands for the computer. Workflows encourage a declarative style because each state of a particular component must be enumerated and then the Rendering (representation that gets passed to the UI framework) is declared for that particular state, alongside a declaration of what children and side effects should be running in that state. The well-tested and reliable Workflow runtime loop itself handles how to start and stop the children and side effects, reducing resource leaks. By requiring these formal definitions of each State, Rendering, and the Actions that will change the current state, Workflow naturally encourages declarative programming. While reactive and declarative programming may be current best practices, there is one Software Engineering principle that has proven over and over again to be the most universal and the most important for systems of scale: Separation of Concerns . Any system of scale requires multiple separate components that can be worked on, tested, improved, and refactored independently by multiple teams of people. A system of multiple components requires communication and any good communication begs explicit structure and contracts. For mobile applications at Square we have settled on the Model-View-ViewModel (MVVM) architecture as the structure for the topical separation of concerns of the layers of the application. MVVM\u2019s unidirectional layered communication is the same as that of Model-View-Presenter (MVP), as opposed to the \u2018circular\u2019 communication of Model-View-Controller (MVC). MVVM\u2019s use of a strict binding between the ViewModel and the View is the same as MVC, as opposed to the imperative interpretation of the Model in MVP. MVVM provides the reasoning and comprehension benefits of unidirectional data flow while also eliminating as much business logic as possible from the view layer and encouraging declarative ViewModels. At Square this works well because we have UI design frameworks that change infrequently (so keeping bindings up-to-date is not much overhead), but business logic that is constantly being updated (so emphasizing low coupling is important). Workflows embrace MVVM because the Rendering produced by a Workflow tree is the ViewModel, which can then be bound to any native mobile UI framework. For feature based separation of concerns we lean on Workflow\u2019s facility for composition at scale via strong parent-child contracts and a hierarchical tree organization. While building a Hello World Workflow may seem like overkill (although it\u2019s really not that bad!), the explicitness and contracts that Workflows require of the developer lay the structure for good communication. The composability of Workflows encourages reuse and encourages separation of concerns into the most appropriate reusable components. There are even more platform-specific best practices that Workflow dovetails well with, such as structured concurrency with Kotlin coroutines, as each Worker or side effect can define a specific coroutine scope for the operations. What about the next 10 years? Jetpack Compose UI and SwiftUI are establishing themselves as the native mobile UI toolkits of the future. They both embrace the same MVVM approach that Workflow does, and encourage thinking about the \u201ccomposability\u201d of separate components of your application. With this resonance, Workflows help you to prepare your mental model to adapt to these new UI toolkits, and shapes our codebase in a way that will ease our adoption of them. To learn more about Compose and Workflow see this post .","title":"Why Workflow?"},{"location":"userguide/whyworkflow/#why-workflow","text":"So you want me to take the application feature I have to develop and break it down into separate components? And then enumerate every possible state for each of those components? As well as writing classes or structs that represent each of these states in addition to the collection of objects that each component might pass to another? That sounds like a lot of work just to help the seller order a set of gift cards! Why make something simple so complicated? Why should I use Workflow? I think even those of us who use Workflow all the time end up asking this question. It\u2019s a very reasonable question that we try to answer here. At the heart of the matter, there are two complementary justifications for Workflow, which we will expand on below: Software clarity, correctness, and testability (especially at scale). Encouraging programming paradigms that are best practices for the mobile domain.","title":"Why Workflow?"},{"location":"userguide/whyworkflow/#software-clarity-correctness-and-testability-at-scale","text":"I like to think that most of us have been there: It\u2019s our second straight day staring at the logs from over 200 customers. We know what the problem is : the user gets to screen Y and object foo\u2019s state is bar, but foo should not be bar while in screen Y. Why is foo bar? Unfortunately we don\u2019t have any debug log for foo\u2019s state at the time we start screen Y. We only have one when the user tries to click on button Z, and at that point the state is already bar even though it should only ever be baz or buz. What happened? How did foo get to state bar on screen Y? Looking at the code, foo is shared state with 15 other screens, and it is mutable in all of them. The logic to update foo\u2019s state in screen Y happens in code that is coupled to interaction with button Z, so we cannot simply add a unit test for this, we need a complex UI test to reproduce screen Y. We don\u2019t know how the problem happened and it almost seems like we can\u2019t know how without significant effort! The story above is a little dramatic but I hope the feeling it invokes is familiar. It is a daunting task to reason through application code and build up a sufficient mental model of all possible side effects in any one feature area. Now scale up the numbers a bit \u2014 foo is shared by 150 other screens \u2014 and the once daunting task seems almost impossible. All mobile developers face some form of the above problem, and at Square within our Point of Sale applications we face the scaled up version every day.","title":"Software clarity, correctness, and testability (at scale)"},{"location":"userguide/whyworkflow/#what-do-we-want","text":"Clear boundaries between each feature\u2019s software components that can be instrumented with logs and that have contracts that can be tested. Clear expectations for outcomes within a particular feature\u2019s software component that can be verified for correctness with tests. Immutable State within any particular scope (e.g. Screen Y in the context above) so that the code handling mutations to provide a new State as a result of some event is in a \u201cprotected area\u201d that can be instrumented and tested. A clear separation of the State updates from the presentation of the UI. We want the conditions above because we want: Not to have bugs like the one we started this discussion with. In other words, we want our tests to give us confidence in our application logic. In the inevitable case that we do have a bug, we want to be able to isolate the scenario, reproduce the exact conditions, fix the bug and write a test so that it doesn\u2019t happen again. Workflow facilitates these goals for native mobile applications by providing a pattern (and a supporting application Runtime) similar to React, Elm, or any number of other web application JavaScript frameworks (not to mention forthcoming native mobile frameworks such as Jetpack Compose and SwiftUI). Each logical component area is separated into a Workflow with a finite set of states and the logic to transition between them. Workflows can be composed together for a full feature with each Workflow\u2019s signature specifying a clear contract. The Workflow Runtime\u2019s event loop handles the production of new immutable states for each Workflow so that within the Workflow render logic it is immutable. Workflows can be executed and instrumented in a testable way with extra hooks for simple verification of outcomes in unit tests. On an even simpler level Workflow improves clarity by giving a large team of developers a shared idiom of software components with which to discuss business logic across feature areas, and across mobile platforms (Android, iOS). Further, as the application is composed with multiple Workflows, the framework enables loose coupling between features to focus the impact of code changes.","title":"What do we want?"},{"location":"userguide/whyworkflow/#encouraging-programming-paradigms-that-are-best-practices-for-the-mobile-domain","text":"Mobile applications receive and display a lot of data! Our applications at Square certainly do. As a result of this, there is a growing trend towards reactive programming for mobile applications. In this paradigm, the application logic subscribes to a stream of data which is then pushed to the logic rather than having to be periodically pulled and operated on. This has the profound effect of ensuring that the data shown to the application user is never stale. This style of programming also makes clear that most mobile applications are a series of mapping operations on a stream of data that is eventually mapped into some UI. Another mobile programming best practice (arising out of a long tradition) is to favor declarative programming over imperative programming . With this style choice, the code for a feature declares what should be occurring for a particular state, rather than consisting of a series of statements that are essentially how to make that occur. This is a best practice because when a program\u2019s logic is defined in this way, it is very simple to test (so more likely to be tested!): \u201cFor state Y we expect Rendering Z;\u201d \u201cFrom state Y given input A we expect Rendering Z+.\u201d Possibly more important, it is easier to read, comprehend quickly, and to reason about than a series of complex commands for the computer. Workflows encourage a declarative style because each state of a particular component must be enumerated and then the Rendering (representation that gets passed to the UI framework) is declared for that particular state, alongside a declaration of what children and side effects should be running in that state. The well-tested and reliable Workflow runtime loop itself handles how to start and stop the children and side effects, reducing resource leaks. By requiring these formal definitions of each State, Rendering, and the Actions that will change the current state, Workflow naturally encourages declarative programming. While reactive and declarative programming may be current best practices, there is one Software Engineering principle that has proven over and over again to be the most universal and the most important for systems of scale: Separation of Concerns . Any system of scale requires multiple separate components that can be worked on, tested, improved, and refactored independently by multiple teams of people. A system of multiple components requires communication and any good communication begs explicit structure and contracts. For mobile applications at Square we have settled on the Model-View-ViewModel (MVVM) architecture as the structure for the topical separation of concerns of the layers of the application. MVVM\u2019s unidirectional layered communication is the same as that of Model-View-Presenter (MVP), as opposed to the \u2018circular\u2019 communication of Model-View-Controller (MVC). MVVM\u2019s use of a strict binding between the ViewModel and the View is the same as MVC, as opposed to the imperative interpretation of the Model in MVP. MVVM provides the reasoning and comprehension benefits of unidirectional data flow while also eliminating as much business logic as possible from the view layer and encouraging declarative ViewModels. At Square this works well because we have UI design frameworks that change infrequently (so keeping bindings up-to-date is not much overhead), but business logic that is constantly being updated (so emphasizing low coupling is important). Workflows embrace MVVM because the Rendering produced by a Workflow tree is the ViewModel, which can then be bound to any native mobile UI framework. For feature based separation of concerns we lean on Workflow\u2019s facility for composition at scale via strong parent-child contracts and a hierarchical tree organization. While building a Hello World Workflow may seem like overkill (although it\u2019s really not that bad!), the explicitness and contracts that Workflows require of the developer lay the structure for good communication. The composability of Workflows encourages reuse and encourages separation of concerns into the most appropriate reusable components. There are even more platform-specific best practices that Workflow dovetails well with, such as structured concurrency with Kotlin coroutines, as each Worker or side effect can define a specific coroutine scope for the operations. What about the next 10 years? Jetpack Compose UI and SwiftUI are establishing themselves as the native mobile UI toolkits of the future. They both embrace the same MVVM approach that Workflow does, and encourage thinking about the \u201ccomposability\u201d of separate components of your application. With this resonance, Workflows help you to prepare your mental model to adapt to these new UI toolkits, and shapes our codebase in a way that will ease our adoption of them. To learn more about Compose and Workflow see this post .","title":"Encouraging programming paradigms that are best practices for the mobile domain"}]}