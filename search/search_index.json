{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview \u00b6 Workflow is an application framework that provides architectural primitives. Workflow is: Written in and used for Kotlin and Swift A unidirectional data flow library that uses immutable data within each Workflow. Data flows in a single direction from source to UI, and events in a single direction from the UI to the business logic. A library that supports writing business logic and complex UI navigation logic as state machines, thereby enabling confident reasoning about state and validation of correctness. Optimized for composability and scalability of features and screens. Corresponding UI frameworks that bind Rendering data classes for \u201cviews\u201d (including event callbacks) to Mobile UI frameworks for Android and iOS. A corresponding testing framework that facilitates simple-to-write unit tests for all application business logic and helps ensure correctness. Using Workflows in your project \u00b6 Swift \u00b6 See the square/workflow-swift repository. Kotlin \u00b6 See the square/workflow-kotlin repository. Resources \u00b6 Wondering why to use Workflow? See \u201cWhy Workflow\u201d There is a Glossary of Terms We have a User Guide describing core concepts. For Kotlin (and Android), there is a codelab style tutorial in the repo. For Swift (and iOS), there is also a Getting Started tutorial in the repo. There are also a number of Kotlin samples and Swift samples . Support & Contact \u00b6 Workflow discussion happens in the Workflow Community slack. Use this open invitation . Workflow maintainers also hang out in the #squarelibraries channel on the Kotlin Slack . Releasing and Deploying \u00b6 See RELEASING.md . License \u00b6 Copyright 2019 Square Inc. Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"Overview"},{"location":"#overview","text":"Workflow is an application framework that provides architectural primitives. Workflow is: Written in and used for Kotlin and Swift A unidirectional data flow library that uses immutable data within each Workflow. Data flows in a single direction from source to UI, and events in a single direction from the UI to the business logic. A library that supports writing business logic and complex UI navigation logic as state machines, thereby enabling confident reasoning about state and validation of correctness. Optimized for composability and scalability of features and screens. Corresponding UI frameworks that bind Rendering data classes for \u201cviews\u201d (including event callbacks) to Mobile UI frameworks for Android and iOS. A corresponding testing framework that facilitates simple-to-write unit tests for all application business logic and helps ensure correctness.","title":"Overview"},{"location":"#using-workflows-in-your-project","text":"","title":"Using Workflows in your project"},{"location":"#swift","text":"See the square/workflow-swift repository.","title":"Swift"},{"location":"#kotlin","text":"See the square/workflow-kotlin repository.","title":"Kotlin"},{"location":"#resources","text":"Wondering why to use Workflow? See \u201cWhy Workflow\u201d There is a Glossary of Terms We have a User Guide describing core concepts. For Kotlin (and Android), there is a codelab style tutorial in the repo. For Swift (and iOS), there is also a Getting Started tutorial in the repo. There are also a number of Kotlin samples and Swift samples .","title":"Resources"},{"location":"#support-contact","text":"Workflow discussion happens in the Workflow Community slack. Use this open invitation . Workflow maintainers also hang out in the #squarelibraries channel on the Kotlin Slack .","title":"Support &amp; Contact"},{"location":"#releasing-and-deploying","text":"See RELEASING.md .","title":"Releasing and Deploying"},{"location":"#license","text":"Copyright 2019 Square Inc. Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"License"},{"location":"CHANGELOG/","text":"Changelog \u00b6 You can find the changelogs for the library in the respective language repositories: Kotlin Swift","title":"Changelog"},{"location":"CHANGELOG/#changelog","text":"You can find the changelogs for the library in the respective language repositories: Kotlin Swift","title":"Changelog"},{"location":"CODE_OF_CONDUCT/","text":"Open Source Code of Conduct \u00b6 At Square, we are committed to contributing to the open source community and simplifying the process of releasing and managing open source software. We\u2019ve seen incredible support and enthusiasm from thousands of people who have already contributed to our projects\u200a\u2014\u200aand we want to ensure ourcommunity continues to be truly open for everyone. This code of conduct outlines our expectations for participants, as well as steps to reporting unacceptable behavior. We are committed to providing a welcoming and inspiring community for all and expect our code of conduct to be honored. Square\u2019s open source community strives to: Be open : We invite anyone to participate in any aspect of our projects. Our community is open, and any responsibility can be carried by a contributor who demonstrates the required capacity and competence. Be considerate : People use our work, and we depend on the work of others. Consider users and colleagues before taking action. For example, changes to code, infrastructure, policy, and documentation may negatively impact others. Be respectful : We expect people to work together to resolve conflict, assume good intentions, and act with empathy. Do not turn disagreements into personal attacks. Be collaborative : Collaboration reduces redundancy and improves the quality of our work. We strive for transparency within our open source community, and we work closely with upstream developers and others in the free software community to coordinate our efforts. Be pragmatic : Questions are encouraged and should be asked early in the process to avoid problems later. Be thoughtful and considerate when seeking out the appropriate forum for your questions. Those who are asked should be responsive and helpful. Step down considerately : Members of every project come and go. When somebody leaves or disengages from the project, they should make it known and take the proper steps to ensure that others can pick up where they left off. This code is not exhaustive or complete. It serves to distill our common understanding of a collaborative, shared environment, and goals. We expect it to be followed in spirit as much as in the letter. Diversity Statement \u00b6 We encourage everyone to participate and are committed to building a community for all. Although we may not be able to satisfy everyone, we all agree that everyone is equal. Whenever a participant has made a mistake, we expect them to take responsibility for it. If someone has been harmed or offended, it is our responsibility to listen carefully and respectfully, and do our best to right the wrong. Although this list cannot be exhaustive, we explicitly honor diversity in age, culture, ethnicity, gender identity or expression, language, national origin, political beliefs, profession, race, religion, sexual orientation, socioeconomic status, and technical ability. We will not tolerate discrimination based on any of the protected characteristics above, including participants with disabilities. Reporting Issues \u00b6 If you experience or witness unacceptable behavior\u200a\u2014\u200aor have any other concerns\u200a\u2014\u200aplease report it by emailing codeofconduct@squareup.com . For more details, please see our Reporting Guidelines below. Thanks \u00b6 Some of the ideas and wording for the statements and guidelines above were based on work by the Twitter , Ubuntu , GDC , and Django communities. We are thankful for their work. Reporting Guide \u00b6 If you experience or witness unacceptable behavior\u200a\u2014\u200aor have any other concerns\u200a\u2014\u200aplease report it by emailing codeofconduct@squareup.com . All reports will be handled with discretion. In your report please include: Your contact information. Names (real, nicknames, or pseudonyms) of any individuals involved. If there are additional witnesses, please include them as well. Your account of what occurred, and if you believe the incident is ongoing. If there is a publicly available record (e.g. a mailing list archive or a public IRC logger), please include a link. Any additional information that may be helpful. After filing a report, a representative from the Square Code of Conduct committee will contact you personally. The committee will then review the incident, follow up with any additional questions, and make a decision as to how to respond. Anyone asked to stop unacceptable behavior is expected to comply immediately. If an individual engages in unacceptable behavior, the Square Code of Conduct committee may take any action they deem appropriate, up to and including a permanent ban from all of Square spaces without warning.","title":"Code of Conduct"},{"location":"CODE_OF_CONDUCT/#open-source-code-of-conduct","text":"At Square, we are committed to contributing to the open source community and simplifying the process of releasing and managing open source software. We\u2019ve seen incredible support and enthusiasm from thousands of people who have already contributed to our projects\u200a\u2014\u200aand we want to ensure ourcommunity continues to be truly open for everyone. This code of conduct outlines our expectations for participants, as well as steps to reporting unacceptable behavior. We are committed to providing a welcoming and inspiring community for all and expect our code of conduct to be honored. Square\u2019s open source community strives to: Be open : We invite anyone to participate in any aspect of our projects. Our community is open, and any responsibility can be carried by a contributor who demonstrates the required capacity and competence. Be considerate : People use our work, and we depend on the work of others. Consider users and colleagues before taking action. For example, changes to code, infrastructure, policy, and documentation may negatively impact others. Be respectful : We expect people to work together to resolve conflict, assume good intentions, and act with empathy. Do not turn disagreements into personal attacks. Be collaborative : Collaboration reduces redundancy and improves the quality of our work. We strive for transparency within our open source community, and we work closely with upstream developers and others in the free software community to coordinate our efforts. Be pragmatic : Questions are encouraged and should be asked early in the process to avoid problems later. Be thoughtful and considerate when seeking out the appropriate forum for your questions. Those who are asked should be responsive and helpful. Step down considerately : Members of every project come and go. When somebody leaves or disengages from the project, they should make it known and take the proper steps to ensure that others can pick up where they left off. This code is not exhaustive or complete. It serves to distill our common understanding of a collaborative, shared environment, and goals. We expect it to be followed in spirit as much as in the letter.","title":"Open Source Code of Conduct"},{"location":"CODE_OF_CONDUCT/#diversity-statement","text":"We encourage everyone to participate and are committed to building a community for all. Although we may not be able to satisfy everyone, we all agree that everyone is equal. Whenever a participant has made a mistake, we expect them to take responsibility for it. If someone has been harmed or offended, it is our responsibility to listen carefully and respectfully, and do our best to right the wrong. Although this list cannot be exhaustive, we explicitly honor diversity in age, culture, ethnicity, gender identity or expression, language, national origin, political beliefs, profession, race, religion, sexual orientation, socioeconomic status, and technical ability. We will not tolerate discrimination based on any of the protected characteristics above, including participants with disabilities.","title":"Diversity Statement"},{"location":"CODE_OF_CONDUCT/#reporting-issues","text":"If you experience or witness unacceptable behavior\u200a\u2014\u200aor have any other concerns\u200a\u2014\u200aplease report it by emailing codeofconduct@squareup.com . For more details, please see our Reporting Guidelines below.","title":"Reporting Issues"},{"location":"CODE_OF_CONDUCT/#thanks","text":"Some of the ideas and wording for the statements and guidelines above were based on work by the Twitter , Ubuntu , GDC , and Django communities. We are thankful for their work.","title":"Thanks"},{"location":"CODE_OF_CONDUCT/#reporting-guide","text":"If you experience or witness unacceptable behavior\u200a\u2014\u200aor have any other concerns\u200a\u2014\u200aplease report it by emailing codeofconduct@squareup.com . All reports will be handled with discretion. In your report please include: Your contact information. Names (real, nicknames, or pseudonyms) of any individuals involved. If there are additional witnesses, please include them as well. Your account of what occurred, and if you believe the incident is ongoing. If there is a publicly available record (e.g. a mailing list archive or a public IRC logger), please include a link. Any additional information that may be helpful. After filing a report, a representative from the Square Code of Conduct committee will contact you personally. The committee will then review the incident, follow up with any additional questions, and make a decision as to how to respond. Anyone asked to stop unacceptable behavior is expected to comply immediately. If an individual engages in unacceptable behavior, the Square Code of Conduct committee may take any action they deem appropriate, up to and including a permanent ban from all of Square spaces without warning.","title":"Reporting Guide"},{"location":"CONTRIBUTING/","text":"Contributing \u00b6 If you would like to contribute code to Workflow you can do so through GitHub by forking the repository and sending a pull request. When submitting code, please make every effort to follow existing conventions and style in order to keep the code as readable as possible. Please also make sure your code compiles. Before your code can be accepted into the project you must also sign the Individual Contributor License Agreement (CLA) .","title":"Contributing"},{"location":"CONTRIBUTING/#contributing","text":"If you would like to contribute code to Workflow you can do so through GitHub by forking the repository and sending a pull request. When submitting code, please make every effort to follow existing conventions and style in order to keep the code as readable as possible. Please also make sure your code compiles. Before your code can be accepted into the project you must also sign the Individual Contributor License Agreement (CLA) .","title":"Contributing"},{"location":"RELEASING/","text":"Releasing workflow \u00b6 Deploying the documentation website \u00b6 Official Workflow documentation lives at https://square.github.io/workflow . The website content consists of three parts: Markdown documentation: Lives in the docs/ folder, and consists of a set of hand-written Markdown files that document high-level concepts. The static site generator mkdocs (with Material theming) is used to convert the Markdown to static, styled HTML. Kotlin API reference: Kdoc embedded in Kotlin source files is converted to GitHub-flavored Markdown by Dokka and then included in the statically-generated website. Swift API reference: Markup comments from Swift files are converted Markdown by DocC and then published independently at square.github.io/workflow-swift/documentation . Note: The documentation site is automatically built and deployed whenever a version tag is pushed. You only need these steps if you want to work on the site locally. Setting up the site generators \u00b6 If you\u2019ve already done this, you can skip to Deploying the website to production below. Kotlin: Dokka \u00b6 Dokka runs as a Gradle plugin, so you need to be able to build the Kotlin source with Gradle, but that\u2019s it. To generate the docs manually, run: cd kotlin ./gradlew dokka Swift: DocC \u00b6 The Swift documentation is published by CI in the Swift repo and linked from the cross-platform Workflow docs. For info on how to generate the Swift docs locally, check out the workflow-swift repo . mkdocs \u00b6 Mkdocs is written in Python, so you\u2019ll need Python 3 and pip in order to run it. Assuming those are set up, run: pip install -r requirements.txt Generate the site manually with: mkdocs build While you\u2019re working on the documentation files, you can run the site locally with: mkdocs serve Deploying the website to production \u00b6 Note: The documentation site is automatically built and deployed by a Github Workflow whenever a version tag is pushed. You only need these steps if you want to publish the site manually. Before deploying the website for real, you need to export our Google Analytics key in an environment variable so that it will get added to the HTML. Get the key from one of the project maintainers, then add the following to your .bashrc and re-source it: export WORKFLOW_GOOGLE_ANALYTICS_KEY = UA-__________-1 Now you\u2019re ready to publish the site! Just choose a tag or SHA to deploy from, and run: ./deploy_website.sh TAG_OR_SHA # For example: #./deploy_website.sh v0.18.0 This will clone the repo to a temporary directory, checkout the right SHA, build Kotlin and Swift API docs, generate HTML, and push the newly-generated content to the gh-pages branch on GitHub. Validating Markdown \u00b6 Since all of our high-level documentation is written in Markdown, we run a linter in CI to ensure we use consistent formatting. Lint errors will fail your PR builds, so to run locally, install markdownlint : gem install mdl Run the linter using the lint_docs.sh : ./lint_docs.sh Rules can be configured by editing .markdownlint.rb . Kotlin Notes \u00b6 Development \u00b6 To build and install the current version to your local Maven repository ( ~/.m2 ), run: ./gradlew clean installArchives Deploying \u00b6 Configuration \u00b6 In order to deploy artifacts to a Maven repository, you\u2019ll need to set 4 properties in your private Gradle properties file ( ~/.gradle/gradle.properties ): RELEASE_REPOSITORY_URL=<url of release repository> SNAPSHOT_REPOSITORY_URL=<url of snapshot repository SONATYPE_NEXUS_USERNAME=<username> SONATYPE_NEXUS_PASSWORD=<password> Snapshot Releases \u00b6 Double-check that gradle.properties correctly contains the -SNAPSHOT suffix, then upload snapshot artifacts to Sonatype just like you would for a production release: ./gradlew clean build && ./gradlew uploadArchives --no-parallel --no-daemon You can verify the artifacts are available by visiting https://oss.sonatype.org/content/repositories/snapshots/com/squareup/workflow/ .","title":"Releasing workflow"},{"location":"RELEASING/#releasing-workflow","text":"","title":"Releasing workflow"},{"location":"RELEASING/#deploying-the-documentation-website","text":"Official Workflow documentation lives at https://square.github.io/workflow . The website content consists of three parts: Markdown documentation: Lives in the docs/ folder, and consists of a set of hand-written Markdown files that document high-level concepts. The static site generator mkdocs (with Material theming) is used to convert the Markdown to static, styled HTML. Kotlin API reference: Kdoc embedded in Kotlin source files is converted to GitHub-flavored Markdown by Dokka and then included in the statically-generated website. Swift API reference: Markup comments from Swift files are converted Markdown by DocC and then published independently at square.github.io/workflow-swift/documentation . Note: The documentation site is automatically built and deployed whenever a version tag is pushed. You only need these steps if you want to work on the site locally.","title":"Deploying the documentation website"},{"location":"RELEASING/#setting-up-the-site-generators","text":"If you\u2019ve already done this, you can skip to Deploying the website to production below.","title":"Setting up the site generators"},{"location":"RELEASING/#kotlin-dokka","text":"Dokka runs as a Gradle plugin, so you need to be able to build the Kotlin source with Gradle, but that\u2019s it. To generate the docs manually, run: cd kotlin ./gradlew dokka","title":"Kotlin: Dokka"},{"location":"RELEASING/#swift-docc","text":"The Swift documentation is published by CI in the Swift repo and linked from the cross-platform Workflow docs. For info on how to generate the Swift docs locally, check out the workflow-swift repo .","title":"Swift: DocC"},{"location":"RELEASING/#mkdocs","text":"Mkdocs is written in Python, so you\u2019ll need Python 3 and pip in order to run it. Assuming those are set up, run: pip install -r requirements.txt Generate the site manually with: mkdocs build While you\u2019re working on the documentation files, you can run the site locally with: mkdocs serve","title":"mkdocs"},{"location":"RELEASING/#deploying-the-website-to-production","text":"Note: The documentation site is automatically built and deployed by a Github Workflow whenever a version tag is pushed. You only need these steps if you want to publish the site manually. Before deploying the website for real, you need to export our Google Analytics key in an environment variable so that it will get added to the HTML. Get the key from one of the project maintainers, then add the following to your .bashrc and re-source it: export WORKFLOW_GOOGLE_ANALYTICS_KEY = UA-__________-1 Now you\u2019re ready to publish the site! Just choose a tag or SHA to deploy from, and run: ./deploy_website.sh TAG_OR_SHA # For example: #./deploy_website.sh v0.18.0 This will clone the repo to a temporary directory, checkout the right SHA, build Kotlin and Swift API docs, generate HTML, and push the newly-generated content to the gh-pages branch on GitHub.","title":"Deploying the website to production"},{"location":"RELEASING/#validating-markdown","text":"Since all of our high-level documentation is written in Markdown, we run a linter in CI to ensure we use consistent formatting. Lint errors will fail your PR builds, so to run locally, install markdownlint : gem install mdl Run the linter using the lint_docs.sh : ./lint_docs.sh Rules can be configured by editing .markdownlint.rb .","title":"Validating Markdown"},{"location":"RELEASING/#kotlin-notes","text":"","title":"Kotlin Notes"},{"location":"RELEASING/#development","text":"To build and install the current version to your local Maven repository ( ~/.m2 ), run: ./gradlew clean installArchives","title":"Development"},{"location":"RELEASING/#deploying","text":"","title":"Deploying"},{"location":"RELEASING/#configuration","text":"In order to deploy artifacts to a Maven repository, you\u2019ll need to set 4 properties in your private Gradle properties file ( ~/.gradle/gradle.properties ): RELEASE_REPOSITORY_URL=<url of release repository> SNAPSHOT_REPOSITORY_URL=<url of snapshot repository SONATYPE_NEXUS_USERNAME=<username> SONATYPE_NEXUS_PASSWORD=<password>","title":"Configuration"},{"location":"RELEASING/#snapshot-releases","text":"Double-check that gradle.properties correctly contains the -SNAPSHOT suffix, then upload snapshot artifacts to Sonatype just like you would for a production release: ./gradlew clean build && ./gradlew uploadArchives --no-parallel --no-daemon You can verify the artifacts are available by visiting https://oss.sonatype.org/content/repositories/snapshots/com/squareup/workflow/ .","title":"Snapshot Releases"},{"location":"code-recipes/","text":"Code Receipes \u00b6 Coming soon!","title":"Code Receipes"},{"location":"code-recipes/#code-receipes","text":"Coming soon!","title":"Code Receipes"},{"location":"development-process/","text":"Development Process \u00b6 Coming soon!","title":"Development Process"},{"location":"development-process/#development-process","text":"Coming soon!","title":"Development Process"},{"location":"faq/","text":"Frequently Asked Questions \u00b6 Why do we need another architecture? \u00b6 We ask this question too! So we wrote a longer answer for it: \u201cWhy Workflow?\u201d . How do I get involved and/or contribute? \u00b6 Workflow is open source! See our CONTRIBUTING doc to get started. Stay tuned! We\u2019re considering hosting a public Slack channel for open source contributors. Isn\u2019t this basically React/Elm? \u00b6 React and the Elm architecture were both strong influences for this library. However both those libraries are written for JavaScript. Workflows are written in and for both Kotlin and Swift, making use of features of those languages, and with usability from those languages as a major design goal. There are some architectural differences which we can see briefly in the following table: React Elm Workflow Modularity Component Module s for code organization, but not \u2018composable\u2019 in the same way. A Workflow is analogous to React\u2019s Component State Each Component has a state property that is read directly and updated via a setState method. State is called Model in Elm. Workflow s have an associated state type. The state can only be updated when the props change, or with a WorkflowAction . Views Component s have a render method that returns a tree of elements. Elm applications have a view function that returns a tree of elements. Since workflows are not tied to any particular UI view layer, they can have an arbitrary rendering type. The render() method returns this type. Injected Dependencies React allows parent components to pass \u201cprops\u201d down to their children. N/A In Swift, Workflow s are often structs that need to be initialized with their dependencies and configuration data from their parent. In Kotlin, they have a separate type parameter ( PropsT ) that is always passed down from the parent. Workflow instances can also inject dependencies, and play nicely with dependency injection frameworks. Composability Component s are composed of other Component s. N/A Workflow s can have children; they control their lifecycle and can choose to incorporate child renderings into their own. Event Handling DOM event listeners are hooked up to functions on the Component . The update function takes a Msg to modify state based on events. action can be sent to the Sink to update State . How is this different than MvRx? \u00b6 Besides being very Android and Rx specific, MvRx solves view modeling problems only per screen. Workflow was mainly inspired by the need to manage and compose navigation in apps with dozens or hundreds of screens. This seems clever. Can I stick with a traditional development approach? \u00b6 Of course! Workflow was designed to make complex application architecture predictable and safe for large development teams. We\u2019re confident that it brings benefits even to smaller projects, but there is never only one right way to build software. We recommend to follow good practices and use an architecture that makes sense for your project .","title":"FAQ"},{"location":"faq/#frequently-asked-questions","text":"","title":"Frequently Asked Questions"},{"location":"faq/#why-do-we-need-another-architecture","text":"We ask this question too! So we wrote a longer answer for it: \u201cWhy Workflow?\u201d .","title":"Why do we need another architecture?"},{"location":"faq/#how-do-i-get-involved-andor-contribute","text":"Workflow is open source! See our CONTRIBUTING doc to get started. Stay tuned! We\u2019re considering hosting a public Slack channel for open source contributors.","title":"How do I get involved and/or contribute?"},{"location":"faq/#isnt-this-basically-reactelm","text":"React and the Elm architecture were both strong influences for this library. However both those libraries are written for JavaScript. Workflows are written in and for both Kotlin and Swift, making use of features of those languages, and with usability from those languages as a major design goal. There are some architectural differences which we can see briefly in the following table: React Elm Workflow Modularity Component Module s for code organization, but not \u2018composable\u2019 in the same way. A Workflow is analogous to React\u2019s Component State Each Component has a state property that is read directly and updated via a setState method. State is called Model in Elm. Workflow s have an associated state type. The state can only be updated when the props change, or with a WorkflowAction . Views Component s have a render method that returns a tree of elements. Elm applications have a view function that returns a tree of elements. Since workflows are not tied to any particular UI view layer, they can have an arbitrary rendering type. The render() method returns this type. Injected Dependencies React allows parent components to pass \u201cprops\u201d down to their children. N/A In Swift, Workflow s are often structs that need to be initialized with their dependencies and configuration data from their parent. In Kotlin, they have a separate type parameter ( PropsT ) that is always passed down from the parent. Workflow instances can also inject dependencies, and play nicely with dependency injection frameworks. Composability Component s are composed of other Component s. N/A Workflow s can have children; they control their lifecycle and can choose to incorporate child renderings into their own. Event Handling DOM event listeners are hooked up to functions on the Component . The update function takes a Msg to modify state based on events. action can be sent to the Sink to update State .","title":"Isn&rsquo;t this basically React/Elm?"},{"location":"faq/#how-is-this-different-than-mvrx","text":"Besides being very Android and Rx specific, MvRx solves view modeling problems only per screen. Workflow was mainly inspired by the need to manage and compose navigation in apps with dozens or hundreds of screens.","title":"How is this different than MvRx?"},{"location":"faq/#this-seems-clever-can-i-stick-with-a-traditional-development-approach","text":"Of course! Workflow was designed to make complex application architecture predictable and safe for large development teams. We\u2019re confident that it brings benefits even to smaller projects, but there is never only one right way to build software. We recommend to follow good practices and use an architecture that makes sense for your project .","title":"This seems clever. Can I stick with a traditional development approach?"},{"location":"glossary/","text":"Glossary of Terms \u00b6 Reactive Programming \u00b6 A style of programming where data or events are pushed to the logic processing them rather than having the logic pull the data and events from a source. A representation of program logic as a series of operations on a stream of data that is performed while a subscription to that stream is active. Unidirectional Data Flow \u00b6 Data travels a single path from business logic to UI, and travels the entirety of that path in a single direction. Events travel a single path from UI to business logic and they travel the entirety of that path in a single direction. There are thus two sets of directed edges in the graph that are handled separately and neither set has any cycles or back edges on its own. Declarative Programming \u00b6 A declarative program declares the state it wants the system to be in rather than how that is accomplished. Imperative Programming \u00b6 An imperative program\u2019s code is a series of statements that directly change a program\u2019s state as a result of certain events. State Machine \u00b6 An abstraction that models a program\u2019s logic as a graph of a set of states and the transitions between them (edges). See: en.wikipedia.org/wiki/Finite-state_machine Idempotent \u00b6 A function whose side effects won\u2019t be repeated with multiple invocations, the result is purely a function of the input. In other words, if called multiple times with the same input, the result is the same. For Workflows, the render() function must be idempotent, as the runtime offers no guarantees for how many times it may be called. Workflow Runtime \u00b6 An event loop that executes a Workflow Tree. On each pass: A Rendering is assembled by calling render() on each Node of the Workflow Tree with each parent Workflow given the option to incorporate the Renderings of its children into its own. The event loop waits for an Action to be sent to the Sink. This Action provides a (possibly updated) State for the Workflow that created it and possibly an Output. Any Output emitted is processed in turn by an Action defined by the updated Workflow\u2019s parent again possibly updating its State and emitting an Output cascading up the hierarchy. A new render() pass is made against the entire Workflow Tree with the updated States. We use the term Workflow Runtime to refer to the core code in the framework that executes this event loop, responding to Actions and invoking render() . Workflow (Instance) \u00b6 An object that defines the transitions and side effects of a state machine as, effectively, two functions: Providing the first state: (Props) -> State Providing a rendering: (Props and State) -> (Rendering and Side Effect Invocations and Child Workflow Invocations) The Child Workflow Invocations declared by the render function result in calls to the children\u2019s render() functions in turn, allowing the parent render function to choose to incorporate child Rendering values into its own. A Workflow is not itself a state machine, and ideally has no state of its own. It is rather a schema that identifies a particular type of state machine that can be started in initialState() by the Workflow Runtime, and advanced by repeated invocations of render() . Note: there is significant fuzziness in using the term \u2018Workflow\u2019, as it can mean at times the class/struct that declares the Workflow behavior as well as the object representing the running Workflow Node. To understand the Runtime behavior, grasping this distinction is necessary and valuable. When using a Workflow, the formal distinction is less valuable than the mental model of how a Workflow will be run. Workflow (Node) \u00b6 An active state machine whose behavior is defined by a Workflow Instance. This is the object that is held by the Workflow Runtime and whose state is updated (or \u201cdriven\u201d) according to the behavior declared in the Workflow Instance. In Kotlin and Swift a Workflow Node is implemented with the private WorkflowNode class/struct. Workflow Lifecycle \u00b6 Every Workflow or Side Effect Node has a lifecycle that is determined by its parent. In the case of the root Workflow, this lifecycle is determined by how long the host of the root chooses to use the stream of Renderings from the root Workflow. In the case of a non-root Workflow or Side Effect \u2014 that is, in the case of a Child \u2014 its lifecycle is determined as follows: Start: the first time its parent invokes the Child in the parent\u2019s own render() pass. End: the first subsequent render() pass that does not invoke the Child. Note that in between Start and End, the Workflow, or Side Effect is not \u201cre-invoked\u201d in the sense of starting again with each render() pass, but rather the originally invoked instance continues to run until a render() call is made without invoking it. Workflow Tree \u00b6 The tree of Workflow Nodes sharing a root. Workflow Nodes can have children and form a hierarchy. Workflow Root \u00b6 The root of a Workflow Tree. This is owned by a host which starts the Workflow Runtime with a particular Workflow instance. RenderContext \u00b6 The object which provides access to the Workflow Runtime from a Workflow render method. Provides three services: a Sink for accepting WorkflowActions recursively rendering Workflow children executing Side Effects Render Pass \u00b6 The portion of the Workflow Runtime event loop which traverses the Workflow tree, calling render() on each Workflow Node. When the RenderContext Sink receives an Action an Action Cascade occurs and at the completion of the Action Cascade the Render Pass occurs. Output Event \u00b6 When a Child Workflow emits an Output value, this is an Output Event. Handlers are registered when a Child Workflow is invoked to transform the child\u2019s Output values to Actions, which can advance the state of the parent. UI Event \u00b6 Any occurrence in the UI of a program \u2014 e.g. click, drag, keypress \u2014 the listener for which has been connected to a callback in the Rendering of a Workflow. UI Event callbacks typically add Actions to the Sink, to advance the state of the Workflow. Action \u00b6 A type associated with a particular Workflow (Instance) that is responsible for transforming a given State into a new State and optionally emitting an Output. Actions are sent to the Sink to be processed by the Workflow Runtime. Action Cascade \u00b6 When an event occurs and the handler provides an Action, this Action may possibly produce an Output for the parent Workflow which in turn has its own handler provide an Action that may produce an Output and onwards up the Workflow Tree. This is an Action Cascade. Sink \u00b6 The handle provided by the RenderContext to send Actions to the Workflow Runtime. These Actions are applied by the Workflow Runtime to advance a Workflow\u2019s State, and optionally produce an Output to be processed by the handler its parent registered. Props \u00b6 The set of input properties for a particular Workflow. This is the public state which is provided to a child Workflow by its parent, or to the root Workflow by its host. For Swift: The set of properties on the struct implementing the Workflow. For Kotlin: Parameter type PropsT in the Workflow signature. In Kotlin there is a formal distinction between Props and other dependencies, typically provided as constructor parameters. State \u00b6 The type of the internal state of a Workflow implementation. \u201cImmutable\u201d State \u00b6 The State object itself is immutable, in other words, its property values cannot be changed. What this means for Workflows is that the Workflow Runtime holds a canonical instance of the internal State of each Workflow. A Workflow\u2019s state is \u201cadvanced\u201d when that canonical instance is atomically replaced by one returned when an Action is invoked. State can only be mutated through WorkflowAction which will trigger a re-render. There are a number of benefits to keeping State immutable in this way: Reasoning about and debugging the Workflow is easier because, for any given State, there is a deterministic Rendering and the State cannot change except as a new parameter value to the render() method. This assists in making render() idempotent as the State will not be modified in the course of the execution of that function. Note that this immutability can be enforced only by convention. It is possible to cheat, but that is strongly discouraged. Rendering \u00b6 The externally available public representation of the state of a Workflow. It may include event handling functions. It is given a concrete type in the Workflow signature. Note that this \u201cRendering\u201d does not have to represent the UI of a program. The \u201cRendering\u201d is simply the published state of the Workflow, and could simply be data. Often that data is used to render UI, but it can be used in other ways \u2014 for example, as the implementation of a service API. Output \u00b6 The type of the object that can optionally be delivered to the Workflow\u2019s parent or the host of the root Workflow by an Action. Child Workflow \u00b6 A Workflow which has a parent. A parent may compose a child Workflow\u2019s Rendering into its own. Side Effect \u00b6 From render() , runningSideEffect() can be called with a given key and a function that will be called once by the Workflow Runtime. For Swift, a Lifetime object is also passed to runningSideEffect() which has an onEnded() closure that can be used for cleanup. For Kotlin, a coroutine scope is used to execute the function so it can be cancelled() at cleanup time. Given that any property (including the Sink) could be captured by the closure of the Side Effect this is the basic building block that can be used to interact with asynchronous (and often imperative) Workflow Children. Worker \u00b6 A Child Workflow that provides only output, with no rendering \u2014 a pattern for doing asynchronous work in Workflows. For Kotlin, this is an actual Interface which provides a convenient way to specify asynchronous work that produces an Output and a handler for that Output which can provide an Action. There are Kotlin extensions to map Rx Observables and Kotlin Flows to create Worker implementations. For Swift, there are at least 3 different Worker types which are convenience wrappers around reactive APIs that facilitate performing work. View \u00b6 A class or function managing a 2d box in a graphical user interface system, able to paint a defined region of the display and respond to user input events within its bounds. Views are arranged in a hierarchical tree, with parents able to lay out children and manage their painting and event handling. Instances supported by Workflow are: For Kotlin: Classic Android: class android.view.View Android JetPack Compose: @Composable fun Box() For Swift: class NSViewController Screen \u00b6 An interface / protocol identifying Renderings that model a View. Workflow UI libraries can map a given Screen type to a View instance that can display a series of such Screens. In Kotlin, Screen is a marker interface. Each type S : Screen is mapped by the Android UI library to a ScreenViewFactory&lt;S> that is able to: create instances of android.view.View or provide a @Composable fun Content(S) function to be called from a Box {} context. Note that the Android UI support is able to interleave Screens bound to View or @Composable seamlessly. In Swift, the Screen protocol defines a single function creating ViewControllerDescription instances, objects which create and update ViewController instances to display Screens of the corresponding type. Overlay (Kotlin only) \u00b6 An interface identifying Renderings that model a plane covering a base Screen, possibly hosting another Screen \u2014 \u201ccovering\u201d in that they have a higher z-index, for visibility and event-handling. In Kotlin, Overlay is a marker interface. Each type O : Overlay is mapped by the Android UI library to an OverlayDialogFactory&lt;O> able to create and update instances of android.app.Dialog Container Screen \u00b6 A design pattern, describing a Screen type whose instances wrap one or more other Screens, commonly to either annotate those Screens or define the relationships between them. Wrapping one Screen in another does not necessarily imply that the derived View hierarchy will change. It is common for the Kotlin ScreenViewFactory or Swift ViewControllerDescription bound to a Container Screen to delegate its construction and updating work to those of the wrapped Screens. Container View \u00b6 A View able to host children that are driven by Screen renderings. A Container View is generally driven by Container Screens of a specific type \u2014 e.g., a BackStackContainer View that can display BackStackScreen values. The exception is a root Container View, which is able to display a series of Screen instances of any type. For Kotlin, the root Container Views are WorkflowLayout : FrameLayout , and @Composable Workflow.renderAsState() . Custom Container Views written to display custom Container Screens can use WorkflowViewStub : FrameLayout or @Composable fun WorkflowRendering() to display wrapped Screens. For Swift, the root Container View is ContainerViewController . Custom Container Views written to render custom Container Screens can be built as subclasses of ScreenViewController , and use DescribedViewController to display wrapped Screens. ViewEnvironment \u00b6 A read-only key/value map passed from a Container View down to its children at update time, similar in spirit to Swift UI EnvironmentValues and Jetpack CompositionLocal . Like them, the ViewEnvironment is primarily intended to allow parents to offer children hints about the context in which they are being displayed \u2014 for example, to allow a child to know if it is a member of a back stack, and so decide whether or not to display a Go Back button. The ViewEnvironment also can be used judiciously as a service provider for UI-specific concerns, like image loaders \u2014 tread carefully.","title":"Glossary"},{"location":"glossary/#glossary-of-terms","text":"","title":"Glossary of Terms"},{"location":"glossary/#reactive-programming","text":"A style of programming where data or events are pushed to the logic processing them rather than having the logic pull the data and events from a source. A representation of program logic as a series of operations on a stream of data that is performed while a subscription to that stream is active.","title":"Reactive Programming"},{"location":"glossary/#unidirectional-data-flow","text":"Data travels a single path from business logic to UI, and travels the entirety of that path in a single direction. Events travel a single path from UI to business logic and they travel the entirety of that path in a single direction. There are thus two sets of directed edges in the graph that are handled separately and neither set has any cycles or back edges on its own.","title":"Unidirectional Data Flow"},{"location":"glossary/#declarative-programming","text":"A declarative program declares the state it wants the system to be in rather than how that is accomplished.","title":"Declarative Programming"},{"location":"glossary/#imperative-programming","text":"An imperative program\u2019s code is a series of statements that directly change a program\u2019s state as a result of certain events.","title":"Imperative Programming"},{"location":"glossary/#state-machine","text":"An abstraction that models a program\u2019s logic as a graph of a set of states and the transitions between them (edges). See: en.wikipedia.org/wiki/Finite-state_machine","title":"State Machine"},{"location":"glossary/#idempotent","text":"A function whose side effects won\u2019t be repeated with multiple invocations, the result is purely a function of the input. In other words, if called multiple times with the same input, the result is the same. For Workflows, the render() function must be idempotent, as the runtime offers no guarantees for how many times it may be called.","title":"Idempotent"},{"location":"glossary/#workflow-runtime","text":"An event loop that executes a Workflow Tree. On each pass: A Rendering is assembled by calling render() on each Node of the Workflow Tree with each parent Workflow given the option to incorporate the Renderings of its children into its own. The event loop waits for an Action to be sent to the Sink. This Action provides a (possibly updated) State for the Workflow that created it and possibly an Output. Any Output emitted is processed in turn by an Action defined by the updated Workflow\u2019s parent again possibly updating its State and emitting an Output cascading up the hierarchy. A new render() pass is made against the entire Workflow Tree with the updated States. We use the term Workflow Runtime to refer to the core code in the framework that executes this event loop, responding to Actions and invoking render() .","title":"Workflow Runtime"},{"location":"glossary/#workflow-instance","text":"An object that defines the transitions and side effects of a state machine as, effectively, two functions: Providing the first state: (Props) -> State Providing a rendering: (Props and State) -> (Rendering and Side Effect Invocations and Child Workflow Invocations) The Child Workflow Invocations declared by the render function result in calls to the children\u2019s render() functions in turn, allowing the parent render function to choose to incorporate child Rendering values into its own. A Workflow is not itself a state machine, and ideally has no state of its own. It is rather a schema that identifies a particular type of state machine that can be started in initialState() by the Workflow Runtime, and advanced by repeated invocations of render() . Note: there is significant fuzziness in using the term \u2018Workflow\u2019, as it can mean at times the class/struct that declares the Workflow behavior as well as the object representing the running Workflow Node. To understand the Runtime behavior, grasping this distinction is necessary and valuable. When using a Workflow, the formal distinction is less valuable than the mental model of how a Workflow will be run.","title":"Workflow (Instance)"},{"location":"glossary/#workflow-node","text":"An active state machine whose behavior is defined by a Workflow Instance. This is the object that is held by the Workflow Runtime and whose state is updated (or \u201cdriven\u201d) according to the behavior declared in the Workflow Instance. In Kotlin and Swift a Workflow Node is implemented with the private WorkflowNode class/struct.","title":"Workflow (Node)"},{"location":"glossary/#workflow-lifecycle","text":"Every Workflow or Side Effect Node has a lifecycle that is determined by its parent. In the case of the root Workflow, this lifecycle is determined by how long the host of the root chooses to use the stream of Renderings from the root Workflow. In the case of a non-root Workflow or Side Effect \u2014 that is, in the case of a Child \u2014 its lifecycle is determined as follows: Start: the first time its parent invokes the Child in the parent\u2019s own render() pass. End: the first subsequent render() pass that does not invoke the Child. Note that in between Start and End, the Workflow, or Side Effect is not \u201cre-invoked\u201d in the sense of starting again with each render() pass, but rather the originally invoked instance continues to run until a render() call is made without invoking it.","title":"Workflow Lifecycle"},{"location":"glossary/#workflow-tree","text":"The tree of Workflow Nodes sharing a root. Workflow Nodes can have children and form a hierarchy.","title":"Workflow Tree"},{"location":"glossary/#workflow-root","text":"The root of a Workflow Tree. This is owned by a host which starts the Workflow Runtime with a particular Workflow instance.","title":"Workflow Root"},{"location":"glossary/#rendercontext","text":"The object which provides access to the Workflow Runtime from a Workflow render method. Provides three services: a Sink for accepting WorkflowActions recursively rendering Workflow children executing Side Effects","title":"RenderContext"},{"location":"glossary/#render-pass","text":"The portion of the Workflow Runtime event loop which traverses the Workflow tree, calling render() on each Workflow Node. When the RenderContext Sink receives an Action an Action Cascade occurs and at the completion of the Action Cascade the Render Pass occurs.","title":"Render Pass"},{"location":"glossary/#output-event","text":"When a Child Workflow emits an Output value, this is an Output Event. Handlers are registered when a Child Workflow is invoked to transform the child\u2019s Output values to Actions, which can advance the state of the parent.","title":"Output Event"},{"location":"glossary/#ui-event","text":"Any occurrence in the UI of a program \u2014 e.g. click, drag, keypress \u2014 the listener for which has been connected to a callback in the Rendering of a Workflow. UI Event callbacks typically add Actions to the Sink, to advance the state of the Workflow.","title":"UI Event"},{"location":"glossary/#action","text":"A type associated with a particular Workflow (Instance) that is responsible for transforming a given State into a new State and optionally emitting an Output. Actions are sent to the Sink to be processed by the Workflow Runtime.","title":"Action"},{"location":"glossary/#action-cascade","text":"When an event occurs and the handler provides an Action, this Action may possibly produce an Output for the parent Workflow which in turn has its own handler provide an Action that may produce an Output and onwards up the Workflow Tree. This is an Action Cascade.","title":"Action Cascade"},{"location":"glossary/#sink","text":"The handle provided by the RenderContext to send Actions to the Workflow Runtime. These Actions are applied by the Workflow Runtime to advance a Workflow\u2019s State, and optionally produce an Output to be processed by the handler its parent registered.","title":"Sink"},{"location":"glossary/#props","text":"The set of input properties for a particular Workflow. This is the public state which is provided to a child Workflow by its parent, or to the root Workflow by its host. For Swift: The set of properties on the struct implementing the Workflow. For Kotlin: Parameter type PropsT in the Workflow signature. In Kotlin there is a formal distinction between Props and other dependencies, typically provided as constructor parameters.","title":"Props"},{"location":"glossary/#state","text":"The type of the internal state of a Workflow implementation.","title":"State"},{"location":"glossary/#immutable-state","text":"The State object itself is immutable, in other words, its property values cannot be changed. What this means for Workflows is that the Workflow Runtime holds a canonical instance of the internal State of each Workflow. A Workflow\u2019s state is \u201cadvanced\u201d when that canonical instance is atomically replaced by one returned when an Action is invoked. State can only be mutated through WorkflowAction which will trigger a re-render. There are a number of benefits to keeping State immutable in this way: Reasoning about and debugging the Workflow is easier because, for any given State, there is a deterministic Rendering and the State cannot change except as a new parameter value to the render() method. This assists in making render() idempotent as the State will not be modified in the course of the execution of that function. Note that this immutability can be enforced only by convention. It is possible to cheat, but that is strongly discouraged.","title":"&ldquo;Immutable&rdquo; State"},{"location":"glossary/#rendering","text":"The externally available public representation of the state of a Workflow. It may include event handling functions. It is given a concrete type in the Workflow signature. Note that this \u201cRendering\u201d does not have to represent the UI of a program. The \u201cRendering\u201d is simply the published state of the Workflow, and could simply be data. Often that data is used to render UI, but it can be used in other ways \u2014 for example, as the implementation of a service API.","title":"Rendering"},{"location":"glossary/#output","text":"The type of the object that can optionally be delivered to the Workflow\u2019s parent or the host of the root Workflow by an Action.","title":"Output"},{"location":"glossary/#child-workflow","text":"A Workflow which has a parent. A parent may compose a child Workflow\u2019s Rendering into its own.","title":"Child Workflow"},{"location":"glossary/#side-effect","text":"From render() , runningSideEffect() can be called with a given key and a function that will be called once by the Workflow Runtime. For Swift, a Lifetime object is also passed to runningSideEffect() which has an onEnded() closure that can be used for cleanup. For Kotlin, a coroutine scope is used to execute the function so it can be cancelled() at cleanup time. Given that any property (including the Sink) could be captured by the closure of the Side Effect this is the basic building block that can be used to interact with asynchronous (and often imperative) Workflow Children.","title":"Side Effect"},{"location":"glossary/#worker","text":"A Child Workflow that provides only output, with no rendering \u2014 a pattern for doing asynchronous work in Workflows. For Kotlin, this is an actual Interface which provides a convenient way to specify asynchronous work that produces an Output and a handler for that Output which can provide an Action. There are Kotlin extensions to map Rx Observables and Kotlin Flows to create Worker implementations. For Swift, there are at least 3 different Worker types which are convenience wrappers around reactive APIs that facilitate performing work.","title":"Worker"},{"location":"glossary/#view","text":"A class or function managing a 2d box in a graphical user interface system, able to paint a defined region of the display and respond to user input events within its bounds. Views are arranged in a hierarchical tree, with parents able to lay out children and manage their painting and event handling. Instances supported by Workflow are: For Kotlin: Classic Android: class android.view.View Android JetPack Compose: @Composable fun Box() For Swift: class NSViewController","title":"View"},{"location":"glossary/#screen","text":"An interface / protocol identifying Renderings that model a View. Workflow UI libraries can map a given Screen type to a View instance that can display a series of such Screens. In Kotlin, Screen is a marker interface. Each type S : Screen is mapped by the Android UI library to a ScreenViewFactory&lt;S> that is able to: create instances of android.view.View or provide a @Composable fun Content(S) function to be called from a Box {} context. Note that the Android UI support is able to interleave Screens bound to View or @Composable seamlessly. In Swift, the Screen protocol defines a single function creating ViewControllerDescription instances, objects which create and update ViewController instances to display Screens of the corresponding type.","title":"Screen"},{"location":"glossary/#overlay-kotlin-only","text":"An interface identifying Renderings that model a plane covering a base Screen, possibly hosting another Screen \u2014 \u201ccovering\u201d in that they have a higher z-index, for visibility and event-handling. In Kotlin, Overlay is a marker interface. Each type O : Overlay is mapped by the Android UI library to an OverlayDialogFactory&lt;O> able to create and update instances of android.app.Dialog","title":"Overlay (Kotlin only)"},{"location":"glossary/#container-screen","text":"A design pattern, describing a Screen type whose instances wrap one or more other Screens, commonly to either annotate those Screens or define the relationships between them. Wrapping one Screen in another does not necessarily imply that the derived View hierarchy will change. It is common for the Kotlin ScreenViewFactory or Swift ViewControllerDescription bound to a Container Screen to delegate its construction and updating work to those of the wrapped Screens.","title":"Container Screen"},{"location":"glossary/#container-view","text":"A View able to host children that are driven by Screen renderings. A Container View is generally driven by Container Screens of a specific type \u2014 e.g., a BackStackContainer View that can display BackStackScreen values. The exception is a root Container View, which is able to display a series of Screen instances of any type. For Kotlin, the root Container Views are WorkflowLayout : FrameLayout , and @Composable Workflow.renderAsState() . Custom Container Views written to display custom Container Screens can use WorkflowViewStub : FrameLayout or @Composable fun WorkflowRendering() to display wrapped Screens. For Swift, the root Container View is ContainerViewController . Custom Container Views written to render custom Container Screens can be built as subclasses of ScreenViewController , and use DescribedViewController to display wrapped Screens.","title":"Container View"},{"location":"glossary/#viewenvironment","text":"A read-only key/value map passed from a Container View down to its children at update time, similar in spirit to Swift UI EnvironmentValues and Jetpack CompositionLocal . Like them, the ViewEnvironment is primarily intended to allow parents to offer children hints about the context in which they are being displayed \u2014 for example, to allow a child to know if it is a member of a back stack, and so decide whether or not to display a Go Back button. The ViewEnvironment also can be used judiciously as a service provider for UI-specific concerns, like image loaders \u2014 tread carefully.","title":"ViewEnvironment"},{"location":"historical/","text":"Pre-1.0 Presentations and Resources \u00b6 Square Workflow \u2013 Droidcon NYC 2019 ( slides ) SF Android GDG @ Square 2019 - Hello Workflow (live coding) Android Dialogs 5-part Coding Series 1 , 2 , 3 , 4 , 5 Reactive Workflows a Year Later \u2013 Droidcon NYC 2018 The Reactive Workflow Pattern \u2013 Fragmented Podcast The Reactive Workflow Pattern Update \u2013 Droidcon SF 2017 The Rx Workflow Pattern \u2013 Droidcon NYC 2017 ( slides )","title":"Pre-1.0 Resources"},{"location":"historical/#pre-10-presentations-and-resources","text":"Square Workflow \u2013 Droidcon NYC 2019 ( slides ) SF Android GDG @ Square 2019 - Hello Workflow (live coding) Android Dialogs 5-part Coding Series 1 , 2 , 3 , 4 , 5 Reactive Workflows a Year Later \u2013 Droidcon NYC 2018 The Reactive Workflow Pattern \u2013 Fragmented Podcast The Reactive Workflow Pattern Update \u2013 Droidcon SF 2017 The Rx Workflow Pattern \u2013 Droidcon NYC 2017 ( slides )","title":"Pre-1.0 Presentations and Resources"},{"location":"sequence_diagrams/","text":"Sequence Diagrams \u00b6 These are the source files used to generate the sequence diagrams via WebSequenceDiagrams .","title":"Sequence Diagrams"},{"location":"sequence_diagrams/#sequence-diagrams","text":"These are the source files used to generate the sequence diagrams via WebSequenceDiagrams .","title":"Sequence Diagrams"},{"location":"userguide/common-patterns/","text":"Common Patterns \u00b6 There are a lot associated/generic types in workflow code \u2013 that doesn\u2019t mean you always need to use all of them. Here are some common configurations we\u2019ve seen. Stateless Workflows \u00b6 Remember that workflow state is made up of public and private parts. When a workflow\u2019s state consists entirely of public state (i.e. it\u2019s initializer arguments in Swift or PropsT in Kotlin), it can ignore all the machinery for private state. In Swift, the State type can be Void , and in Kotlin it can be Unit \u2013 such workflows are often referred to as \u201cstateless\u201d, since they have no state of their own. Props-less Workflows \u00b6 Some workflows manage all of their state internally, and have no public state (aka props). In Swift, this just means the workflow implementation has no parameters (although this is rare, see Injecting Dependencies below). In Kotlin, the PropsT type can be Unit . RenderContext has convenience overloads of most of its functions to implicitly pass Unit for these workflows. Outputless Workflows \u00b6 Workflows that only talk to their parent via their Rendering , and never emit any output, are encouraged to indicate that by using the bottom type as their Output type. In addition to documenting the fact that the workflow will never output, using the bottom type also lets the compiler enforce it \u2013 code that tries to emit outputs will not compile. In Swift, the Output type is specified as Never . In Kotlin, use Nothing . Composite Workflows \u00b6 Composition is a powerful tool for working with Workflows. A workflow can often accomplish a lot simply by rendering various children. It may just combine the renderings of multiple children, or use its props to determine which of a set of children to render. Such workflows can often be stateless. One-and-done Workflows (RenderingT v. OutputT) \u00b6 A common question is \u201cwhy can\u2019t I emit output from initialState ,\u201d or \u201cwhat if my Workflow realizes it doesn\u2019t actually need to run? The most efficient, and most expressive, way to handle this is to use an optional or conditional Rendering type, and an Output of Never / Nothing . Imagine a PromptForPermissionMaybeWorkflow , that renders a UI to get a passcode, but only if that permission has not already been granted. If you make its RenderingT nullable (e.g. Screen? ), it can return null to indicate that its job is done. Its callers will be synchronously informed that the coast is clear, and can immediately render what they actually care about. Another variation of this pattern is to use a sealed class / enum type for Rendering , with a Working type that implements Screen , and a unviewable Finished type that carries the work product. A good rule of thumb for choosing between using Rendering or Output is to remember that Output is event-like, and is always asynchronous. A parent waiting for an output must be given something to render in the meantime. Using Rendering is a great idiom for a one-and-done workflow tasked with providing a single product, especially one that might be available instantly. Props values v. Injected Dependencies \u00b6 Dependency injection is a technique for making code less coupled and more testable. In short, it\u2019s better for classes/structs to accept their dependencies when they\u2019re created instead of hard-coding them. Workflows typically have dependencies like specific Workers they need to perform some tasks, child workflows to delegate rendering to, or helpers for things like network requests, formatting and logging. Swift \u00b6 A Swift workflow typically receives its dependencies as initializer arguments, just like its input values, and is normally instantiated anew by its parent in each call to the parent\u2019s render method. The factory pattern can be employed to keep knowledge of children\u2019s implementation details from leaking into their parents. Kotlin \u00b6 Kotlin workflows make a more formal distinction between dependencies and props, via the PropsT parameter type on the Kotlin Workflow interface. Dependencies (e.g. a network service) are typically provided as constructor parameters, while props values (e.g. a record locator) are provided by the parent as an argument to the RenderContext.renderChild method. This works seamlessly with DI libraries like Dagger . The careful reader will note that this is technically storing \u201cstate\u201d in the workflow instance \u2013 something that is generally discouraged. However, since this \u201cstate\u201d is never changed, we can make an exception for this case. If a workflow has properties, they should only be used to store injected dependencies or dependencies derived from injected ones (e.g. Worker s created from Observable s). Info This difference between Swift and Kotlin practices is a side effect of Kotlin\u2019s lack of a parallel to Swift\u2019s Self type. Kotlin has no practical way to provide a method like Swift\u2019s Workflow.workflowDidChange , which accepts a strongly typed reference to the instance from the previous run of a parent\u2019s Render method. Kotlin\u2019s alternative, StatefulWorkflow.onPropsChanged , requires the extra PropsT type parameter.","title":"Common Patterns"},{"location":"userguide/common-patterns/#common-patterns","text":"There are a lot associated/generic types in workflow code \u2013 that doesn\u2019t mean you always need to use all of them. Here are some common configurations we\u2019ve seen.","title":"Common Patterns"},{"location":"userguide/common-patterns/#stateless-workflows","text":"Remember that workflow state is made up of public and private parts. When a workflow\u2019s state consists entirely of public state (i.e. it\u2019s initializer arguments in Swift or PropsT in Kotlin), it can ignore all the machinery for private state. In Swift, the State type can be Void , and in Kotlin it can be Unit \u2013 such workflows are often referred to as \u201cstateless\u201d, since they have no state of their own.","title":"Stateless Workflows"},{"location":"userguide/common-patterns/#props-less-workflows","text":"Some workflows manage all of their state internally, and have no public state (aka props). In Swift, this just means the workflow implementation has no parameters (although this is rare, see Injecting Dependencies below). In Kotlin, the PropsT type can be Unit . RenderContext has convenience overloads of most of its functions to implicitly pass Unit for these workflows.","title":"Props-less Workflows"},{"location":"userguide/common-patterns/#outputless-workflows","text":"Workflows that only talk to their parent via their Rendering , and never emit any output, are encouraged to indicate that by using the bottom type as their Output type. In addition to documenting the fact that the workflow will never output, using the bottom type also lets the compiler enforce it \u2013 code that tries to emit outputs will not compile. In Swift, the Output type is specified as Never . In Kotlin, use Nothing .","title":"Outputless Workflows"},{"location":"userguide/common-patterns/#composite-workflows","text":"Composition is a powerful tool for working with Workflows. A workflow can often accomplish a lot simply by rendering various children. It may just combine the renderings of multiple children, or use its props to determine which of a set of children to render. Such workflows can often be stateless.","title":"Composite Workflows"},{"location":"userguide/common-patterns/#one-and-done-workflows-renderingt-v-outputt","text":"A common question is \u201cwhy can\u2019t I emit output from initialState ,\u201d or \u201cwhat if my Workflow realizes it doesn\u2019t actually need to run? The most efficient, and most expressive, way to handle this is to use an optional or conditional Rendering type, and an Output of Never / Nothing . Imagine a PromptForPermissionMaybeWorkflow , that renders a UI to get a passcode, but only if that permission has not already been granted. If you make its RenderingT nullable (e.g. Screen? ), it can return null to indicate that its job is done. Its callers will be synchronously informed that the coast is clear, and can immediately render what they actually care about. Another variation of this pattern is to use a sealed class / enum type for Rendering , with a Working type that implements Screen , and a unviewable Finished type that carries the work product. A good rule of thumb for choosing between using Rendering or Output is to remember that Output is event-like, and is always asynchronous. A parent waiting for an output must be given something to render in the meantime. Using Rendering is a great idiom for a one-and-done workflow tasked with providing a single product, especially one that might be available instantly.","title":"One-and-done Workflows (RenderingT v. OutputT)"},{"location":"userguide/common-patterns/#props-values-v-injected-dependencies","text":"Dependency injection is a technique for making code less coupled and more testable. In short, it\u2019s better for classes/structs to accept their dependencies when they\u2019re created instead of hard-coding them. Workflows typically have dependencies like specific Workers they need to perform some tasks, child workflows to delegate rendering to, or helpers for things like network requests, formatting and logging.","title":"Props values v. Injected Dependencies"},{"location":"userguide/common-patterns/#swift","text":"A Swift workflow typically receives its dependencies as initializer arguments, just like its input values, and is normally instantiated anew by its parent in each call to the parent\u2019s render method. The factory pattern can be employed to keep knowledge of children\u2019s implementation details from leaking into their parents.","title":"Swift"},{"location":"userguide/common-patterns/#kotlin","text":"Kotlin workflows make a more formal distinction between dependencies and props, via the PropsT parameter type on the Kotlin Workflow interface. Dependencies (e.g. a network service) are typically provided as constructor parameters, while props values (e.g. a record locator) are provided by the parent as an argument to the RenderContext.renderChild method. This works seamlessly with DI libraries like Dagger . The careful reader will note that this is technically storing \u201cstate\u201d in the workflow instance \u2013 something that is generally discouraged. However, since this \u201cstate\u201d is never changed, we can make an exception for this case. If a workflow has properties, they should only be used to store injected dependencies or dependencies derived from injected ones (e.g. Worker s created from Observable s). Info This difference between Swift and Kotlin practices is a side effect of Kotlin\u2019s lack of a parallel to Swift\u2019s Self type. Kotlin has no practical way to provide a method like Swift\u2019s Workflow.workflowDidChange , which accepts a strongly typed reference to the instance from the previous run of a parent\u2019s Render method. Kotlin\u2019s alternative, StatefulWorkflow.onPropsChanged , requires the extra PropsT type parameter.","title":"Kotlin"},{"location":"userguide/concepts/","text":"Workflow Core \u00b6 This page provides a high level overview of Workflow Core, the UI-agnostic Swift and Kotlin runtimes at the heart of the Workflow libraries. See Workflow UI to learn about the companion Android and iOS specific modules. What is a Workflow? \u00b6 A Workflow defines the possible states and behaviors of components of a particular type. The overall state of a Workflow has two parts: Props , configuration information provided by whatever is running the Workflow And the private State managed by the Workflow itself At any time, a Workflow can be asked to transform its current Props and State into a Rendering that is suitable for external consumption. A Rendering is typically a simple struct with display data, and event handler functions that can enqueue Workflow Actions \u2014 functions that update State, and which may at the same time emit Output events. For example, a Workflow running a simple game might be configured with a description of the participating Players as its Props, build GameScreen structs when asked to render, and emit a GameOver event as Output to signal that is finished. A workflow Rendering usually serves as a view model in iOS or Android apps, but that is not a requirement. Again, this page includes no details about how platform specific UI code is driven. See Workflow UI for that discussion. Note Readers with an Android background should note the lower case v and m of \u201cview model\u201d \u2014 this notion has nothing to do with Jetpack ViewModel . Composing Workflows \u00b6 Workflows run in a tree, with a single root Workflow declaring it has any number of children for a particular state, each of which can declare children of their own, and so on. The most common reason to compose Workflows this way is to build big view models (Renderings) out of small ones. For example, consider an overview / detail split screen, like an email app with a list of messages on the left, and the body of the selected message on the right. This could be modeled as a trio of Workflows: InboxWorkflow Expects a List<MessageId> as its Props Rendering is an InboxScreen , a struct with displayable information derived from its Props, and an onMessageSelected() function When onMessageSelected() is called, a WorkflowAction is executed which emits the given MessageId as Output Has no private State MessageWorkflow Requires a MessageId Props value to produce a MessageScreen Rendering Has no private State, and emits no Output EmailBrowserWorkflow State includes a List<MessageId> , and the selected MessageId Rendering is a SplitScreen view model, to be assembled from the renderings of the other two Workflows Accepts no Props, and emits no Output When EmailBrowserWorkflow is asked to provide its Rendering, it in turn asks for Renderings from its two children. It provides the List<MessageId> from its state as the Props for EmailInboxWorkflow and receives an InBoxScreen rendering in return. That InboxScreen becomes the left pane of a SplitScreen Rendering. For the SplitScreen \u2019s right pane, the browser Workflow provides the currently selected MessageId as input to EmailMessageWorkflow , to get a MessageScreen rendering. Note Note that the two children, EmailInboxWorkflow and EmailMessageWorkflow , have no knowledge of each other, nor of the context in which they are run. The InboxScreen rendering includes an onMessageSelected(MessageId) function. When that is called, EmailInboxWorkflow enqueues an Action function that emits the given MessageId as Output. EmailBrowserWorkflow receives that Output, and enqueues another Action that updates the selection: MessageId of its State accordingly. Whenever such a Workflow Action cascade fires, the root Workflow is asked for a new Rendering. Just as before, EmailBrowserWorkflow delegates to its two children for their Renderings, this time providing the new value of selection as the updated Props for MessageWorkflow . Why does Workflow work this way? \u00b6 Workflow was built to tame the composition and navigation challenges presented by Square\u2019s massive Android and iOS apps. It lets us write intricate, centralized, well tested code encapsulating the flow through literally hundreds of individual screens. These days we are able to see and shape the forest, despite all of the trees. We built it with two core design principals in mind: Unidirectional data flow is the best way to stay sane when building UI Declarative programming is the best way to define unidirectional data flows What does that actually mean? Unidirectional Data Flow \u00b6 There is a wealth of information on the web about Unidirectional Data Flow , but it very simply means that there is a single path along which data travel from your business logic to your UI, and events travel to your business logic from your UI, and they always and only travel in one direction along that path. For Workflow, this also implies that the UI is (almost) stateless, and that the interesting state for your app is centralized and not duplicated. In practice, this makes program flow much easier to reason about because anytime something happens in an app, it removes the questions of where the state came from that caused it, which components got which events, and which sequences of cause and effect actually occurred. It makes unit testing easier because state and events are explicit, and always live in the same place and flow through the same APIs, so unit tests only need to test state transitions, for the most part. Declarative vs Imperative \u00b6 Traditionally, most mobile code is \u201cimperative\u201d \u2013 it consists of instructions for how to build and display the UI. These instructions can include control flow like loops. Imperative code is usually stateful, state is usually sprinkled all over the place, and tends to care about instances and identity. When reading imperative code, you almost have to run an interpreter and keep all the pieces of state in your head to figure out what it does. Web UI is traditionally declarative \u2013 it describes what to render, and some aspects of how to render it (style), but doesn\u2019t say how to actually draw it. Declarative code is usually easier to read than imperative code. It describes what it produces, not how to generate it. Declarative code usually cares more about pure values than instance identities. However, since computers still need actual instructions at some point, declarative code requires something else, usually imperative, either a compiler or interpreter, to actually do something with it. Workflow code is written in regular Kotlin or Swift, which are both imperative languages, but the library encourages you to write your logic in a declarative and functional style. The library manages state and wiring up event handling for you, so the only code you need to write is code that is actually interesting for your particular problem. A note about functional programming Kotlin and Swift are not strictly functional programming languages, but both have features that allow you to write functional -style code. Functional code discourages side effects and is generally much easier to test than object-oriented code. Functional and declarative programming go very well together, and Workflow encourages you to write such code.","title":"Workflow Core"},{"location":"userguide/concepts/#workflow-core","text":"This page provides a high level overview of Workflow Core, the UI-agnostic Swift and Kotlin runtimes at the heart of the Workflow libraries. See Workflow UI to learn about the companion Android and iOS specific modules.","title":"Workflow Core"},{"location":"userguide/concepts/#what-is-a-workflow","text":"A Workflow defines the possible states and behaviors of components of a particular type. The overall state of a Workflow has two parts: Props , configuration information provided by whatever is running the Workflow And the private State managed by the Workflow itself At any time, a Workflow can be asked to transform its current Props and State into a Rendering that is suitable for external consumption. A Rendering is typically a simple struct with display data, and event handler functions that can enqueue Workflow Actions \u2014 functions that update State, and which may at the same time emit Output events. For example, a Workflow running a simple game might be configured with a description of the participating Players as its Props, build GameScreen structs when asked to render, and emit a GameOver event as Output to signal that is finished. A workflow Rendering usually serves as a view model in iOS or Android apps, but that is not a requirement. Again, this page includes no details about how platform specific UI code is driven. See Workflow UI for that discussion. Note Readers with an Android background should note the lower case v and m of \u201cview model\u201d \u2014 this notion has nothing to do with Jetpack ViewModel .","title":"What is a Workflow?"},{"location":"userguide/concepts/#composing-workflows","text":"Workflows run in a tree, with a single root Workflow declaring it has any number of children for a particular state, each of which can declare children of their own, and so on. The most common reason to compose Workflows this way is to build big view models (Renderings) out of small ones. For example, consider an overview / detail split screen, like an email app with a list of messages on the left, and the body of the selected message on the right. This could be modeled as a trio of Workflows: InboxWorkflow Expects a List<MessageId> as its Props Rendering is an InboxScreen , a struct with displayable information derived from its Props, and an onMessageSelected() function When onMessageSelected() is called, a WorkflowAction is executed which emits the given MessageId as Output Has no private State MessageWorkflow Requires a MessageId Props value to produce a MessageScreen Rendering Has no private State, and emits no Output EmailBrowserWorkflow State includes a List<MessageId> , and the selected MessageId Rendering is a SplitScreen view model, to be assembled from the renderings of the other two Workflows Accepts no Props, and emits no Output When EmailBrowserWorkflow is asked to provide its Rendering, it in turn asks for Renderings from its two children. It provides the List<MessageId> from its state as the Props for EmailInboxWorkflow and receives an InBoxScreen rendering in return. That InboxScreen becomes the left pane of a SplitScreen Rendering. For the SplitScreen \u2019s right pane, the browser Workflow provides the currently selected MessageId as input to EmailMessageWorkflow , to get a MessageScreen rendering. Note Note that the two children, EmailInboxWorkflow and EmailMessageWorkflow , have no knowledge of each other, nor of the context in which they are run. The InboxScreen rendering includes an onMessageSelected(MessageId) function. When that is called, EmailInboxWorkflow enqueues an Action function that emits the given MessageId as Output. EmailBrowserWorkflow receives that Output, and enqueues another Action that updates the selection: MessageId of its State accordingly. Whenever such a Workflow Action cascade fires, the root Workflow is asked for a new Rendering. Just as before, EmailBrowserWorkflow delegates to its two children for their Renderings, this time providing the new value of selection as the updated Props for MessageWorkflow .","title":"Composing Workflows"},{"location":"userguide/concepts/#why-does-workflow-work-this-way","text":"Workflow was built to tame the composition and navigation challenges presented by Square\u2019s massive Android and iOS apps. It lets us write intricate, centralized, well tested code encapsulating the flow through literally hundreds of individual screens. These days we are able to see and shape the forest, despite all of the trees. We built it with two core design principals in mind: Unidirectional data flow is the best way to stay sane when building UI Declarative programming is the best way to define unidirectional data flows What does that actually mean?","title":"Why does Workflow work this way?"},{"location":"userguide/concepts/#unidirectional-data-flow","text":"There is a wealth of information on the web about Unidirectional Data Flow , but it very simply means that there is a single path along which data travel from your business logic to your UI, and events travel to your business logic from your UI, and they always and only travel in one direction along that path. For Workflow, this also implies that the UI is (almost) stateless, and that the interesting state for your app is centralized and not duplicated. In practice, this makes program flow much easier to reason about because anytime something happens in an app, it removes the questions of where the state came from that caused it, which components got which events, and which sequences of cause and effect actually occurred. It makes unit testing easier because state and events are explicit, and always live in the same place and flow through the same APIs, so unit tests only need to test state transitions, for the most part.","title":"Unidirectional Data Flow"},{"location":"userguide/concepts/#declarative-vs-imperative","text":"Traditionally, most mobile code is \u201cimperative\u201d \u2013 it consists of instructions for how to build and display the UI. These instructions can include control flow like loops. Imperative code is usually stateful, state is usually sprinkled all over the place, and tends to care about instances and identity. When reading imperative code, you almost have to run an interpreter and keep all the pieces of state in your head to figure out what it does. Web UI is traditionally declarative \u2013 it describes what to render, and some aspects of how to render it (style), but doesn\u2019t say how to actually draw it. Declarative code is usually easier to read than imperative code. It describes what it produces, not how to generate it. Declarative code usually cares more about pure values than instance identities. However, since computers still need actual instructions at some point, declarative code requires something else, usually imperative, either a compiler or interpreter, to actually do something with it. Workflow code is written in regular Kotlin or Swift, which are both imperative languages, but the library encourages you to write your logic in a declarative and functional style. The library manages state and wiring up event handling for you, so the only code you need to write is code that is actually interesting for your particular problem. A note about functional programming Kotlin and Swift are not strictly functional programming languages, but both have features that allow you to write functional -style code. Functional code discourages side effects and is generally much easier to test than object-oriented code. Functional and declarative programming go very well together, and Workflow encourages you to write such code.","title":"Declarative vs Imperative"},{"location":"userguide/implementation/","text":"Implementation Notes \u00b6 Work in progress\u2026 So far we only have notes on the implementation of the Swift runtime. They\u2019re actually pretty close to what goes on in Kotlin, the WorkflowNode and SubtreeManager classes in particular. Swift \u00b6 The Render loop \u00b6 Initial pass \u00b6 The root of your workflow hierarchy gets put into a WorkflowHost (if you\u2019re using ContainerViewController this is created for you). As part of its initializer, WorkflowHost creates a WorkflowNode that wraps the given root Workflow (and keeps track of the Workflow \u2019s State ). It then calls render() on the node: // WorkflowHost public init ( workflow : WorkflowType , debugger : WorkflowDebugger ? = nil ) { self . debugger = debugger self . rootNode = WorkflowNode ( workflow : workflow ) // 1. Create the node self . mutableRendering = MutableProperty ( self . rootNode . render ()) // 2. Call render() WorkflowNode contains a SubtreeManager , whose primary purpose is to manage child workflows (more on this later). When render() gets invoked on the node, it calls render on the SubtreeManager and passes a closure that takes a RenderContext and returns a Rendering for the Workflow associated with the node. // WorkflowNode func render () -> WorkflowType . Rendering { return subtreeManager . render { context in return workflow . render ( state : state , context : context ) } } The SubtreeManager instantiates a RenderContext and invokes the closure that was passed in. This last step generates the Rendering . This Rendering then gets passed back up the call stack until it reaches the WorkflowHost . Composition \u00b6 In cases where a Workflow has child Workflow s, the render sequence is similar. The [tutorial] (../tutorial/building-a-workflow/#the-render-context) goes through this in more detail. Essentially, a Workflow containing child Workflow s calls render(context:key:outputMap:) on each child Workflow and passes in the RenderContext . The context does some bookkeeping for the child Workflow (creating or updating a ChildWorkflow<T> ) and then calls render() . ChildWorkflow<T>.render() calls render() on its WorkflowNode and we recurse back to step 2.","title":"Implementation Notes"},{"location":"userguide/implementation/#implementation-notes","text":"Work in progress\u2026 So far we only have notes on the implementation of the Swift runtime. They\u2019re actually pretty close to what goes on in Kotlin, the WorkflowNode and SubtreeManager classes in particular.","title":"Implementation Notes"},{"location":"userguide/implementation/#swift","text":"","title":"Swift"},{"location":"userguide/implementation/#the-render-loop","text":"","title":"The Render loop"},{"location":"userguide/implementation/#initial-pass","text":"The root of your workflow hierarchy gets put into a WorkflowHost (if you\u2019re using ContainerViewController this is created for you). As part of its initializer, WorkflowHost creates a WorkflowNode that wraps the given root Workflow (and keeps track of the Workflow \u2019s State ). It then calls render() on the node: // WorkflowHost public init ( workflow : WorkflowType , debugger : WorkflowDebugger ? = nil ) { self . debugger = debugger self . rootNode = WorkflowNode ( workflow : workflow ) // 1. Create the node self . mutableRendering = MutableProperty ( self . rootNode . render ()) // 2. Call render() WorkflowNode contains a SubtreeManager , whose primary purpose is to manage child workflows (more on this later). When render() gets invoked on the node, it calls render on the SubtreeManager and passes a closure that takes a RenderContext and returns a Rendering for the Workflow associated with the node. // WorkflowNode func render () -> WorkflowType . Rendering { return subtreeManager . render { context in return workflow . render ( state : state , context : context ) } } The SubtreeManager instantiates a RenderContext and invokes the closure that was passed in. This last step generates the Rendering . This Rendering then gets passed back up the call stack until it reaches the WorkflowHost .","title":"Initial pass"},{"location":"userguide/implementation/#composition","text":"In cases where a Workflow has child Workflow s, the render sequence is similar. The [tutorial] (../tutorial/building-a-workflow/#the-render-context) goes through this in more detail. Essentially, a Workflow containing child Workflow s calls render(context:key:outputMap:) on each child Workflow and passes in the RenderContext . The context does some bookkeeping for the child Workflow (creating or updating a ChildWorkflow<T> ) and then calls render() . ChildWorkflow<T>.render() calls render() on its WorkflowNode and we recurse back to step 2.","title":"Composition"},{"location":"userguide/testing-concepts/","text":"Workflow Testing \u00b6 Coming soon!","title":"Testing (TBD)"},{"location":"userguide/testing-concepts/#workflow-testing","text":"Coming soon!","title":"Workflow Testing"},{"location":"userguide/ui-concepts/","text":"Workflow UI \u00b6 This page provides a high level overview of Workflow UI, the companion that allows Workflow Core to drive Android and iOS apps. To see how these ideas are realized in code, move on to Coding Workflow UI . Warning The Screen interface that is so central to this discussion has reached Kotlin very recently, via v1.8.0-beta01 . Thus, if you are working against the most recent non-beta release, you will find the code blocks here don\u2019t match what you\u2019re seeing. Square is using the Screen machinery introduced with the beta at the heart of our Android app suite, and we expect the beta period to be a short one. The Swift Screen protocol et al. have been in steady use for years. What\u2019s a Screen? \u00b6 Most Workflow implementations produce struct / data class renderings that can serve as view models. Such a rendering provides enough data to paint a complete UI, including functions to be called in response to UI events. These view model renderings implement the Screen protocol / interface to advertise that this is their intended use. The core service provided by Workflow UI is to transform Screen types into platform-specific view objects, and to keep those views updated as new Screen renderings are emitted. Screen is the lynch pin that ties the Workflow Core and Workflow UI worlds together, the basic UI building block for Workflow-driven apps. A Screen is an object that can be presented as a basic 2D UI box, like an android.view.View or a UIViewController . And Workflow UI provides the glue that allows you to declare (at compile time!) that instances of FooScreen : Screen are used to drive FooViewController , layout/foo_screen.xml , or @Composable fun Content(FooScreen, ViewEnvironment) . Why \"Screen\"? We chose the name \u201cScreen\u201d because \u201cView\u201d would invite confusion with the like-named Android and iOS classes, and because \u201cBox\u201d didn\u2019t occur to us. (No one seems to have been bothered by the fact that Screen and iOS\u2019s UIScreen are unrelated.) And really, we went with \u201cScreen\u201d because it\u2019s the nebulous term that we and our users have always used to discuss our apps: \u201cGo to the Settings screen.\u201d \u201cHow do I get to the Tipping screen?\u201d \u201cThe Cart screen is shown in a modal over the Home screen on tablets.\u201d It\u2019s a safe bet you understood each of those sentences. Workflow Tree, Rendering Tree, View Tree \u00b6 In the Workflow Core page we discussed how Workflows can be composed as trees , like this email app driven by a trio of Workflows that assemble a composite SplitScreen rendering. Let\u2019s take a look at how Workflow UI transforms such a container screen into a container view . The main connection between the Workflow Core runtime and a native view system is the stream of Rendering objects from the root Workflow, EmailBrowserWorkflow in this discussion. From that point on, the flow of control is entirely in view-land. The precise details of that journey vary between Android and iOS in terms of naming, subclassing v. delegating, and so on, mainly to ensure that the API is idiomatic for each audience. None the less, the broad strokes are the same. (Move on to Coding Workflow UI to drill into the platform-specific details.) Each flavor of Workflow UI provides two core container helpers, both pictured below: A \u201cworkflow container\u201d, able to instantiate and update a view that can display Screen instances of the given type In iOS this is DescribedViewController For Android Classic we provide WorkflowViewStub , very similar to android.view.ViewStub . Android Jetpack Compose code can call @Compose fun WorkflowRendering() . A \u201cworkflow root container\u201d, able to field a stream of renderings from the Workflow Core runtime, and pass them on to a workflow container ContainerViewController for iOS WorkflowLayout for Android Classic @Compose fun Workflow.renderAsState() for Android Jetpack Compose When the runtime in our example is started, the flow is something like this: EmailBrowserWorkflow is asked for its first Rendering, a SplitScreen wrapping an InboxScreen and a MessageScreen . The Workflow root container receives that, and hands it off to its Workflow container . The container is able to resolve that SplitScreen instances can be displayed by views of the associated type Custom split view . The container builds that view, and passes it the SplitScreen . Custom split view is written with two Workflow containers of its own, one for the left side and for the right. The left hand container resolves InboxScreen to Custom inbox view , builds one, and hands the rendering that new view. The right hand container does the same for the MessageScreen , creating a Custom message view to display it. Sooner or later the state of EmailBrowserWorkflow or one of its children will change. Perhaps a new message has been received. Perhaps an event handler function on InboxScreen has been called because the user wants to read something else now. Regardless of where in the Workflow hierarchy the update happens, the entire tree will be re-rendered: EmailBrowserWorkflow will be asked for a new Rendering, it will ask its children for the same, and so on. Yes, everything renders when anything changes New Workflow developers generally freak out when they hear that the entire tree is re-rendered when any state anywhere updates. Remember that render() implementations are expected to be idempotent, and that their job is strictly declarative: render() effectively means \u201cI assume these children are running, and that I am subscribed to these work streams. Please make sure that stays the case, or fire up some new ones if needed.\u201d Another way is to think of them as declaring how to adapt the internal State into the external Rendering. These calls should be cheap, with all real work happening outside of the render() call. Optimizations may prevent rendering calls that are clearly redundant from being made, but semantically one should assume that the whole world is rendered when any part of the world changes. Once the runtime\u2019s Workflow tree finishes re-rendering, the new SplitScreen is passed through the native view system like so: The Workflow root container once again passes the new SplitScreen to its Workflow container , because that is the only trick it knows. That container recognizes that SplitScreen can be accepted by the Custom split view it created last time, and so there is no work to be done. The existing Custom split view receives the new SplitScreen . Just like last time, Custom split view passes InboxScreen to the Workflow container on its left, and MessageScreen to that on its right. The left hand Workflow container sees that it is already showing a Custom inbox view and passes InboxScreen rendering through. The same things happens with MessageScreen , and the Custom message view previously built by the right hand Workflow container . As is always the case with view code, Custom inbox view and Custom message view should be written with care to avoid redundant work, comparing what they are already showing with what they are being asked to show now. (A simple way to do this is to keep a Screen type\u2019s display data in a separate object from its event handlers, as an Equatable Swift struct, or as a Kotlin data class. Always hold on to the latest Screen in a var , and write UI click handlers and to reference it.) The update scenario would be different if the types of any of the Screen Renderings changed. Suppose our email app is able to host both email and voice mail in its inbox, and that the MessageScreen from the previous update is replaced with a VoicemailScreen this time. In that case, Custom message view would refuse the new Rendering, and the right hand Workflow container that created it would destroy it. A Custom voicemail view would be created in its stead, and that new view would paint itself with the information from the VoicemailScreen . So just how do these containers know what views to create for what Screen types? Those details are very language and platform specific, and are covered in the next page, under Building views from Screens . ViewEnvironment \u00b6 TK","title":"Workflow UI (in progress)"},{"location":"userguide/ui-concepts/#workflow-ui","text":"This page provides a high level overview of Workflow UI, the companion that allows Workflow Core to drive Android and iOS apps. To see how these ideas are realized in code, move on to Coding Workflow UI . Warning The Screen interface that is so central to this discussion has reached Kotlin very recently, via v1.8.0-beta01 . Thus, if you are working against the most recent non-beta release, you will find the code blocks here don\u2019t match what you\u2019re seeing. Square is using the Screen machinery introduced with the beta at the heart of our Android app suite, and we expect the beta period to be a short one. The Swift Screen protocol et al. have been in steady use for years.","title":"Workflow UI"},{"location":"userguide/ui-concepts/#whats-a-screen","text":"Most Workflow implementations produce struct / data class renderings that can serve as view models. Such a rendering provides enough data to paint a complete UI, including functions to be called in response to UI events. These view model renderings implement the Screen protocol / interface to advertise that this is their intended use. The core service provided by Workflow UI is to transform Screen types into platform-specific view objects, and to keep those views updated as new Screen renderings are emitted. Screen is the lynch pin that ties the Workflow Core and Workflow UI worlds together, the basic UI building block for Workflow-driven apps. A Screen is an object that can be presented as a basic 2D UI box, like an android.view.View or a UIViewController . And Workflow UI provides the glue that allows you to declare (at compile time!) that instances of FooScreen : Screen are used to drive FooViewController , layout/foo_screen.xml , or @Composable fun Content(FooScreen, ViewEnvironment) . Why \"Screen\"? We chose the name \u201cScreen\u201d because \u201cView\u201d would invite confusion with the like-named Android and iOS classes, and because \u201cBox\u201d didn\u2019t occur to us. (No one seems to have been bothered by the fact that Screen and iOS\u2019s UIScreen are unrelated.) And really, we went with \u201cScreen\u201d because it\u2019s the nebulous term that we and our users have always used to discuss our apps: \u201cGo to the Settings screen.\u201d \u201cHow do I get to the Tipping screen?\u201d \u201cThe Cart screen is shown in a modal over the Home screen on tablets.\u201d It\u2019s a safe bet you understood each of those sentences.","title":"What&rsquo;s a Screen?"},{"location":"userguide/ui-concepts/#workflow-tree-rendering-tree-view-tree","text":"In the Workflow Core page we discussed how Workflows can be composed as trees , like this email app driven by a trio of Workflows that assemble a composite SplitScreen rendering. Let\u2019s take a look at how Workflow UI transforms such a container screen into a container view . The main connection between the Workflow Core runtime and a native view system is the stream of Rendering objects from the root Workflow, EmailBrowserWorkflow in this discussion. From that point on, the flow of control is entirely in view-land. The precise details of that journey vary between Android and iOS in terms of naming, subclassing v. delegating, and so on, mainly to ensure that the API is idiomatic for each audience. None the less, the broad strokes are the same. (Move on to Coding Workflow UI to drill into the platform-specific details.) Each flavor of Workflow UI provides two core container helpers, both pictured below: A \u201cworkflow container\u201d, able to instantiate and update a view that can display Screen instances of the given type In iOS this is DescribedViewController For Android Classic we provide WorkflowViewStub , very similar to android.view.ViewStub . Android Jetpack Compose code can call @Compose fun WorkflowRendering() . A \u201cworkflow root container\u201d, able to field a stream of renderings from the Workflow Core runtime, and pass them on to a workflow container ContainerViewController for iOS WorkflowLayout for Android Classic @Compose fun Workflow.renderAsState() for Android Jetpack Compose When the runtime in our example is started, the flow is something like this: EmailBrowserWorkflow is asked for its first Rendering, a SplitScreen wrapping an InboxScreen and a MessageScreen . The Workflow root container receives that, and hands it off to its Workflow container . The container is able to resolve that SplitScreen instances can be displayed by views of the associated type Custom split view . The container builds that view, and passes it the SplitScreen . Custom split view is written with two Workflow containers of its own, one for the left side and for the right. The left hand container resolves InboxScreen to Custom inbox view , builds one, and hands the rendering that new view. The right hand container does the same for the MessageScreen , creating a Custom message view to display it. Sooner or later the state of EmailBrowserWorkflow or one of its children will change. Perhaps a new message has been received. Perhaps an event handler function on InboxScreen has been called because the user wants to read something else now. Regardless of where in the Workflow hierarchy the update happens, the entire tree will be re-rendered: EmailBrowserWorkflow will be asked for a new Rendering, it will ask its children for the same, and so on. Yes, everything renders when anything changes New Workflow developers generally freak out when they hear that the entire tree is re-rendered when any state anywhere updates. Remember that render() implementations are expected to be idempotent, and that their job is strictly declarative: render() effectively means \u201cI assume these children are running, and that I am subscribed to these work streams. Please make sure that stays the case, or fire up some new ones if needed.\u201d Another way is to think of them as declaring how to adapt the internal State into the external Rendering. These calls should be cheap, with all real work happening outside of the render() call. Optimizations may prevent rendering calls that are clearly redundant from being made, but semantically one should assume that the whole world is rendered when any part of the world changes. Once the runtime\u2019s Workflow tree finishes re-rendering, the new SplitScreen is passed through the native view system like so: The Workflow root container once again passes the new SplitScreen to its Workflow container , because that is the only trick it knows. That container recognizes that SplitScreen can be accepted by the Custom split view it created last time, and so there is no work to be done. The existing Custom split view receives the new SplitScreen . Just like last time, Custom split view passes InboxScreen to the Workflow container on its left, and MessageScreen to that on its right. The left hand Workflow container sees that it is already showing a Custom inbox view and passes InboxScreen rendering through. The same things happens with MessageScreen , and the Custom message view previously built by the right hand Workflow container . As is always the case with view code, Custom inbox view and Custom message view should be written with care to avoid redundant work, comparing what they are already showing with what they are being asked to show now. (A simple way to do this is to keep a Screen type\u2019s display data in a separate object from its event handlers, as an Equatable Swift struct, or as a Kotlin data class. Always hold on to the latest Screen in a var , and write UI click handlers and to reference it.) The update scenario would be different if the types of any of the Screen Renderings changed. Suppose our email app is able to host both email and voice mail in its inbox, and that the MessageScreen from the previous update is replaced with a VoicemailScreen this time. In that case, Custom message view would refuse the new Rendering, and the right hand Workflow container that created it would destroy it. A Custom voicemail view would be created in its stead, and that new view would paint itself with the information from the VoicemailScreen . So just how do these containers know what views to create for what Screen types? Those details are very language and platform specific, and are covered in the next page, under Building views from Screens .","title":"Workflow Tree, Rendering Tree, View Tree"},{"location":"userguide/ui-concepts/#viewenvironment","text":"TK","title":"ViewEnvironment"},{"location":"userguide/ui-in-code/","text":"Coding Workflow UI \u00b6 This page translates the high level discussion of Workflow UI into Android and iOS code. Separation of Concerns \u00b6 Workflow maintains a rigid separation between its core runtime and its UI support. The Workflow Core modules are strictly Swift and Kotlin, with no dependencies on any UI framework. Dependencies on Android and iOS are restricted to the Workflow UI modules, as you would expect. This innate separation naturally puts developers on a path to avoid entangling view concerns with their app logic. And note that we say \u201capp logic\u201d rather than \u201cbusiness logic.\u201d In any interesting app, the code that manages navigation and other UI-releated behavior is likely to dwarf that for what we typically think of as model concerns, in both size and complexity. We\u2019re all pretty good at capturing business concerns in tidy object-oriented models of items for sale, shopping carts, payment cards and the like, nicely decoupled from the UI world. But the rest of the app, and in particular the bits about how our users navigate it? Traditionally it\u2019s hard to keep that app-specific logic centralized, so that you can see what\u2019s going on; and even harder to keep it decoupled from your view system, so that it\u2019s easy to test. The strict divide between Workflow UI and Workflow Core leads you to maintain that separation by accident. Bootstrapping \u00b6 The following snippets demonstrate using Workflow to drive the root views of iOS and Android apps. But really, you can host a Workflow driven UI anywhere you can show a view, whatever \u201cview\u201d means on your platform. iOS @UIApplicationMain class AppDelegate : UIResponder , UIApplicationDelegate { var window : UIWindow ? func application ( _ application : UIApplication , didFinishLaunchingWithOptions launchOptions : [ UIApplication . LaunchOptionsKey : Any ]?) -> Bool { window = UIWindow ( frame : UIScreen . main . bounds ) window ?. rootViewController = ContainerViewController ( workflow : RootWorkflow ()) window ?. makeKeyAndVisible () return true } } Android Classic Android classic makes things a little complicated (naturally), as your Workflow runtime has to survive configuration changes. Our habit is use a Jetpack ViewModel to solve that problem, on what is typically the only line of code in a Workflow app that deals with the Jetpack Lifecycle at all. HelloWorkflowActivity.kt class HelloWorkflowActivity : AppCompatActivity () { override fun onCreate ( savedInstanceState : Bundle?) { super . onCreate ( savedInstanceState ) // This ViewModel will survive configuration changes. It's instantiated // by the first call to androidx.activity.viewModels(), and that // original instance is returned by succeeding calls. val model : HelloViewModel by viewModels () setContentView ( WorkflowLayout ( this ). apply { take ( lifecycle , model . renderings ) } ) } } class HelloViewModel ( savedState : SavedStateHandle ) : ViewModel () { val renderings : StateFlow < HelloRendering > by lazy { renderWorkflowIn ( workflow = HelloWorkflow , scope = viewModelScope , savedStateHandle = savedState ) } } Android Jetpack Compose HelloComposeActivity.kt class HelloComposeActivity : AppCompatActivity () { override fun onCreate ( savedInstanceState : Bundle?) { super . onCreate ( savedInstanceState ) setContent { val rendering by HelloWorkflow . renderAsState ( props = Unit , onOutput = {}) WorkflowRendering ( rendering , ViewEnvironment . EMPTY ) } } } Android developers should note that classic and Compose bootstrapping are completely interchangeable. Each style is able to display Screens of any type, regardless of whether they are set up to inflate View instances or to run @Composeable functions. Building views from Screens \u00b6 Hello, Screen world. iOS WelcomeScreen.swift struct WelcomeScreen : Screen { var name : String var onNameChanged : ( String ) -> Void var onLoginTapped : () -> Void func viewControllerDescription ( environment : ViewEnvironment ) -> ViewControllerDescription { return WelcomeViewController . description ( for : self , environment : environment ) } } private final class WelcomeViewController : ScreenViewController < WelcomeScreen > { override func viewDidLoad () { \u2026 } override func viewDidLayoutSubviews () { \u2026 } override func screenDidChange ( from previousScreen : WelcomeScreen , previousEnvironment : ViewEnvironment ) { super . screenDidChange ( from : previousScreen , previousEnvironment : previousEnvironment ) nameField . text = screen . name } } iOS Screen classes are expected to provide matching ViewControllerDescription instances. A ViewControllerDescription can build a UIViewController on demand, or update an existing one if it\u2019s recognized by ViewControllerDescription.canUpdate(UIViewController) . These duties are all fullfilled by the provided open class ScreenViewController . It\u2019s like any other ViewController , with the addition of: an open screenDidChange() method that the Workflow UI runtime calls with a series of Screen instances of the specified type a description() class method, perfect for calling from Screen.viewcontrollerDescription() Android Classic HelloScreen.kt data class HelloScreen ( val message : String , val onClick : () -> Unit ) : AndroidScreen < HelloScreen > { override val viewFactory : ScreenViewFactory < HelloScreen > = fromViewBinding ( HelloViewBinding :: inflate ) { helloScreen , viewEnvironment -> helloMessage . text = helloScreen . message helloMessage . setOnClickListener { helloScreen . onClick () } } } The Android Screen interface is purely a marker type. It defines no Android-specific methods to ensure you have the option of keeping your app logic pure. If you don\u2019t need that rigor, life is simpler (and safer, no runtime errors) if your Screen renderings implement AndroidScreen instead. An AndroidScreen is required to provide a matching ScreenViewFactory . ScreenViewFactory returns View instances wrapped in ScreenViewHolder objects. ScreenViewHolder.show is called by the Workflow UI runtime to update the view with Screen instances that are deemed acceptible by ScreenViewHolder.canShow . In this example the fromViewBinding function creates a ScreenViewFactory that builds View instances using a Jetpack View Binding , HelloViewBinding , presumably derived from hello_view_binding.xml . The lamda argument to the fromViewBinding provides the implementation for ScreenViewHolder.show , and is guaranteed that the given helloScreen parameter is of the appropriate type. Other factory functions are provided to work with layout resources directly, or to build views entirely from code. Android Jetpack Compose HelloScreen.kt data class HelloScreen ( val message : String , val onClick : () -> Unit ) : ComposeScreen < HelloScreen > { @Composable override fun Content ( viewEnvironment : ViewEnvironment ) { Button ( onClick ) { Text ( message ) } } } Here, HelloScreen is implementing ComposeScreen . ComposeScreen extends the same AndroidScreen class used for classic Android, defining @Composable fun Content() to get its work done. Content is always called from a @Composable Box() context. It\u2019s context aware Even though AndroidScreen provides a thing called ScreenViewFactory to do its work, the factories built by ComposeScreen are able to recognize whether they\u2019re being called from a classic View or from a @Composeable function, and do the right thing. Workflow UI only creates ComposeView instances as needed: when a @Composeable needs to be shown in a View . If the factory is to be used in a @Composable context, Content() is called directly. Where is that \u201cseparation of concerns\u201d you promised? \u00b6 After all the chest-thumping above about Separation of Concerns , the code samples above probably look pretty entangled. That\u2019s because, while the Workflow libraries themselves are completely decoupled, they don\u2019t force that strict rigor on your app code. If you aren\u2019t building, say, a core Workflow module that you want to ship separately from its Android and command line interfaces, you\u2019d probably gain nothing from enforced separation but boilerplate and runtime errors. And in practice, your Workflow unit tests won\u2019t call viewFactory and will build and run just fine against the JVM. Likewise, at this point we\u2019ve been building apps this way for hundreds of engineering years, and so far no one has called viewControllerDescription() and stashed a UIViewController in their workflow state. (This is not a challenge.) If you are one of the few who truly do need impermeable boundaries between your core and UI modules, they aren\u2019t hard to get. Your Screen implementations can be defined completely separately from their view code and bound later. iOS WelcomeScreen.swift struct WelcomeScreen { var name : String var onNameChanged : ( String ) -> Void var onLoginTapped : () -> Void } WelcomeViewController.swift extension WelcomeScreen : Screen { func viewControllerDescription ( environment : ViewEnvironment ) -> ViewControllerDescription { return WelcomeViewController . description ( for : self , environment : environment ) } } private final class WelcomeViewController : ScreenViewController < WelcomeScreen > { // ... Android HelloScreen.kt data class HelloScreen ( val message : String , val onClick : () -> Unit ) : Screen HelloWorkflowGreenTheme.kt private object HelloScreenGreenThemeViewFactory : ScreenViewFactory < HelloScreen > by ScreenViewFactory . fromViewBinding ( GreenHelloViewBinding :: inflate ) { r , _ -> helloMessage . text = r . message helloMessage . setOnClickListener { r . onClick () } } } private val viewRegistry = ViewRegistry ( HelloScreenGreenThemeViewFactory ) val HelloWorkflowGreenTheme = HelloWorkflow . mapRenderings { it . withRegistry ( viewRegistry ) } Container screens make container views \u00b6 A container screen is one that is built out of other Screens. And naturally enough, the thing that a container screen drives is a container view : one that is able to host child views that are driven by Screen instances of arbitrary type. Workflow UI provides two root container views out of the box, the ContainerViewController and WorkflowLayout classes discussed above, under Bootstrapping . They do most of their work by delegating to another pair of support view classes: ScreenViewController for iOS and WorkflowViewStub for Android. Android also provides @Composable fun WorkflowRendering() for use with Jetpack Compose. For something like a SplitScreen rendering, you\u2019ll write your own view code that does the same. iOS SplitScreen.swift public struct SplitScreen < LeadingScreenType : Screen , TrailingScreenType : Screen >: Screen { public let leadingScreen : LeadingScreenType public let trailingScreen : TrailingScreenType public func viewControllerDescription ( environment : ViewEnvironment ) -> ViewControllerDescription { return SplitScreenViewController . description ( for : self , environment : environment ) } SplitScreenViewController.swift internal final class SplitScreenViewController < LeadingScreenType : Screen , TrailingScreenType : Screen >: ScreenViewController < SplitScreenViewController . ContainerScreen > { internal typealias ContainerScreen = SplitScreen < LeadingScreenType , TrailingScreenType > private var leadingContentViewController : DescribedViewController private lazy var leadingContainerView : ContainerView = . init () private lazy var separatorView : UIView = . init () private var trailingContentViewController : DescribedViewController private lazy var trailingContainerView : ContainerView = . init () required init ( screen : ContainerScreen , environment : ViewEnvironment ) { self . leadingContentViewController = DescribedViewController ( screen : screen . leadingScreen , environment : environment ) self . trailingContentViewController = DescribedViewController ( screen : screen . trailingScreen , environment : environment ) super . init ( screen : screen , environment : environment ) } override internal func screenDidChange ( from previousScreen : ContainerScreen , previousEnvironment : ViewEnvironment ) { super . screenDidChange ( from : previousScreen , previousEnvironment : previousEnvironment ) update ( with : screen ) } private func update ( with screen : ContainerScreen ) { leadingContentViewController . update ( screen : screen . leadingScreen , environment : environment ) trailingContentViewController . update ( screen : screen . trailingScreen , environment : environment ) // Intentional force of layout pass after updating the child view controllers view . layoutIfNeeded () } override internal func viewDidLoad () { /** Lay out the two children horizontally, nothing workflow specific here. */ update ( with : screen ) } override internal func viewDidLayoutSubviews () { /** Calculate the layout, nothing workflow specific here. */ } The interesting thing here is the use of DescribedViewController to display the nested leadingContent and trailingContent Screens. DescribedViewController uses Screen.viewControllerDescription to build a new UIViewController if it needs to, or update an existing one if it can. Everything else is just run of the mill iOS view code. Android Classic SplitScreen.kt data class SplitScreen < L : Screen , T : Screen > ( val leadingScreen : L , val trailingScreen : T ): AndroidScreen < SplitScreen < L , T >> { override val viewFactory : ScreenViewFactory < SplitScreen < L , T >> = fromViewBinding ( SplitScreenBinding :: inflate ) { screen , _ -> leadingStub . show ( leadingScreen ) trailingStub . show ( trailingScreen ) } } split_screen.xml <?xml version=\"1.0\" encoding=\"utf-8\"?> <LinearLayout xmlns:android= \"http://schemas.android.com/apk/res/android\" android:layout_width= \"match_parent\" android:layout_height= \"match_parent\" android:orientation= \"horizontal\" > <com.squareup.workflow1.ui.WorkflowViewStub android:id= \"@+id/leading_stub\" android:layout_width= \"0dp\" android:layout_height= \"match_parent\" android:layout_weight= \"30\" /> <View android:layout_width= \"1dp\" android:layout_height= \"match_parent\" android:background= \"@android:drawable/divider_horizontal_bright\" /> <com.squareup.workflow1.ui.WorkflowViewStub android:id= \"@+id/trailing_stub\" android:layout_width= \"0dp\" android:layout_height= \"match_parent\" android:layout_weight= \"70\" /> </LinearLayout> Android Jetpack Compose SplitScreen.kt data class SplitScreen < L : Screen , T : Screen > ( val leadingScreen : L , val trailingScreen : T ): ComposeScreen < SplitScreen < L , T >> { @Composable override fun Content ( viewEnvironment : ViewEnvironment ) { Row { WorkflowRendering ( rendering = leadingScreen , modifier = Modifier . weight ( 1 / 3f ) . fillMaxHeight () ) WorkflowRendering ( rendering = trailingScreen , modifier = Modifier . weight ( 2 / 3f ) . fillMaxHeight () ) } } }","title":"Coding Workflow UI (in progress)"},{"location":"userguide/ui-in-code/#coding-workflow-ui","text":"This page translates the high level discussion of Workflow UI into Android and iOS code.","title":"Coding Workflow UI"},{"location":"userguide/ui-in-code/#separation-of-concerns","text":"Workflow maintains a rigid separation between its core runtime and its UI support. The Workflow Core modules are strictly Swift and Kotlin, with no dependencies on any UI framework. Dependencies on Android and iOS are restricted to the Workflow UI modules, as you would expect. This innate separation naturally puts developers on a path to avoid entangling view concerns with their app logic. And note that we say \u201capp logic\u201d rather than \u201cbusiness logic.\u201d In any interesting app, the code that manages navigation and other UI-releated behavior is likely to dwarf that for what we typically think of as model concerns, in both size and complexity. We\u2019re all pretty good at capturing business concerns in tidy object-oriented models of items for sale, shopping carts, payment cards and the like, nicely decoupled from the UI world. But the rest of the app, and in particular the bits about how our users navigate it? Traditionally it\u2019s hard to keep that app-specific logic centralized, so that you can see what\u2019s going on; and even harder to keep it decoupled from your view system, so that it\u2019s easy to test. The strict divide between Workflow UI and Workflow Core leads you to maintain that separation by accident.","title":"Separation of Concerns"},{"location":"userguide/ui-in-code/#bootstrapping","text":"The following snippets demonstrate using Workflow to drive the root views of iOS and Android apps. But really, you can host a Workflow driven UI anywhere you can show a view, whatever \u201cview\u201d means on your platform. iOS @UIApplicationMain class AppDelegate : UIResponder , UIApplicationDelegate { var window : UIWindow ? func application ( _ application : UIApplication , didFinishLaunchingWithOptions launchOptions : [ UIApplication . LaunchOptionsKey : Any ]?) -> Bool { window = UIWindow ( frame : UIScreen . main . bounds ) window ?. rootViewController = ContainerViewController ( workflow : RootWorkflow ()) window ?. makeKeyAndVisible () return true } } Android Classic Android classic makes things a little complicated (naturally), as your Workflow runtime has to survive configuration changes. Our habit is use a Jetpack ViewModel to solve that problem, on what is typically the only line of code in a Workflow app that deals with the Jetpack Lifecycle at all. HelloWorkflowActivity.kt class HelloWorkflowActivity : AppCompatActivity () { override fun onCreate ( savedInstanceState : Bundle?) { super . onCreate ( savedInstanceState ) // This ViewModel will survive configuration changes. It's instantiated // by the first call to androidx.activity.viewModels(), and that // original instance is returned by succeeding calls. val model : HelloViewModel by viewModels () setContentView ( WorkflowLayout ( this ). apply { take ( lifecycle , model . renderings ) } ) } } class HelloViewModel ( savedState : SavedStateHandle ) : ViewModel () { val renderings : StateFlow < HelloRendering > by lazy { renderWorkflowIn ( workflow = HelloWorkflow , scope = viewModelScope , savedStateHandle = savedState ) } } Android Jetpack Compose HelloComposeActivity.kt class HelloComposeActivity : AppCompatActivity () { override fun onCreate ( savedInstanceState : Bundle?) { super . onCreate ( savedInstanceState ) setContent { val rendering by HelloWorkflow . renderAsState ( props = Unit , onOutput = {}) WorkflowRendering ( rendering , ViewEnvironment . EMPTY ) } } } Android developers should note that classic and Compose bootstrapping are completely interchangeable. Each style is able to display Screens of any type, regardless of whether they are set up to inflate View instances or to run @Composeable functions.","title":"Bootstrapping"},{"location":"userguide/ui-in-code/#building-views-from-screens","text":"Hello, Screen world. iOS WelcomeScreen.swift struct WelcomeScreen : Screen { var name : String var onNameChanged : ( String ) -> Void var onLoginTapped : () -> Void func viewControllerDescription ( environment : ViewEnvironment ) -> ViewControllerDescription { return WelcomeViewController . description ( for : self , environment : environment ) } } private final class WelcomeViewController : ScreenViewController < WelcomeScreen > { override func viewDidLoad () { \u2026 } override func viewDidLayoutSubviews () { \u2026 } override func screenDidChange ( from previousScreen : WelcomeScreen , previousEnvironment : ViewEnvironment ) { super . screenDidChange ( from : previousScreen , previousEnvironment : previousEnvironment ) nameField . text = screen . name } } iOS Screen classes are expected to provide matching ViewControllerDescription instances. A ViewControllerDescription can build a UIViewController on demand, or update an existing one if it\u2019s recognized by ViewControllerDescription.canUpdate(UIViewController) . These duties are all fullfilled by the provided open class ScreenViewController . It\u2019s like any other ViewController , with the addition of: an open screenDidChange() method that the Workflow UI runtime calls with a series of Screen instances of the specified type a description() class method, perfect for calling from Screen.viewcontrollerDescription() Android Classic HelloScreen.kt data class HelloScreen ( val message : String , val onClick : () -> Unit ) : AndroidScreen < HelloScreen > { override val viewFactory : ScreenViewFactory < HelloScreen > = fromViewBinding ( HelloViewBinding :: inflate ) { helloScreen , viewEnvironment -> helloMessage . text = helloScreen . message helloMessage . setOnClickListener { helloScreen . onClick () } } } The Android Screen interface is purely a marker type. It defines no Android-specific methods to ensure you have the option of keeping your app logic pure. If you don\u2019t need that rigor, life is simpler (and safer, no runtime errors) if your Screen renderings implement AndroidScreen instead. An AndroidScreen is required to provide a matching ScreenViewFactory . ScreenViewFactory returns View instances wrapped in ScreenViewHolder objects. ScreenViewHolder.show is called by the Workflow UI runtime to update the view with Screen instances that are deemed acceptible by ScreenViewHolder.canShow . In this example the fromViewBinding function creates a ScreenViewFactory that builds View instances using a Jetpack View Binding , HelloViewBinding , presumably derived from hello_view_binding.xml . The lamda argument to the fromViewBinding provides the implementation for ScreenViewHolder.show , and is guaranteed that the given helloScreen parameter is of the appropriate type. Other factory functions are provided to work with layout resources directly, or to build views entirely from code. Android Jetpack Compose HelloScreen.kt data class HelloScreen ( val message : String , val onClick : () -> Unit ) : ComposeScreen < HelloScreen > { @Composable override fun Content ( viewEnvironment : ViewEnvironment ) { Button ( onClick ) { Text ( message ) } } } Here, HelloScreen is implementing ComposeScreen . ComposeScreen extends the same AndroidScreen class used for classic Android, defining @Composable fun Content() to get its work done. Content is always called from a @Composable Box() context. It\u2019s context aware Even though AndroidScreen provides a thing called ScreenViewFactory to do its work, the factories built by ComposeScreen are able to recognize whether they\u2019re being called from a classic View or from a @Composeable function, and do the right thing. Workflow UI only creates ComposeView instances as needed: when a @Composeable needs to be shown in a View . If the factory is to be used in a @Composable context, Content() is called directly.","title":"Building views from Screens"},{"location":"userguide/ui-in-code/#where-is-that-separation-of-concerns-you-promised","text":"After all the chest-thumping above about Separation of Concerns , the code samples above probably look pretty entangled. That\u2019s because, while the Workflow libraries themselves are completely decoupled, they don\u2019t force that strict rigor on your app code. If you aren\u2019t building, say, a core Workflow module that you want to ship separately from its Android and command line interfaces, you\u2019d probably gain nothing from enforced separation but boilerplate and runtime errors. And in practice, your Workflow unit tests won\u2019t call viewFactory and will build and run just fine against the JVM. Likewise, at this point we\u2019ve been building apps this way for hundreds of engineering years, and so far no one has called viewControllerDescription() and stashed a UIViewController in their workflow state. (This is not a challenge.) If you are one of the few who truly do need impermeable boundaries between your core and UI modules, they aren\u2019t hard to get. Your Screen implementations can be defined completely separately from their view code and bound later. iOS WelcomeScreen.swift struct WelcomeScreen { var name : String var onNameChanged : ( String ) -> Void var onLoginTapped : () -> Void } WelcomeViewController.swift extension WelcomeScreen : Screen { func viewControllerDescription ( environment : ViewEnvironment ) -> ViewControllerDescription { return WelcomeViewController . description ( for : self , environment : environment ) } } private final class WelcomeViewController : ScreenViewController < WelcomeScreen > { // ... Android HelloScreen.kt data class HelloScreen ( val message : String , val onClick : () -> Unit ) : Screen HelloWorkflowGreenTheme.kt private object HelloScreenGreenThemeViewFactory : ScreenViewFactory < HelloScreen > by ScreenViewFactory . fromViewBinding ( GreenHelloViewBinding :: inflate ) { r , _ -> helloMessage . text = r . message helloMessage . setOnClickListener { r . onClick () } } } private val viewRegistry = ViewRegistry ( HelloScreenGreenThemeViewFactory ) val HelloWorkflowGreenTheme = HelloWorkflow . mapRenderings { it . withRegistry ( viewRegistry ) }","title":"Where is that &ldquo;separation of concerns&rdquo; you promised?"},{"location":"userguide/ui-in-code/#container-screens-make-container-views","text":"A container screen is one that is built out of other Screens. And naturally enough, the thing that a container screen drives is a container view : one that is able to host child views that are driven by Screen instances of arbitrary type. Workflow UI provides two root container views out of the box, the ContainerViewController and WorkflowLayout classes discussed above, under Bootstrapping . They do most of their work by delegating to another pair of support view classes: ScreenViewController for iOS and WorkflowViewStub for Android. Android also provides @Composable fun WorkflowRendering() for use with Jetpack Compose. For something like a SplitScreen rendering, you\u2019ll write your own view code that does the same. iOS SplitScreen.swift public struct SplitScreen < LeadingScreenType : Screen , TrailingScreenType : Screen >: Screen { public let leadingScreen : LeadingScreenType public let trailingScreen : TrailingScreenType public func viewControllerDescription ( environment : ViewEnvironment ) -> ViewControllerDescription { return SplitScreenViewController . description ( for : self , environment : environment ) } SplitScreenViewController.swift internal final class SplitScreenViewController < LeadingScreenType : Screen , TrailingScreenType : Screen >: ScreenViewController < SplitScreenViewController . ContainerScreen > { internal typealias ContainerScreen = SplitScreen < LeadingScreenType , TrailingScreenType > private var leadingContentViewController : DescribedViewController private lazy var leadingContainerView : ContainerView = . init () private lazy var separatorView : UIView = . init () private var trailingContentViewController : DescribedViewController private lazy var trailingContainerView : ContainerView = . init () required init ( screen : ContainerScreen , environment : ViewEnvironment ) { self . leadingContentViewController = DescribedViewController ( screen : screen . leadingScreen , environment : environment ) self . trailingContentViewController = DescribedViewController ( screen : screen . trailingScreen , environment : environment ) super . init ( screen : screen , environment : environment ) } override internal func screenDidChange ( from previousScreen : ContainerScreen , previousEnvironment : ViewEnvironment ) { super . screenDidChange ( from : previousScreen , previousEnvironment : previousEnvironment ) update ( with : screen ) } private func update ( with screen : ContainerScreen ) { leadingContentViewController . update ( screen : screen . leadingScreen , environment : environment ) trailingContentViewController . update ( screen : screen . trailingScreen , environment : environment ) // Intentional force of layout pass after updating the child view controllers view . layoutIfNeeded () } override internal func viewDidLoad () { /** Lay out the two children horizontally, nothing workflow specific here. */ update ( with : screen ) } override internal func viewDidLayoutSubviews () { /** Calculate the layout, nothing workflow specific here. */ } The interesting thing here is the use of DescribedViewController to display the nested leadingContent and trailingContent Screens. DescribedViewController uses Screen.viewControllerDescription to build a new UIViewController if it needs to, or update an existing one if it can. Everything else is just run of the mill iOS view code. Android Classic SplitScreen.kt data class SplitScreen < L : Screen , T : Screen > ( val leadingScreen : L , val trailingScreen : T ): AndroidScreen < SplitScreen < L , T >> { override val viewFactory : ScreenViewFactory < SplitScreen < L , T >> = fromViewBinding ( SplitScreenBinding :: inflate ) { screen , _ -> leadingStub . show ( leadingScreen ) trailingStub . show ( trailingScreen ) } } split_screen.xml <?xml version=\"1.0\" encoding=\"utf-8\"?> <LinearLayout xmlns:android= \"http://schemas.android.com/apk/res/android\" android:layout_width= \"match_parent\" android:layout_height= \"match_parent\" android:orientation= \"horizontal\" > <com.squareup.workflow1.ui.WorkflowViewStub android:id= \"@+id/leading_stub\" android:layout_width= \"0dp\" android:layout_height= \"match_parent\" android:layout_weight= \"30\" /> <View android:layout_width= \"1dp\" android:layout_height= \"match_parent\" android:background= \"@android:drawable/divider_horizontal_bright\" /> <com.squareup.workflow1.ui.WorkflowViewStub android:id= \"@+id/trailing_stub\" android:layout_width= \"0dp\" android:layout_height= \"match_parent\" android:layout_weight= \"70\" /> </LinearLayout> Android Jetpack Compose SplitScreen.kt data class SplitScreen < L : Screen , T : Screen > ( val leadingScreen : L , val trailingScreen : T ): ComposeScreen < SplitScreen < L , T >> { @Composable override fun Content ( viewEnvironment : ViewEnvironment ) { Row { WorkflowRendering ( rendering = leadingScreen , modifier = Modifier . weight ( 1 / 3f ) . fillMaxHeight () ) WorkflowRendering ( rendering = trailingScreen , modifier = Modifier . weight ( 2 / 3f ) . fillMaxHeight () ) } } }","title":"Container screens make container views"},{"location":"userguide/whyworkflow/","text":"Why Workflow? \u00b6 So you want me to take the application feature I have to develop and break it down into separate components? And then enumerate every possible state for each of those components? As well as writing classes or structs that represent each of these states in addition to the collection of objects that each component might pass to another? That sounds like a lot of work just to help the seller order a set of gift cards! Why make something simple so complicated? Why should I use Workflow? I think even those of us who use Workflow all the time end up asking this question. It\u2019s a very reasonable question that we try to answer here. At the heart of the matter, there are two complementary justifications for Workflow, which we will expand on below: Software clarity, correctness, and testability (especially at scale). Encouraging programming paradigms that are best practices for the mobile domain. Software clarity, correctness, and testability (at scale) \u00b6 I like to think that most of us have been there: It\u2019s our second straight day staring at the logs from over 200 customers. We know what the problem is : the user gets to screen Y and object foo\u2019s state is bar, but foo should not be bar while in screen Y. Why is foo bar? Unfortunately we don\u2019t have any debug log for foo\u2019s state at the time we start screen Y. We only have one when the user tries to click on button Z, and at that point the state is already bar even though it should only ever be baz or buz. What happened? How did foo get to state bar on screen Y? Looking at the code, foo is shared state with 15 other screens, and it is mutable in all of them. The logic to update foo\u2019s state in screen Y happens in code that is coupled to interaction with button Z, so we cannot simply add a unit test for this, we need a complex UI test to reproduce screen Y. We don\u2019t know how the problem happened and it almost seems like we can\u2019t know how without significant effort! The story above is a little dramatic but I hope the feeling it invokes is familiar. It is a daunting task to reason through application code and build up a sufficient mental model of all possible side effects in any one feature area. Now scale up the numbers a bit \u2014 foo is shared by 150 other screens \u2014 and the once daunting task seems almost impossible. All mobile developers face some form of the above problem, and at Square within our Point of Sale applications we face the scaled up version every day. What do we want? \u00b6 Clear boundaries between each feature\u2019s software components that can be instrumented with logs and that have contracts that can be tested. Clear expectations for outcomes within a particular feature\u2019s software component that can be verified for correctness with tests. Immutable State within any particular scope (e.g. Screen Y in the context above) so that the code handling mutations to provide a new State as a result of some event is in a \u201cprotected area\u201d that can be instrumented and tested. A clear separation of the State updates from the presentation of the UI. We want the conditions above because we want: Not to have bugs like the one we started this discussion with. In other words, we want our tests to give us confidence in our application logic. In the inevitable case that we do have a bug, we want to be able to isolate the scenario, reproduce the exact conditions, fix the bug and write a test so that it doesn\u2019t happen again. Workflow facilitates these goals for native mobile applications by providing a pattern (and a supporting application Runtime) similar to React, Elm, or any number of other web application JavaScript frameworks (not to mention forthcoming native mobile frameworks such as Jetpack Compose and SwiftUI). Each logical component area is separated into a Workflow with a finite set of states and the logic to transition between them. Workflows can be composed together for a full feature with each Workflow\u2019s signature specifying a clear contract. The Workflow Runtime\u2019s event loop handles the production of new immutable states for each Workflow so that within the Workflow render logic it is immutable. Workflows can be executed and instrumented in a testable way with extra hooks for simple verification of outcomes in unit tests. On an even simpler level Workflow improves clarity by giving a large team of developers a shared idiom of software components with which to discuss business logic across feature areas, and across mobile platforms (Android, iOS). Further, as the application is composed with multiple Workflows, the framework enables loose coupling between features to focus the impact of code changes. Encouraging programming paradigms that are best practices for the mobile domain \u00b6 Mobile applications receive and display a lot of data! Our applications at Square certainly do. As a result of this, there is a growing trend towards reactive programming for mobile applications. In this paradigm, the application logic subscribes to a stream of data which is then pushed to the logic rather than having to be periodically pulled and operated on. This has the profound effect of ensuring that the data shown to the application user is never stale. This style of programming also makes clear that most mobile applications are a series of mapping operations on a stream of data that is eventually mapped into some UI. Another mobile programming best practice (arising out of a long tradition) is to favor declarative programming over imperative programming . With this style choice, the code for a feature declares what should be occurring for a particular state, rather than consisting of a series of statements that are essentially how to make that occur. This is a best practice because when a program\u2019s logic is defined in this way, it is very simple to test (so more likely to be tested!): \u201cFor state Y we expect Rendering Z;\u201d \u201cFrom state Y given input A we expect Rendering Z+.\u201d Possibly more important, it is easier to read, comprehend quickly, and to reason about than a series of complex commands for the computer. Workflows encourage a declarative style because each state of a particular component must be enumerated and then the Rendering (representation that gets passed to the UI framework) is declared for that particular state, alongside a declaration of what children and side effects should be running in that state. The well-tested and reliable Workflow runtime loop itself handles how to start and stop the children and side effects, reducing resource leaks. By requiring these formal definitions of each State, Rendering, and the Actions that will change the current state, Workflow naturally encourages declarative programming. While reactive and declarative programming may be current best practices, there is one Software Engineering principle that has proven over and over again to be the most universal and the most important for systems of scale: Separation of Concerns . Any system of scale requires multiple separate components that can be worked on, tested, improved, and refactored independently by multiple teams of people. A system of multiple components requires communication and any good communication begs explicit structure and contracts. For mobile applications at Square we have settled on the Model-View-ViewModel (MVVM) architecture as the structure for the topical separation of concerns of the layers of the application. MVVM\u2019s unidirectional layered communication is the same as that of Model-View-Presenter (MVP), as opposed to the \u2018circular\u2019 communication of Model-View-Controller (MVC). MVVM\u2019s use of a strict binding between the ViewModel and the View is the same as MVC, as opposed to the imperative interpretation of the Model in MVP. MVVM provides the reasoning and comprehension benefits of unidirectional data flow while also eliminating as much business logic as possible from the view layer and encouraging declarative ViewModels. At Square this works well because we have UI design frameworks that change infrequently (so keeping bindings up-to-date is not much overhead), but business logic that is constantly being updated (so emphasizing low coupling is important). Workflows embrace MVVM because the Rendering produced by a Workflow tree is the ViewModel, which can then be bound to any native mobile UI framework. For feature based separation of concerns we lean on Workflow\u2019s facility for composition at scale via strong parent-child contracts and a hierarchical tree organization. While building a Hello World Workflow may seem like overkill (although it\u2019s really not that bad!), the explicitness and contracts that Workflows require of the developer lay the structure for good communication. The composability of Workflows encourages reuse and encourages separation of concerns into the most appropriate reusable components. There are even more platform-specific best practices that Workflow dovetails well with, such as structured concurrency with Kotlin coroutines, as each Worker or side effect can define a specific coroutine scope for the operations. What about the next 10 years? Jetpack Compose UI and SwiftUI are establishing themselves as the native mobile UI toolkits of the future. They both embrace the same MVVM approach that Workflow does, and encourage thinking about the \u201ccomposability\u201d of separate components of your application. With this resonance, Workflows help you to prepare your mental model to adapt to these new UI toolkits, and shapes our codebase in a way that will ease our adoption of them. To learn more about Compose and Workflow see this post .","title":"Why Workflow?"},{"location":"userguide/whyworkflow/#why-workflow","text":"So you want me to take the application feature I have to develop and break it down into separate components? And then enumerate every possible state for each of those components? As well as writing classes or structs that represent each of these states in addition to the collection of objects that each component might pass to another? That sounds like a lot of work just to help the seller order a set of gift cards! Why make something simple so complicated? Why should I use Workflow? I think even those of us who use Workflow all the time end up asking this question. It\u2019s a very reasonable question that we try to answer here. At the heart of the matter, there are two complementary justifications for Workflow, which we will expand on below: Software clarity, correctness, and testability (especially at scale). Encouraging programming paradigms that are best practices for the mobile domain.","title":"Why Workflow?"},{"location":"userguide/whyworkflow/#software-clarity-correctness-and-testability-at-scale","text":"I like to think that most of us have been there: It\u2019s our second straight day staring at the logs from over 200 customers. We know what the problem is : the user gets to screen Y and object foo\u2019s state is bar, but foo should not be bar while in screen Y. Why is foo bar? Unfortunately we don\u2019t have any debug log for foo\u2019s state at the time we start screen Y. We only have one when the user tries to click on button Z, and at that point the state is already bar even though it should only ever be baz or buz. What happened? How did foo get to state bar on screen Y? Looking at the code, foo is shared state with 15 other screens, and it is mutable in all of them. The logic to update foo\u2019s state in screen Y happens in code that is coupled to interaction with button Z, so we cannot simply add a unit test for this, we need a complex UI test to reproduce screen Y. We don\u2019t know how the problem happened and it almost seems like we can\u2019t know how without significant effort! The story above is a little dramatic but I hope the feeling it invokes is familiar. It is a daunting task to reason through application code and build up a sufficient mental model of all possible side effects in any one feature area. Now scale up the numbers a bit \u2014 foo is shared by 150 other screens \u2014 and the once daunting task seems almost impossible. All mobile developers face some form of the above problem, and at Square within our Point of Sale applications we face the scaled up version every day.","title":"Software clarity, correctness, and testability (at scale)"},{"location":"userguide/whyworkflow/#what-do-we-want","text":"Clear boundaries between each feature\u2019s software components that can be instrumented with logs and that have contracts that can be tested. Clear expectations for outcomes within a particular feature\u2019s software component that can be verified for correctness with tests. Immutable State within any particular scope (e.g. Screen Y in the context above) so that the code handling mutations to provide a new State as a result of some event is in a \u201cprotected area\u201d that can be instrumented and tested. A clear separation of the State updates from the presentation of the UI. We want the conditions above because we want: Not to have bugs like the one we started this discussion with. In other words, we want our tests to give us confidence in our application logic. In the inevitable case that we do have a bug, we want to be able to isolate the scenario, reproduce the exact conditions, fix the bug and write a test so that it doesn\u2019t happen again. Workflow facilitates these goals for native mobile applications by providing a pattern (and a supporting application Runtime) similar to React, Elm, or any number of other web application JavaScript frameworks (not to mention forthcoming native mobile frameworks such as Jetpack Compose and SwiftUI). Each logical component area is separated into a Workflow with a finite set of states and the logic to transition between them. Workflows can be composed together for a full feature with each Workflow\u2019s signature specifying a clear contract. The Workflow Runtime\u2019s event loop handles the production of new immutable states for each Workflow so that within the Workflow render logic it is immutable. Workflows can be executed and instrumented in a testable way with extra hooks for simple verification of outcomes in unit tests. On an even simpler level Workflow improves clarity by giving a large team of developers a shared idiom of software components with which to discuss business logic across feature areas, and across mobile platforms (Android, iOS). Further, as the application is composed with multiple Workflows, the framework enables loose coupling between features to focus the impact of code changes.","title":"What do we want?"},{"location":"userguide/whyworkflow/#encouraging-programming-paradigms-that-are-best-practices-for-the-mobile-domain","text":"Mobile applications receive and display a lot of data! Our applications at Square certainly do. As a result of this, there is a growing trend towards reactive programming for mobile applications. In this paradigm, the application logic subscribes to a stream of data which is then pushed to the logic rather than having to be periodically pulled and operated on. This has the profound effect of ensuring that the data shown to the application user is never stale. This style of programming also makes clear that most mobile applications are a series of mapping operations on a stream of data that is eventually mapped into some UI. Another mobile programming best practice (arising out of a long tradition) is to favor declarative programming over imperative programming . With this style choice, the code for a feature declares what should be occurring for a particular state, rather than consisting of a series of statements that are essentially how to make that occur. This is a best practice because when a program\u2019s logic is defined in this way, it is very simple to test (so more likely to be tested!): \u201cFor state Y we expect Rendering Z;\u201d \u201cFrom state Y given input A we expect Rendering Z+.\u201d Possibly more important, it is easier to read, comprehend quickly, and to reason about than a series of complex commands for the computer. Workflows encourage a declarative style because each state of a particular component must be enumerated and then the Rendering (representation that gets passed to the UI framework) is declared for that particular state, alongside a declaration of what children and side effects should be running in that state. The well-tested and reliable Workflow runtime loop itself handles how to start and stop the children and side effects, reducing resource leaks. By requiring these formal definitions of each State, Rendering, and the Actions that will change the current state, Workflow naturally encourages declarative programming. While reactive and declarative programming may be current best practices, there is one Software Engineering principle that has proven over and over again to be the most universal and the most important for systems of scale: Separation of Concerns . Any system of scale requires multiple separate components that can be worked on, tested, improved, and refactored independently by multiple teams of people. A system of multiple components requires communication and any good communication begs explicit structure and contracts. For mobile applications at Square we have settled on the Model-View-ViewModel (MVVM) architecture as the structure for the topical separation of concerns of the layers of the application. MVVM\u2019s unidirectional layered communication is the same as that of Model-View-Presenter (MVP), as opposed to the \u2018circular\u2019 communication of Model-View-Controller (MVC). MVVM\u2019s use of a strict binding between the ViewModel and the View is the same as MVC, as opposed to the imperative interpretation of the Model in MVP. MVVM provides the reasoning and comprehension benefits of unidirectional data flow while also eliminating as much business logic as possible from the view layer and encouraging declarative ViewModels. At Square this works well because we have UI design frameworks that change infrequently (so keeping bindings up-to-date is not much overhead), but business logic that is constantly being updated (so emphasizing low coupling is important). Workflows embrace MVVM because the Rendering produced by a Workflow tree is the ViewModel, which can then be bound to any native mobile UI framework. For feature based separation of concerns we lean on Workflow\u2019s facility for composition at scale via strong parent-child contracts and a hierarchical tree organization. While building a Hello World Workflow may seem like overkill (although it\u2019s really not that bad!), the explicitness and contracts that Workflows require of the developer lay the structure for good communication. The composability of Workflows encourages reuse and encourages separation of concerns into the most appropriate reusable components. There are even more platform-specific best practices that Workflow dovetails well with, such as structured concurrency with Kotlin coroutines, as each Worker or side effect can define a specific coroutine scope for the operations. What about the next 10 years? Jetpack Compose UI and SwiftUI are establishing themselves as the native mobile UI toolkits of the future. They both embrace the same MVVM approach that Workflow does, and encourage thinking about the \u201ccomposability\u201d of separate components of your application. With this resonance, Workflows help you to prepare your mental model to adapt to these new UI toolkits, and shapes our codebase in a way that will ease our adoption of them. To learn more about Compose and Workflow see this post .","title":"Encouraging programming paradigms that are best practices for the mobile domain"},{"location":"userguide/worker-in-code/","text":"Coding a Worker \u00b6 Worker is a protocol (in Swift) and interface (in Kotlin) that defines an asynchronous task that can be performed by a Workflow . Worker s only emit outputs, they do not have a Rendering type. They are similar to child workflows with Void / Unit rendering types. A workflow can ask the infrastructure to await the result of a worker by passing that worker to the RenderContext.runningWorker method within a call to the render method. A workflow can handle outputs from a Worker . Workers provide a declarative window into the imperative world \u00b6 As nice as it is to write declarative code, real apps need to interact with imperative APIs. Workers allow wrapping imperative APIs so that Workflows can interact with them in a declarative fashion. Instead of making imperative \u201cstart this, do that, now stop\u201d calls, a Workflow can say \u201cI declare that this task should now be running\u201d and let the infrastructure worry about ensuring the task is actually started when necessary, continues running if it was already in flight, and torn down when it\u2019s not needed anymore. Workers can perform side effects \u00b6 Unlike workflows\u2019 render method, which can be called many times and must be idempotent, workers are started and then ran until completion (or cancellation) \u2013 independently of how many times the workflow running them is actually rendered. This means that side effects that should be performed only once when a workflow enters a particular state, for example, should be placed into a Worker that the workflow runs while in that state. Workers are cold reactive streams \u00b6 Workers are effectively simple wrappers around asynchronous streams with explicit equivalence. In Swift, workers are backed by ReactiveSwift SignalProducer s . In Kotlin, they\u2019re backed by Kotlin Flow s . They are also easily derived from Reactive Streams Publishers , including RxJava Observable , Flowable , or Single instances. Worker subscriptions are managed automatically \u00b6 While Workers are backed by reactive streams with library-specific subscription APIs, you never actually subscribe directly to a worker yourself. Instead, a Workflow asks the infrastructure to run a worker, and the infrastructure will take care of initializing and tearing down the subscription as appropriate \u2013 much like how child workflows\u2019 lifetimes are automatically managed by the runtime. This makes it impossible to accidentally leak a subscription to a worker. Workers manage their own internal state \u00b6 Unlike Workflows, which are effectively collections of functions defining state transitions, Workers represent long-running tasks. For example, Workers commonly execute network requests. The worker\u2019s stream will open a socket and, either blocking on a background thread or asynchronously, read from that socket and eventually emit data to the workflow that is running it. Workers define their own equivalence \u00b6 Since Workers represent ongoing tasks, the infrastructure needs to be able to tell when two workers represent the same task (so it doesn\u2019t perform the task twice), or when a worker has changed between render passes such that it needs to be torn down and re-started for the new work. For these reasons, any time a workflow requests that a worker be run in sequential render passes, it is asked to compare itself with its last instance and determine if they are equivalent. In Swift, this is determined by the Worker isEquivalent:to: method. Worker s that conform to Equatable will automatically get an isEquivalent:to: method based on the Equatable implementation. In Kotlin, the Worker interface defines the doesSameWorkAs method which is passed the previous worker. Kotlin: Why don\u2019t Workers use equals ? Worker equivalence is a key part of the Worker API. The default implementation of equals , which just compares object identity, is almost always incorrect for workers. Defining a separate method forces implementers to think about how equivalence is defined. Workers are lifecycle-aware \u00b6 Workers are aware of when they\u2019re started (just like Workflows), but they are also aware of when they are torn down. This makes them handy for managing resources as well.","title":"Coding a Worker (stale)"},{"location":"userguide/worker-in-code/#coding-a-worker","text":"Worker is a protocol (in Swift) and interface (in Kotlin) that defines an asynchronous task that can be performed by a Workflow . Worker s only emit outputs, they do not have a Rendering type. They are similar to child workflows with Void / Unit rendering types. A workflow can ask the infrastructure to await the result of a worker by passing that worker to the RenderContext.runningWorker method within a call to the render method. A workflow can handle outputs from a Worker .","title":"Coding a Worker"},{"location":"userguide/worker-in-code/#workers-provide-a-declarative-window-into-the-imperative-world","text":"As nice as it is to write declarative code, real apps need to interact with imperative APIs. Workers allow wrapping imperative APIs so that Workflows can interact with them in a declarative fashion. Instead of making imperative \u201cstart this, do that, now stop\u201d calls, a Workflow can say \u201cI declare that this task should now be running\u201d and let the infrastructure worry about ensuring the task is actually started when necessary, continues running if it was already in flight, and torn down when it\u2019s not needed anymore.","title":"Workers provide a declarative window into the imperative world"},{"location":"userguide/worker-in-code/#workers-can-perform-side-effects","text":"Unlike workflows\u2019 render method, which can be called many times and must be idempotent, workers are started and then ran until completion (or cancellation) \u2013 independently of how many times the workflow running them is actually rendered. This means that side effects that should be performed only once when a workflow enters a particular state, for example, should be placed into a Worker that the workflow runs while in that state.","title":"Workers can perform side effects"},{"location":"userguide/worker-in-code/#workers-are-cold-reactive-streams","text":"Workers are effectively simple wrappers around asynchronous streams with explicit equivalence. In Swift, workers are backed by ReactiveSwift SignalProducer s . In Kotlin, they\u2019re backed by Kotlin Flow s . They are also easily derived from Reactive Streams Publishers , including RxJava Observable , Flowable , or Single instances.","title":"Workers are cold reactive streams"},{"location":"userguide/worker-in-code/#worker-subscriptions-are-managed-automatically","text":"While Workers are backed by reactive streams with library-specific subscription APIs, you never actually subscribe directly to a worker yourself. Instead, a Workflow asks the infrastructure to run a worker, and the infrastructure will take care of initializing and tearing down the subscription as appropriate \u2013 much like how child workflows\u2019 lifetimes are automatically managed by the runtime. This makes it impossible to accidentally leak a subscription to a worker.","title":"Worker subscriptions are managed automatically"},{"location":"userguide/worker-in-code/#workers-manage-their-own-internal-state","text":"Unlike Workflows, which are effectively collections of functions defining state transitions, Workers represent long-running tasks. For example, Workers commonly execute network requests. The worker\u2019s stream will open a socket and, either blocking on a background thread or asynchronously, read from that socket and eventually emit data to the workflow that is running it.","title":"Workers manage their own internal state"},{"location":"userguide/worker-in-code/#workers-define-their-own-equivalence","text":"Since Workers represent ongoing tasks, the infrastructure needs to be able to tell when two workers represent the same task (so it doesn\u2019t perform the task twice), or when a worker has changed between render passes such that it needs to be torn down and re-started for the new work. For these reasons, any time a workflow requests that a worker be run in sequential render passes, it is asked to compare itself with its last instance and determine if they are equivalent. In Swift, this is determined by the Worker isEquivalent:to: method. Worker s that conform to Equatable will automatically get an isEquivalent:to: method based on the Equatable implementation. In Kotlin, the Worker interface defines the doesSameWorkAs method which is passed the previous worker. Kotlin: Why don\u2019t Workers use equals ? Worker equivalence is a key part of the Worker API. The default implementation of equals , which just compares object identity, is almost always incorrect for workers. Defining a separate method forces implementers to think about how equivalence is defined.","title":"Workers define their own equivalence"},{"location":"userguide/worker-in-code/#workers-are-lifecycle-aware","text":"Workers are aware of when they\u2019re started (just like Workflows), but they are also aware of when they are torn down. This makes them handy for managing resources as well.","title":"Workers are lifecycle-aware"},{"location":"userguide/workflow-in-code/","text":"Coding a Workflow \u00b6 In code, Workflow is a Swift protocol or Kotlin interface with State, Rendering and Output parameter types. The Kotlin interface also defines a Props type. In Swift, props are implicit as properties of the struct implementing Workflow. Swift public protocol Workflow : AnyWorkflowConvertible { associatedtype State associatedtype Output = Never associatedtype Rendering func makeInitialState () -> State func workflowDidChange ( from previousWorkflow : Self , state : inout State ) func render ( state : State , context : RenderContext < Self >) -> Rendering } Kotlin abstract class StatefulWorkflow < in PropsT , StateT , out OutputT : Any , out RenderingT > : Workflow < PropsT , OutputT , RenderingT > { abstract fun initialState ( props : PropsT , initialSnapshot : Snapshot? ): StateT open fun onPropsChanged ( old : PropsT , new : PropsT , state : StateT ): StateT = state abstract fun render ( props : PropsT , state : StateT , context : RenderContext < StateT , OutputT > ): RenderingT abstract fun snapshotState ( state : StateT ): Snapshot } Swift: What is AnyWorkflowConvertible ? When a protocol has an associated Self type, Swift requires the use of a type-erasing wrapper to store references to instances of that protocol. AnyWorkflow is such a wrapper for Workflow . AnyWorkflowConvertible is a protocol with a single method that returns an AnyWorkflow . It is useful as a base type because it allows instances of Workflow to be used directly by any code that requires the type-erased AnyWorkflow . Kotlin: StatefulWorkflow vs Workflow It is a common practice in Kotlin to divide types into two parts: an interface for public API, and a class for private implementation. The Workflow library defines a Workflow interface, which should be used as the type of properties and parameters by code that needs to refer to a particular Workflow interface. The Workflow interface contains a single method, which simply returns a StatefulWorkflow \u2013 a Workflow can be described as \u201canything that can be expressed as a StatefulWorkflow .\u201d The library also defines two abstract classes which define the contract for workflows and should be subclassed to implement your workflows: StatefulWorkflow should be subclassed to implement Workflows that have private state . StatelessWorkflow should be subclassed to implement Workflows that don\u2019t have any private state. See Stateless Workflows . Workflows have several responsibilities: Workflows have state \u00b6 Once a Workflow has been started, it always operates in the context of some state. This state is divided into two parts: private state, which only the Workflow implementation itself knows about, which is defined by the State type, and properties (or \u201cprops\u201d), which is passed to the Workflow from its parent (more on hierarchical workflows below). Private state \u00b6 Every Workflow implementation defines a State type to maintain any necessary state while the workflow is running. For example, a tic-tac-toe game might have a state like this: Swift struct State { enum Player { case x case o } enum Space { case unfilled filled ( Player ) } // 3 rows * 3 columns = 9 spaces var spaces : [ Space ] = Array ( repeating : . unfilled , count : 9 ) var currentTurn : Player = . x } Kotlin data class State ( // 3 rows * 3 columns = 9 spaces val spaces : List < Space > = List ( 9 ) { Unfilled }, val currentTurn : Player = X ) { enum class Player { X , O } sealed class Space { object Unfilled : Space () data class Filled ( val player : Player ) : Space () } } When the workflow is first started, it is queried for an initial state value. From that point forward, the workflow may advance to a new state as the result of events occurring from various sources (which will be covered below). Stateless Workflows If a workflow does not have any private state, it is often referred to as a \u201cstateless workflow\u201d. A stateless Workflow is simply a Workflow that has a Void or Unit State type. See more . Public Props \u00b6 Every Workflow implementation also defines data that is passed into it. The Workflow is not able to modify this state itself, but it may change between render passes. This public state is called Props . In Swift, the props are simply defined as properties of the struct implementing Workflow itself. In Kotlin, the Workflow interface defines a separate PropsT type parameter. (This additional type parameter is necessary due to Kotlin\u2019s lack of the Self type that Swift workflow\u2019s workflowDidChange method relies upon.) Swift TK Kotlin data class Props ( val playerXName : String val playerOName : String ) Workflows are advanced by WorkflowAction s \u00b6 Any time something happens that should advance a workflow \u2013 a UI event, a network response, a child\u2019s output event \u2013 actions are used to perform the update. For example, a workflow may respond to UI events by mapping those events into a type conforming to/implementing WorkflowAction . These types implement the logic to advance a workflow by: Advancing to a new state (Optionally) emitting an output event up the tree. WorkflowAction s are typically defined as enums with associated types (Swift) or sealed classes (Kotlin), and can include data from the event \u2013 for example, the ID of the item in the list that was clicked. Side effects such as logging button clicks to an analytics framework are also typically performed in actions. If you\u2019re familiar with React/Redux, WorkflowAction s are essentially reducers. Workflows can emit output events up the hierarchy to their parent \u00b6 When a workflow is advanced by an action, an optional output event can be sent up the workflow hierarchy. This is the opportunity for a workflow to notify its parent that something has happened (and the parent\u2019s opportunity to respond to that event by dispatching its own action, continuing up the tree as long as output events are emitted). Workflows produce an external representation of their state via Rendering \u00b6 Immediately after starting up, or after a state transition occurs, a workflow will have its render method called. This method is responsible for creating and returning a value of type Rendering . You can think of Rendering as the \u201cexternal published state\u201d of the workflow, and the render function as a map of ( Props + State + childrens\u2019 Rendering s) -> Rendering . While a workflow\u2019s internal state may contain more detailed or comprehensive state, the Rendering (external state) is a type that is useful outside of the workflow. Because a workflow\u2019s render method may be called by infrastructure for a variety of reasons, it\u2019s important to not perform side effects when rendering \u2014 render methods must be idempotent. Event-based side effects should use Actions and state-based side effects should use Workers. When building an interactive application, the Rendering type is commonly (but not always) a view model that will drive the UI layer. Workflows can respond to UI events \u00b6 The RenderContext that is passed into render as the last parameter provides some useful tools to assist in creating the Rendering value. If a workflow is producing a view model, it is common to need an event handler to respond to UI events. The RenderContext has API to create an event handler, called a Sink , that when called will advance the workflow by dispatching an action back to the workflow (for more on actions, see above ). Swift func render ( state : State , context : RenderContext < DemoWorkflow >) -> DemoScreen { // Create a sink of our Action type so we can send actions back to the workflow. let sink = context . makeSink ( of : Action . self ) return DemoScreen ( title : \"A nice title\" , onTap : { sink . send ( Action . refreshButtonTapped ) } } Kotlin TK Workflows form a hierarchy (they may have children) \u00b6 As they produce a Rendering value, it is common for workflows to delegate some portion of that work to a child workflow . This is done via the RenderContext that is passed into the render method. In order to delegate to a child, the parent calls renderChild on the context, with the child workflow as the single argument. The infrastructure will spin up the child workflow (including initializing its initial state) if this is the first time this child has been used, or, if the child was also used on the previous render pass, the existing child will be updated. Either way, render will immediately be called on the child (by the Workflow infrastructure), and the resulting child\u2019s Rendering value will be returned to the parent. This allows a parent to return complex Rendering types (such as a view model representing the entire UI state of an application) without needing to model all of that complexity within a single workflow. Workflow Identity The Workflow infrastructure automatically detects the first time and the last subsequent time you\u2019ve asked to render a child workflow, and will automatically initialize the child and clean it up. In both Swift and Kotlin, this is done using the workflow\u2019s concrete type. Both languages use reflection to do this comparison (e.g. in Kotlin, the workflows\u2019 KClass es are compared). It is an error to render workflows of the same type more than once in the same render pass. Since type is used for workflow identity, the child rendering APIs take an optional string key to differentiate between multiple child workflows of the same type. Workflows can subscribe to external event sources \u00b6 If a workflow needs to respond to some external event source (e.g. push notifications), the workflow can ask the context to listen to those events from within the render method. Swift vs Kotlin In the Swift library, there is a special API for subscribing to hot streams ( Signal in ReactiveSwift). The Kotlin library does not have any special API for subscribing to hot streams (channels), though it does have extension methods to convert ReceiveChannel s , and RxJava Flowable s and Observables , to Worker s . The reason for this discrepancy is simply that we don\u2019t have any uses of channels yet in production, and so we\u2019ve decided to keep the API simpler. If we start using channels in the future, it may make sense to make subscribing to them a first-class API like in Swift. Workflows can perform asynchronous tasks (Workers) \u00b6 Workers are very similar in concept to child workflows. Unlike child workflows, however, workers do not have a Rendering type; they only exist to perform a single asynchronous task before sending zero or more output events back up the tree to their parent. For more information about workers, see the Worker section below. Workflows can be saved to and restored from a snapshot (Kotlin only) \u00b6 On every render pass, each workflow is asked to create a \u201csnapshot\u201d of its state \u2013 a lazily-produced serialization of the workflow\u2019s State as a binary blob. These Snapshot s are aggregated into a single Snapshot for the entire workflow tree and emitted along with the root workflow\u2019s Rendering . When the workflow runtime is started, it can be passed an optional Snapshot to restore the tree from. When non-null, the root workflow\u2019s snapshot is extracted and passed to the root workflow\u2019s initialState . The workflow can choose to either ignore the snapshot or use it to restore its State . On the first render pass, if the root workflow renders any children that were also being rendered when the snapshot was taken, those children\u2019s snapshots are also extracted from the aggregate and used to initialize their states. Why don\u2019t Swift Workflows support snapshotting? Snapshotting was built into Kotlin workflows specifically to support Android\u2019s app lifecycle, which requires apps to serialize their current state before being backgrounded so that they can be restored in case the system needs to kill the hosting process. iOS apps don\u2019t have this requirement, so the Swift library doesn\u2019t need to support it.","title":"Coding a Workflow (stale)"},{"location":"userguide/workflow-in-code/#coding-a-workflow","text":"In code, Workflow is a Swift protocol or Kotlin interface with State, Rendering and Output parameter types. The Kotlin interface also defines a Props type. In Swift, props are implicit as properties of the struct implementing Workflow. Swift public protocol Workflow : AnyWorkflowConvertible { associatedtype State associatedtype Output = Never associatedtype Rendering func makeInitialState () -> State func workflowDidChange ( from previousWorkflow : Self , state : inout State ) func render ( state : State , context : RenderContext < Self >) -> Rendering } Kotlin abstract class StatefulWorkflow < in PropsT , StateT , out OutputT : Any , out RenderingT > : Workflow < PropsT , OutputT , RenderingT > { abstract fun initialState ( props : PropsT , initialSnapshot : Snapshot? ): StateT open fun onPropsChanged ( old : PropsT , new : PropsT , state : StateT ): StateT = state abstract fun render ( props : PropsT , state : StateT , context : RenderContext < StateT , OutputT > ): RenderingT abstract fun snapshotState ( state : StateT ): Snapshot } Swift: What is AnyWorkflowConvertible ? When a protocol has an associated Self type, Swift requires the use of a type-erasing wrapper to store references to instances of that protocol. AnyWorkflow is such a wrapper for Workflow . AnyWorkflowConvertible is a protocol with a single method that returns an AnyWorkflow . It is useful as a base type because it allows instances of Workflow to be used directly by any code that requires the type-erased AnyWorkflow . Kotlin: StatefulWorkflow vs Workflow It is a common practice in Kotlin to divide types into two parts: an interface for public API, and a class for private implementation. The Workflow library defines a Workflow interface, which should be used as the type of properties and parameters by code that needs to refer to a particular Workflow interface. The Workflow interface contains a single method, which simply returns a StatefulWorkflow \u2013 a Workflow can be described as \u201canything that can be expressed as a StatefulWorkflow .\u201d The library also defines two abstract classes which define the contract for workflows and should be subclassed to implement your workflows: StatefulWorkflow should be subclassed to implement Workflows that have private state . StatelessWorkflow should be subclassed to implement Workflows that don\u2019t have any private state. See Stateless Workflows . Workflows have several responsibilities:","title":"Coding a Workflow"},{"location":"userguide/workflow-in-code/#workflows-have-state","text":"Once a Workflow has been started, it always operates in the context of some state. This state is divided into two parts: private state, which only the Workflow implementation itself knows about, which is defined by the State type, and properties (or \u201cprops\u201d), which is passed to the Workflow from its parent (more on hierarchical workflows below).","title":"Workflows have state"},{"location":"userguide/workflow-in-code/#private-state","text":"Every Workflow implementation defines a State type to maintain any necessary state while the workflow is running. For example, a tic-tac-toe game might have a state like this: Swift struct State { enum Player { case x case o } enum Space { case unfilled filled ( Player ) } // 3 rows * 3 columns = 9 spaces var spaces : [ Space ] = Array ( repeating : . unfilled , count : 9 ) var currentTurn : Player = . x } Kotlin data class State ( // 3 rows * 3 columns = 9 spaces val spaces : List < Space > = List ( 9 ) { Unfilled }, val currentTurn : Player = X ) { enum class Player { X , O } sealed class Space { object Unfilled : Space () data class Filled ( val player : Player ) : Space () } } When the workflow is first started, it is queried for an initial state value. From that point forward, the workflow may advance to a new state as the result of events occurring from various sources (which will be covered below). Stateless Workflows If a workflow does not have any private state, it is often referred to as a \u201cstateless workflow\u201d. A stateless Workflow is simply a Workflow that has a Void or Unit State type. See more .","title":"Private state"},{"location":"userguide/workflow-in-code/#public-props","text":"Every Workflow implementation also defines data that is passed into it. The Workflow is not able to modify this state itself, but it may change between render passes. This public state is called Props . In Swift, the props are simply defined as properties of the struct implementing Workflow itself. In Kotlin, the Workflow interface defines a separate PropsT type parameter. (This additional type parameter is necessary due to Kotlin\u2019s lack of the Self type that Swift workflow\u2019s workflowDidChange method relies upon.) Swift TK Kotlin data class Props ( val playerXName : String val playerOName : String )","title":"Public Props"},{"location":"userguide/workflow-in-code/#workflows-are-advanced-by-workflowactions","text":"Any time something happens that should advance a workflow \u2013 a UI event, a network response, a child\u2019s output event \u2013 actions are used to perform the update. For example, a workflow may respond to UI events by mapping those events into a type conforming to/implementing WorkflowAction . These types implement the logic to advance a workflow by: Advancing to a new state (Optionally) emitting an output event up the tree. WorkflowAction s are typically defined as enums with associated types (Swift) or sealed classes (Kotlin), and can include data from the event \u2013 for example, the ID of the item in the list that was clicked. Side effects such as logging button clicks to an analytics framework are also typically performed in actions. If you\u2019re familiar with React/Redux, WorkflowAction s are essentially reducers.","title":"Workflows are advanced by WorkflowActions"},{"location":"userguide/workflow-in-code/#workflows-can-emit-output-events-up-the-hierarchy-to-their-parent","text":"When a workflow is advanced by an action, an optional output event can be sent up the workflow hierarchy. This is the opportunity for a workflow to notify its parent that something has happened (and the parent\u2019s opportunity to respond to that event by dispatching its own action, continuing up the tree as long as output events are emitted).","title":"Workflows can emit output events up the hierarchy to their parent"},{"location":"userguide/workflow-in-code/#workflows-produce-an-external-representation-of-their-state-via-rendering","text":"Immediately after starting up, or after a state transition occurs, a workflow will have its render method called. This method is responsible for creating and returning a value of type Rendering . You can think of Rendering as the \u201cexternal published state\u201d of the workflow, and the render function as a map of ( Props + State + childrens\u2019 Rendering s) -> Rendering . While a workflow\u2019s internal state may contain more detailed or comprehensive state, the Rendering (external state) is a type that is useful outside of the workflow. Because a workflow\u2019s render method may be called by infrastructure for a variety of reasons, it\u2019s important to not perform side effects when rendering \u2014 render methods must be idempotent. Event-based side effects should use Actions and state-based side effects should use Workers. When building an interactive application, the Rendering type is commonly (but not always) a view model that will drive the UI layer.","title":"Workflows produce an external representation of their state via Rendering"},{"location":"userguide/workflow-in-code/#workflows-can-respond-to-ui-events","text":"The RenderContext that is passed into render as the last parameter provides some useful tools to assist in creating the Rendering value. If a workflow is producing a view model, it is common to need an event handler to respond to UI events. The RenderContext has API to create an event handler, called a Sink , that when called will advance the workflow by dispatching an action back to the workflow (for more on actions, see above ). Swift func render ( state : State , context : RenderContext < DemoWorkflow >) -> DemoScreen { // Create a sink of our Action type so we can send actions back to the workflow. let sink = context . makeSink ( of : Action . self ) return DemoScreen ( title : \"A nice title\" , onTap : { sink . send ( Action . refreshButtonTapped ) } } Kotlin TK","title":"Workflows can respond to UI events"},{"location":"userguide/workflow-in-code/#workflows-form-a-hierarchy-they-may-have-children","text":"As they produce a Rendering value, it is common for workflows to delegate some portion of that work to a child workflow . This is done via the RenderContext that is passed into the render method. In order to delegate to a child, the parent calls renderChild on the context, with the child workflow as the single argument. The infrastructure will spin up the child workflow (including initializing its initial state) if this is the first time this child has been used, or, if the child was also used on the previous render pass, the existing child will be updated. Either way, render will immediately be called on the child (by the Workflow infrastructure), and the resulting child\u2019s Rendering value will be returned to the parent. This allows a parent to return complex Rendering types (such as a view model representing the entire UI state of an application) without needing to model all of that complexity within a single workflow. Workflow Identity The Workflow infrastructure automatically detects the first time and the last subsequent time you\u2019ve asked to render a child workflow, and will automatically initialize the child and clean it up. In both Swift and Kotlin, this is done using the workflow\u2019s concrete type. Both languages use reflection to do this comparison (e.g. in Kotlin, the workflows\u2019 KClass es are compared). It is an error to render workflows of the same type more than once in the same render pass. Since type is used for workflow identity, the child rendering APIs take an optional string key to differentiate between multiple child workflows of the same type.","title":"Workflows form a hierarchy (they may have children)"},{"location":"userguide/workflow-in-code/#workflows-can-subscribe-to-external-event-sources","text":"If a workflow needs to respond to some external event source (e.g. push notifications), the workflow can ask the context to listen to those events from within the render method. Swift vs Kotlin In the Swift library, there is a special API for subscribing to hot streams ( Signal in ReactiveSwift). The Kotlin library does not have any special API for subscribing to hot streams (channels), though it does have extension methods to convert ReceiveChannel s , and RxJava Flowable s and Observables , to Worker s . The reason for this discrepancy is simply that we don\u2019t have any uses of channels yet in production, and so we\u2019ve decided to keep the API simpler. If we start using channels in the future, it may make sense to make subscribing to them a first-class API like in Swift.","title":"Workflows can subscribe to external event sources"},{"location":"userguide/workflow-in-code/#workflows-can-perform-asynchronous-tasks-workers","text":"Workers are very similar in concept to child workflows. Unlike child workflows, however, workers do not have a Rendering type; they only exist to perform a single asynchronous task before sending zero or more output events back up the tree to their parent. For more information about workers, see the Worker section below.","title":"Workflows can perform asynchronous tasks (Workers)"},{"location":"userguide/workflow-in-code/#workflows-can-be-saved-to-and-restored-from-a-snapshot-kotlin-only","text":"On every render pass, each workflow is asked to create a \u201csnapshot\u201d of its state \u2013 a lazily-produced serialization of the workflow\u2019s State as a binary blob. These Snapshot s are aggregated into a single Snapshot for the entire workflow tree and emitted along with the root workflow\u2019s Rendering . When the workflow runtime is started, it can be passed an optional Snapshot to restore the tree from. When non-null, the root workflow\u2019s snapshot is extracted and passed to the root workflow\u2019s initialState . The workflow can choose to either ignore the snapshot or use it to restore its State . On the first render pass, if the root workflow renders any children that were also being rendered when the snapshot was taken, those children\u2019s snapshots are also extracted from the aggregate and used to initialize their states. Why don\u2019t Swift Workflows support snapshotting? Snapshotting was built into Kotlin workflows specifically to support Android\u2019s app lifecycle, which requires apps to serialize their current state before being backgrounded so that they can be restored in case the system needs to kill the hosting process. iOS apps don\u2019t have this requirement, so the Swift library doesn\u2019t need to support it.","title":"Workflows can be saved to and restored from a snapshot (Kotlin only)"}]}